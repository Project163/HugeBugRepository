diff --git a/src/main/java/org/apache/tika/parser/msexcel/MsExcelParser.java b/src/main/java/org/apache/tika/parser/msexcel/MsExcelParser.java
index e772ce756..f86b2f2bf 100644
--- a/src/main/java/org/apache/tika/parser/msexcel/MsExcelParser.java
+++ b/src/main/java/org/apache/tika/parser/msexcel/MsExcelParser.java
@@ -29,18 +29,18 @@ import org.apache.tika.utils.MSExtractor;
  */
 public class MsExcelParser extends Parser {
 
-	protected String parse(InputStream stream, Iterable<Content> contents)
-			throws IOException, TikaException {
-		try {
-			MSExtractor extractor = new ExcelExtractor();
-			extractor.setContents(contents);
-			extractor.extract(stream);
-			return extractor.getText();
-		} catch (IOException e) {
-			throw e;
-		} catch (Exception e) {
-			throw new TikaException("Error parsing an Excel document", e);
-		}
-	}
+    protected String parse(InputStream stream, Iterable<Content> contents)
+            throws IOException, TikaException {
+        try {
+            MSExtractor extractor = new ExcelExtractor();
+            extractor.setContents(contents);
+            extractor.extract(stream);
+            return extractor.getText();
+        } catch (IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new TikaException("Error parsing an Excel document", e);
+        }
+    }
 
 }
diff --git a/src/main/java/org/apache/tika/parser/mspowerpoint/MsPowerPointParser.java b/src/main/java/org/apache/tika/parser/mspowerpoint/MsPowerPointParser.java
index 46fc01f05..658c7e5ba 100644
--- a/src/main/java/org/apache/tika/parser/mspowerpoint/MsPowerPointParser.java
+++ b/src/main/java/org/apache/tika/parser/mspowerpoint/MsPowerPointParser.java
@@ -29,19 +29,18 @@ import org.apache.tika.utils.MSExtractor;
  */
 public class MsPowerPointParser extends Parser {
 
-	
-	protected String parse(InputStream stream, Iterable<Content> contents)
-			throws IOException, TikaException {
-		try {
-			MSExtractor extractor = new PPTExtractor();
-			extractor.setContents(contents);
-			extractor.extract(stream);
-			return extractor.getText();
-		} catch (IOException e) {
-			throw e;
-		} catch (Exception e) {
-			throw new TikaException("Error parsing a PowerPoint document", e);
-		}
-	}
+    protected String parse(InputStream stream, Iterable<Content> contents)
+            throws IOException, TikaException {
+        try {
+            MSExtractor extractor = new PPTExtractor();
+            extractor.setContents(contents);
+            extractor.extract(stream);
+            return extractor.getText();
+        } catch (IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new TikaException("Error parsing a PowerPoint document", e);
+        }
+    }
 
 }
diff --git a/src/main/java/org/apache/tika/parser/msword/MsWordParser.java b/src/main/java/org/apache/tika/parser/msword/MsWordParser.java
index ff6a3c83b..74cd4a97c 100644
--- a/src/main/java/org/apache/tika/parser/msword/MsWordParser.java
+++ b/src/main/java/org/apache/tika/parser/msword/MsWordParser.java
@@ -29,18 +29,18 @@ import org.apache.tika.utils.MSExtractor;
  */
 public class MsWordParser extends Parser {
 
-	protected String parse(InputStream stream, Iterable<Content> contents)
-			throws IOException, TikaException {
-		try {
-			MSExtractor extractor = new WordExtractor();
-			extractor.setContents(contents);
-			extractor.extract(stream);
-			return extractor.getText();
-		} catch (IOException e) {
-			throw e;
-		} catch (Exception e) {
-			throw new TikaException("Error parsing a Word document", e);
-		}
-	}
+    protected String parse(InputStream stream, Iterable<Content> contents)
+            throws IOException, TikaException {
+        try {
+            MSExtractor extractor = new WordExtractor();
+            extractor.setContents(contents);
+            extractor.extract(stream);
+            return extractor.getText();
+        } catch (IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new TikaException("Error parsing a Word document", e);
+        }
+    }
 
 }
diff --git a/src/main/java/org/apache/tika/utils/MSExtractor.java b/src/main/java/org/apache/tika/utils/MSExtractor.java
index db1613c51..91fd3d1ac 100644
--- a/src/main/java/org/apache/tika/utils/MSExtractor.java
+++ b/src/main/java/org/apache/tika/utils/MSExtractor.java
@@ -34,148 +34,148 @@ import org.apache.tika.config.Content;
  */
 public abstract class MSExtractor {
 
-	static Logger LOG = Logger.getRootLogger();
-
-	private String text = null;
-
-	private POIFSReader reader = null;
-
-	private Iterable<Content> contents;
-
-	private final int MEMORY_THRESHOLD = 1024 * 1024;
-
-	/** Constructs a new Microsoft document extractor. */
-	public MSExtractor() {
-	}
-
-	public void setContents(Iterable<Content> contents) {
-		this.contents = contents;
-	}
-
-	/**
-	 * Extracts properties and text from an MS Document input stream
-	 */
-	public void extract(InputStream input) throws Exception {
-		RereadableInputStream ris = new RereadableInputStream(input,
-				MEMORY_THRESHOLD);
-		try {
-			// First, extract properties
-			this.reader = new POIFSReader();
-
-			this.reader.registerListener(new PropertiesReaderListener(),
-					SummaryInformation.DEFAULT_STREAM_NAME);
-
-			if (input.available() > 0) {
-				reader.read(ris);
-			}
-			while (ris.read() != -1) {
-			}
-			ris.rewind();
-			// Extract document full text
-			this.text = extractText(ris);
-		} finally {
-			ris.close();
-		}
-	}
-
-	/**
-	 * Extracts the text content from a Microsoft document input stream.
-	 */
-	public abstract String extractText(InputStream input) throws Exception;
-
-	/**
-	 * Get the content text of the Microsoft document.
-	 * 
-	 * @return the content text of the document
-	 */
-	public String getText() {
-		return this.text;
-	}
-
-	private class PropertiesReaderListener implements POIFSReaderListener {
-
-		public void processPOIFSReaderEvent(POIFSReaderEvent event) {
-			if (!event.getName().startsWith(
-					SummaryInformation.DEFAULT_STREAM_NAME)) {
-				return;
-			}
-
-			try {
-				SummaryInformation si = (SummaryInformation) PropertySetFactory
-						.create(event.getStream());
-				for (Content content : contents) {
-					if (content.getTextSelect().equalsIgnoreCase("title")) {
-						if (si.getTitle() != null)
-							content.setValue(si.getTitle());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"author")) {
-						if (si.getAuthor() != null)
-							content.setValue(si.getAuthor());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"keywords")) {
-						if (si.getKeywords() != null)
-							content.setValue(si.getKeywords());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"subject")) {
-						if (si.getSubject() != null)
-							content.setValue(si.getSubject());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"lastauthor")) {
-						if (si.getLastAuthor() != null)
-							content.setValue(si.getLastAuthor());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"comments")) {
-						if (si.getComments() != null)
-							content.setValue(si.getComments());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"template")) {
-						if (si.getTemplate() != null)
-							content.setValue(si.getTemplate());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"applicationname")) {
-						if (si.getApplicationName() != null)
-							content.setValue(si.getApplicationName());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"revnumber")) {
-						if (si.getRevNumber() != null)
-							content.setValue(si.getRevNumber());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"creationdate")) {
-						if (si.getCreateDateTime() != null)
-							content.setValue(si.getCreateDateTime().toString());
-					} else if (content.getTextSelect().equalsIgnoreCase(
-							"charcount")) {
-						if (si.getCharCount() > 0)
-							content.setValue("" + si.getCharCount());
-					} else if (content.getTextSelect().equals("edittime")) {
-						if (si.getEditTime() > 0)
-							content.setValue("" + si.getEditTime());
-					} else if (content.getTextSelect().equals(
-							"lastsavedatetime")) {
-						if (si.getLastSaveDateTime() != null)
-							content.setValue(si.getLastSaveDateTime()
-									.toString());
-					} else if (content.getTextSelect().equals("pagecount")) {
-						if (si.getPageCount() > 0)
-							content.setValue("" + si.getPageCount());
-					} else if (content.getTextSelect().equals("security")) {
-						if (si.getSecurity() > 0)
-							content.setValue("" + si.getSecurity());
-					} else if (content.getTextSelect().equals("wordcount")) {
-						if (si.getWordCount() > 0)
-							content.setValue("" + si.getWordCount());
-					} else if (content.getTextSelect().equals("lastprinted")) {
-						if (si.getLastPrinted() != null)
-							content.setValue(si.getLastPrinted().toString());
-					}
-
-				}
-
-			} catch (Exception ex) {
-			}
-
-		}
-
-	}
+    static Logger LOG = Logger.getRootLogger();
+
+    private String text = null;
+
+    private POIFSReader reader = null;
+
+    private Iterable<Content> contents;
+
+    private final int MEMORY_THRESHOLD = 1024 * 1024;
+
+    /** Constructs a new Microsoft document extractor. */
+    public MSExtractor() {
+    }
+
+    public void setContents(Iterable<Content> contents) {
+        this.contents = contents;
+    }
+
+    /**
+     * Extracts properties and text from an MS Document input stream
+     */
+    public void extract(InputStream input) throws Exception {
+        RereadableInputStream ris = new RereadableInputStream(input,
+                MEMORY_THRESHOLD);
+        try {
+            // First, extract properties
+            this.reader = new POIFSReader();
+
+            this.reader.registerListener(new PropertiesReaderListener(),
+                    SummaryInformation.DEFAULT_STREAM_NAME);
+
+            if (input.available() > 0) {
+                reader.read(ris);
+            }
+            while (ris.read() != -1) {
+            }
+            ris.rewind();
+            // Extract document full text
+            this.text = extractText(ris);
+        } finally {
+            ris.close();
+        }
+    }
+
+    /**
+     * Extracts the text content from a Microsoft document input stream.
+     */
+    public abstract String extractText(InputStream input) throws Exception;
+
+    /**
+     * Get the content text of the Microsoft document.
+     * 
+     * @return the content text of the document
+     */
+    public String getText() {
+        return this.text;
+    }
+
+    private class PropertiesReaderListener implements POIFSReaderListener {
+
+        public void processPOIFSReaderEvent(POIFSReaderEvent event) {
+            if (!event.getName().startsWith(
+                    SummaryInformation.DEFAULT_STREAM_NAME)) {
+                return;
+            }
+
+            try {
+                SummaryInformation si = (SummaryInformation) PropertySetFactory
+                .create(event.getStream());
+                for (Content content : contents) {
+                    if (content.getTextSelect().equalsIgnoreCase("title")) {
+                        if (si.getTitle() != null)
+                            content.setValue(si.getTitle());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "author")) {
+                        if (si.getAuthor() != null)
+                            content.setValue(si.getAuthor());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "keywords")) {
+                        if (si.getKeywords() != null)
+                            content.setValue(si.getKeywords());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "subject")) {
+                        if (si.getSubject() != null)
+                            content.setValue(si.getSubject());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "lastauthor")) {
+                        if (si.getLastAuthor() != null)
+                            content.setValue(si.getLastAuthor());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "comments")) {
+                        if (si.getComments() != null)
+                            content.setValue(si.getComments());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "template")) {
+                        if (si.getTemplate() != null)
+                            content.setValue(si.getTemplate());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "applicationname")) {
+                        if (si.getApplicationName() != null)
+                            content.setValue(si.getApplicationName());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "revnumber")) {
+                        if (si.getRevNumber() != null)
+                            content.setValue(si.getRevNumber());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "creationdate")) {
+                        if (si.getCreateDateTime() != null)
+                            content.setValue(si.getCreateDateTime().toString());
+                    } else if (content.getTextSelect().equalsIgnoreCase(
+                    "charcount")) {
+                        if (si.getCharCount() > 0)
+                            content.setValue("" + si.getCharCount());
+                    } else if (content.getTextSelect().equals("edittime")) {
+                        if (si.getEditTime() > 0)
+                            content.setValue("" + si.getEditTime());
+                    } else if (content.getTextSelect().equals(
+                    "lastsavedatetime")) {
+                        if (si.getLastSaveDateTime() != null)
+                            content.setValue(si.getLastSaveDateTime()
+                                    .toString());
+                    } else if (content.getTextSelect().equals("pagecount")) {
+                        if (si.getPageCount() > 0)
+                            content.setValue("" + si.getPageCount());
+                    } else if (content.getTextSelect().equals("security")) {
+                        if (si.getSecurity() > 0)
+                            content.setValue("" + si.getSecurity());
+                    } else if (content.getTextSelect().equals("wordcount")) {
+                        if (si.getWordCount() > 0)
+                            content.setValue("" + si.getWordCount());
+                    } else if (content.getTextSelect().equals("lastprinted")) {
+                        if (si.getLastPrinted() != null)
+                            content.setValue(si.getLastPrinted().toString());
+                    }
+
+                }
+
+            } catch (Exception ex) {
+            }
+
+        }
+
+    }
 
 }
\ No newline at end of file
diff --git a/src/main/java/org/apache/tika/utils/ParseUtils.java b/src/main/java/org/apache/tika/utils/ParseUtils.java
index f12716cca..d804e8cf9 100644
--- a/src/main/java/org/apache/tika/utils/ParseUtils.java
+++ b/src/main/java/org/apache/tika/utils/ParseUtils.java
@@ -16,7 +16,7 @@
  */
 package org.apache.tika.utils;
 
-// JDK imports
+//JDK imports
 import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.FileInputStream;
@@ -40,221 +40,221 @@ import org.apache.tika.parser.ParserFactory;
  */
 public class ParseUtils implements TikaMimeKeys {
 
-	/**
-	 * Returns a parser that can handle the specified MIME type, and is set to
-	 * receive input from a stream opened from the specified URL. NB: Close the
-	 * input stream when it is no longer needed!
-	 * 
-	 * @param config
-	 * @param mimeType
-	 *            the document's MIME type
-	 * @return a parser appropriate to this MIME type
-	 * @throws TikaException
-	 */
-	public static Parser getParser(TikaConfig config, String mimeType)
-			throws TikaException {
-		ParserConfig pc = config.getParserConfig(mimeType);
-		Parser parser = ParserFactory.getParser(pc);
-		parser.setMimeType(mimeType);
-		return parser;
-	}
+    /**
+     * Returns a parser that can handle the specified MIME type, and is set to
+     * receive input from a stream opened from the specified URL. NB: Close the
+     * input stream when it is no longer needed!
+     * 
+     * @param config
+     * @param mimeType
+     *            the document's MIME type
+     * @return a parser appropriate to this MIME type
+     * @throws TikaException
+     */
+    public static Parser getParser(TikaConfig config, String mimeType)
+            throws TikaException {
+        ParserConfig pc = config.getParserConfig(mimeType);
+        Parser parser = ParserFactory.getParser(pc);
+        parser.setMimeType(mimeType);
+        return parser;
+    }
 
-	/**
-	 * Returns a parser that can handle the specified MIME type, and is set to
-	 * receive input from a stream opened from the specified URL. The MIME type
-	 * is determined automatically. NB: Close the input stream when it is no
-	 * longer needed!
-	 * 
-	 * @param documentUrl
-	 *            URL pointing to the document to parse
-	 * @param config
-	 * @return a parser appropriate to this MIME type and ready to read input
-	 *         from the specified document
-	 * @throws TikaException
-	 */
-	public static Parser getParser(URL documentUrl, TikaConfig config)
-			throws TikaException {
-		String mimetype = config.getMimeRepository().getMimeType(documentUrl)
-				.getName();
-		return getParser(config, mimetype);
-	}
+    /**
+     * Returns a parser that can handle the specified MIME type, and is set to
+     * receive input from a stream opened from the specified URL. The MIME type
+     * is determined automatically. NB: Close the input stream when it is no
+     * longer needed!
+     * 
+     * @param documentUrl
+     *            URL pointing to the document to parse
+     * @param config
+     * @return a parser appropriate to this MIME type and ready to read input
+     *         from the specified document
+     * @throws TikaException
+     */
+    public static Parser getParser(URL documentUrl, TikaConfig config)
+            throws TikaException {
+        String mimetype = config.getMimeRepository().getMimeType(documentUrl)
+        .getName();
+        return getParser(config, mimetype);
+    }
 
-	/**
-	 * Returns a parser that can handle the specified MIME type, and is set to
-	 * receive input from a stream opened from the specified URL. NB: Close the
-	 * input stream when it is no longer needed!
-	 * 
-	 * @param documentFile
-	 *            File object pointing to the document to parse
-	 * @param config
-	 * @return a parser appropriate to this MIME type and ready to read input
-	 *         from the specified document
-	 * @throws TikaException
-	 */
-	public static Parser getParser(File documentFile, TikaConfig config)
-			throws TikaException {
-		String mimetype = config.getMimeRepository().getMimeType(documentFile)
-				.getName();
-		return getParser(config, mimetype);
-	}
+    /**
+     * Returns a parser that can handle the specified MIME type, and is set to
+     * receive input from a stream opened from the specified URL. NB: Close the
+     * input stream when it is no longer needed!
+     * 
+     * @param documentFile
+     *            File object pointing to the document to parse
+     * @param config
+     * @return a parser appropriate to this MIME type and ready to read input
+     *         from the specified document
+     * @throws TikaException
+     */
+    public static Parser getParser(File documentFile, TikaConfig config)
+            throws TikaException {
+        String mimetype = config.getMimeRepository().getMimeType(documentFile)
+        .getName();
+        return getParser(config, mimetype);
+    }
 
-	/**
-	 * Returns a list of parsers from zip InputStream
-	 * 
-	 * @param zip
-	 *            InputStream
-	 * @param config
-	 * @return a list of parsers from zip file
-	 * @throws TikaException
-	 */
-	private static List<Parser> getParsersFromZip(InputStream zipIs,
-			TikaConfig config) throws TikaException {
-		List<Parser> parsers = new ArrayList<Parser>();
-		List<File> zipFiles = Utils.unzip(zipIs);
-		for (int i = 0; i < zipFiles.size(); i++) {
-			File zipEntry = zipFiles.get(i);
-			parsers.add(getParser(zipEntry, config));
-		}
-		return parsers;
-	}
+    /**
+     * Returns a list of parsers from zip InputStream
+     * 
+     * @param zip
+     *            InputStream
+     * @param config
+     * @return a list of parsers from zip file
+     * @throws TikaException
+     */
+    private static List<Parser> getParsersFromZip(InputStream zipIs,
+            TikaConfig config) throws TikaException {
+        List<Parser> parsers = new ArrayList<Parser>();
+        List<File> zipFiles = Utils.unzip(zipIs);
+        for (int i = 0; i < zipFiles.size(); i++) {
+            File zipEntry = zipFiles.get(i);
+            parsers.add(getParser(zipEntry, config));
+        }
+        return parsers;
+    }
 
-	/**
-	 * Returns a list of parsers from zip File
-	 * 
-	 * @param zip
-	 *            File
-	 * @param config
-	 * @return a list of parsers from zip file
-	 * @throws TikaException
-	 * @throws FileNotFoundException
-	 */
-	public static List<Parser> getParsersFromZip(File zip, TikaConfig config)
-			throws TikaException, FileNotFoundException {
-		String zipMimeType = config.getMimeRepository().getMimeType(zip)
-				.getName();
-		if (!zipMimeType.equalsIgnoreCase("application/zip")) {
-			throw new TikaException("The file you are using is note a zip file");
-		}
-		return getParsersFromZip(new FileInputStream(zip), config);
-	}
+    /**
+     * Returns a list of parsers from zip File
+     * 
+     * @param zip
+     *            File
+     * @param config
+     * @return a list of parsers from zip file
+     * @throws TikaException
+     * @throws FileNotFoundException
+     */
+    public static List<Parser> getParsersFromZip(File zip, TikaConfig config)
+            throws TikaException, FileNotFoundException {
+        String zipMimeType = config.getMimeRepository().getMimeType(zip)
+        .getName();
+        if (!zipMimeType.equalsIgnoreCase("application/zip")) {
+            throw new TikaException("The file you are using is note a zip file");
+        }
+        return getParsersFromZip(new FileInputStream(zip), config);
+    }
 
-	/**
-	 * Returns a list of parsers from URL
-	 * 
-	 * @param URL
-	 * @param config
-	 * @return a list of parsers from zip file
-	 * @throws TikaException
-	 * @throws IOException
-	 */
-	public static List<Parser> getParsersFromZip(URL zip, TikaConfig config)
-			throws TikaException, IOException {
-		String zipMimeType = config.getMimeRepository().getMimeType(zip)
-				.getName();
-		if (!zipMimeType.equalsIgnoreCase("application/zip")) {
-			throw new TikaException("The file you are using is note a zip file");
-		}
-		return getParsersFromZip(zip.openStream(), config);
-	}
+    /**
+     * Returns a list of parsers from URL
+     * 
+     * @param URL
+     * @param config
+     * @return a list of parsers from zip file
+     * @throws TikaException
+     * @throws IOException
+     */
+    public static List<Parser> getParsersFromZip(URL zip, TikaConfig config)
+            throws TikaException, IOException {
+        String zipMimeType = config.getMimeRepository().getMimeType(zip)
+        .getName();
+        if (!zipMimeType.equalsIgnoreCase("application/zip")) {
+            throw new TikaException("The file you are using is note a zip file");
+        }
+        return getParsersFromZip(zip.openStream(), config);
+    }
 
-	/**
-	 * Gets the string content of a document read from an input stream.
-	 * 
-	 * @param inputStream
-	 *            the stream from which to read document data
-	 * @param config
-	 * @param mimeType
-	 *            MIME type of the data
-	 * @return the string content parsed from the document
-	 * @throws TikaException
-	 * @throws IOException
-	 */
-	public static String getStringContent(InputStream inputStream,
-			TikaConfig config, String mimeType) throws TikaException,
-			IOException {
-		ParserConfig pc = config.getParserConfig(mimeType);
-		Parser parser = ParserFactory.getParser(pc);
-		parser.setMimeType(mimeType);
-		return parser.getContents(inputStream, pc.getContents());
-	}
+    /**
+     * Gets the string content of a document read from an input stream.
+     * 
+     * @param inputStream
+     *            the stream from which to read document data
+     * @param config
+     * @param mimeType
+     *            MIME type of the data
+     * @return the string content parsed from the document
+     * @throws TikaException
+     * @throws IOException
+     */
+    public static String getStringContent(InputStream inputStream,
+            TikaConfig config, String mimeType) throws TikaException,
+            IOException {
+        ParserConfig pc = config.getParserConfig(mimeType);
+        Parser parser = ParserFactory.getParser(pc);
+        parser.setMimeType(mimeType);
+        return parser.getContents(inputStream, pc.getContents());
+    }
 
-	/**
-	 * Gets the string content of a document read from an input stream.
-	 * 
-	 * @param documentUrl
-	 *            URL pointing to the document to parse
-	 * @param config
-	 * @return the string content parsed from the document
-	 * @throws TikaException
-	 * @throws IOException
-	 */
-	public static String getStringContent(URL documentUrl, TikaConfig config)
-			throws TikaException, IOException {
-		String mime = config.getMimeRepository().getMimeType(documentUrl)
-				.getName();
-		return getStringContent(documentUrl, config, mime);
-	}
+    /**
+     * Gets the string content of a document read from an input stream.
+     * 
+     * @param documentUrl
+     *            URL pointing to the document to parse
+     * @param config
+     * @return the string content parsed from the document
+     * @throws TikaException
+     * @throws IOException
+     */
+    public static String getStringContent(URL documentUrl, TikaConfig config)
+            throws TikaException, IOException {
+        String mime = config.getMimeRepository().getMimeType(documentUrl)
+        .getName();
+        return getStringContent(documentUrl, config, mime);
+    }
 
-	/**
-	 * Gets the string content of a document read from an input stream.
-	 * 
-	 * @param documentUrl
-	 *            URL pointing to the document to parse
-	 * @param config
-	 * @param mimeType
-	 *            MIME type of the data
-	 * @return the string content parsed from the document
-	 * @throws TikaException
-	 * @throws IOException
-	 */
-	public static String getStringContent(URL documentUrl, TikaConfig config,
-			String mimeType) throws TikaException, IOException {
-		InputStream stream = documentUrl.openStream();
-		try {
-			return getStringContent(stream, config, mimeType);
-		} finally {
-			stream.close();
-		}
-	}
+    /**
+     * Gets the string content of a document read from an input stream.
+     * 
+     * @param documentUrl
+     *            URL pointing to the document to parse
+     * @param config
+     * @param mimeType
+     *            MIME type of the data
+     * @return the string content parsed from the document
+     * @throws TikaException
+     * @throws IOException
+     */
+    public static String getStringContent(URL documentUrl, TikaConfig config,
+            String mimeType) throws TikaException, IOException {
+        InputStream stream = documentUrl.openStream();
+        try {
+            return getStringContent(stream, config, mimeType);
+        } finally {
+            stream.close();
+        }
+    }
 
-	/**
-	 * Gets the string content of a document read from an input stream.
-	 * 
-	 * @param documentFile
-	 *            File object pointing to the document to parse
-	 * @param config
-	 * @param mimeType
-	 *            MIME type of the data
-	 * @return the string content parsed from the document
-	 * @throws TikaException
-	 * @throws IOException
-	 */
-	public static String getStringContent(File documentFile, TikaConfig config,
-			String mimeType) throws TikaException, IOException {
-		InputStream stream = new BufferedInputStream(new FileInputStream(
-				documentFile));
-		try {
-			return getStringContent(stream, config, mimeType);
-		} finally {
-			stream.close();
-		}
-	}
+    /**
+     * Gets the string content of a document read from an input stream.
+     * 
+     * @param documentFile
+     *            File object pointing to the document to parse
+     * @param config
+     * @param mimeType
+     *            MIME type of the data
+     * @return the string content parsed from the document
+     * @throws TikaException
+     * @throws IOException
+     */
+    public static String getStringContent(File documentFile, TikaConfig config,
+            String mimeType) throws TikaException, IOException {
+        InputStream stream = new BufferedInputStream(new FileInputStream(
+                documentFile));
+        try {
+            return getStringContent(stream, config, mimeType);
+        } finally {
+            stream.close();
+        }
+    }
 
-	/**
-	 * Gets the string content of a document read from an input stream.
-	 * 
-	 * @param documentFile
-	 *            File object pointing to the document to parse
-	 * @param config
-	 * @return the string content parsed from the document
-	 * @throws TikaException
-	 * @throws IOException
-	 */
-	public static String getStringContent(File documentFile, TikaConfig config)
-			throws TikaException, IOException {
-		String mime = config.getMimeRepository().getMimeType(documentFile)
-				.getName();
-		return getStringContent(documentFile, config, mime);
-	}
+    /**
+     * Gets the string content of a document read from an input stream.
+     * 
+     * @param documentFile
+     *            File object pointing to the document to parse
+     * @param config
+     * @return the string content parsed from the document
+     * @throws TikaException
+     * @throws IOException
+     */
+    public static String getStringContent(File documentFile, TikaConfig config)
+            throws TikaException, IOException {
+        String mime = config.getMimeRepository().getMimeType(documentFile)
+        .getName();
+        return getStringContent(documentFile, config, mime);
+    }
 
 }
diff --git a/src/main/java/org/apache/tika/utils/RereadableInputStream.java b/src/main/java/org/apache/tika/utils/RereadableInputStream.java
index 2be715927..668001f87 100644
--- a/src/main/java/org/apache/tika/utils/RereadableInputStream.java
+++ b/src/main/java/org/apache/tika/utils/RereadableInputStream.java
@@ -28,80 +28,80 @@ import java.io.OutputStream;
 
 public class RereadableInputStream extends InputStream {
 
-	private InputStream inputStream;
-
-	private int maxBytesInMemory;
-
-	private boolean firstPass = true;
-
-	private boolean bufferIsInFile;
-
-	private byte[] byteBuffer;
-
-	private int size;
-
-	private File storeFile;
-
-	private OutputStream storeOutputStream;
-
-	public RereadableInputStream(InputStream inputStream, int maxBytesInMemory) {
-		this.inputStream = inputStream;
-		this.maxBytesInMemory = maxBytesInMemory;
-		byteBuffer = new byte[maxBytesInMemory];
-	}
-
-	public int read() throws IOException {
-		int inputByte = inputStream.read();
-		if (firstPass) {
-			saveByte(inputByte);
-		}
-		return inputByte;
-	}
-
-	private void saveByte(int inputByte) throws IOException {
-
-		if (!bufferIsInFile) {
-			boolean switchToFile = (size == (maxBytesInMemory));
-			if (switchToFile) {
-				storeFile = File.createTempFile("streamstore_", ".tmp");
-				bufferIsInFile = true;
-				storeOutputStream = new BufferedOutputStream(
-						new FileOutputStream(storeFile));
-				storeOutputStream.write(byteBuffer, 0, size);
-				storeOutputStream.write(inputByte);
-			} else {
-				byteBuffer[size] = (byte) inputByte;
-			}
-		} else {
-			storeOutputStream.write(inputByte);
-		}
-		++size;
-	}
-
-	public void rewind() throws IOException {
-		closeStream();
-		if (storeOutputStream != null) {
-			storeOutputStream.close();
-			storeOutputStream = null;
-		}
-		firstPass = false;
-		boolean newStreamIsInMemory = (size < maxBytesInMemory);
-		inputStream = newStreamIsInMemory ? new ByteArrayInputStream(byteBuffer)
-				: new BufferedInputStream(new FileInputStream(storeFile));
-	}
-
-	public void closeStream() throws IOException {
-		if (inputStream != null) {
-			inputStream.close();
-			inputStream = null;
-		}
-	}
-
-	public void close() throws IOException {
-		closeStream();
-		super.close();
-		if (storeFile != null) {
-			storeFile.delete();
-		}
-	}
+    private InputStream inputStream;
+
+    private int maxBytesInMemory;
+
+    private boolean firstPass = true;
+
+    private boolean bufferIsInFile;
+
+    private byte[] byteBuffer;
+
+    private int size;
+
+    private File storeFile;
+
+    private OutputStream storeOutputStream;
+
+    public RereadableInputStream(InputStream inputStream, int maxBytesInMemory) {
+        this.inputStream = inputStream;
+        this.maxBytesInMemory = maxBytesInMemory;
+        byteBuffer = new byte[maxBytesInMemory];
+    }
+
+    public int read() throws IOException {
+        int inputByte = inputStream.read();
+        if (firstPass) {
+            saveByte(inputByte);
+        }
+        return inputByte;
+    }
+
+    private void saveByte(int inputByte) throws IOException {
+
+        if (!bufferIsInFile) {
+            boolean switchToFile = (size == (maxBytesInMemory));
+            if (switchToFile) {
+                storeFile = File.createTempFile("streamstore_", ".tmp");
+                bufferIsInFile = true;
+                storeOutputStream = new BufferedOutputStream(
+                        new FileOutputStream(storeFile));
+                storeOutputStream.write(byteBuffer, 0, size);
+                storeOutputStream.write(inputByte);
+            } else {
+                byteBuffer[size] = (byte) inputByte;
+            }
+        } else {
+            storeOutputStream.write(inputByte);
+        }
+        ++size;
+    }
+
+    public void rewind() throws IOException {
+        closeStream();
+        if (storeOutputStream != null) {
+            storeOutputStream.close();
+            storeOutputStream = null;
+        }
+        firstPass = false;
+        boolean newStreamIsInMemory = (size < maxBytesInMemory);
+        inputStream = newStreamIsInMemory ? new ByteArrayInputStream(byteBuffer)
+        : new BufferedInputStream(new FileInputStream(storeFile));
+    }
+
+    public void closeStream() throws IOException {
+        if (inputStream != null) {
+            inputStream.close();
+            inputStream = null;
+        }
+    }
+
+    public void close() throws IOException {
+        closeStream();
+        super.close();
+        if (storeFile != null) {
+            storeFile.delete();
+        }
+    }
 }
diff --git a/src/main/java/org/apache/tika/utils/Utils.java b/src/main/java/org/apache/tika/utils/Utils.java
index 16a434ed7..d3ac16798 100644
--- a/src/main/java/org/apache/tika/utils/Utils.java
+++ b/src/main/java/org/apache/tika/utils/Utils.java
@@ -50,111 +50,111 @@ import org.jdom.output.XMLOutputter;
 
 public class Utils {
 
-	static Logger logger = Logger.getRootLogger();
-
-	public static String toString(Map<String, Content> structuredContent) {
-		final StringWriter sw = new StringWriter();
-		print(structuredContent, sw);
-		return sw.toString();
-	}
-
-	public static void print(Map<String, Content> structuredContent) {
-		print(structuredContent, new OutputStreamWriter(System.out));
-	}
-
-	public static void print(Map<String, Content> structuredContent,
-			Writer outputWriter) {
-		final PrintWriter output = new PrintWriter(outputWriter, true);
-		for (Map.Entry<String, Content> entry : structuredContent.entrySet()) {
-			Content ct = entry.getValue();
-			if (ct.getValue() != null) {
-				output.print(entry.getKey() + ": ");
-				output.println(ct.getValue());
-			} else if (ct.getValues() != null) {
-				output.print(entry.getKey() + ": ");
-				for (int j = 0; j < ct.getValues().length; j++) {
-					if (j == 0)
-						output.println(ct.getValues()[j]);
-					else {
-						output.println("\t" + ct.getValues()[j]);
-					}
-				}
-			} else { // there are no values, but there is a Content object
-				System.out.println("Content '" + entry.getKey()
-						+ "' has no values.");
-			}
-		}
-	}
-
-	public static Document parse(InputStream is) {
-		org.jdom.Document xmlDoc = new org.jdom.Document();
-		try {
-			SAXBuilder builder = new SAXBuilder();
-			builder.setValidation(false);
-			xmlDoc = builder.build(is);
-		} catch (JDOMException e) {
-			logger.error(e.getMessage());
-		} catch (IOException e) {
-			logger.error(e.getMessage());
-		}
-		return xmlDoc;
-	}
-
-	public static List unzip(InputStream is) {
-		List res = new ArrayList();
-		try {
-			ZipInputStream in = new ZipInputStream(is);
-			ZipEntry entry = null;
-			while ((entry = in.getNextEntry()) != null) {
-				ByteArrayOutputStream stream = new ByteArrayOutputStream();
-				byte[] buf = new byte[1024];
-				int len;
-				while ((len = in.read(buf)) > 0) {
-					stream.write(buf, 0, len);
-				}
-				InputStream isEntry = new ByteArrayInputStream(stream
-						.toByteArray());
-				File file = File.createTempFile("tmp", "_" + entry.getName());
-				saveInputStreamInFile(isEntry, new BufferedOutputStream(
-						new FileOutputStream(file)));
-				res.add(file);
-				isEntry.close();
-			}
-			in.close();
-		} catch (IOException e) {
-			logger.error(e.getMessage());
-		}
-		return res;
-	}
-
-	private static void saveInputStreamInFile(InputStream in, OutputStream out)
-			throws IOException {
-		byte[] buffer = new byte[1024];
-		int len;
-
-		while ((len = in.read(buffer)) >= 0)
-			out.write(buffer, 0, len);
-
-		in.close();
-		out.close();
-	}
-
-	public static void saveInXmlFile(Document doc, String file) {
-		Format f = Format.getPrettyFormat().setEncoding("UTF-8");
-
-		XMLOutputter xop = new XMLOutputter(f);
-
-		try {
-
-			xop.output(doc, new FileOutputStream(file));
-
-		}
-
-		catch (IOException ex) {
-
-			logger.error(ex.getMessage());
-
-		}
-	}
+    static Logger logger = Logger.getRootLogger();
+
+    public static String toString(Map<String, Content> structuredContent) {
+        final StringWriter sw = new StringWriter();
+        print(structuredContent, sw);
+        return sw.toString();
+    }
+
+    public static void print(Map<String, Content> structuredContent) {
+        print(structuredContent, new OutputStreamWriter(System.out));
+    }
+
+    public static void print(Map<String, Content> structuredContent,
+            Writer outputWriter) {
+        final PrintWriter output = new PrintWriter(outputWriter, true);
+        for (Map.Entry<String, Content> entry : structuredContent.entrySet()) {
+            Content ct = entry.getValue();
+            if (ct.getValue() != null) {
+                output.print(entry.getKey() + ": ");
+                output.println(ct.getValue());
+            } else if (ct.getValues() != null) {
+                output.print(entry.getKey() + ": ");
+                for (int j = 0; j < ct.getValues().length; j++) {
+                    if (j == 0)
+                        output.println(ct.getValues()[j]);
+                    else {
+                        output.println("\t" + ct.getValues()[j]);
+                    }
+                }
+            } else { // there are no values, but there is a Content object
+                System.out.println("Content '" + entry.getKey()
+                        + "' has no values.");
+            }
+        }
+    }
+
+    public static Document parse(InputStream is) {
+        org.jdom.Document xmlDoc = new org.jdom.Document();
+        try {
+            SAXBuilder builder = new SAXBuilder();
+            builder.setValidation(false);
+            xmlDoc = builder.build(is);
+        } catch (JDOMException e) {
+            logger.error(e.getMessage());
+        } catch (IOException e) {
+            logger.error(e.getMessage());
+        }
+        return xmlDoc;
+    }
+
+    public static List unzip(InputStream is) {
+        List res = new ArrayList();
+        try {
+            ZipInputStream in = new ZipInputStream(is);
+            ZipEntry entry = null;
+            while ((entry = in.getNextEntry()) != null) {
+                ByteArrayOutputStream stream = new ByteArrayOutputStream();
+                byte[] buf = new byte[1024];
+                int len;
+                while ((len = in.read(buf)) > 0) {
+                    stream.write(buf, 0, len);
+                }
+                InputStream isEntry = new ByteArrayInputStream(stream
+                        .toByteArray());
+                File file = File.createTempFile("tmp", "_" + entry.getName());
+                saveInputStreamInFile(isEntry, new BufferedOutputStream(
+                        new FileOutputStream(file)));
+                res.add(file);
+                isEntry.close();
+            }
+            in.close();
+        } catch (IOException e) {
+            logger.error(e.getMessage());
+        }
+        return res;
+    }
+
+    private static void saveInputStreamInFile(InputStream in, OutputStream out)
+            throws IOException {
+        byte[] buffer = new byte[1024];
+        int len;
+
+        while ((len = in.read(buffer)) >= 0)
+            out.write(buffer, 0, len);
+
+        in.close();
+        out.close();
+    }
+
+    public static void saveInXmlFile(Document doc, String file) {
+        Format f = Format.getPrettyFormat().setEncoding("UTF-8");
+
+        XMLOutputter xop = new XMLOutputter(f);
+
+        try {
+
+            xop.output(doc, new FileOutputStream(file));
+
+        }
+
+        catch (IOException ex) {
+
+            logger.error(ex.getMessage());
+
+        }
+    }
 
 }
diff --git a/src/test/java/org/apache/tika/RereadableInputStreamTest.java b/src/test/java/org/apache/tika/RereadableInputStreamTest.java
index 67f2b6635..5cdb256ed 100644
--- a/src/test/java/org/apache/tika/RereadableInputStreamTest.java
+++ b/src/test/java/org/apache/tika/RereadableInputStreamTest.java
@@ -29,41 +29,41 @@ import junit.framework.TestCase;
 
 public class RereadableInputStreamTest extends TestCase {
 
-	private final int TEST_SIZE = 3;
+    private final int TEST_SIZE = 3;
 
-	private final int MEMORY_THRESHOLD = 1;
+    private final int MEMORY_THRESHOLD = 1;
 
-	private final int NUM_PASSES = 4;
+    private final int NUM_PASSES = 4;
 
-	public void test() throws IOException {
+    public void test() throws IOException {
 
-		File file = createTestFile();
-		InputStream is = new BufferedInputStream(new FileInputStream(file));
-		RereadableInputStream ris = new RereadableInputStream(is,
-				MEMORY_THRESHOLD);
-		try {
-			for (int pass = 0; pass < NUM_PASSES; pass++) {
-				for (int byteNum = 0; byteNum < TEST_SIZE; byteNum++) {
-					int byteRead = ris.read();
-					assertEquals("Pass = " + pass + ", byte num should be "
-							+ byteNum + " but is " + byteRead + ".", byteNum,
-							byteRead);
-				}
-				ris.rewind();
-			}
-		} finally {
-			is.close();
-			ris.close();
-		}
-	}
+        File file = createTestFile();
+        InputStream is = new BufferedInputStream(new FileInputStream(file));
+        RereadableInputStream ris = new RereadableInputStream(is,
+                MEMORY_THRESHOLD);
+        try {
+            for (int pass = 0; pass < NUM_PASSES; pass++) {
+                for (int byteNum = 0; byteNum < TEST_SIZE; byteNum++) {
+                    int byteRead = ris.read();
+                    assertEquals("Pass = " + pass + ", byte num should be "
+                            + byteNum + " but is " + byteRead + ".", byteNum,
+                            byteRead);
+                }
+                ris.rewind();
+            }
+        } finally {
+            is.close();
+            ris.close();
+        }
+    }
 
-	private File createTestFile() throws IOException {
-		File testfile = File.createTempFile("ris_test", ".tmp");
-		FileOutputStream fos = new FileOutputStream(testfile);
-		for (int i = 0; i < TEST_SIZE; i++) {
-			fos.write(i);
-		}
-		fos.close();
-		return testfile;
-	}
+    private File createTestFile() throws IOException {
+        File testfile = File.createTempFile("ris_test", ".tmp");
+        FileOutputStream fos = new FileOutputStream(testfile);
+        for (int i = 0; i < TEST_SIZE; i++) {
+            fos.write(i);
+        }
+        fos.close();
+        return testfile;
+    }
 }
diff --git a/src/test/java/org/apache/tika/TestParsers.java b/src/test/java/org/apache/tika/TestParsers.java
index 04a00b7a0..94d696629 100644
--- a/src/test/java/org/apache/tika/TestParsers.java
+++ b/src/test/java/org/apache/tika/TestParsers.java
@@ -41,208 +41,208 @@ import org.jdom.JDOMException;
  */
 public class TestParsers extends TestCase {
 
-	private TikaConfig tc;
-
-	private File testFilesBaseDir;
-
-	public void setUp() throws JDOMException, IOException {
-		/*
-		 * FIXME the old mechanism does not work anymore when running the tests
-		 * with Maven - need a resource-based one, but this means more changes
-		 * to classes which rely on filenames.
-		 * 
-		 * String sep = File.separator; StringTokenizer st = new
-		 * StringTokenizer(System.getProperty( "java.class.path"),
-		 * File.pathSeparator);
-		 * 
-		 * classDir = new File(st.nextToken());
-		 * 
-		 * config = classDir.getParent() + sep + "config" + sep + "config.xml";
-		 * 
-		 * String log4j = classDir.getParent() + sep + "Config" + sep + "log4j" +
-		 * sep + "log4j.properties";
-		 */
-
-		// FIXME for now, fix filenames according to Maven testing layout
-		// The file below should be the default configuration for the test of
-		// getDefaultConfig() to be legitimate.
-		final String tikaConfigFilename = "target/classes/org/apache/tika/tika-config.xml";
-
-		final String log4jPropertiesFilename = "target/classes/log4j/log4j.properties";
-
-		testFilesBaseDir = new File("src/test/resources/test-documents");
-
-		tc = new TikaConfig(tikaConfigFilename);
-
-		TikaLogger.setLoggerConfigFile(log4jPropertiesFilename);
-	}
-
-	public void testPDFExtraction() throws Exception {
-		File file = getTestFile("testPDF.pdf");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc, "application/pdf");
-		String s3 = ParseUtils.getStringContent(file, TikaConfig
-				.getDefaultConfig());
-		assertEquals(s1, s2);
-		assertEquals(s1, s3);
-	}
-
-	public void testTXTExtraction() throws Exception {
-		File file = getTestFile("testTXT.txt");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc, "text/plain");
-		assertEquals(s1, s2);
-	}
-
-	public void testRTFExtraction() throws Exception {
-		File file = getTestFile("testRTF.rtf");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc, "application/rtf");
-		assertEquals(s1, s2);
-	}
-
-	public void testXMLExtraction() throws Exception {
-		File file = getTestFile("testXML.xml");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc, "application/xml");
-		assertEquals(s1, s2);
-	}
-
-	public void testPPTExtraction() throws Exception {
-		File file = getTestFile("testPPT.ppt");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc,
-				"application/vnd.ms-powerpoint");
-		assertEquals(s1, s2);
-		ParserConfig config = tc
-				.getParserConfig("application/vnd.ms-powerpoint");
-		Parser parser = ParserFactory.getParser(config);
-		Map<String, Content> contents = config.getContents();
-		assertNotNull(contents);
-		InputStream stream = new FileInputStream(file);
-		try {
-			parser.getContents(stream, contents);
-		} finally {
-			stream.close();
-		}
-		assertEquals("Sample Powerpoint Slide", contents.get("title")
-				.getValue());
-	}
-
-	public void testWORDxtraction() throws Exception {
-		File file = getTestFile("testWORD.doc");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc, "application/msword");
-		assertEquals(s1, s2);
-		ParserConfig config = tc.getParserConfig("application/msword");
-		Parser parser = ParserFactory.getParser(config);
-		Map<String, Content> contents = config.getContents();
-		assertNotNull(contents);
-		InputStream stream = new FileInputStream(file);
-		try {
-			parser.getContents(stream, contents);
-		} finally {
-			stream.close();
-		}
-		assertEquals("Sample Word Document", contents.get("title").getValue());
-	}
-
-	public void testEXCELExtraction() throws Exception {
-		final String expected = "Numbers and their Squares Number Square 1.0 "
-				+ "1.0 2.0 4.0 3.0 9.0 4.0 16.0 5.0 25.0 6.0 36.0 7.0 49.0 8.0 "
-				+ "64.0 9.0 81.0 10.0 100.0 11.0 121.0 12.0 144.0 13.0 169.0 "
-				+ "14.0 196.0 15.0 225.0 Written and saved in Microsoft Excel "
-				+ "X for Mac Service Release 1.";
-		File file = getTestFile("testEXCEL.xls");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc,
-				"application/vnd.ms-excel");
-		assertEquals(s1, s2);
-		assertTrue("Text does not contain '" + expected + "'", s1
-				.contains(expected));
-		ParserConfig config = tc.getParserConfig("application/vnd.ms-excel");
-		Parser parser = ParserFactory.getParser(config);
-		Map<String, Content> contents = config.getContents();
-		assertNotNull(contents);
-		InputStream stream = new FileInputStream(file);
-		try {
-			parser.getContents(stream, contents);
-		} finally {
-			stream.close();
-		}
-		assertEquals("Simple Excel document", contents.get("title").getValue());
-	}
-
-	public void testOOExtraction() throws Exception {
-		File file = getTestFile("testOpenOffice2.odt");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc,
-				"application/vnd.oasis.opendocument.text");
-		assertEquals(s1, s2);
-	}
-
-	public void testHTMLExtraction() throws Exception {
-		File file = getTestFile("testHTML.html");
-		String s1 = ParseUtils.getStringContent(file, tc);
-		String s2 = ParseUtils.getStringContent(file, tc, "text/html");
-		assertEquals(s1, s2);
-
-		ParserConfig config = tc.getParserConfig("text/html");
-		Parser parser = ParserFactory.getParser(config);
-		assertNotNull(parser);
-		assertEquals("org.apache.tika.parser.html.HtmlParser", parser
-				.getClass().getName());
-		parser.setMimeType("text/html");
-
-		Map<String, Content> contents = config.getContents();
-		assertNotNull(contents);
-		InputStream stream = new FileInputStream(file);
-		try {
-			parser.getContents(stream, contents);
-		} finally {
-			stream.close();
-		}
-		assertEquals("Title : Test Indexation Html", contents.get("title")
-				.getValue());
-
-		assertEquals("text/html", parser.getMimeType());
-
-		final String text = Utils.toString(contents);
-		final String expected = "Test Indexation Html";
-		assertTrue("text contains '" + expected + "'", text.contains(expected));
-	}
-
-	public void testZipExtraction() throws Exception {
-		File zip = getTestFile("test-documents.zip");
-		List<Parser> parsers = ParseUtils.getParsersFromZip(zip, tc);
-		List<File> zipFiles = Utils.unzip(new FileInputStream(zip));
-		for (int i = 0; i < parsers.size(); i++) {
-			Parser zipEntryParser = parsers.get(i);
-			assertNotNull(zipEntryParser);
-			assertNotNull(zipEntryParser.getMimeType());
-			for (int j = 0; j < zipFiles.size(); j++) {
-				if (zipEntryParser.getMimeType().equalsIgnoreCase(
-						tc.getMimeRepository().getMimeType(zipFiles.get(j))
-								.getName())) {
-					ParserConfig config = tc.getParserConfig(zipEntryParser
-							.getMimeType());
-					Map<String, Content> contents = config.getContents();
-					assertNotNull(contents);
-					InputStream stream = new FileInputStream(zipFiles.get(j));
-					try {
-						zipEntryParser.getContents(stream, contents);
-						assertNotNull(contents.get("fullText"));
-					} finally {
-						stream.close();
-					}
-				}
-			}
-
-		}
-	}
-
-	private File getTestFile(String filename) {
-		return new File(testFilesBaseDir, filename);
-	}
+    private TikaConfig tc;
+
+    private File testFilesBaseDir;
+
+    public void setUp() throws JDOMException, IOException {
+        /*
+         * FIXME the old mechanism does not work anymore when running the tests
+         * with Maven - need a resource-based one, but this means more changes
+         * to classes which rely on filenames.
+         * 
+         * String sep = File.separator; StringTokenizer st = new
+         * StringTokenizer(System.getProperty( "java.class.path"),
+         * File.pathSeparator);
+         * 
+         * classDir = new File(st.nextToken());
+         * 
+         * config = classDir.getParent() + sep + "config" + sep + "config.xml";
+         * 
+         * String log4j = classDir.getParent() + sep + "Config" + sep + "log4j" +
+         * sep + "log4j.properties";
+         */
+
+        // FIXME for now, fix filenames according to Maven testing layout
+        // The file below should be the default configuration for the test of
+        // getDefaultConfig() to be legitimate.
+        final String tikaConfigFilename = "target/classes/org/apache/tika/tika-config.xml";
+
+        final String log4jPropertiesFilename = "target/classes/log4j/log4j.properties";
+
+        testFilesBaseDir = new File("src/test/resources/test-documents");
+
+        tc = new TikaConfig(tikaConfigFilename);
+
+        TikaLogger.setLoggerConfigFile(log4jPropertiesFilename);
+    }
+
+    public void testPDFExtraction() throws Exception {
+        File file = getTestFile("testPDF.pdf");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc, "application/pdf");
+        String s3 = ParseUtils.getStringContent(file, TikaConfig
+                .getDefaultConfig());
+        assertEquals(s1, s2);
+        assertEquals(s1, s3);
+    }
+
+    public void testTXTExtraction() throws Exception {
+        File file = getTestFile("testTXT.txt");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc, "text/plain");
+        assertEquals(s1, s2);
+    }
+
+    public void testRTFExtraction() throws Exception {
+        File file = getTestFile("testRTF.rtf");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc, "application/rtf");
+        assertEquals(s1, s2);
+    }
+
+    public void testXMLExtraction() throws Exception {
+        File file = getTestFile("testXML.xml");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc, "application/xml");
+        assertEquals(s1, s2);
+    }
+
+    public void testPPTExtraction() throws Exception {
+        File file = getTestFile("testPPT.ppt");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc,
+        "application/vnd.ms-powerpoint");
+        assertEquals(s1, s2);
+        ParserConfig config = tc
+        .getParserConfig("application/vnd.ms-powerpoint");
+        Parser parser = ParserFactory.getParser(config);
+        Map<String, Content> contents = config.getContents();
+        assertNotNull(contents);
+        InputStream stream = new FileInputStream(file);
+        try {
+            parser.getContents(stream, contents);
+        } finally {
+            stream.close();
+        }
+        assertEquals("Sample Powerpoint Slide", contents.get("title")
+                .getValue());
+    }
+
+    public void testWORDxtraction() throws Exception {
+        File file = getTestFile("testWORD.doc");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc, "application/msword");
+        assertEquals(s1, s2);
+        ParserConfig config = tc.getParserConfig("application/msword");
+        Parser parser = ParserFactory.getParser(config);
+        Map<String, Content> contents = config.getContents();
+        assertNotNull(contents);
+        InputStream stream = new FileInputStream(file);
+        try {
+            parser.getContents(stream, contents);
+        } finally {
+            stream.close();
+        }
+        assertEquals("Sample Word Document", contents.get("title").getValue());
+    }
+
+    public void testEXCELExtraction() throws Exception {
+        final String expected = "Numbers and their Squares Number Square 1.0 "
+            + "1.0 2.0 4.0 3.0 9.0 4.0 16.0 5.0 25.0 6.0 36.0 7.0 49.0 8.0 "
+            + "64.0 9.0 81.0 10.0 100.0 11.0 121.0 12.0 144.0 13.0 169.0 "
+            + "14.0 196.0 15.0 225.0 Written and saved in Microsoft Excel "
+            + "X for Mac Service Release 1.";
+        File file = getTestFile("testEXCEL.xls");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc,
+        "application/vnd.ms-excel");
+        assertEquals(s1, s2);
+        assertTrue("Text does not contain '" + expected + "'", s1
+                .contains(expected));
+        ParserConfig config = tc.getParserConfig("application/vnd.ms-excel");
+        Parser parser = ParserFactory.getParser(config);
+        Map<String, Content> contents = config.getContents();
+        assertNotNull(contents);
+        InputStream stream = new FileInputStream(file);
+        try {
+            parser.getContents(stream, contents);
+        } finally {
+            stream.close();
+        }
+        assertEquals("Simple Excel document", contents.get("title").getValue());
+    }
+
+    public void testOOExtraction() throws Exception {
+        File file = getTestFile("testOpenOffice2.odt");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc,
+        "application/vnd.oasis.opendocument.text");
+        assertEquals(s1, s2);
+    }
+
+    public void testHTMLExtraction() throws Exception {
+        File file = getTestFile("testHTML.html");
+        String s1 = ParseUtils.getStringContent(file, tc);
+        String s2 = ParseUtils.getStringContent(file, tc, "text/html");
+        assertEquals(s1, s2);
+
+        ParserConfig config = tc.getParserConfig("text/html");
+        Parser parser = ParserFactory.getParser(config);
+        assertNotNull(parser);
+        assertEquals("org.apache.tika.parser.html.HtmlParser", parser
+                .getClass().getName());
+        parser.setMimeType("text/html");
+
+        Map<String, Content> contents = config.getContents();
+        assertNotNull(contents);
+        InputStream stream = new FileInputStream(file);
+        try {
+            parser.getContents(stream, contents);
+        } finally {
+            stream.close();
+        }
+        assertEquals("Title : Test Indexation Html", contents.get("title")
+                .getValue());
+
+        assertEquals("text/html", parser.getMimeType());
+
+        final String text = Utils.toString(contents);
+        final String expected = "Test Indexation Html";
+        assertTrue("text contains '" + expected + "'", text.contains(expected));
+    }
+
+    public void testZipExtraction() throws Exception {
+        File zip = getTestFile("test-documents.zip");
+        List<Parser> parsers = ParseUtils.getParsersFromZip(zip, tc);
+        List<File> zipFiles = Utils.unzip(new FileInputStream(zip));
+        for (int i = 0; i < parsers.size(); i++) {
+            Parser zipEntryParser = parsers.get(i);
+            assertNotNull(zipEntryParser);
+            assertNotNull(zipEntryParser.getMimeType());
+            for (int j = 0; j < zipFiles.size(); j++) {
+                if (zipEntryParser.getMimeType().equalsIgnoreCase(
+                        tc.getMimeRepository().getMimeType(zipFiles.get(j))
+                        .getName())) {
+                    ParserConfig config = tc.getParserConfig(zipEntryParser
+                            .getMimeType());
+                    Map<String, Content> contents = config.getContents();
+                    assertNotNull(contents);
+                    InputStream stream = new FileInputStream(zipFiles.get(j));
+                    try {
+                        zipEntryParser.getContents(stream, contents);
+                        assertNotNull(contents.get("fullText"));
+                    } finally {
+                        stream.close();
+                    }
+                }
+            }
+
+        }
+    }
+
+    private File getTestFile(String filename) {
+        return new File(testFilesBaseDir, filename);
+    }
 
 }
