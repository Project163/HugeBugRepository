diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/ignore.txt b/apache-rat-core/src/it/resources/ReportTest/RAT_335/commandLine.txt
similarity index 63%
rename from apache-rat-core/src/it/resources/ReportTest/RAT_335/ignore.txt
rename to apache-rat-core/src/it/resources/ReportTest/RAT_335/commandLine.txt
index df056a6f..0a6cbd33 100644
--- a/apache-rat-core/src/it/resources/ReportTest/RAT_335/ignore.txt
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_335/commandLine.txt
@@ -1,7 +1,5 @@
 --output-style
 xml
---input-exclude
-**/.gitignore
 --input-exclude-parsed-scm
 GIT
 --
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore
new file mode 100644
index 00000000..8855fa80
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore
@@ -0,0 +1,7 @@
+*.md
+
+# This makes it ignore dir3/dir3.log and dir3/file3.log
+*.log
+
+# This makes it "unignore" dir3/file3.log
+!file*.log
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/.gitignore b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/.gitignore
new file mode 100644
index 00000000..26fd5c95
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/.gitignore
@@ -0,0 +1,3 @@
+*.txt
+!dir1.md
+file1.log
\ No newline at end of file
diff --git a/apache-rat-core/src/test/resources/RAT_355/src/dir1/dir1.md b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/dir1.txt
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/src/dir1/dir1.md
rename to apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/dir1.txt
diff --git a/apache-rat-core/src/test/resources/RAT_355/src/dir2/dir2.txt b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/file1.log
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/src/dir2/dir2.txt
rename to apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/file1.log
diff --git a/apache-rat-core/src/test/resources/RAT_355/src/dir3/file3.log b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir2/dir2.md
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/src/dir3/file3.log
rename to apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir2/dir2.md
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir3/dir3.log b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir3/dir3.log
new file mode 100644
index 00000000..a31cbc89
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir3/dir3.log
@@ -0,0 +1 @@
+File without a valid license
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/root.md b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/root.md
new file mode 100644
index 00000000..a31cbc89
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/root.md
@@ -0,0 +1 @@
+File without a valid license
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/verify.groovy b/apache-rat-core/src/it/resources/ReportTest/RAT_335/verify.groovy
index 8a3e0765..36da7e7d 100644
--- a/apache-rat-core/src/it/resources/ReportTest/RAT_335/verify.groovy
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_335/verify.groovy
@@ -75,6 +75,35 @@ XPath xPath = XPathFactory.newInstance().newXPath()
 //XmlUtils.assertAttributes(document, xPath, "/rat-report/statistics/licenseName[@name='Unknown license']",
 //        mapOf("count", "4" ))
 
+
+
+//Note the output when running in the real commandline version of git
+//
+//# Files that must be ignored (dropping the gitignore matches outside of this test tree)
+//$ git check-ignore --no-index --verbose $(find . -type f|sort)
+//
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/.gitignore:2:!dir1.md	./dir1/dir1.md
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/.gitignore:1:*.txt	./dir1/dir1.txt
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/dir1/.gitignore:3:file1.log	./dir1/file1.log
+// .gitignore:20:**/.gitignore	./dir1/.gitignore
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore:1:*.md	./dir2/dir2.md
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore:4:*.log	./dir3/dir3.log
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore:7:!file*.log	./dir3/file3.log
+//         .gitignore:20:**/.gitignore	./.gitignore
+// apache-rat-core/src/it/resources/ReportTest/RAT_335/src/.gitignore:1:*.md	./root.md
+
+/* list of excluded files:
+
+./dir1/dir1.txt
+./dir1/file1.log
+./dir1/.gitignore
+./dir2/dir2.md
+./dir3/dir3.log
+./.gitignore
+./root.md
+
+ */
+
 List<String> ignoredFiles = new ArrayList<>(Arrays.asList(
         "/dir1/dir1.txt",
         "/dir1/file1.log",
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java
index 02f529f6..b19fde1c 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java
@@ -26,6 +26,7 @@ import java.util.Set;
 import java.util.TreeSet;
 
 import java.util.function.Predicate;
+import java.util.stream.Collectors;
 import javax.print.Doc;
 import org.apache.rat.document.DocumentName;
 import org.apache.rat.document.DocumentNameMatcher;
@@ -188,12 +189,10 @@ public class ExclusionProcessor {
             lastMatcherBaseDir = basedir;
 
             // add the file processors
-            final List<MatcherSet> fileProcessors = extractFileProcessors(basedir, new ArrayList<>());
-
+            final List<MatcherSet> fileProcessors = extractFileProcessors(basedir);
+            final MatcherSet.Builder fromCommandLine = new MatcherSet.Builder();
             DocumentName.Builder nameBuilder = DocumentName.builder().setBaseName(basedir);
-            MatcherSet.Builder fromCommandLine = new MatcherSet.Builder()
-                    .addExcluded(nameBuilder.setName("excludedPatterns").build(), excludedPatterns)
-                    .addIncluded(nameBuilder.setName("includedPatterns").build(), includedPatterns);
+            extractPatterns(nameBuilder, fromCommandLine);
             extractCollectionPatterns(nameBuilder, fromCommandLine);
             extractCollectionMatchers(fromCommandLine);
             extractPaths(fromCommandLine);
@@ -205,7 +204,13 @@ public class ExclusionProcessor {
         return lastMatcher;
     }
 
-    private List<MatcherSet> extractFileProcessors(final DocumentName basedir, final List<MatcherSet> fileProcessorList) {
+    /**
+     * Extracts the file processors from {@link #fileProcessors}.
+     * @param basedir The directory to base the file processors on.
+     * @return a list of MatcherSets that are created for each {@link #fileProcessors} entry.
+     */
+    private List<MatcherSet> extractFileProcessors(final DocumentName basedir) {
+        final List<MatcherSet> fileProcessorList = new ArrayList<>();
         for (StandardCollection sc : fileProcessors) {
             ExtendedIterator<MatcherSet> iter =  sc.fileProcessorBuilder().map(builder -> builder.build(basedir));
             if (iter.hasNext()) {
@@ -217,14 +222,28 @@ public class ExclusionProcessor {
         return fileProcessorList;
     }
 
-    private void extractPatterns(final DocumentName commandLine, final MatcherSet.Builder fromCommandLine) {
-        fromCommandLine
-                .addExcluded(commandLine, excludedPatterns)
-                .addIncluded(commandLine, includedPatterns);
+    /**
+     * Extracts {@link #includedPatterns} and {@link #excludedPatterns} into the specified matcherBuilder.
+     * @param nameBuilder The name builder for the pattern.  File names are resolved against the generated name.
+     * @param matcherBuilder the MatcherSet.Builder to add the patterns to.
+     */
+    private void extractPatterns(DocumentName.Builder nameBuilder, MatcherSet.Builder matcherBuilder) {
+        DocumentName name = nameBuilder.setName("Patterns").build();
+        if (!excludedPatterns.isEmpty()) {
+            matcherBuilder.addExcluded(name, excludedPatterns.stream().map(s -> ExclusionUtils.localizePattern(name.getBaseDocumentName(), s)).collect(Collectors.toSet()));
+        }
+        if (!includedPatterns.isEmpty()) {
+
+            matcherBuilder.addIncluded(name, includedPatterns.stream().map(s -> ExclusionUtils.localizePattern(name.getBaseDocumentName(), s)).collect(Collectors.toSet()));
+        }
     }
 
-    private void extractCollectionPatterns(final DocumentName.Builder nameBuilder, final MatcherSet.Builder fileProcessorBuilder) {
-        // add the collection patterns
+    /**
+     * Extracts {@link #includedCollections} and {@link #excludedCollections} patterns into the specified matcherBuilder.
+     * @param nameBuilder the name builder for the pattern names.
+     * @param matcherBuilder the MatcherSet.Builder to add the collections to.
+     */
+    private void extractCollectionPatterns(final DocumentName.Builder nameBuilder, final MatcherSet.Builder matcherBuilder) {
         final Set<String> incl = new TreeSet<>();
         final Set<String> excl = new TreeSet<>();
         for (StandardCollection sc : includedCollections) {
@@ -243,41 +262,47 @@ public class ExclusionProcessor {
                 MatcherSet.Builder.segregateList(excl, incl, sc.patterns());
             }
         }
-        nameBuilder.setName("collections");
-        fileProcessorBuilder
-                .addExcluded(nameBuilder.setName("excludedCollections").build(), excl)
-                .addIncluded(nameBuilder.setName("includedCollections").build(), incl);
+        DocumentName name = nameBuilder.setName("Collections").build();
+        matcherBuilder
+                .addExcluded(name, excl)
+                .addIncluded(name, incl);
 
     }
 
-    private void extractCollectionMatchers(final MatcherSet.Builder fromCommandLine) {
-        // add the matchers
+    /**
+     * Extracts {@link #includedCollections} and {@link #excludedCollections} matchers into the specified matcherBuilder.
+     * @param matcherBuilder the MatcherSet.Builder to add the collections to.
+     */
+    private void extractCollectionMatchers(final MatcherSet.Builder matcherBuilder) {
         ExtendedIterator.create(includedCollections.iterator())
                 .map(StandardCollection::staticDocumentNameMatcher)
                 .filter(Objects::nonNull)
-                .forEachRemaining(fromCommandLine::addIncluded);
+                .forEachRemaining(matcherBuilder::addIncluded);
 
         ExtendedIterator.create(excludedCollections.iterator())
                 .map(StandardCollection::staticDocumentNameMatcher)
                 .filter(Objects::nonNull)
-                .forEachRemaining(fromCommandLine::addExcluded);
+                .forEachRemaining(matcherBuilder::addExcluded);
 
     }
 
-    private void extractPaths(final MatcherSet.Builder fromCommandLine) {
+    /**
+     * Extracts {@link #includedPaths} and {@link #excludedPaths} patterns into the specified matcherBuilder.
+     * @param matcherBuilder the MatcherSet.Builder to add the collections to.
+     */
+    private void extractPaths(final MatcherSet.Builder matcherBuilder) {
         if (!includedPaths.isEmpty()) {
             for (DocumentNameMatcher matcher : includedPaths) {
                 DefaultLog.getInstance().info(format("Including path matcher %s", matcher));
-                fromCommandLine.addIncluded(matcher);
+                matcherBuilder.addIncluded(matcher);
             }
         }
         if (!excludedPaths.isEmpty()) {
             for (DocumentNameMatcher matcher : excludedPaths) {
                 DefaultLog.getInstance().info(format("Excluding path matcher %s", matcher));
-                fromCommandLine.addExcluded(matcher);
+                matcherBuilder.addExcluded(matcher);
             }
         }
-
     }
 
     private DocumentNameMatcher createMatcher(List<MatcherSet> fileProcessors) {
@@ -312,7 +337,7 @@ public class ExclusionProcessor {
                 }
                 return true;
             };
-            final String name = format("or(%s, not(%s)", included, excluded);
+            final String name = DocumentNameMatcher.or(included, DocumentNameMatcher.not(excluded)).toString();
             return new DocumentNameMatcher(name, pred);
         }
     }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java
index 90a8f1a1..6463be4a 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java
@@ -34,6 +34,8 @@ import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.LineIterator;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.rat.ConfigurationException;
+import org.apache.rat.config.exclusion.plexus.MatchPattern;
+import org.apache.rat.config.exclusion.plexus.SelectorUtils;
 import org.apache.rat.document.DocumentName;
 import org.apache.rat.document.DocumentNameMatcher;
 import org.apache.rat.utils.ExtendedIterator;
@@ -188,4 +190,31 @@ public final class ExclusionUtils {
             throw new ConfigurationException(format("%s is not a valid file.", file));
         }
     }
+
+    /**
+     * Modifies the {@link MatchPattern} formatted {@code pattern} argument by expanding the pattern and
+     * by adjusting the pattern to include the basename from the {@code documentName} argument.
+     * @param documentName the name of the file being read.
+     * @param pattern the pattern to format.
+     * @return the completely formatted pattern
+     */
+    public static String localizePattern(final DocumentName documentName, final String pattern) {
+        boolean prefix = pattern.startsWith(NEGATION_PREFIX);
+        String workingPattern = prefix ? pattern.substring(1) : pattern;
+        String normalizedPattern = SelectorUtils.extractPattern(workingPattern, documentName.getDirectorySeparator());
+        StringBuilder sb = new StringBuilder();
+        if (SelectorUtils.isRegexPrefixedPattern(workingPattern)) {
+            sb.append(prefix ? NEGATION_PREFIX : "")
+                    .append(SelectorUtils.REGEX_HANDLER_PREFIX)
+                    .append("\\Q").append(documentName.getBaseName())
+                    .append(documentName.getDirectorySeparator())
+                    .append("\\E").append(normalizedPattern)
+                    .append(SelectorUtils.PATTERN_HANDLER_SUFFIX);
+            return sb.toString();
+        } else {
+            sb.append(documentName.getBaseName())
+                    .append(documentName.getDirectorySeparator()).append(normalizedPattern);
+            return (prefix ? NEGATION_PREFIX : "") + DocumentName.builder(documentName).setName(sb.toString()).build().getName();
+        }
+    }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/MatcherSet.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/MatcherSet.java
index c13b1cee..73cde574 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/MatcherSet.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/MatcherSet.java
@@ -37,7 +37,6 @@ import org.apache.rat.config.exclusion.plexus.MatchPatterns;
 import org.apache.rat.config.exclusion.plexus.SelectorUtils;
 import org.apache.rat.document.DocumentName;
 import org.apache.rat.document.DocumentNameMatcher;
-import org.apache.rat.utils.ExtendedIterator;
 
 /**
  * The file processor reads the file specified in the DocumentName.
@@ -57,34 +56,7 @@ public interface MatcherSet {
     class Builder {
 
         /** A String format pattern to print a regex string */
-        public static final String REGEX_FMT = "%%regex[%s]";
-
-        /**
-         * Modifies the {@link MatchPattern} formatted {@code pattern} argument by expanding the pattern and
-         * by adjusting the pattern to include the basename from the {@code documentName} argument.
-         * @param documentName the name of the file being read.
-         * @param pattern the pattern to format.
-         * @return the completely formatted pattern
-         */
-        public static String localizePattern(final DocumentName documentName, final String pattern) {
-            boolean prefix = pattern.startsWith(ExclusionUtils.NEGATION_PREFIX);
-            String workingPattern = prefix ? pattern.substring(1) : pattern;
-            String normalizedPattern = SelectorUtils.extractPattern(workingPattern, documentName.getDirectorySeparator());
-            StringBuilder sb = new StringBuilder();
-            if (SelectorUtils.isRegexPrefixedPattern(workingPattern)) {
-                sb.append(prefix ? ExclusionUtils.NEGATION_PREFIX : "")
-                        .append(SelectorUtils.REGEX_HANDLER_PREFIX)
-                        .append("\\Q").append(documentName.getBaseName())
-                        .append(documentName.getDirectorySeparator())
-                        .append("\\E").append(normalizedPattern)
-                        .append(SelectorUtils.PATTERN_HANDLER_SUFFIX);
-                return sb.toString();
-            } else {
-                sb.append(documentName.getBaseName())
-                        .append(documentName.getDirectorySeparator()).append(normalizedPattern);
-                return (prefix ? ExclusionUtils.NEGATION_PREFIX : "") + DocumentName.builder(documentName).setName(sb.toString()).build().getName();
-            }
-        }
+        protected static final String REGEX_FMT = "%%regex[%s]";
 
         /**
          * Adds to lists of qualified file patterns. Non-matching patterns start with a {@code !}.
@@ -118,15 +90,6 @@ public interface MatcherSet {
             commentFilter = StringUtils::isNotBlank;
         }
 
-        /**
-         * Constructor.
-         * @param fileName The name of the file to process.
-         * @param commentPrefix the comment prefix
-         */
-        protected Builder(final String fileName, final String commentPrefix) {
-            this(fileName, commentPrefix == null ? null : Collections.singletonList(commentPrefix));
-        }
-
         /**
          * Constructor.
          * @param fileName name of the file to process
@@ -144,22 +107,24 @@ public interface MatcherSet {
          * Default implementation returns the @{code entry} argument.
          * @param documentName the name of the document that the file was read from.
          * @param entry the entry from that document.
-         * @return the modified string or null to skip the string.
+         * @return the modified string or an empty Optional to skip the string.
          */
-        protected String modifyEntry(final DocumentName documentName, final String entry) {
-            return entry;
+        protected Optional<String> modifyEntry(final DocumentName documentName, final String entry) {
+            return Optional.of(entry);
         }
 
         public Builder addIncluded(DocumentName fromDocument, Set<String> names) {
             if (!names.isEmpty()) {
-                addIncluded(new DocumentNameMatcher(fromDocument.localized("/"), MatchPatterns.from(names), fromDocument.getBaseDocumentName()));
+                String name = String.format("'included %s'", fromDocument.localized("/").substring(1));
+                addIncluded(new DocumentNameMatcher(name, MatchPatterns.from(names), fromDocument.getBaseDocumentName()));
             }
             return this;
         }
 
         public Builder addExcluded(DocumentName fromDocument, Set<String> names) {
             if (!names.isEmpty()) {
-                addExcluded(new DocumentNameMatcher(fromDocument.localized("/"), MatchPatterns.from(names), fromDocument.getBaseDocumentName()));
+                String name = String.format("'excluded %s'", fromDocument.localized("/").substring(1));
+                addExcluded(new DocumentNameMatcher(name, MatchPatterns.from(names), fromDocument.getBaseDocumentName()));
             }
             return this;
         }
@@ -179,14 +144,24 @@ public interface MatcherSet {
          * @param documentName the file to read.
          */
          protected void process(final DocumentName documentName) {
-             Set<String> included = new HashSet<>();
-             Set<String> excluded = new HashSet<>();
              List<String> iterable = new ArrayList<>();
              ExclusionUtils.asIterator(new File(documentName.getName()), commentFilter)
-                    .map(entry -> modifyEntry(documentName, entry))
+                    .map(entry -> modifyEntry(documentName, entry).orElse(null))
                     .filter(Objects::nonNull)
-                    .map(entry -> localizePattern(documentName, entry))
+                    .map(entry -> ExclusionUtils.localizePattern(documentName, entry))
                             .forEachRemaining(iterable::add);
+             segregateProcessResult(documentName, iterable);
+         }
+
+        /**
+         * Moves properly formatted file names includes, excludes into the proper
+         * {@link #included} and {@link #excluded} DocumentMatchers.
+         * @param documentName the nome of the document being processed.
+         * @param iterable the list of properly formatted include and excludes from the input.
+         */
+        protected void segregateProcessResult(final DocumentName documentName, List<String> iterable) {
+             Set<String> included = new HashSet<>();
+             Set<String> excluded = new HashSet<>();
              segregateList(included, excluded, iterable);
              addExcluded(documentName, excluded);
              addIncluded(documentName, included);
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/AbstractBuilder.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/AbstractBuilder.java
new file mode 100644
index 00000000..59fcfd06
--- /dev/null
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/AbstractBuilder.java
@@ -0,0 +1,44 @@
+package org.apache.rat.config.exclusion.fileProcessors;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.apache.rat.config.exclusion.MatcherSet;
+import org.apache.rat.document.DocumentName;
+
+public class AbstractBuilder extends MatcherSet.Builder {
+
+    /**
+     * Constructor.
+     * @param fileName The name of the file to process.
+     * @param commentPrefix the comment prefix
+     */
+    protected AbstractBuilder(final String fileName, final String commentPrefix) {
+        this(fileName, commentPrefix == null ? null : Collections.singletonList(commentPrefix));
+    }
+
+    /**
+     * Constructor.
+     * @param fileName name of the file to process
+     * @param commentPrefixes a collection of comment prefixes.
+     */
+    protected AbstractBuilder(final String fileName, final Iterable<String> commentPrefixes) {
+        super(fileName, commentPrefixes);
+    }
+
+    /**
+     * Moves properly formatted file names includes, excludes into the proper
+     * {@link #included} and {@link #excluded} DocumentMatchers.  This differs from the parent implementation
+     * in that patterns that match the process are excluded.
+     * @param documentName the nome of the document being processed.
+     * @param iterable the list of properly formatted include and excludes from the input.
+     */
+    protected void segregateProcessResult(final DocumentName documentName, List<String> iterable) {
+        Set<String> included = new HashSet<>();
+        Set<String> excluded = new HashSet<>();
+        segregateList(excluded, included, iterable);
+        addExcluded(documentName, excluded);
+        addIncluded(documentName, included);
+    }
+}
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilder.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilder.java
index 315ec99d..a8b65c96 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilder.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilder.java
@@ -18,6 +18,7 @@
  */
 package org.apache.rat.config.exclusion.fileProcessors;
 
+import java.util.Optional;
 import org.apache.rat.config.exclusion.MatcherSet;
 import org.apache.rat.document.DocumentName;
 
@@ -26,7 +27,7 @@ import static java.lang.String.format;
 /**
  * A processor for {@code .bzrignore} files.
  */
-public final class BazaarIgnoreBuilder extends MatcherSet.Builder {
+public final class BazaarIgnoreBuilder extends AbstractBuilder {
     /**
      * Constructor.
      */
@@ -35,12 +36,12 @@ public final class BazaarIgnoreBuilder extends MatcherSet.Builder {
     }
 
     @Override
-    public String modifyEntry(final DocumentName baseName, final String entry) {
+    public Optional<String> modifyEntry(final DocumentName baseName, final String entry) {
         if (entry.startsWith("RE:")) {
             String line = entry.substring("RE:".length()).trim();
             String pattern = line.startsWith("^") ? line.substring(1) : line;
-            return format(REGEX_FMT, pattern);
+            return Optional.of(format(REGEX_FMT, pattern));
         }
-        return entry;
+        return Optional.of(entry);
     }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilder.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilder.java
index cd308e92..3aae5765 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilder.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilder.java
@@ -31,7 +31,7 @@ import org.apache.rat.document.DocumentName;
 /**
  * A file processor for the {@code .csvignore} file.
  */
-public class CVSIgnoreBuilder extends MatcherSet.Builder {
+public class CVSIgnoreBuilder extends AbstractBuilder {
     /**
      * The constructor.
      */
@@ -49,10 +49,10 @@ public class CVSIgnoreBuilder extends MatcherSet.Builder {
             String[] parts = line.split("\\s+");
             for (String part : parts) {
                 if (!part.isEmpty()) {
-                    result.add(localizePattern(documentName, part));
+                    result.add(ExclusionUtils.localizePattern(documentName, part));
                 }
             }
         }
-        addIncluded(documentName.getBaseDocumentName(), result);
+        addExcluded(documentName, result);
     }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java
index 319f2a13..0c931d79 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java
@@ -22,10 +22,9 @@ import java.io.File;
 
 import java.io.FileFilter;
 import java.util.ArrayList;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Objects;
-import java.util.Set;
+import java.util.Optional;
 import java.util.SortedMap;
 import java.util.TreeMap;
 import java.util.function.Consumer;
@@ -42,7 +41,7 @@ import static org.apache.rat.config.exclusion.ExclusionUtils.NEGATION_PREFIX;
  * Processes the .gitignore file.
  * @see <a href='https://git-scm.com/docs/gitignore'>.gitignore documentation</a>
  */
-public class GitIgnoreBuilder extends MatcherSet.Builder {
+public class GitIgnoreBuilder extends AbstractBuilder {
     // create a list of levels that a list of processors at that level.
     // will return a custom matcher that from an overridden MatcherSet.customDocumentNameMatchers method
     // build LevelMatcher as a system that returns Include, Exclude or no status for each check.
@@ -112,12 +111,24 @@ public class GitIgnoreBuilder extends MatcherSet.Builder {
     }
 
     @Override
-    public String modifyEntry(final DocumentName documentName, final String entry) {
+    public Optional<String> modifyEntry(final DocumentName documentName, final String entry) {
         return modifyEntry(documentName, entry, this::addIncluded, this::addExcluded);
     }
 
-    private static String modifyEntry(final DocumentName documentName, final String entry, Consumer<DocumentNameMatcher> include,
-                                      Consumer<DocumentNameMatcher> exclude) {
+    /**
+     * Convert the string entry.
+     * If the string ends with a slash an {@link DocumentNameMatcher#and} is constructed from a directory check and the file
+     * name matcher.  In this case an empty Optional is returned.
+     * If the string starts with {@link ExclusionUtils#NEGATION_PREFIX} then the entry is placed in the include list, otherwise
+     * the entry is placed in the exclude list and the name of the check returned.
+     * @param documentName The name of the document being processed.
+     * @param entry The entry from the document
+     * @param include A consumer to accept the included DocumentNameMatchers.
+     * @param exclude A consumer to accept the excluded DocumentNameMatchers.
+     * @return and Optional containing the name of the matcher.
+     */
+    private static Optional<String> modifyEntry(final DocumentName documentName, final String entry, Consumer<DocumentNameMatcher> include,
+                                                Consumer<DocumentNameMatcher> exclude) {
         // An optional prefix "!" which negates the pattern;
         boolean prefix = entry.startsWith(NEGATION_PREFIX);
         String pattern = prefix || entry.startsWith(ESCAPED_COMMENT) || entry.startsWith(ESCAPED_NEGATION) ?
@@ -148,33 +159,28 @@ public class GitIgnoreBuilder extends MatcherSet.Builder {
             } else {
                 include.accept(matcher);
             }
-            return null;
+            return Optional.empty();
         }
-        return prefix ? NEGATION_PREFIX + pattern : pattern;
+        return Optional.of(prefix ? NEGATION_PREFIX + pattern : pattern);
     }
 
-    private class LevelBuilder extends MatcherSet.Builder {
+    private static class LevelBuilder extends AbstractBuilder {
         LevelBuilder(int level) {
             super(IGNORE_FILE+"-"+level, COMMENT_PREFIX);
         }
 
-        public String modifyEntry(final DocumentName documentName, final String entry) {
+        public Optional<String> modifyEntry(final DocumentName documentName, final String entry) {
             return GitIgnoreBuilder.modifyEntry(documentName, entry, this::addIncluded, this::addExcluded);
         }
 
         public void process(DocumentName directory, DocumentName documentName) {
-            Set<String> included = new HashSet<>();
-            Set<String> excluded = new HashSet<>();
             List<String> iterable = new ArrayList<>();
             ExclusionUtils.asIterator(new File(documentName.getName()), commentFilter)
-                    .map(entry -> modifyEntry(documentName, entry))
+                    .map(entry -> modifyEntry(documentName, entry).orElse(null))
                     .filter(Objects::nonNull)
-                    .map(entry -> localizePattern(documentName, entry))
+                    .map(entry -> ExclusionUtils.localizePattern(documentName, entry))
                     .forEachRemaining(iterable::add);
-            segregateList(included, excluded, iterable);
-            addExcluded(directory, excluded);
-            addIncluded(directory, included);
-
+            segregateProcessResult(directory, iterable);
         }
     }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilder.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilder.java
index 036333ea..86e8253c 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilder.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilder.java
@@ -19,6 +19,7 @@
 package org.apache.rat.config.exclusion.fileProcessors;
 
 import java.util.Locale;
+import java.util.Optional;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -30,7 +31,7 @@ import static java.lang.String.format;
 /**
  * A processor for the {@code .hgignore} files.
  */
-public final class  HgIgnoreBuilder extends MatcherSet.Builder {
+public final class  HgIgnoreBuilder extends AbstractBuilder {
     /**
      * The state enumeration for the processor. When processing the file the processor changes
      * syntax state depending on the input.
@@ -62,16 +63,16 @@ public final class  HgIgnoreBuilder extends MatcherSet.Builder {
     }
 
     @Override
-    public String modifyEntry(final DocumentName baseName, final String entry) {
+    public Optional<String> modifyEntry(final DocumentName baseName, final String entry) {
         Matcher m = SYNTAX_CHECK.matcher(entry.toLowerCase(Locale.ROOT));
         if (m.matches()) {
             state = Syntax.valueOf(m.group(1).toUpperCase());
-            return null;
+            return Optional.empty();
         }
         if (state == Syntax.REGEXP) {
             String pattern = entry.startsWith("^") ? entry.substring(1) : ".*" + entry;
-            return format(REGEX_FMT, pattern);
+            return Optional.of(format(REGEX_FMT, pattern));
         }
-        return entry;
+        return Optional.of(entry);
     }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java
index 043f3b0d..b0620b23 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java
@@ -23,7 +23,7 @@ import java.io.FileFilter;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
@@ -65,7 +65,7 @@ public final class DocumentNameMatcher {
     public DocumentNameMatcher(final String name, final Predicate<DocumentName> predicate) {
         this.name = name;
         this.predicate = predicate;
-        this.isCollection = predicate instanceof MatcherPredicate;
+        this.isCollection = predicate instanceof CollectionPredicate;
     }
 
     /**
@@ -85,10 +85,25 @@ public final class DocumentNameMatcher {
      */
     public DocumentNameMatcher(final String name, final MatchPatterns patterns, final DocumentName basedir) {
         this(name, (Predicate<DocumentName>) documentName -> patterns.matches(documentName.getName(),
-                MatchPattern.tokenizePathToString(documentName.getName(), basedir.getDirectorySeparator()),
+                tokenize(documentName.getName(), basedir.getDirectorySeparator()),
                 basedir.isCaseSensitive()));
     }
 
+    /**
+     * Tokenizes name for faster Matcher processing.
+     * @param name the name to tokenize
+     * @param dirSeparator the directory separator
+     * @return the tokenized name.
+     */
+    private static char[][] tokenize(String name, String dirSeparator) {
+        String[] tokenizedName = MatchPattern.tokenizePathToString(name, dirSeparator);
+        char[][] tokenizedNameChar = new char[tokenizedName.length][];
+        for (int i = 0; i < tokenizedName.length; i++) {
+            tokenizedNameChar[i] = tokenizedName[i].toCharArray();
+        }
+        return tokenizedNameChar;
+    }
+
     /**
      * Constructs a DocumentNameMatcher from a name and a DocumentName predicate.
      * @param name the name of the matcher.
@@ -185,17 +200,18 @@ public final class DocumentNameMatcher {
             return opt.get();
         }
 
-        Set<DocumentNameMatcher> myList = new HashSet<>();
+        // preserve order
+        Set<DocumentNameMatcher> workingSet = new LinkedHashSet<>();
         for (DocumentNameMatcher matcher : matchers) {
-            if (matcher.predicate instanceof MatcherPredicate && ((MatcherPredicate)matcher.predicate).matchValue) {
-                // nested "or"
-                ((MatcherPredicate)matcher.predicate).matchers.forEach(myList::add);
+            // check for nested or
+            if (matcher.predicate instanceof Or) {
+                ((Or)matcher.predicate).matchers.forEach(workingSet::add);
             } else {
-                myList.add(matcher);
+                workingSet.add(matcher);
             }
         }
-        opt = standardCollectionCheck(matchers, MATCHES_ALL);
-        return opt.orElseGet(() -> new DocumentNameMatcher(format("or(%s)", join(myList)), new MatcherPredicate(true, myList)));
+        return standardCollectionCheck(matchers, MATCHES_ALL)
+                .orElseGet(() -> new DocumentNameMatcher(format("or(%s)", join(workingSet)), new Or(workingSet)));
     }
 
     /**
@@ -218,17 +234,18 @@ public final class DocumentNameMatcher {
             return opt.get();
         }
 
-        Set<DocumentNameMatcher> myList = new HashSet<>();
+        // preserve order
+        Set<DocumentNameMatcher> workingSet = new LinkedHashSet<>();
         for (DocumentNameMatcher matcher : matchers) {
-            if (matcher.predicate instanceof MatcherPredicate && !((MatcherPredicate)matcher.predicate).matchValue) {
-                // nested "and"
-                ((MatcherPredicate)matcher.predicate).matchers.forEach(myList::add);
+            //  check for nexted And
+            if (matcher.predicate instanceof And) {
+                ((And)matcher.predicate).matchers.forEach(workingSet::add);
             } else {
-                myList.add(matcher);
+                workingSet.add(matcher);
             }
         }
         opt = standardCollectionCheck(matchers, MATCHES_NONE);
-        return opt.orElseGet(() -> new DocumentNameMatcher(format("and(%s)", join(myList)), new MatcherPredicate(false, myList)));
+        return opt.orElseGet(() -> new DocumentNameMatcher(format("and(%s)", join(workingSet)), new And(workingSet)));
     }
 
     /**
@@ -240,13 +257,36 @@ public final class DocumentNameMatcher {
         return and(Arrays.asList(matchers));
     }
 
-    private static class MatcherPredicate implements Predicate<DocumentName> {
-        final Iterable<DocumentNameMatcher> matchers;
-        final boolean matchValue;
+    /**
+     * A marker interface to indicate this predicate contains a collection of matchers.
+     */
+    private interface CollectionPredicate extends Predicate<DocumentName>{}
+
+    private static class And implements CollectionPredicate {
+
+        private final Iterable<DocumentNameMatcher> matchers;
+
+        And(final Iterable<DocumentNameMatcher> matchers) {
+            this.matchers = matchers;
+        }
+
+        @Override
+        public boolean test(DocumentName documentName) {
+            for (DocumentNameMatcher matcher : matchers) {
+                if (!matcher.matches(documentName)) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    private static class Or implements CollectionPredicate {
+
+        private final Iterable<DocumentNameMatcher> matchers;
 
-        MatcherPredicate(boolean matchValue, Iterable<DocumentNameMatcher> matchers) {
+        Or(final Iterable<DocumentNameMatcher> matchers) {
             this.matchers = matchers;
-            this.matchValue = matchValue;
         }
 
         @Override
@@ -256,7 +296,7 @@ public final class DocumentNameMatcher {
                     return true;
                 }
             }
-            return !matchValue;
+            return false;
         }
     }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java
index 62987340..0421eaa6 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java
@@ -35,7 +35,7 @@ public class FileProcessorTest {
     @ParameterizedTest(name="{index} {1}")
     @MethodSource("localizePatternData")
     void localizePatternTest(DocumentName baseName, String pattern, String expectedStr) {
-        assertThat(MatcherSet.Builder.localizePattern(baseName, pattern)).isEqualTo(expectedStr);
+        assertThat(ExclusionUtils.localizePattern(baseName, pattern)).isEqualTo(expectedStr);
     }
 
     public static Stream<Arguments> localizePatternData() {
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilderTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilderTest.java
index f2a86016..fe5cec33 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilderTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/BazaarIgnoreBuilderTest.java
@@ -47,9 +47,9 @@ public class BazaarIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
 
         BazaarIgnoreBuilder processor = new BazaarIgnoreBuilder();
         MatcherSet matcherSet = processor.build(baseName);
-        assertThat(matcherSet.includes()).isPresent();
-        assertThat(matcherSet.excludes()).isNotPresent();
-        DocumentNameMatcher matcher = matcherSet.includes().orElseThrow(() -> new IllegalStateException("How?"));
+        assertThat(matcherSet.excludes()).isPresent();
+        assertThat(matcherSet.includes()).isNotPresent();
+        DocumentNameMatcher matcher = matcherSet.excludes().orElseThrow(() -> new IllegalStateException("How?"));
         for (String name : expected) {
             DocumentName docName = baseName.resolve(name);
             assertThat(matcher.matches(docName)).as(docName.getName()).isTrue();
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilderTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilderTest.java
index 1f4799f7..ac5578b6 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilderTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/CVSIgnoreBuilderTest.java
@@ -47,9 +47,9 @@ public class CVSIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
         CVSIgnoreBuilder processor = new CVSIgnoreBuilder();
         MatcherSet matcherSet = processor.build(baseName);
 
-        assertThat(matcherSet.includes()).isPresent();
-        assertThat(matcherSet.excludes()).isNotPresent();
-        DocumentNameMatcher matcher = matcherSet.includes().orElseThrow(() -> new IllegalStateException("How?"));
+        assertThat(matcherSet.excludes()).isPresent();
+        assertThat(matcherSet.includes()).isNotPresent();
+        DocumentNameMatcher matcher = matcherSet.excludes().orElseThrow(() -> new IllegalStateException("How?"));
         for (String name : expected) {
             DocumentName docName = baseName.resolve(name);
             assertThat(matcher.matches(docName)).as(docName.getName()).isTrue();
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilderTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilderTest.java
index 3156eae1..d3591967 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilderTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilderTest.java
@@ -35,6 +35,7 @@ import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.not;
 
 public class GitIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
 
@@ -48,11 +49,10 @@ public class GitIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
                 "# some colorful directories",
                 "red/", "blue/*/"};
 
-        List<String> expected = Arrays.asList("some/things", "some/fish", "another/red_fish");
+        List<String> excluded = Arrays.asList("some/things", "some/fish", "another/red_fish");
 
-        List<String> ignored = Arrays.asList("some/thinggone");
+        List<String> included = Arrays.asList("some/thingone");
 
-        // "thingone",
         writeFile(".gitignore", Arrays.asList(lines));
 
         GitIgnoreBuilder processor = new GitIgnoreBuilder();
@@ -61,13 +61,13 @@ public class GitIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
         assertThat(matcherSet.excludes()).isPresent();
 
         DocumentNameMatcher matcher = matcherSet.includes().orElseThrow(() -> new IllegalStateException("How?"));
-        for (String name : expected) {
+        for (String name : included) {
             DocumentName docName = baseName.resolve(name);
             assertThat(matcher.matches(docName)).as(docName.getName()).isTrue();
         }
 
         matcher = matcherSet.excludes().orElseThrow(() -> new IllegalStateException("How?"));
-        for (String name : ignored) {
+        for (String name : excluded) {
             DocumentName docName = baseName.resolve(name);
             assertThat(matcher.matches(docName)).as(docName.getName()).isTrue();
         }
@@ -80,10 +80,10 @@ public class GitIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
         GitIgnoreBuilder underTest = new GitIgnoreBuilder();
         DocumentName testName = DocumentName.builder().setName("GitIgnoreBuilderTest").setBaseName("testDir").build();
         if (source.endsWith("/")) {
-            assertThat(underTest.modifyEntry(testName, source)).isEqualTo(null);
+            assertThat(underTest.modifyEntry(testName, source)).isNotPresent();
             assertThat(underTest.getIncluded().toString()).isEqualTo(expected);
         } else {
-            assertThat(underTest.modifyEntry(testName, source)).isEqualTo(expected);
+            assertThat(underTest.modifyEntry(testName, source)).contains(expected);
         }
     }
 
@@ -105,43 +105,41 @@ public class GitIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
         return lst.stream();
     }
 
+    private void assertMatches(DocumentName documentName, DocumentNameMatcher matcher, String[] matching, String[] notMatching) {
+        for (String test : matching) {
+            DocumentName name = documentName.resolve(test);
+            assertThat(matcher.matches(name)).as(test).isTrue();
+        }
+        for (String test: notMatching) {
+            DocumentName name = documentName.resolve(test);
+            assertThat(matcher.matches(name)).as(test).isFalse();
+        }
+    }
+
     @Test
     public void test_RAT_335() {
         GitIgnoreBuilder underTest = new GitIgnoreBuilder();
-        URL url = GitIgnoreBuilderTest.class.getClassLoader().getResource("RAT_355/src/");
+        URL url = GitIgnoreBuilderTest.class.getClassLoader().getResource("GitIgnoreBuilderTest/src/");
         File file = new File(url.getFile());
 
         DocumentName documentName = DocumentName.builder(file).build();
         MatcherSet matcherSet = underTest.build(documentName);
         assertThat(matcherSet.excludes()).isPresent();
         assertThat(matcherSet.includes()).isPresent();
+
+        // includes test
         DocumentNameMatcher matcher = matcherSet.includes().orElseThrow(() -> new IllegalStateException("How?"));
-        assertThat(matcher.toString()).isEqualTo("or(/dir1/.gitignore, /.gitignore)");
-
-        DocumentName name = documentName.resolve("subdir/file1.log" );
-        assertThat(matcher.matches(name)).isTrue();
-        name = documentName.resolve("subdir/joe.txt" );
-        assertThat(matcher.matches(name)).isFalse();
-        name = documentName.resolve("subdir/file1.log" );
-        assertThat(matcher.matches(name)).isTrue();
-        name = documentName.resolve("subdir/joe.md" );
-        assertThat(matcher.matches(name)).isTrue();
-
-        name = documentName.resolve("dir1/joe.txt" );
-        assertThat(matcher.matches(name)).isTrue();
-        name = documentName.resolve("dir1/file1.md" );
-        assertThat(matcher.matches(name)).isTrue();
+        assertThat(matcher.toString()).isEqualTo("or('included dir1/.gitignore', 'included .gitignore')");
+        assertMatches(documentName, matcher, new String[]{"subdir/file1.log", "dir1/dir1.md", "dir1/somedir/dir1.md",
+                        "dir1/file1.log"},
+                 new String[]{"dir1/joe.txt", "subdir/joe.txt", "subdir/joe.md", "dir1/joe.md" });
 
+        // excludes tests
         matcher = matcherSet.excludes().orElseThrow(() -> new IllegalStateException("How?"));
-        assertThat(matcher.toString()).isEqualTo("or(/dir1/.gitignore, /.gitignore)");
-
-        name = documentName.resolve("dir1/dir1.md" );
-        assertThat(matcher.matches(name)).isTrue();
-        name = documentName.resolve("subdir/dir1.md" );
-        assertThat(matcher.matches(name)).isFalse();
-        name = documentName.resolve("dir1/file1.log" );
-        assertThat(matcher.matches(name)).isTrue();
-        name = documentName.resolve("subdir/file1.log" );
-        assertThat(matcher.matches(name)).isTrue();
+        assertThat(matcher.toString()).isEqualTo("or('excluded dir1/.gitignore', 'excluded .gitignore')");
+        assertMatches(documentName, matcher, new String[]{ "dir1/file1.txt", "dir1/somedir/file1.txt", "dir1/file1.log",
+                        "dir1/somedir/file1.log", "subdir/dir1.md", "subdir/some.log"},
+                new String[]{"subdir/afile.txt" });
+
     }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilderTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilderTest.java
index 0b23e90d..a56c26eb 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilderTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreBuilderTest.java
@@ -48,9 +48,9 @@ public class HgIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
 
         HgIgnoreBuilder processor = new HgIgnoreBuilder();
         MatcherSet matcherSet = processor.build(baseName);
-        assertThat(matcherSet.includes()).isPresent();
-        assertThat(matcherSet.excludes()).isNotPresent();
-        DocumentNameMatcher matcher = matcherSet.includes().orElseThrow(() -> new IllegalStateException("How?"));
+        assertThat(matcherSet.excludes()).isPresent();
+        assertThat(matcherSet.includes()).isNotPresent();
+        DocumentNameMatcher matcher = matcherSet.excludes().orElseThrow(() -> new IllegalStateException("How?"));
         for (String name : expected) {
             DocumentName docName = baseName.resolve(name);
             assertThat(matcher.matches(docName)).as(docName.getName()).isTrue();
@@ -61,20 +61,19 @@ public class HgIgnoreBuilderTest extends AbstractIgnoreBuilderTest {
     public void processDefaultFileTest() throws IOException {
         String[] lines = {"^[A-Z]*\\.txt", "[0-9]*\\.txt"};
 
-        List<String> expected = Arrays.asList("ABIGNAME.txt", "endsIn9.txt");
+        List<String> match = Arrays.asList("ABIGNAME.txt", "endsIn9.txt");
+        List<String> notMatch = Arrays.asList("asmallName.txt", "endsin.doc");
 
-
-        List<String> denied = Arrays.asList("asmallName.txt", "endsin.doc");
         writeFile(".hgignore", Arrays.asList(lines));
 
         HgIgnoreBuilder processor = new HgIgnoreBuilder();
         MatcherSet matcherSet = processor.build(baseName);
-        DocumentNameMatcher matcher = matcherSet.includes().orElseThrow(() -> new IllegalStateException("How?"));
-        for (String name : expected) {
+        DocumentNameMatcher matcher = matcherSet.excludes().orElseThrow(() -> new IllegalStateException("How?"));
+        for (String name : match) {
             DocumentName docName = baseName.resolve(name);
             assertThat(matcher.matches(docName)).as(docName.getName()).isTrue();
         }
-        for (String name : denied) {
+        for (String name : notMatch) {
             DocumentName docName = DocumentName.builder().setName(name).setBaseName(baseDir).build();
             assertThat(matcher.matches(docName)).as(docName.getName()).isFalse();
         }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
index baf44ead..dfad5b43 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
@@ -64,11 +64,7 @@ import java.util.stream.Stream;
 
 import static org.apache.rat.commandline.Arg.HELP_LICENSES;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.Assert.fail;
 
 /**
  * A list of methods that an OptionsProvider in a test case must support.
@@ -77,11 +73,13 @@ import static org.junit.jupiter.api.Assertions.fail;
  * Each method in this interface tests an Option in {@link org.apache.rat.OptionCollection}.
  */
 public abstract class AbstractOptionsProvider {
-    /** A map of test Options to tests */
+    /**
+     * A map of test Options to tests
+     */
     protected final Map<String, OptionCollectionTest.OptionTest> testMap = new TreeMap<>();
 
-    protected static final String[] EXCLUDE_ARGS = { "*.foo", "%regex[[A-Z]\\.bar]", "justbaz"};
-    protected static final String[] INCLUDE_ARGS = { "B.bar", "justbaz" };
+    protected static final String[] EXCLUDE_ARGS = {"*.foo", "%regex[[A-Z]\\.bar]", "justbaz"};
+    protected static final String[] INCLUDE_ARGS = {"B.bar", "justbaz"};
     /**
      * The directory to place test data in.
      * We do not use temp file here as we want the evidence to survive failure.
@@ -182,6 +180,7 @@ public abstract class AbstractOptionsProvider {
     /**
      * Create the report configuration from the argument pairs.
      * There must be at least one arg. It may be `ImmutablePair.nullPair()`.
+     *
      * @param args Pairs comprising the argument option and the values for the option.
      * @return The generated ReportConfiguration.
      * @throws IOException on error.
@@ -193,7 +192,7 @@ public abstract class AbstractOptionsProvider {
         try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
             lines.forEach(writer::println);
         } catch (IOException e) {
-            fail(e.getMessage(), e);
+            fail(e.getMessage());
         }
         return file;
     }
@@ -205,18 +204,21 @@ public abstract class AbstractOptionsProvider {
     /* tests to be implemented */
     protected abstract void helpTest();
 
+    private String displayArgAndName(Option option, String fname) {
+        return String.format("%s %s", option.getLongOpt(), fname);
+    }
     // exclude tests
     private void execExcludeTest(Option option, String[] args) {
-        String[] notExcluded = { "notbaz", "well._afile"  };
-        String[] excluded = { "some.foo", "B.bar", "justbaz"};
+        String[] notExcluded = {"notbaz", "well._afile"};
+        String[] excluded = {"some.foo", "B.bar", "justbaz"};
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
             for (String fname : notExcluded) {
-                assertTrue(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isTrue();
             }
             for (String fname : excluded) {
-                assertFalse(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isFalse();
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -225,7 +227,7 @@ public abstract class AbstractOptionsProvider {
 
     private void excludeFileTest(Option option) {
         File outputFile = writeFile("exclude.txt", Arrays.asList(EXCLUDE_ARGS));
-        execExcludeTest(option, new String[] {outputFile.getPath()});
+        execExcludeTest(option, new String[]{outputFile.getPath()});
     }
 
     protected void excludeFileTest() {
@@ -246,17 +248,17 @@ public abstract class AbstractOptionsProvider {
 
     protected void inputExcludeStdTest() {
         Option option = Arg.EXCLUDE_STD.find("input-exclude-std");
-        String[] args = { StandardCollection.MISC.name() };
-        String[] excluded = { "afile~", ".#afile", "%afile%", "._afile" };
-        String[] notExcluded = { "afile~more",   "what.#afile", "%afile%withMore", "well._afile" };
+        String[] args = {StandardCollection.MISC.name()};
+        String[] excluded = {"afile~", ".#afile", "%afile%", "._afile"};
+        String[] notExcluded = {"afile~more", "what.#afile", "%afile%withMore", "well._afile"};
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
             for (String fname : excluded) {
-                assertFalse(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isFalse();
             }
             for (String fname : notExcluded) {
-                assertTrue(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isTrue();
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -265,7 +267,7 @@ public abstract class AbstractOptionsProvider {
 
     protected void inputExcludeParsedScmTest() {
         Option option = Arg.EXCLUDE_PARSE_SCM.find("input-exclude-parsed-scm");
-        String[] args = { "GIT" };
+        String[] args = {"GIT"};
         String[] lines = {
                 "# somethings",
                 "!thingone", "thing*", System.lineSeparator(),
@@ -273,8 +275,8 @@ public abstract class AbstractOptionsProvider {
                 "**/fish", "*_fish",
                 "# some colorful directories",
                 "red/", "blue/*/"};
-        String[] notExcluded = { "thingone", "dir/fish_two"};
-        String[] excluded = { "thingtwo", "dir/fish", "red/fish", "blue/fish" };
+        String[] notExcluded = {"thingone", "dir/fish_two"};
+        String[] excluded = {"thingtwo", "dir/fish", "red/fish", "blue/fish"};
 
         writeFile(".gitignore", Arrays.asList(lines));
 
@@ -285,10 +287,10 @@ public abstract class AbstractOptionsProvider {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
             for (String fname : excluded) {
-                assertFalse(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isFalse();
             }
             for (String fname : notExcluded) {
-                assertTrue(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isTrue();
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -297,22 +299,22 @@ public abstract class AbstractOptionsProvider {
 
     private void inputExcludeSizeTest() {
         Option option = Arg.EXCLUDE_SIZE.option();
-        String[] args = { "5" };
-        writeFile("Hi.txt", Arrays.asList("Hi"));
-        writeFile("Hello.txt", Arrays.asList("Hello"));
-        writeFile("HelloWorld.txt", Arrays.asList("HelloWorld"));
+        String[] args = {"5"};
+        writeFile("Hi.txt", Collections.singletonList("Hi"));
+        writeFile("Hello.txt", Collections.singletonList("Hello"));
+        writeFile("HelloWorld.txt", Collections.singletonList("HelloWorld"));
 
-        String[] notExcluded = { "Hello.txt", "HelloWorld.txt"};
-        String[] excluded = { "Hi.txt" };
+        String[] notExcluded = {"Hello.txt", "HelloWorld.txt"};
+        String[] excluded = {"Hi.txt"};
 
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
             for (String fname : excluded) {
-                assertFalse(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isFalse();
             }
             for (String fname : notExcluded) {
-                assertTrue(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isTrue();
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -329,10 +331,10 @@ public abstract class AbstractOptionsProvider {
                     ImmutablePair.of(excludeOption, EXCLUDE_ARGS));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
             for (String fname : excluded) {
-                assertFalse(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isFalse();
             }
             for (String fname : notExcluded) {
-                assertTrue(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isTrue();
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -341,7 +343,7 @@ public abstract class AbstractOptionsProvider {
 
     private void includeFileTest(Option option) {
         File outputFile = writeFile("include.txt", Arrays.asList(INCLUDE_ARGS));
-        execIncludeTest(option, new String[] {outputFile.getPath()});
+        execIncludeTest(option, new String[]{outputFile.getPath()});
     }
 
     protected void inputIncludeFileTest() {
@@ -362,19 +364,19 @@ public abstract class AbstractOptionsProvider {
 
     protected void inputIncludeStdTest() {
         ImmutablePair<Option, String[]> excludes = ImmutablePair.of(Arg.EXCLUDE.find("input-exclude"),
-                new String[] { "*~more", "*~" });
+                new String[]{"*~more", "*~"});
         Option option = Arg.INCLUDE_STD.find("input-include-std");
-        String[] args = { StandardCollection.MISC.name() };
-        String[] excluded = { "afile~more" };
-        String[] notExcluded = { "afile~", ".#afile", "%afile%", "._afile", "what.#afile", "%afile%withMore", "well._afile" };
+        String[] args = {StandardCollection.MISC.name()};
+        String[] excluded = {"afile~more"};
+        String[] notExcluded = {"afile~", ".#afile", "%afile%", "._afile", "what.#afile", "%afile%withMore", "well._afile"};
         try {
             ReportConfiguration config = generateConfig(excludes, ImmutablePair.of(option, args));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
             for (String fname : excluded) {
-                assertFalse(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isFalse();
             }
             for (String fname : notExcluded) {
-                assertTrue(excluder.matches(mkDocName(fname)), () -> option.getKey() + " " + fname);
+                assertThat(excluder.matches(mkDocName(fname))).as(() -> displayArgAndName(option, fname)).isTrue();
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -385,7 +387,7 @@ public abstract class AbstractOptionsProvider {
         Option option = Arg.SOURCE.find("input-source");
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, new String[]{baseDir.getAbsolutePath()}));
-            assertTrue(config.hasSource());
+            assertThat(config.hasSource()).isTrue();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -393,7 +395,7 @@ public abstract class AbstractOptionsProvider {
 
     // LICENSE tests
     protected void execLicensesApprovedTest(Option option, String[] args) {
-        Pair<Option,String[]>  arg1 = ImmutablePair.of(option, args);
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
         try {
             ReportConfiguration config = generateConfig(arg1);
             SortedSet<String> result = config.getLicenseIds(LicenseSetFactory.LicenseFilter.APPROVED);
@@ -402,13 +404,13 @@ public abstract class AbstractOptionsProvider {
             fail(e.getMessage());
         }
 
-        Pair<Option,String[]> arg2 = ImmutablePair.of(
+        Pair<Option, String[]> arg2 = ImmutablePair.of(
                 Arg.CONFIGURATION_NO_DEFAULTS.find("configuration-no-defaults"),
                 null
         );
 
         try {
-            ReportConfiguration config = generateConfig(arg1, arg2 );
+            ReportConfiguration config = generateConfig(arg1, arg2);
             SortedSet<String> result = config.getLicenseIds(LicenseSetFactory.LicenseFilter.APPROVED);
             assertThat(result).containsExactly("one", "two");
         } catch (IOException e) {
@@ -419,7 +421,7 @@ public abstract class AbstractOptionsProvider {
     protected void helpLicenses() {
         ByteArrayOutputStream output = new ByteArrayOutputStream();
         PrintStream origin = System.out;
-        try (PrintStream out = new PrintStream(output)){
+        try (PrintStream out = new PrintStream(output)) {
             System.setOut(out);
             generateConfig(ImmutablePair.of(HELP_LICENSES.option(), null));
         } catch (IOException e) {
@@ -436,12 +438,12 @@ public abstract class AbstractOptionsProvider {
     protected void licensesApprovedFileTest() {
         File outputFile = writeFile("licensesApproved.txt", Arrays.asList("one", "two"));
         execLicensesApprovedTest(Arg.LICENSES_APPROVED_FILE.find("licenses-approved-file"),
-                new String[] { outputFile.getPath()});
+                new String[]{outputFile.getPath()});
     }
 
     protected void licensesApprovedTest() {
         execLicensesApprovedTest(Arg.LICENSES_APPROVED.find("licenses-approved"),
-                new String[] { "one", "two"});
+                new String[]{"one", "two"});
     }
 
     private void execLicensesDeniedTest(Option option, String[] args) {
@@ -456,12 +458,12 @@ public abstract class AbstractOptionsProvider {
     }
 
     protected void licensesDeniedTest() {
-        execLicensesDeniedTest(Arg.LICENSES_DENIED.find("licenses-denied"), new String[] {"ILLUMOS"});
+        execLicensesDeniedTest(Arg.LICENSES_DENIED.find("licenses-denied"), new String[]{"ILLUMOS"});
     }
 
     protected void licensesDeniedFileTest() {
         File outputFile = writeFile("licensesDenied.txt", Collections.singletonList("ILLUMOS"));
-        execLicensesDeniedTest(Arg.LICENSES_DENIED_FILE.find("licenses-denied-file"), new String[] {outputFile.getPath()});
+        execLicensesDeniedTest(Arg.LICENSES_DENIED_FILE.find("licenses-denied-file"), new String[]{outputFile.getPath()});
     }
 
     private void execLicenseFamiliesApprovedTest(Option option, String[] args) {
@@ -488,12 +490,12 @@ public abstract class AbstractOptionsProvider {
     protected void licenseFamiliesApprovedFileTest() {
         File outputFile = writeFile("familiesApproved.txt", Collections.singletonList("catz"));
         execLicenseFamiliesApprovedTest(Arg.FAMILIES_APPROVED_FILE.find("license-families-approved-file"),
-                new String[] { outputFile.getPath() });
+                new String[]{outputFile.getPath()});
     }
 
     protected void licenseFamiliesApprovedTest() {
         execLicenseFamiliesApprovedTest(Arg.FAMILIES_APPROVED.find("license-families-approved"),
-                new String[] {"catz"});
+                new String[]{"catz"});
     }
 
     private void execLicenseFamiliesDeniedTest(Option option, String[] args) {
@@ -508,15 +510,15 @@ public abstract class AbstractOptionsProvider {
         }
     }
 
-   protected void licenseFamiliesDeniedFileTest() {
+    protected void licenseFamiliesDeniedFileTest() {
         File outputFile = writeFile("familiesDenied.txt", Collections.singletonList("GPL"));
         execLicenseFamiliesDeniedTest(Arg.FAMILIES_DENIED_FILE.find("license-families-denied-file"),
-                new String[] { outputFile.getPath() });
+                new String[]{outputFile.getPath()});
     }
 
     protected void licenseFamiliesDeniedTest() {
         execLicenseFamiliesDeniedTest(Arg.FAMILIES_DENIED.find("license-families-denied"),
-                new String[] { "GPL" });
+                new String[]{"GPL"});
     }
 
     protected void counterMaxTest() {
@@ -525,17 +527,17 @@ public abstract class AbstractOptionsProvider {
 
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.nullPair());
-            assertEquals(0, config.getClaimValidator().getMax(ClaimStatistic.Counter.UNAPPROVED));
+            assertThat(config.getClaimValidator().getMax(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
             args[0] = "Unapproved:-1";
             args[1] = "ignored:1";
             config = generateConfig(ImmutablePair.of(option, args));
-            assertEquals(Integer.MAX_VALUE, config.getClaimValidator().getMax(ClaimStatistic.Counter.UNAPPROVED));
-            assertEquals(1, config.getClaimValidator().getMax(ClaimStatistic.Counter.IGNORED));
+            assertThat(config.getClaimValidator().getMax(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(Integer.MAX_VALUE);
+            assertThat(config.getClaimValidator().getMax(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
             args[1] = "unapproved:5";
             args[0] = "ignored:0";
             config = generateConfig(ImmutablePair.of(option, args));
-            assertEquals(5, config.getClaimValidator().getMax(ClaimStatistic.Counter.UNAPPROVED));
-            assertEquals(0, config.getClaimValidator().getMax(ClaimStatistic.Counter.IGNORED));
+            assertThat(config.getClaimValidator().getMax(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(5);
+            assertThat(config.getClaimValidator().getMax(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -547,17 +549,17 @@ public abstract class AbstractOptionsProvider {
 
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.nullPair());
-            assertEquals(0, config.getClaimValidator().getMin(ClaimStatistic.Counter.UNAPPROVED));
+            assertThat(config.getClaimValidator().getMin(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
             args[0] = "Unapproved:1";
             args[1] = "ignored:1";
             config = generateConfig(ImmutablePair.of(option, args));
-            assertEquals(1, config.getClaimValidator().getMin(ClaimStatistic.Counter.UNAPPROVED));
-            assertEquals(1, config.getClaimValidator().getMin(ClaimStatistic.Counter.IGNORED));
+            assertThat(config.getClaimValidator().getMin(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+            assertThat(config.getClaimValidator().getMin(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
             args[1] = "unapproved:5";
             args[0] = "ignored:0";
             config = generateConfig(ImmutablePair.of(option, args));
-            assertEquals(5, config.getClaimValidator().getMin(ClaimStatistic.Counter.UNAPPROVED));
-            assertEquals(0, config.getClaimValidator().getMin(ClaimStatistic.Counter.IGNORED));
+            assertThat(config.getClaimValidator().getMin(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(5);
+            assertThat(config.getClaimValidator().getMin(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -569,17 +571,17 @@ public abstract class AbstractOptionsProvider {
         try {
             ReportConfiguration config = generateConfig(arg1);
             SortedSet<ILicense> set = config.getLicenses(LicenseSetFactory.LicenseFilter.ALL);
-            assertTrue(set.size() > 2);
-            assertTrue(LicenseSetFactory.search("ONE", "ONE", set).isPresent());
-            assertTrue(LicenseSetFactory.search("TWO", "TWO", set).isPresent());
+            assertThat(set).hasSizeGreaterThan(2);
+            assertThat(LicenseSetFactory.search("ONE", "ONE", set)).isPresent();
+            assertThat(LicenseSetFactory.search("TWO", "TWO", set)).isPresent();
 
             Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.CONFIGURATION_NO_DEFAULTS.find("configuration-no-defaults"), null);
 
             config = generateConfig(arg1, arg2);
             set = config.getLicenses(LicenseSetFactory.LicenseFilter.ALL);
-            assertEquals(2, set.size());
-            assertTrue(LicenseSetFactory.search("ONE", "ONE", set).isPresent());
-            assertTrue(LicenseSetFactory.search("TWO", "TWO", set).isPresent());
+            assertThat(set).hasSize(2);
+            assertThat(LicenseSetFactory.search("ONE", "ONE", set)).isPresent();
+            assertThat(LicenseSetFactory.search("TWO", "TWO", set)).isPresent();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -596,9 +598,9 @@ public abstract class AbstractOptionsProvider {
     private void noDefaultsTest(Option arg) {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(arg, null));
-            assertTrue(config.getLicenses(LicenseSetFactory.LicenseFilter.ALL).isEmpty());
+            assertThat(config.getLicenses(LicenseSetFactory.LicenseFilter.ALL)).isEmpty();
             config = generateConfig(ImmutablePair.nullPair());
-            assertFalse(config.getLicenses(LicenseSetFactory.LicenseFilter.ALL).isEmpty());
+            assertThat(config.getLicenses(LicenseSetFactory.LicenseFilter.ALL)).isNotEmpty();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -615,9 +617,9 @@ public abstract class AbstractOptionsProvider {
     protected void dryRunTest() {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(Arg.DRY_RUN.find("dry-run"), null));
-            assertTrue(config.isDryRun());
+            assertThat(config.isDryRun()).isTrue();
             config = generateConfig(ImmutablePair.nullPair());
-            assertFalse(config.isDryRun());
+            assertThat(config.isDryRun()).isFalse();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -627,10 +629,10 @@ public abstract class AbstractOptionsProvider {
         try {
             Pair<Option, String[]> arg1 = ImmutablePair.of(option, new String[]{"MyCopyright"});
             ReportConfiguration config = generateConfig(arg1);
-            assertNull(config.getCopyrightMessage(), "Copyright without --edit-license should not work");
+            assertThat(config.getCopyrightMessage()).as("Copyright without --edit-license should not work").isNull();
             Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.EDIT_ADD.find("edit-license"), null);
             config = generateConfig(arg1, arg2);
-            assertEquals("MyCopyright", config.getCopyrightMessage());
+            assertThat(config.getCopyrightMessage()).isEqualTo("MyCopyright");
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -647,9 +649,9 @@ public abstract class AbstractOptionsProvider {
     private void editLicenseTest(Option option) {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
-            assertTrue(config.isAddingLicenses());
+            assertThat(config.isAddingLicenses()).isTrue();
             config = generateConfig(ImmutablePair.nullPair());
-            assertFalse(config.isAddingLicenses());
+            assertThat(config.isAddingLicenses()).isFalse();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -658,6 +660,7 @@ public abstract class AbstractOptionsProvider {
     protected void addLicenseTest() {
         editLicenseTest(Arg.EDIT_ADD.find("addLicense"));
     }
+
     protected void editLicensesTest() {
         editLicenseTest(Arg.EDIT_ADD.find("edit-license"));
     }
@@ -666,11 +669,11 @@ public abstract class AbstractOptionsProvider {
         Pair<Option, String[]> arg1 = ImmutablePair.of(option, null);
         try {
             ReportConfiguration config = generateConfig(arg1);
-            assertFalse(config.isAddingLicensesForced());
+            assertThat(config.isAddingLicensesForced()).isFalse();
             Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.EDIT_ADD.find("edit-license"), null);
 
             config = generateConfig(arg1, arg2);
-            assertTrue(config.isAddingLicensesForced());
+            assertThat(config.isAddingLicensesForced()).isTrue();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -693,7 +696,7 @@ public abstract class AbstractOptionsProvider {
                 try {
                     args[0] = level.name();
                     generateConfig(ImmutablePair.of(option, args));
-                    assertEquals(level, DefaultLog.getInstance().getLevel());
+                    assertThat(DefaultLog.getInstance().getLevel()).isEqualTo(level);
                 } catch (IOException e) {
                     fail(e.getMessage());
                 }
@@ -709,7 +712,7 @@ public abstract class AbstractOptionsProvider {
             for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
                 args[0] = proc.name();
                 ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                assertEquals(proc, config.getArchiveProcessing());
+                assertThat(config.getArchiveProcessing()).isEqualTo(proc);
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -726,7 +729,7 @@ public abstract class AbstractOptionsProvider {
             try {
                 args[0] = filter.name();
                 ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                assertEquals(filter, config.listFamilies());
+                assertThat(config.listFamilies()).isEqualTo(filter);
             } catch (IOException e) {
                 fail(e.getMessage());
             }
@@ -752,7 +755,7 @@ public abstract class AbstractOptionsProvider {
                 throw new RuntimeException(e);
             }
             try (BufferedReader reader = new BufferedReader(new InputStreamReader(Files.newInputStream(outFile.toPath())))) {
-                assertEquals("Hello world", reader.readLine());
+                assertThat(reader.readLine()).isEqualTo("Hello world");
             } catch (IOException e) {
                 throw new RuntimeException(e);
             }
@@ -775,7 +778,7 @@ public abstract class AbstractOptionsProvider {
             try {
                 args[0] = filter.name();
                 ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                assertEquals(filter, config.listLicenses());
+                assertThat(config.listLicenses()).isEqualTo(filter);
             } catch (IOException e) {
                 fail(e.getMessage());
             }
@@ -791,12 +794,12 @@ public abstract class AbstractOptionsProvider {
     }
 
     private void standardTest(Option option) {
-        String[] args = { null};
+        String[] args = {null};
         try {
             for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
                 args[0] = proc.name();
                 ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                assertEquals(proc, config.getStandardProcessing());
+                assertThat(config.getStandardProcessing()).isEqualTo(proc);
             }
         } catch (IOException e) {
             fail(e.getMessage());
@@ -815,7 +818,7 @@ public abstract class AbstractOptionsProvider {
                 OutputStream out = Files.newOutputStream(file.toPath())) {
             IOUtils.copy(in, out);
         } catch (IOException e) {
-            fail("Could not copy MatcherContainerResource.txt: "+e.getMessage());
+            fail("Could not copy MatcherContainerResource.txt: " + e.getMessage());
         }
         // run the test
         String[] args = {null};
@@ -825,11 +828,11 @@ public abstract class AbstractOptionsProvider {
                 ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
                 try (InputStream expected = StyleSheets.getStyleSheet(sheet).get();
                      InputStream actual = config.getStyleSheet().get()) {
-                    assertTrue(IOUtils.contentEquals(expected, actual), () -> String.format("'%s' does not match", sheet));
+                    assertThat(IOUtils.contentEquals(expected, actual)).as(() -> String.format("'%s' does not match", sheet)).isTrue();
                 }
             }
         } catch (IOException e) {
-            fail(e.getMessage(), e);
+            fail(e.getMessage());
         }
     }
 
@@ -845,7 +848,7 @@ public abstract class AbstractOptionsProvider {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(Arg.INCLUDE_STD.find("scan-hidden-directories"), null));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
-            assertTrue(excluder.matches(mkDocName(".file")), ".file");
+            assertThat(excluder.matches(mkDocName(".file"))).as(".file").isTrue();
         } catch (IOException e) {
             fail(e.getMessage());
         }
@@ -856,28 +859,28 @@ public abstract class AbstractOptionsProvider {
             ReportConfiguration config = generateConfig(ImmutablePair.of(Arg.OUTPUT_STYLE.find("xml"), null));
             try (InputStream expected = StyleSheets.getStyleSheet("xml").get();
                  InputStream actual = config.getStyleSheet().get()) {
-                assertTrue(IOUtils.contentEquals(expected, actual), "'xml' does not match");
+                assertThat(IOUtils.contentEquals(expected, actual)).as("'xml' does not match").isTrue();
             }
         } catch (IOException e) {
             fail(e.getMessage());
         }
     }
 
-        final public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
-                List<Arguments> lst = new ArrayList<>();
-                List<String> missingTests = new ArrayList<>();
+    final public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
+        List<Arguments> lst = new ArrayList<>();
+        List<String> missingTests = new ArrayList<>();
 
-                        for (String key : OptionsList.getKeys()) {
-                        OptionCollectionTest.OptionTest test = testMap.get(key);
-                        if (test == null) {
-                                missingTests.add(key);
-                            } else {
-                                lst.add(Arguments.of(key, test));
-                            }
-                    }
-                if (!missingTests.isEmpty()) {
-                        System.out.println("The following tests are excluded: '" + String.join( "', '", missingTests ) + "'");
-                    }
-                return lst.stream();
+        for (String key : OptionsList.getKeys()) {
+            OptionCollectionTest.OptionTest test = testMap.get(key);
+            if (test == null) {
+                missingTests.add(key);
+            } else {
+                lst.add(Arguments.of(key, test));
             }
+        }
+        if (!missingTests.isEmpty()) {
+            System.out.println("The following tests are excluded: '" + String.join("', '", missingTests) + "'");
+        }
+        return lst.stream();
+    }
 }
diff --git a/apache-rat-core/src/test/resources/RAT_355/commandLine.txt b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/commandLine.txt
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/commandLine.txt
rename to apache-rat-core/src/test/resources/GitIgnoreBuilderTest/commandLine.txt
diff --git a/apache-rat-core/src/test/resources/RAT_355/expected-message.txt b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/expected-message.txt
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/expected-message.txt
rename to apache-rat-core/src/test/resources/GitIgnoreBuilderTest/expected-message.txt
diff --git a/apache-rat-core/src/test/resources/RAT_355/pom.xml b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/pom.xml
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/pom.xml
rename to apache-rat-core/src/test/resources/GitIgnoreBuilderTest/pom.xml
diff --git a/apache-rat-core/src/test/resources/RAT_355/src/README.txt b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/README.txt
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/src/README.txt
rename to apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/README.txt
diff --git a/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir1/dir1.md b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir1/dir1.md
new file mode 100644
index 00000000..a31cbc89
--- /dev/null
+++ b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir1/dir1.md
@@ -0,0 +1 @@
+File without a valid license
diff --git a/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir2/dir2.txt b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir2/dir2.txt
new file mode 100644
index 00000000..a31cbc89
--- /dev/null
+++ b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir2/dir2.txt
@@ -0,0 +1 @@
+File without a valid license
diff --git a/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir3/file3.log b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir3/file3.log
new file mode 100644
index 00000000..a31cbc89
--- /dev/null
+++ b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/dir3/file3.log
@@ -0,0 +1 @@
+File without a valid license
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_335/src/invoker.properties b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/invoker.properties
similarity index 100%
rename from apache-rat-core/src/it/resources/ReportTest/RAT_335/src/invoker.properties
rename to apache-rat-core/src/test/resources/GitIgnoreBuilderTest/src/invoker.properties
diff --git a/apache-rat-core/src/test/resources/RAT_355/verify.groovy b/apache-rat-core/src/test/resources/GitIgnoreBuilderTest/verify.groovy
similarity index 100%
rename from apache-rat-core/src/test/resources/RAT_355/verify.groovy
rename to apache-rat-core/src/test/resources/GitIgnoreBuilderTest/verify.groovy
diff --git a/apache-rat-core/src/test/resources/RAT_355/src/invoker.properties b/apache-rat-core/src/test/resources/RAT_355/src/invoker.properties
deleted file mode 100644
index 6e8c3479..00000000
--- a/apache-rat-core/src/test/resources/RAT_355/src/invoker.properties
+++ /dev/null
@@ -1,16 +0,0 @@
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-invoker.goals = clean apache-rat:check
