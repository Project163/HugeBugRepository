diff --git a/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java b/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java
index 121875c3..8c32ed04 100644
--- a/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java
+++ b/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java
@@ -336,7 +336,7 @@ public class ConfigurationInterpolator {
     public Object interpolate(final Object value) {
         if (value instanceof String) {
             final String strValue = (String) value;
-            if (looksLikeSingleVariable(strValue)) {
+            if (isSingleVariable(strValue)) {
                 final Object resolvedValue = resolveSingleVariable(strValue);
                 if (resolvedValue != null && !(resolvedValue instanceof String)) {
                     // If the value is again a string, it needs no special
@@ -380,15 +380,16 @@ public class ConfigurationInterpolator {
     }
 
     /**
-     * Checks whether a value to be interpolated seems to be a single variable. In this case, it is resolved directly
-     * without using the {@code StringSubstitutor}. Note that it is okay if this method returns a false positive: In this
-     * case, resolving is going to fail, and standard mechanism is used.
+     * Checks whether a value to be interpolated consists of single, simple variable reference, e.g.,
+     * <code>${myvar}</code>. In this case, the variable is resolved directly without using the
+     * {@code StringSubstitutor}.
      *
      * @param strValue the value to be interpolated
-     * @return a flag whether this value seems to be a single variable
+     * @return {@code true} if the value contains a single, simple variable reference
      */
-    private boolean looksLikeSingleVariable(final String strValue) {
-        return strValue.startsWith(VAR_START) && strValue.endsWith(VAR_END);
+    private boolean isSingleVariable(final String strValue) {
+        return strValue.startsWith(VAR_START)
+                && strValue.indexOf(VAR_END, VAR_START_LENGTH) == strValue.length() - VAR_END_LENGTH;
     }
 
     /**
@@ -483,7 +484,7 @@ public class ConfigurationInterpolator {
     }
 
     /**
-     * Interpolates a string value that seems to be a single variable.
+     * Interpolates a string value that consists of a single variable.
      *
      * @param strValue the string to be interpolated
      * @return the resolved value or <b>null</b> if resolving failed
diff --git a/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java b/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java
index 322a59a6..2a1bb903 100644
--- a/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java
+++ b/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java
@@ -449,6 +449,17 @@ public class TestConfigurationInterpolator {
         assertEquals("Wrong result", value, interpolator.interpolate(value));
     }
 
+    /**
+     * Tests an interpolated string that begins and ends with variable lookups that have
+     * the potential to fail. Part of CONFIGURATION-764.
+     */
+    @Test
+    public void testInterpolationBeginningAndEndingRiskyVariableLookups() {
+        interpolator.registerLookups(ConfigurationInterpolator.getDefaultPrefixLookups());
+        final String result = (String) interpolator.interpolate("${date:yyyy-MM}-${date:dd}");
+        assertTrue("Wrong result: " + result, result.matches("\\d{4}-\\d{2}-\\d{2}"));
+    }
+
     /**
      * Tests nullSafeLookup() if a lookup object was provided.
      */
