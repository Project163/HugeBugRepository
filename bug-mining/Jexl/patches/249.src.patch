diff --git a/src/main/java/org/apache/commons/jexl3/internal/Engine.java b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
index 88ca43df..519e4811 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Engine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
@@ -846,6 +846,20 @@ public class Engine extends JexlEngine implements JexlUberspect.ConstantResolver
         return script;
     }
 
+    /**
+     * Parses a Jexl expression or script.
+     * <p>This is a convenience method that uses the default parser and the script features.
+     * @param info the JexlInfo
+     * @param expr whether to parse an expression or a script
+     * @param src the source to parse
+     * @param scope the scope, may be null
+     * @return the parsed tree
+     */
+    protected ASTJexlScript jxltParse(final JexlInfo info, final boolean expr, final String src, final Scope scope) {
+        return parse(info, expr, src, scope);
+    }
+
+
     /**
      * Processes jexl.module.ns pragma.
      *
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Scope.java b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
index de3d0e42..fc043bc2 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Scope.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
@@ -29,7 +29,7 @@ import java.util.Map;
  */
 public final class Scope {
     /**
-     * The value of an as-yet  undeclared but variable, for instance: x; before var x;.
+     * The value of an as-yet undeclared but variable, for instance: x; before var x;.
      */
     static final Object UNDECLARED = new Object() {
         @Override public String toString() {
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Script.java b/src/main/java/org/apache/commons/jexl3/internal/Script.java
index 16d26c93..7884a11e 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Script.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Script.java
@@ -87,12 +87,13 @@ public class Script implements JexlScript, JexlExpression {
         }
 
         /**
-         * @return true if evaluation was cancelled, false otherwise
+         * @return true if evaluation was canceled, false otherwise
          */
         public boolean isCancelled() {
             return interpreter.isCancelled();
         }
     }
+
     /**
      * The engine for this expression.
      */
@@ -105,7 +106,6 @@ public class Script implements JexlScript, JexlExpression {
      * The resulting AST we can interpret.
      */
     protected final ASTJexlScript script;
-
     /**
      * The engine version (as class loader change count) that last evaluated this script.
      */
@@ -127,7 +127,7 @@ public class Script implements JexlScript, JexlExpression {
 
     /**
      * Creates a Callable from this script.
-     * <p>This allows to submit it to an executor pool and provides support for asynchronous calls.</p>
+     * <p>This allows submitting it to an executor pool and provides support for asynchronous calls.</p>
      * <p>The interpreter will handle interruption/cancellation gracefully if needed.</p>
      * @param context the context
      * @return the callable
@@ -139,7 +139,7 @@ public class Script implements JexlScript, JexlExpression {
 
     /**
      * Creates a Callable from this script.
-     * <p>This allows to submit it to an executor pool and provides support for asynchronous calls.</p>
+     * <p>This allows submitting it to an executor pool and provides support for asynchronous calls.</p>
      * <p>The interpreter will handle interruption/cancellation gracefully if needed.</p>
      * @param context the context
      * @param args    the script arguments
diff --git a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
index 11b48fff..73a9ad4b 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
@@ -92,7 +92,7 @@ public final class TemplateEngine extends JxltEngine {
          * @param strb   the string builder to append to
          * @param prefix the line prefix (immediate or deferred)
          */
-        protected void toString(final StringBuilder strb, final String prefix) {
+        void toString(final StringBuilder strb, final String prefix) {
             if (BlockType.VERBATIM.equals(type)) {
                 strb.append(body);
             } else {
@@ -112,12 +112,13 @@ public final class TemplateEngine extends JxltEngine {
         /** Block is a directive, ie a fragment of JEXL code. */
         DIRECTIVE
     }
+
     /** A composite unified expression: "... ${...} ... #{...} ...". */
     final class CompositeExpression extends TemplateExpression {
         /** Bit encoded (deferred count > 0) bit 1, (immediate count > 0) bit 0. */
         private final int meta;
         /** The list of sub-expression resulting from parsing. */
-        protected final TemplateExpression[] exprs;
+        final TemplateExpression[] exprs;
 
         /**
          * Creates a composite expression.
@@ -766,7 +767,7 @@ public final class TemplateEngine extends JxltEngine {
      * @param reader the reader
      * @return the line iterator
      */
-    protected static Iterator<CharSequence> readLines(final Reader reader) {
+    private static Iterator<CharSequence> readLines(final Reader reader) {
         if (!reader.markSupported()) {
             throw new IllegalArgumentException("mark support in reader required");
         }
@@ -920,7 +921,7 @@ public final class TemplateEngine extends JxltEngine {
      * @param expr  the string expression
      * @param scope the template scope
      * @return the unified expression instance
-     * @throws JexlException if an error occur during parsing
+     * @throws JexlException if an error occurs during parsing
      */
     TemplateExpression parseExpression(final JexlInfo info, final String expr, final Scope scope) {  // CSOFF: MethodLength
         final int size = expr.length();
@@ -990,8 +991,9 @@ public final class TemplateEngine extends JxltEngine {
                         strb.append(c);
                     } else {
                         // materialize the immediate expr
-                        final String src = strb.toString();
-                        final TemplateExpression iexpr = new ImmediateExpression(src, jexl.parse(info.at(lineno, column), noscript, src, scope), null);
+                        final String src = escapeString(strb);
+                        final JexlInfo srcInfo = info.at(lineno, column);
+                        final TemplateExpression iexpr = new ImmediateExpression(src, jexl.jxltParse(srcInfo, noscript, src, scope), null);
                         builder.add(iexpr);
                         strb.delete(0, Integer.MAX_VALUE);
                         state = ParseState.CONST;
@@ -1033,12 +1035,19 @@ public final class TemplateEngine extends JxltEngine {
                         inner1 -= 1;
                     } else {
                         // materialize the nested/deferred expr
-                        final String src = strb.toString();
+                        final String src = escapeString(strb);
+                        final JexlInfo srcInfo = info.at(lineno, column);
                         TemplateExpression dexpr;
                         if (nested) {
-                            dexpr = new NestedExpression(expr.substring(inested, column + 1), jexl.parse(info.at(lineno, column), noscript, src, scope), null);
+                            dexpr = new NestedExpression(
+                                        escapeString(expr.substring(inested, column + 1)),
+                                        jexl.jxltParse(srcInfo, noscript, src, scope),
+                                 null);
                         } else {
-                            dexpr = new DeferredExpression(strb.toString(), jexl.parse(info.at(lineno, column), noscript, src, scope), null);
+                            dexpr = new DeferredExpression(
+                                    src,
+                                    jexl.jxltParse(srcInfo, noscript, src, scope),
+                             null);
                         }
                         builder.add(dexpr);
                         strb.delete(0, Integer.MAX_VALUE);
@@ -1096,6 +1105,10 @@ public final class TemplateEngine extends JxltEngine {
         return builder.build(this, null);
     }
 
+    private String escapeString(final CharSequence str) {
+        return StringParser.escapeString(str, (char) 0);
+    }
+
     /**
      * Reads lines of a template grouping them by typed blocks.
      * @param prefix the directive prefix
diff --git a/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java b/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java
index 1fcf808e..3db934e7 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java
@@ -88,16 +88,15 @@ public final class TemplateScript implements JxltEngine.Template {
         }
         return null;
     }
+
     /** The prefix marker. */
     private final String prefix;
     /** The array of source blocks. */
     private final Block[] source;
     /** The resulting script. */
     private final ASTJexlScript script;
-
     /** The TemplateEngine expressions called by the script. */
     private final TemplateExpression[] exprs;
-
     /** The engine. */
     private final TemplateEngine jxlt;
 
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java b/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java
index 269578aa..9a192081 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java
@@ -22,7 +22,7 @@ import org.apache.commons.jexl3.JxltEngine;
 /**
  * x.`expr`.
  */
-public class ASTIdentifierAccessJxlt extends ASTIdentifierAccess implements JexlNode.JxltHandle{
+public class ASTIdentifierAccessJxlt extends ASTIdentifierAccess implements JexlNode.JxltHandle {
     protected transient JxltEngine.Expression jxltExpression;
 
     ASTIdentifierAccessJxlt(final int id) {
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
index 003b8f52..f3189cfc 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
@@ -23,7 +23,7 @@ import org.apache.commons.jexl3.internal.Frame;
 import org.apache.commons.jexl3.internal.Scope;
 
 /**
- * Enhanced script to allow parameters declaration.
+ * Enhanced script to allow parameter declaration.
  */
 public class ASTJexlScript extends JexlLexicalNode  {
     /** Serial uid.*/
diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
index a073afc8..c378770e 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
@@ -169,7 +169,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * The associated controller.
      */
-    protected final FeatureController featureController = new FeatureController(JexlEngine.DEFAULT_FEATURES);
+    protected final FeatureController featureController;
     /**
      * The basic source info.
      */
@@ -180,14 +180,14 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     protected String source;
     /**
      * The map of named registers aka script parameters.
-     * <p>Each parameter is associated to a register and is materialized
+     * <p>Each parameter is associated with a register and is materialized
      * as an offset in the registers array used during evaluation.</p>
      */
     protected Scope scope;
     /**
      * When parsing inner functions/lambda, need to stack the scope (sic).
      */
-    protected final Deque<Scope> scopes = new ArrayDeque<>();
+    protected final Deque<Scope> scopes;
     /**
      * The list of pragma declarations.
      */
@@ -242,7 +242,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * Stack of parsing loop counts.
      */
-    protected final Deque<Integer> loopCounts = new ArrayDeque<>();
+    protected final Deque<Integer> loopCounts;
     /**
      * The current lexical block.
      */
@@ -250,11 +250,50 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * Stack of lexical blocks.
      */
-    protected final Deque<LexicalUnit> blocks = new ArrayDeque<>();
+    protected final Deque<LexicalUnit> blocks;
     /**
      * The map of lexical to functional blocks.
      */
-    protected final Map<LexicalUnit, Scope> blockScopes = new IdentityHashMap<>();
+    protected final Map<LexicalUnit, Scope> blockScopes;
+
+    /**
+     * Creates a new parser.
+     * <p>
+     * This constructor is protected so that it can only be used by subclasses.
+     * </p>
+     */
+    protected JexlParser() {
+        featureController = new FeatureController(JexlEngine.DEFAULT_FEATURES);
+        scopes = new ArrayDeque<>();
+        loopCounts = new ArrayDeque<>();
+        blocks = new ArrayDeque<>();
+        blockScopes = new IdentityHashMap<>();
+    }
+
+    /**
+     * Creates a new inner-parser.
+     * <p>
+     * This is the constructor used to create a parser for template expressions.
+     * </p>
+     */
+    protected JexlParser(JexlParser parser) {
+        this.info = null;
+        this.source = null;
+        featureController = parser.featureController;
+        scope = parser.scope;
+        scopes = parser.scopes;
+        pragmas = parser.pragmas;
+        namespaces = parser.namespaces;
+        loopCount = parser.loopCount;
+        loopCounts = parser.loopCounts;
+        block = parser.block;
+        blocks = parser.blocks;
+        blockScopes = parser.blockScopes;
+        fqcnResolver = parser.fqcnResolver;
+        imports = parser.imports;
+        autoSemicolon = parser.autoSemicolon;
+    }
+
     /**
      * The name of the null case constant.
      */
@@ -525,7 +564,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * Declares a local parameter.
      * <p>
-     * This method creates an new entry in the symbol map.
+     * This method creates a new entry in the symbol map.
      * </p>
      *
      * @param token the parameter name token
@@ -890,6 +929,20 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
         // heavy check
         featureController.controlNode(node);
     }
+//
+//    JxltEngine.Expression parseJxlt(final String src) {
+//        if (src != null && !src.isEmpty()) {
+//            JexlEngine jexl = JexlEngine.getThreadEngine();
+//            if (jexl != null) {
+//                JxltEngine jxlt = jexl.createJxltEngine();
+//                if (jxlt instanceof TemplateEngine) {
+//                    JxltEngine.Expression jxltExpression = ((TemplateEngine) jxlt).createExpression(null, src);
+//                    return jxltExpression;
+//                }
+//            }
+//        }
+//        return null;
+//    }
 
     /**
      * Called by parser at beginning of node construction.
diff --git a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
index 5470bc01..be51f942 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
@@ -49,6 +49,13 @@ import org.apache.commons.jexl3.internal.Scope;
 
 public final class Parser extends JexlParser
 {
+        public Parser(JexlParser parser) {
+            super(parser);
+            jj_input_stream = new SimpleCharStream(new StringProvider(""), 1, 1);
+            token_source = new ParserTokenManager(jj_input_stream);
+            token = new Token();
+            token.next = jj_nt = token_source.getNextToken();
+        }
 
     /**
      * Parses a JEXL source string and returns the corresponding AST.
@@ -65,9 +72,9 @@ public final class Parser extends JexlParser
         try {
             setFeatures(jexlFeatures);
             // lets do the 'Unique Init' in here to be safe - it's a pain to remember
-            info = jexlInfo != null? jexlInfo : new JexlInfo();
-            source = jexlSrc;
-            pragmas = null;
+            this.info = jexlInfo != null? jexlInfo : new JexlInfo();
+            this.source = jexlSrc;
+            this.pragmas = null;
             this.scope = jexlScope;
             token_source.comparatorNames = jexlFeatures.supportsComparatorNames();
             ReInit(jexlSrc);
@@ -353,7 +360,7 @@ TOKEN_MGR_DECLS : {
 <*> TOKEN :
 {
   < JXLT_LITERAL:
-    "`" (~["`","\\"] | "\\" ~["\u0000"])* "`"
+    "`"("\n" | "\r" | "\r\n")* ("\\" "`" | ~["\u2028"-"\u202E","\u2066"-"\u2069"])*"`"
   > : DEFAULT
 }
 
@@ -1050,10 +1057,11 @@ void StringLiteral() :
 void JxltLiteral() #JxltLiteral :
 {
    Token t;
+   String src;
 }
 {
    t=<JXLT_LITERAL>
-   { jjtThis.setLiteral(Parser.buildString(t.image, true)); }
+   { jjtThis.setLiteral(src = Parser.buildString(t.image, true)); }
 }
 
 void RegexLiteral() :
diff --git a/src/main/java/org/apache/commons/jexl3/parser/StringParser.java b/src/main/java/org/apache/commons/jexl3/parser/StringParser.java
index 07e92b64..798a788a 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/StringParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/StringParser.java
@@ -131,17 +131,19 @@ public class StringParser {
 
     /**
      * Escapes a String representation, expand non-ASCII characters as Unicode escape sequence.
-     * @param delim the delimiter character
+     * @param delim the delimiter character (if 0, no delimiter is added)
      * @param str the string to escape
      * @return the escaped representation
      */
-    public static String escapeString(final String str, final char delim) {
+    public static String escapeString(final CharSequence str, final char delim) {
         if (str == null) {
             return null;
         }
         final int length = str.length();
         final StringBuilder strb = new StringBuilder(length + 2);
-        strb.append(delim);
+        if (delim > 0) {
+            strb.append(delim);
+        }
         for (int i = 0; i < length; ++i) {
             final char c = str.charAt(i);
             switch (c) {
@@ -168,7 +170,10 @@ public class StringParser {
                     strb.append('r');
                     break;
                 case '\\':
-                    strb.append('\\');
+                    // we escape the backslash only if there is a delimiter
+                    if (delim > 0) {
+                        strb.append('\\');
+                    }
                     strb.append('\\');
                     break;
                 default:
@@ -189,9 +194,12 @@ public class StringParser {
                     }
             }
         }
-        strb.append(delim);
+        if (delim > 0) {
+            strb.append(delim);
+        }
         return strb.toString();
     }
+
     /**
      * Reads the remainder of a string till a given separator,
      * handles escaping through '\' syntax.
diff --git a/src/test/java/org/apache/commons/jexl3/Issues400Test.java b/src/test/java/org/apache/commons/jexl3/Issues400Test.java
index b7ecc67a..59640cc2 100644
--- a/src/test/java/org/apache/commons/jexl3/Issues400Test.java
+++ b/src/test/java/org/apache/commons/jexl3/Issues400Test.java
@@ -52,7 +52,7 @@ import org.junit.jupiter.api.Test;
 /**
  * Test cases for reported issue between JEXL-300 and JEXL-399.
  */
-class Issues400Test {
+public class Issues400Test {
 
     public static class VinzCaller {
         private final JexlContext context;
@@ -519,7 +519,7 @@ class Issues400Test {
 
     @Test
     void test431b() {
-        final JexlEngine jexl = new JexlBuilder().create();
+        JexlEngine jexl = new JexlBuilder().create();
         final String src = "let x = 0; try(let error) { x += 19 } catch (let error) { return 169 } try { x += 23 } catch (let error) { return 169 }";
         final JexlScript script = jexl.createScript(src);
         assertNotNull(script);
@@ -837,4 +837,37 @@ class Issues400Test {
         result = script.execute(null, 21);
         Assertions.assertEquals("OTHER", result);
     }
+
+    @Test
+    public void testIssue441() throws Exception {
+        JexlEngine jexl = new JexlBuilder().create();
+        String ctl = "\nab\nc`d\n";
+        JexlExpression e = jexl.createExpression("`\nab\nc\\`d\n`");
+        Object o = e.evaluate(null);
+        Assertions.assertEquals(ctl, o);
+
+        JexlContext context = new MapContext();
+        context.set("name", "Hello");
+        String code = "return `${name + '\\n' + name}`;";
+        JexlScript script = jexl.createScript(code);
+        o = script.execute(context);
+        ctl = "Hello\nHello";
+        Assertions.assertEquals(ctl, o);
+    }
+
+    @Test
+    void testIssue442() {
+        JexlEngine jexl = new JexlBuilder().create();
+        JexlContext context = new MapContext();
+        String code = "var x = 'hello';\n" +
+                "function test(z) {\n" +
+                "let y = x;\n"+
+                "  return `${x} ${z}`;\n" +
+                "}\n" +
+                "test('world');";
+        JexlScript script = jexl.createScript(code);
+        Object result = script.execute(context);
+        Assertions.assertEquals("hello world", result);
+    }
 }
+
