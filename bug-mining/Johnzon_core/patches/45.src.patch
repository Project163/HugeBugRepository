diff --git a/johnzon-core/src/main/java/org/apache/johnzon/core/AbstractJsonFactory.java b/johnzon-core/src/main/java/org/apache/johnzon/core/AbstractJsonFactory.java
index 41cce432..4f09d38b 100644
--- a/johnzon-core/src/main/java/org/apache/johnzon/core/AbstractJsonFactory.java
+++ b/johnzon-core/src/main/java/org/apache/johnzon/core/AbstractJsonFactory.java
@@ -29,7 +29,7 @@ import java.util.logging.Logger;
 public abstract class AbstractJsonFactory implements Serializable {
 
     public static final String BUFFER_STRATEGY = "org.apache.johnzon.buffer-strategy";
-    public static final BufferStrategy DEFAULT_BUFFER_STRATEGY = BufferStrategy.valueOf(System.getProperty(BUFFER_STRATEGY, "QUEUE"));
+    public static final BufferStrategy DEFAULT_BUFFER_STRATEGY = BufferStrategyFactory.valueOf(System.getProperty(BUFFER_STRATEGY, "QUEUE"));
     
     protected final Map<String, Object> internalConfig = new HashMap<String, Object>();
     
@@ -54,7 +54,7 @@ public abstract class AbstractJsonFactory implements Serializable {
     protected BufferStrategy getBufferProvider() {
         final Object name = internalConfig.get(BUFFER_STRATEGY);
         if (name != null) {
-            return BufferStrategy.valueOf(name.toString().toUpperCase(Locale.ENGLISH));
+            return BufferStrategyFactory.valueOf(name.toString().toUpperCase(Locale.ENGLISH));
         }
         return DEFAULT_BUFFER_STRATEGY;
     }
diff --git a/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategy.java b/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategy.java
index c37ecfb9..89d7ce4e 100644
--- a/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategy.java
+++ b/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategy.java
@@ -19,254 +19,18 @@
 package org.apache.johnzon.core;
 
 import java.io.Serializable;
-import java.util.concurrent.ConcurrentLinkedQueue;
 
-public enum BufferStrategy {
-    BY_INSTANCE {
-        @Override
-        public BufferProvider<char[]> newCharProvider(final int size) {
-            return new CharBufferByInstanceProvider(size);
-        }
-
-        @Override
-        public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
-            return new StringBuilderByInstanceProvider(size);
-        }
-    },
-    THREAD_LOCAL {
-        @Override
-        public BufferProvider<char[]> newCharProvider(final int size) {
-            return new CharBufferThreadLocalProvider(size);
-        }
-
-        @Override
-        public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
-            return new StringBuilderThreadLocalProvider(size);
-        }
-    },
-    QUEUE {
-        @Override
-        public BufferProvider<char[]> newCharProvider(final int size) {
-            return new CharBufferQueueProvider(size);
-        }
-
-        @Override
-        public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
-            return new StringBuilderQueueProvider(size);
-        }
-    },
-    SINGLETON {
-        @Override
-        public BufferProvider<char[]> newCharProvider(final int size) {
-            return new CharBufferSingletonProvider(size);
-        }
-
-        @Override
-        public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
-            return new StringBuilderSingletonProvider(size);
-        }
-    };
-
-    public abstract BufferProvider<char[]> newCharProvider(int size);
-    public abstract BufferProvider<StringBuilder> newStringBuilderProvider(int size);
+/**
+ * Plugable way to hold various buffers for reading and writing json
+ */
+public interface BufferStrategy {
+    BufferProvider<char[]> newCharProvider(int size);
+    BufferProvider<StringBuilder> newStringBuilderProvider(int size);
 
-    public static interface BufferProvider<T> extends Serializable {
+    interface BufferProvider<T> extends Serializable {
         T newBuffer();
 
         void release(T value);
     }
 
-    private static class CharBufferSingletonProvider extends SingletonProvider<char[]> {
-        public CharBufferSingletonProvider(final int size) {
-            super(size);
-        }
-
-        @Override
-        protected char[] newInstance(int size) {
-            return new char[size];
-        }
-
-        @Override
-        public void release(final char[] value) {
-            // no-op
-        }
-    }
-
-    private static class StringBuilderSingletonProvider extends SingletonProvider<StringBuilder> {
-        public StringBuilderSingletonProvider(final int size) {
-            super(size);
-        }
-
-        @Override
-        protected StringBuilder newInstance(final int size) {
-            return new StringBuilder(size);
-        }
-
-        @Override
-        public void release(final StringBuilder value) {
-            value.setLength(0);
-        }
-    }
-
-    private static abstract class SingletonProvider<T> implements BufferProvider<T> {
-        protected final T buffer;
-
-        public SingletonProvider(final int size) {
-            buffer = newInstance(size);
-        }
-
-        protected abstract T newInstance(int size);
-
-        @Override
-        public T newBuffer() {
-            return buffer;
-        }
-
-        @Override
-        public void release(final T value) {
-            // no-op
-        }
-    }
-
-    private static abstract class ThreadLocalProvider<T> implements BufferProvider<T> {
-        private final ThreadLocalBufferCache<T> cache;
-
-        public ThreadLocalProvider(final int size) {
-            cache = new ThreadLocalBufferCache<T>(size) {
-                @Override
-                protected T newValue(int defaultSize) {
-                    return newInstance(size);
-                }
-            };
-        }
-
-        protected abstract T newInstance(int size);
-
-        @Override
-        public T newBuffer() {
-            return cache.getCache();
-        }
-
-        @Override
-        public void release(final T value) {
-            cache.release(value);
-        }
-    }
-
-    private static class CharBufferThreadLocalProvider extends ThreadLocalProvider<char[]> {
-        public CharBufferThreadLocalProvider(int size) {
-            super(size);
-        }
-
-        @Override
-        protected char[] newInstance(final int size) {
-            return new char[size];
-        }
-    }
-
-    private static class StringBuilderThreadLocalProvider extends ThreadLocalProvider<StringBuilder> {
-        public StringBuilderThreadLocalProvider(int size) {
-            super(size);
-        }
-
-        @Override
-        protected StringBuilder newInstance(final int size) {
-            return new StringBuilder(size);
-        }
-
-        @Override
-        public void release(final StringBuilder value) {
-            value.setLength(0);
-            super.release(value);
-        }
-    }
-
-    private static class CharBufferByInstanceProvider implements BufferProvider<char[]> {
-        private final int size;
-
-        public CharBufferByInstanceProvider(final int size) {
-            this.size = size;
-        }
-
-        @Override
-        public char[] newBuffer() {
-            return new char[size];
-        }
-
-        @Override
-        public void release(final char[] value) {
-            // no-op
-        }
-    }
-
-    private static class StringBuilderByInstanceProvider implements BufferProvider<StringBuilder> {
-        private final int size;
-
-        public StringBuilderByInstanceProvider(final int size) {
-            this.size = size;
-        }
-
-        @Override
-        public StringBuilder newBuffer() {
-            return new StringBuilder(size);
-        }
-
-        @Override
-        public void release(final StringBuilder value) {
-            // no-op
-        }
-    }
-
-    private static abstract class QueueProvider<T> implements BufferProvider<T> {
-        private final int size;
-        private final ConcurrentLinkedQueue<T> queue = new ConcurrentLinkedQueue<T>();
-
-        public QueueProvider(final int size) {
-            this.size = size;
-        }
-
-        protected abstract T newInstance(int size);
-
-        @Override
-        public T newBuffer() {
-            final T buffer = queue.poll();
-            if (buffer == null) {
-                return newInstance(size);
-            }
-            return buffer;
-        }
-
-        @Override
-        public void release(final T value) {
-            queue.offer(value);
-        }
-    }
-
-    private static class CharBufferQueueProvider extends QueueProvider<char[]> {
-        public CharBufferQueueProvider(final int size) {
-            super(size);
-        }
-
-        @Override
-        protected char[] newInstance(int size) {
-            return new char[size];
-        }
-    }
-
-    private static class StringBuilderQueueProvider extends QueueProvider<StringBuilder> {
-        public StringBuilderQueueProvider(final int size) {
-            super(size);
-        }
-
-        @Override
-        protected StringBuilder newInstance(int size) {
-            return new StringBuilder(size);
-        }
-
-        @Override
-        public void release(final StringBuilder value) {
-            value.setLength(0);
-            super.release(value);
-        }
-    }
 }
diff --git a/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategyFactory.java b/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategyFactory.java
new file mode 100644
index 00000000..a52d379b
--- /dev/null
+++ b/johnzon-core/src/main/java/org/apache/johnzon/core/BufferStrategyFactory.java
@@ -0,0 +1,312 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.johnzon.core;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+import org.apache.johnzon.core.util.ClassUtil;
+
+public class BufferStrategyFactory {
+    private static final Map<String, BufferStrategy> DEFAULT_STRATEGIES;
+    static {
+        DEFAULT_STRATEGIES = new HashMap<>();
+
+        DEFAULT_STRATEGIES.put("BY_INSTANCE", new BufferStrategy() {
+            @Override
+            public BufferProvider<char[]> newCharProvider(final int size) {
+                return new CharBufferByInstanceProvider(size);
+            }
+
+            @Override
+            public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
+                return new StringBuilderByInstanceProvider(size);
+            }
+        });
+
+        DEFAULT_STRATEGIES.put("THREAD_LOCAL", new BufferStrategy() {
+            @Override
+            public BufferProvider<char[]> newCharProvider(final int size) {
+                return new CharBufferThreadLocalProvider(size);
+            }
+
+            @Override
+            public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
+                return new StringBuilderThreadLocalProvider(size);
+            }
+        });
+
+        DEFAULT_STRATEGIES.put("QUEUE", new BufferStrategy() {
+            @Override
+            public BufferProvider<char[]> newCharProvider(final int size) {
+                return new CharBufferQueueProvider(size);
+            }
+
+            @Override
+            public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
+                return new StringBuilderQueueProvider(size);
+            }
+        });
+        DEFAULT_STRATEGIES.put("SINGLETON", new BufferStrategy() {
+            @Override
+            public BufferProvider<char[]> newCharProvider(final int size) {
+                return new CharBufferSingletonProvider(size);
+            }
+
+            @Override
+            public BufferProvider<StringBuilder> newStringBuilderProvider(final int size) {
+                return new StringBuilderSingletonProvider(size);
+            }
+        });
+    }
+
+    private BufferStrategyFactory() {
+        // utility class ct
+    }
+
+    /**
+     * creates a BufferStrategy based on the name.
+     *
+     * The following BufferStrategies are supported out of the box:
+     * <ul>
+     *     <li>BY_INSTANCE</li>
+     *     <li>THREAD_LOCAL</li>
+     *     <li>QUEUE</li>
+     *     <li>SINGLETON</li>
+     * </ul>
+     *
+     * You can also pass in a fully qualified class name of a custom {@link BufferStrategy}.
+     *
+     * @throws IllegalArgumentException if the given strategyName does not resolve to a BufferStrategy.
+     */
+    public static BufferStrategy valueOf(String strategyName) {
+        BufferStrategy bufferStrategy = DEFAULT_STRATEGIES.get(strategyName);
+        if (bufferStrategy == null) {
+            // try to load the BufferStrategy via reflection
+            Class<?> bsClass = ClassUtil.loadClassOptional(strategyName, false);
+            if (bsClass == null || bsClass.isAssignableFrom(BufferStrategy.class)) {
+                throw new IllegalArgumentException("Could not load Johnzon BufferStrategy " + strategyName +
+                        ". Valid BufferStrategies are " + DEFAULT_STRATEGIES.keySet().toString() +
+                        " or a fully qualified class name of an implementation of " + BufferStrategy.class.getName());
+            }
+
+            try {
+                bufferStrategy = (BufferStrategy) bsClass.newInstance();
+            } catch (InstantiationException | IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        return bufferStrategy;
+    }
+
+    private static class CharBufferSingletonProvider extends SingletonProvider<char[]> {
+        public CharBufferSingletonProvider(final int size) {
+            super(size);
+        }
+
+        @Override
+        protected char[] newInstance(int size) {
+            return new char[size];
+        }
+
+        @Override
+        public void release(final char[] value) {
+            // no-op
+        }
+    }
+
+    private static class StringBuilderSingletonProvider extends SingletonProvider<StringBuilder> {
+        public StringBuilderSingletonProvider(final int size) {
+            super(size);
+        }
+
+        @Override
+        protected StringBuilder newInstance(final int size) {
+            return new StringBuilder(size);
+        }
+
+        @Override
+        public void release(final StringBuilder value) {
+            value.setLength(0);
+        }
+    }
+
+    private static abstract class SingletonProvider<T> implements BufferStrategy.BufferProvider<T> {
+        protected final T buffer;
+
+        public SingletonProvider(final int size) {
+            buffer = newInstance(size);
+        }
+
+        protected abstract T newInstance(int size);
+
+        @Override
+        public T newBuffer() {
+            return buffer;
+        }
+
+        @Override
+        public void release(final T value) {
+            // no-op
+        }
+    }
+
+    private static abstract class ThreadLocalProvider<T> implements BufferStrategy.BufferProvider<T> {
+        private final ThreadLocalBufferCache<T> cache;
+
+        public ThreadLocalProvider(final int size) {
+            cache = new ThreadLocalBufferCache<T>(size) {
+                @Override
+                protected T newValue(int defaultSize) {
+                    return newInstance(size);
+                }
+            };
+        }
+
+        protected abstract T newInstance(int size);
+
+        @Override
+        public T newBuffer() {
+            return cache.getCache();
+        }
+
+        @Override
+        public void release(final T value) {
+            cache.release(value);
+        }
+    }
+
+    private static class CharBufferThreadLocalProvider extends ThreadLocalProvider<char[]> {
+        public CharBufferThreadLocalProvider(int size) {
+            super(size);
+        }
+
+        @Override
+        protected char[] newInstance(final int size) {
+            return new char[size];
+        }
+    }
+
+    private static class StringBuilderThreadLocalProvider extends ThreadLocalProvider<StringBuilder> {
+        public StringBuilderThreadLocalProvider(int size) {
+            super(size);
+        }
+
+        @Override
+        protected StringBuilder newInstance(final int size) {
+            return new StringBuilder(size);
+        }
+
+        @Override
+        public void release(final StringBuilder value) {
+            value.setLength(0);
+            super.release(value);
+        }
+    }
+
+    private static class CharBufferByInstanceProvider implements BufferStrategy.BufferProvider<char[]> {
+        private final int size;
+
+        public CharBufferByInstanceProvider(final int size) {
+            this.size = size;
+        }
+
+        @Override
+        public char[] newBuffer() {
+            return new char[size];
+        }
+
+        @Override
+        public void release(final char[] value) {
+            // no-op
+        }
+    }
+
+    private static class StringBuilderByInstanceProvider implements BufferStrategy.BufferProvider<StringBuilder> {
+        private final int size;
+
+        public StringBuilderByInstanceProvider(final int size) {
+            this.size = size;
+        }
+
+        @Override
+        public StringBuilder newBuffer() {
+            return new StringBuilder(size);
+        }
+
+        @Override
+        public void release(final StringBuilder value) {
+            // no-op
+        }
+    }
+
+    private static abstract class QueueProvider<T> implements BufferStrategy.BufferProvider<T> {
+        private final int size;
+        private final ConcurrentLinkedQueue<T> queue = new ConcurrentLinkedQueue<T>();
+
+        public QueueProvider(final int size) {
+            this.size = size;
+        }
+
+        protected abstract T newInstance(int size);
+
+        @Override
+        public T newBuffer() {
+            final T buffer = queue.poll();
+            if (buffer == null) {
+                return newInstance(size);
+            }
+            return buffer;
+        }
+
+        @Override
+        public void release(final T value) {
+            queue.offer(value);
+        }
+    }
+
+    private static class CharBufferQueueProvider extends QueueProvider<char[]> {
+        public CharBufferQueueProvider(final int size) {
+            super(size);
+        }
+
+        @Override
+        protected char[] newInstance(int size) {
+            return new char[size];
+        }
+    }
+
+    private static class StringBuilderQueueProvider extends QueueProvider<StringBuilder> {
+        public StringBuilderQueueProvider(final int size) {
+            super(size);
+        }
+
+        @Override
+        protected StringBuilder newInstance(int size) {
+            return new StringBuilder(size);
+        }
+
+        @Override
+        public void release(final StringBuilder value) {
+            value.setLength(0);
+            super.release(value);
+        }
+    }
+
+}
diff --git a/johnzon-core/src/main/java/org/apache/johnzon/core/JsonProviderImpl.java b/johnzon-core/src/main/java/org/apache/johnzon/core/JsonProviderImpl.java
index 4447a7d7..2ae20df9 100644
--- a/johnzon-core/src/main/java/org/apache/johnzon/core/JsonProviderImpl.java
+++ b/johnzon-core/src/main/java/org/apache/johnzon/core/JsonProviderImpl.java
@@ -216,7 +216,7 @@ public class JsonProviderImpl extends JsonProvider implements Serializable {
 
     static class JsonProviderDelegate extends JsonProvider {
         private final BufferStrategy.BufferProvider<char[]> bufferProvider =
-            BufferStrategy.valueOf(System.getProperty("johnzon.global-char-provider.strategy", "QUEUE"))
+            BufferStrategyFactory.valueOf(System.getProperty("johnzon.global-char-provider.strategy", "QUEUE"))
                 .newCharProvider(Integer.getInteger("org.apache.johnzon.default-char-provider.length", 1024));
 
         private final JsonReaderFactory readerFactory = new JsonReaderFactoryImpl(null);
diff --git a/johnzon-core/src/main/java/org/apache/johnzon/core/Strings.java b/johnzon-core/src/main/java/org/apache/johnzon/core/Strings.java
index 5ea33054..e229d4c2 100644
--- a/johnzon-core/src/main/java/org/apache/johnzon/core/Strings.java
+++ b/johnzon-core/src/main/java/org/apache/johnzon/core/Strings.java
@@ -25,7 +25,7 @@ import javax.json.stream.JsonParsingException;
 
 class Strings implements JsonChars {
     private static final BufferStrategy.BufferProvider<StringBuilder> BUILDER_CACHE =
-        BufferStrategy.valueOf(System.getProperty("johnzon.string-builder.strategy", "QUEUE"))
+        BufferStrategyFactory.valueOf(System.getProperty("johnzon.string-builder.strategy", "QUEUE"))
             .newStringBuilderProvider(Integer.getInteger("org.apache.johnzon.default-string-builder", 1024));
 
     private static final String UNICODE_PREFIX = "\\u";
diff --git a/johnzon-core/src/main/java/org/apache/johnzon/core/util/ClassUtil.java b/johnzon-core/src/main/java/org/apache/johnzon/core/util/ClassUtil.java
new file mode 100644
index 00000000..1dc189b1
--- /dev/null
+++ b/johnzon-core/src/main/java/org/apache/johnzon/core/util/ClassUtil.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.johnzon.core.util;
+
+/**
+ * ClassLoader related utils
+ */
+public final class ClassUtil {
+
+    private ClassUtil() {
+        // private utility class ct
+    }
+
+    /**
+     * @return either the ThreadContextClassLoader or the CL of this very class if no TCCL exists
+     */
+    public static ClassLoader getClassLoader() {
+        ClassLoader tccl = Thread.currentThread().getContextClassLoader();
+        if (tccl != null) {
+            return tccl;
+        }
+
+        return ClassUtil.class.getClassLoader();
+    }
+
+    /**
+     * @param className           to be loaded
+     * @param ignoreBrokenClasses if {@link NoClassDefFoundError} should be ignored
+     * @return Class or {@code null} if the class could not be found
+     */
+    public static Class<?> loadClassOptional(String className, boolean ignoreBrokenClasses) {
+        ClassLoader cl = getClassLoader();
+
+        try {
+            return cl.loadClass(className);
+        } catch (ClassNotFoundException e) {
+            // all fine, that class is optional!
+            return null;
+        } catch (NoClassDefFoundError ncdfe) {
+            if (ignoreBrokenClasses) {
+                return null;
+            }
+            throw ncdfe;
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/johnzon-core/src/test/java/org/apache/johnzon/core/BufferStrategyFactoryTest.java b/johnzon-core/src/test/java/org/apache/johnzon/core/BufferStrategyFactoryTest.java
new file mode 100644
index 00000000..06efdcf9
--- /dev/null
+++ b/johnzon-core/src/test/java/org/apache/johnzon/core/BufferStrategyFactoryTest.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.johnzon.core;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class BufferStrategyFactoryTest {
+
+    @Test
+    public void testDefaultStrategies() {
+        verify(BufferStrategyFactory.valueOf("BY_INSTANCE"));
+        verify(BufferStrategyFactory.valueOf("THREAD_LOCAL"));
+        verify(BufferStrategyFactory.valueOf("QUEUE"));
+        verify(BufferStrategyFactory.valueOf("SINGLETON"));
+    }
+
+    @Test(expected = IllegalArgumentException.class)
+    public void testNotExistingStrategy() {
+        BufferStrategyFactory.valueOf("NOT_EXISTING");
+    }
+
+    @Test
+    public void testFqcnBufferStrategy() {
+        verify(BufferStrategyFactory.valueOf(DummyBufferStrategy.class.getName()));
+    }
+
+    private void verify(Object bufferStrategy) {
+        assertNotNull(bufferStrategy);
+        assertTrue(bufferStrategy instanceof BufferStrategy);
+    }
+
+    public static final class DummyBufferStrategy implements BufferStrategy {
+        @Override
+        public BufferProvider<char[]> newCharProvider(int size) {
+            return null;
+        }
+
+        @Override
+        public BufferProvider<StringBuilder> newStringBuilderProvider(int size) {
+            return null;
+        }
+    }
+}
diff --git a/johnzon-core/src/test/java/org/apache/johnzon/core/SerializationTest.java b/johnzon-core/src/test/java/org/apache/johnzon/core/SerializationTest.java
index de90ff3f..6074563b 100644
--- a/johnzon-core/src/test/java/org/apache/johnzon/core/SerializationTest.java
+++ b/johnzon-core/src/test/java/org/apache/johnzon/core/SerializationTest.java
@@ -83,7 +83,7 @@ public class SerializationTest {
         map.put("test", new JsonStringImpl("val"));
         map.put("test2", JsonValue.TRUE);
         final JsonObject source = new JsonObjectImpl(Collections.unmodifiableMap(map),
-                BufferStrategy.BY_INSTANCE.newCharProvider(512));
+                BufferStrategyFactory.valueOf("BY_INSTANCE").newCharProvider(512));
         final JsonObject serialization = serialDeser(source);
         assertNotSame(source, serialization);
         assertTrue(serialization.containsKey("test"));
@@ -98,7 +98,7 @@ public class SerializationTest {
         list.add(new JsonStringImpl("test"));
         list.add(JsonValue.TRUE); // not ser but we should be able to handle that
         final JsonArray source = new JsonArrayImpl(Collections.unmodifiableList(list),
-                BufferStrategy.BY_INSTANCE.newCharProvider(512));
+                BufferStrategyFactory.valueOf("BY_INSTANCE").newCharProvider(512));
         final JsonArray serialization = serialDeser(source);
         assertNotSame(source, serialization);
         assertEquals(2, serialization.size());
