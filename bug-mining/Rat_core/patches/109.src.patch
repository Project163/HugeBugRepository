diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/FileProcessor.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/FileProcessor.java
deleted file mode 100644
index 9d788659..00000000
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/FileProcessor.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.rat.config.exclusion;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Function;
-import java.util.stream.Collectors;
-
-import org.apache.rat.config.exclusion.plexus.MatchPattern;
-import org.apache.rat.config.exclusion.plexus.SelectorUtils;
-import org.apache.rat.document.DocumentName;
-import org.apache.rat.document.DocumentNameMatcher;
-
-/**
- * The file processor reads the file specified in the DocumentName.
- * It must return a list of fully qualified strings for the {@link MatchPattern} to process.
- * It may return either Ant or Regex style strings, or a mixture of both.
- * See {@link SelectorUtils} for a description of the formats.
- * It may also generate custom DocumentNameMatchers which are added to the customMatchers instance variable.
- */
-public class FileProcessor implements Function<DocumentName, Iterable<String>> {
-    /** A String format pattern to print a regex string */
-    public static final String REGEX_FMT = "%%regex[%s]";
-    /** An empty file processor returning no entries.*/
-    public static final FileProcessor EMPTY = new FileProcessor();
-    /** Prefix used to negate the given pattern. */
-    public static final String NEGATION_PREFIX = "!";
-    /** The list of patterns that will be converted into DocumentNameMatchers */
-    private final List<String> patterns = new ArrayList<>();
-    /** The collection of custom DocumentNameMatchers generated by this processor */
-    protected final List<DocumentNameMatcher> customMatchers = new ArrayList<>();
-
-    /**
-     * Protected constructor.
-     */
-    protected FileProcessor() {
-    }
-
-    /**
-     * Create a file processor out of a list of file patterns.
-     * @param patterns the patterns to simulate the file from.
-     */
-    public FileProcessor(final Iterable<String> patterns) {
-        patterns.forEach(this.patterns::add);
-    }
-
-    @Override
-    public Iterable<String> apply(final DocumentName documentName) {
-        return patterns.stream().map(entry -> localizePattern(documentName, entry)).collect(Collectors.toList());
-    }
-
-    /**
-     * If this FileProcessor builds custom matchers to handles special cases this method returns them
-     * to the processing stream.
-     * @return A collection of DocumentNameMatchers. Default returns an empty list.
-     */
-    public final Iterable<DocumentNameMatcher> customDocumentNameMatchers() {
-        return customMatchers;
-    }
-
-    /**
-     * Allows modification of the file entry to match the {@link MatchPattern} format.
-     * Default implementation returns the @{code entry} argument.
-     * @param documentName the name of the document that the file was read from.
-     * @param entry the entry from that document.
-     * @return the modified string or null to skip the string.
-     */
-    protected String modifyEntry(final DocumentName documentName, final String entry) {
-        return entry;
-    }
-
-    /**
-     * Modifies the {@link MatchPattern} formatted {@code pattern} argument by expanding the pattern and
-     * by adjusting the pattern to include the basename from the {@code documentName} argument.
-     * @param documentName the name of the file being read.
-     * @param pattern the pattern to format.
-     * @return the completely formatted pattern
-     */
-    protected final String localizePattern(final DocumentName documentName, final String pattern) {
-        boolean prefix = pattern.startsWith(NEGATION_PREFIX);
-        String workingPattern = prefix ? pattern.substring(1) : pattern;
-        String normalizedPattern = SelectorUtils.extractPattern(workingPattern, documentName.getDirectorySeparator());
-        StringBuilder sb = new StringBuilder();
-        if (SelectorUtils.isRegexPrefixedPattern(workingPattern)) {
-            sb.append(prefix ? NEGATION_PREFIX : "")
-                    .append(SelectorUtils.REGEX_HANDLER_PREFIX)
-                    .append("\\Q").append(documentName.getBaseName())
-                    .append(documentName.getDirectorySeparator())
-                    .append("\\E").append(normalizedPattern)
-                    .append(SelectorUtils.PATTERN_HANDLER_SUFFIX);
-            return sb.toString();
-        } else {
-            sb.append(documentName.getBaseName())
-                    .append(documentName.getDirectorySeparator()).append(normalizedPattern);
-            return (prefix ? NEGATION_PREFIX : "") + DocumentName.builder(documentName).setName(sb.toString()).build().getName();
-        }
-    }
-}
diff --git a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentName.java b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentName.java
index d5cc1126..74a32671 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentName.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentName.java
@@ -67,46 +67,8 @@ public class DocumentName implements Comparable<DocumentName> {
     private final String root;
 
     /**
-     * Determines if the file system is case-sensitive.
-     * @param fileSystem the file system to check
-     * @return {@code true} if the file system is case-sensitive.
-     */
-    private static boolean isCaseSensitive(final FileSystem fileSystem) {
-        boolean isCaseSensitive = false;
-        Path nameSet = null;
-        Path filea = null;
-        Path fileA = null;
-        try {
-            try {
-                Path root = fileSystem.getPath("");
-                nameSet = Files.createTempDirectory(root, "NameSet");
-                filea = nameSet.resolve("a");
-                fileA = nameSet.resolve("A");
-                Files.createFile(filea);
-                Files.createFile(fileA);
-                isCaseSensitive = true;
-            } catch (IOException e) {
-                // do nothing
-            } finally {
-                if (filea != null) {
-                    Files.deleteIfExists(filea);
-                }
-                if (fileA != null) {
-                    Files.deleteIfExists(fileA);
-                }
-                if (nameSet != null) {
-                    Files.deleteIfExists(nameSet);
-                }
-            }
-        } catch (IOException e) {
-            // do nothing.
-        }
-        return isCaseSensitive;
-    }
-
-    /**
-     * Creates a Builder with the default File system info.
-     * @return the Builder.
+     * Creates a Builder with the default file system info.
+     * @return the builder.
      * @see FSInfo
      */
     public static Builder builder() {
@@ -124,7 +86,7 @@ public class DocumentName implements Comparable<DocumentName> {
 
     /**
      * Creates a builder for the specified file system.
-     * @param fileSystem the file system to create ethe builder on.
+     * @param fileSystem the file system to create the builder on.
      * @return a new builder.
      */
     public static Builder builder(final FileSystem fileSystem) {
@@ -135,16 +97,16 @@ public class DocumentName implements Comparable<DocumentName> {
      * Creates a builder from a File. The {@link #baseName} is set to the file name if it is a directory otherwise
      * it is set to the directory containing the file.
      * @param file The file to set defaults from.
-     * @return the Builder.
+     * @return the builder.
      */
     public static Builder builder(final File file) {
         return new Builder(file);
     }
 
     /**
-     * Creates a Builder from a document name. The Builder will be configured to create a clone of the DocumentName.
+     * Creates a builder from a document name. The builder will be configured to create a clone of the DocumentName.
      * @param documentName the document name to set the defaults from.
-     * @return the Builder.
+     * @return the builder.
      */
     public static Builder builder(final DocumentName documentName) {
         return new Builder(documentName);
@@ -188,7 +150,7 @@ public class DocumentName implements Comparable<DocumentName> {
         if (StringUtils.isBlank(child)) {
             return this;
         }
-        String separator = fsInfo.dirSeparator();
+        String separator = getDirectorySeparator();
         String pattern = separator.equals("/") ? child.replace('\\', '/') :
                 child.replace('/', '\\');
 
@@ -196,7 +158,7 @@ public class DocumentName implements Comparable<DocumentName> {
              pattern = name + separator + pattern;
         }
 
-        return new Builder(this).setName(pattern).build();
+        return new Builder(this).setName(fsInfo.normalize(pattern)).build();
     }
 
     /**
@@ -241,7 +203,7 @@ public class DocumentName implements Comparable<DocumentName> {
 
     /**
      * Determines if the candidate starts with the root or separator strings.
-     * @param candidate the candidate ot check. If blank method will return {@code false}.
+     * @param candidate the candidate to check. If blank method will return {@code false}.
      * @param root the root to check. If blank the root check is skipped.
      * @param separator the separator to check. If blank the check is skipped.
      * @return true if either the root or separator check returned {@code true}.
@@ -370,11 +332,49 @@ public class DocumentName implements Comparable<DocumentName> {
         public FSInfo(final String name, final FileSystem fileSystem) {
             this.name = name;
             this.separator = fileSystem.getSeparator();
-            this.isCaseSensitive = DocumentName.isCaseSensitive(fileSystem);
+            this.isCaseSensitive = isCaseSensitive(fileSystem);
             roots = new ArrayList<>();
             fileSystem.getRootDirectories().forEach(r -> roots.add(r.toString()));
         }
 
+        /**
+         * Determines if the file system is case-sensitive.
+         * @param fileSystem the file system to check.
+         * @return {@code true} if the file system is case-sensitive.
+         */
+        private static boolean isCaseSensitive(final FileSystem fileSystem) {
+            boolean isCaseSensitive = false;
+            Path nameSet = null;
+            Path filea = null;
+            Path fileA = null;
+            try {
+                try {
+                    Path root = fileSystem.getPath("");
+                    nameSet = Files.createTempDirectory(root, "NameSet");
+                    filea = nameSet.resolve("a");
+                    fileA = nameSet.resolve("A");
+                    Files.createFile(filea);
+                    Files.createFile(fileA);
+                    isCaseSensitive = true;
+                } catch (IOException e) {
+                    // do nothing
+                } finally {
+                    if (filea != null) {
+                        Files.deleteIfExists(filea);
+                    }
+                    if (fileA != null) {
+                        Files.deleteIfExists(fileA);
+                    }
+                    if (nameSet != null) {
+                        Files.deleteIfExists(nameSet);
+                    }
+                }
+            } catch (IOException e) {
+                // do nothing.
+            }
+            return isCaseSensitive;
+        }
+
         /**
          * Gets the common name for the underlying file system.
          * @return the common file system name.
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java
deleted file mode 100644
index 92291267..00000000
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/FileProcessorTest.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.rat.config.exclusion;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.stream.Stream;
-import org.apache.rat.document.DocumentName;
-import org.apache.rat.document.FSInfoTest;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.MethodSource;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class FileProcessorTest {
-
-    FileProcessorTest() {}
-
-    @ParameterizedTest(name="{index} {1}")
-    @MethodSource("localizePatternData")
-    void localizePatternTest(DocumentName baseName, String pattern, String expectedStr) {
-        assertThat(FileProcessor.EMPTY.localizePattern(baseName, pattern)).isEqualTo(expectedStr);
-    }
-
-    public static Stream<Arguments> localizePatternData() {
-        List<Arguments>  lst = new ArrayList<>();
-        DocumentName baseName = DocumentName.builder(FSInfoTest.UNIX).setName("fileBeingRead").setBaseName("baseDir").build();
-
-        lst.add(Arguments.of(baseName, "file", "/baseDir/file"));
-        lst.add(Arguments.of(baseName, "!file", "!/baseDir/file"));
-        lst.add(Arguments.of(baseName, "%regex[file]", "%regex[\\Q/baseDir/\\Efile]"));
-        lst.add(Arguments.of(baseName, "!%regex[file]", "!%regex[\\Q/baseDir/\\Efile]"));
-        lst.add(Arguments.of(baseName, "%ant[file]", "/baseDir/file"));
-        lst.add(Arguments.of(baseName, "!%ant[file]", "!/baseDir/file"));
-
-        lst.add(Arguments.of(baseName, "file/**", "/baseDir/file/**"));
-        lst.add(Arguments.of(baseName, "!file/**", "!/baseDir/file/**"));
-        lst.add(Arguments.of(baseName, "%regex[file/.*]", "%regex[\\Q/baseDir/\\Efile/.*]"));
-        lst.add(Arguments.of(baseName, "!%regex[file/.*]", "!%regex[\\Q/baseDir/\\Efile/.*]"));
-        lst.add(Arguments.of(baseName, "%ant[file/**]", "/baseDir/file/**"));
-        lst.add(Arguments.of(baseName, "!%ant[file/**]", "!/baseDir/file/**"));
-
-        return lst.stream();
-    }
-}
