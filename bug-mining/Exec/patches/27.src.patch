diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index fc68bf6a..5189147f 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -24,6 +24,9 @@
     </properties>
     <body>
         <release version="1.1.1-SNAPSHOT" date="TBA" description="Bugfixing Release">
+            <action issue="EXEC-68" dev="ggregory" type="fix" date="2012-10-22"  due-to="Joel McCance">
+                Watchdog kills process immediately if timeout is too large.
+            </action>
             <action issue="EXEC-57" dev="sgoeschl" type="fix" date="2011-10-10"  due-to="Nickolay Martinov">
                 Applied the patch from Nickolay Martinov but the timeout disguises the fact
                 that the process might be still runnung - therefore added a sanity check in
diff --git a/src/main/java/org/apache/commons/exec/Watchdog.java b/src/main/java/org/apache/commons/exec/Watchdog.java
index c7b6fd67..971dd5b8 100644
--- a/src/main/java/org/apache/commons/exec/Watchdog.java
+++ b/src/main/java/org/apache/commons/exec/Watchdog.java
@@ -69,25 +69,25 @@ public class Watchdog implements Runnable {
     }
 
     public void run() {
-       final long until = System.currentTimeMillis() + timeout;
-       boolean isWaiting;
-       synchronized (this) {
-          long now = System.currentTimeMillis();
-          isWaiting = until > now;
-          while (!stopped && isWaiting) {
-              try {
-                  wait(until - now);
-              } catch (InterruptedException e) {
-              }
-              now = System.currentTimeMillis();
-              isWaiting = until > now;
-          }
-       }
+        final long startTime = System.currentTimeMillis();
+        boolean isWaiting;
+        synchronized (this) {
+            long timeLeft = timeout - (System.currentTimeMillis() - startTime);
+            isWaiting = timeLeft > 0;
+            while (!stopped && isWaiting) {
+                try {
+                    wait(timeLeft);
+                } catch (InterruptedException e) {
+                }
+                timeLeft = timeout - (System.currentTimeMillis() - startTime);
+                isWaiting = timeLeft > 0;
+            }
+        }
 
-       // notify the listeners outside of the synchronized block (see EXEC-60)
-       if (!isWaiting) {
-           fireTimeoutOccured();
-       }
-   }
+        // notify the listeners outside of the synchronized block (see EXEC-60)
+        if (!isWaiting) {
+            fireTimeoutOccured();
+        }
+    }
     
 }
diff --git a/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java b/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java
index aa9e9648..9f1fafc5 100644
--- a/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java
+++ b/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java
@@ -326,6 +326,31 @@ public class DefaultExecutorTest extends TestCase {
         assertTrue("Killing the process did not work : " + nrOfInvocations, nrOfInvocations > 5 && nrOfInvocations <= 11);
     }
 
+    /**
+     * [EXEC-68] Synchronously starts a short script with a Watchdog attached with an extremely large timeout. Checks
+     * to see if the script terminated naturally or if it was killed by the Watchdog. Fail if killed by Watchdog.
+     * 
+     * @throws Exception
+     *             the test failed
+     */
+    public void testExecuteWatchdogVeryLongTimeout() throws Exception {
+        long timeout = Long.MAX_VALUE;
+
+        CommandLine cl = new CommandLine(testScript);
+        DefaultExecutor executor = new DefaultExecutor();
+        executor.setWorkingDirectory(new File("."));
+        ExecuteWatchdog watchdog = new ExecuteWatchdog(timeout);
+        executor.setWatchdog(watchdog);
+
+        try {
+            executor.execute(cl);
+        } catch (ExecuteException e) {
+            assertFalse("Process should exit normally, not be killed by watchdog", watchdog.killedProcess());
+            // If the Watchdog did not kill it, something else went wrong.
+            throw e;
+        }
+    }
+
     /**
      * Try to start an non-existing application which should result
      * in an exception.
