diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index 063a6e33..53e09046 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -25,7 +25,6 @@ import org.apache.johnzon.mapper.internal.AdapterKey;
 import org.apache.johnzon.mapper.internal.ConverterAdapter;
 import org.apache.johnzon.mapper.reflection.JohnzonCollectionType;
 import org.apache.johnzon.mapper.reflection.JohnzonParameterizedType;
-import org.apache.johnzon.mapper.reflection.Mappings;
 
 import javax.json.JsonArray;
 import javax.json.JsonNumber;
@@ -54,7 +53,6 @@ import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.nio.charset.Charset;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -87,43 +85,28 @@ public class Mapper implements Closeable {
     private static final Adapter<Object, String> FALLBACK_CONVERTER = new ConverterAdapter<Object>(new FallbackConverter());
     private static final JohnzonParameterizedType ANY_LIST = new JohnzonParameterizedType(List.class, Object.class);
 
+    protected final MapperConfig config;
     protected final Mappings mappings;
     protected final JsonReaderFactory readerFactory;
     protected final JsonGeneratorFactory generatorFactory;
-    protected final boolean close;
     protected final ConcurrentMap<AdapterKey, Adapter<?, ?>> adapters;
     protected final ConcurrentMap<Adapter<?, ?>, AdapterKey> reverseAdaptersRegistry = new ConcurrentHashMap<Adapter<?, ?>, AdapterKey>();
     protected final int version;
-    protected final boolean skipNull;
-    protected final boolean skipEmptyArray;
-    protected final boolean treatByteArrayAsBase64;
-    protected final boolean treatByteArrayAsBase64URL;
-    protected final boolean readAttributeBeforeWrite;
-    protected final Charset encoding;
     protected final ReaderHandler readerHandler;
     protected final Collection<Closeable> closeables;
 
-    // CHECKSTYLE:OFF
-    public Mapper(final JsonReaderFactory readerFactory, final JsonGeneratorFactory generatorFactory,
-                  final boolean doClose, final Map<AdapterKey, Adapter<?, ?>> adapters,
-                  final int version, final Comparator<String> attributeOrder, final boolean skipNull, final boolean skipEmptyArray,
-                  final AccessMode accessMode, final boolean treatByteArrayAsBase64, final boolean treatByteArrayAsBase64URL, final Charset encoding,
-                  final Collection<Closeable> closeables, final boolean readAttributeBeforeWrite) {
-    // CHECKSTYLE:ON
+    Mapper(final JsonReaderFactory readerFactory, final JsonGeneratorFactory generatorFactory, MapperConfig config,
+                  final Map<AdapterKey, Adapter<?, ?>> adapters,
+                  final int version, final Comparator<String> attributeOrder,
+                  final Collection<Closeable> closeables) {
         this.readerFactory = readerFactory;
         this.generatorFactory = generatorFactory;
-        this.close = doClose;
+        this.config = config;
         this.adapters = new ConcurrentHashMap<AdapterKey, Adapter<?, ?>>(adapters);
         this.version = version;
-        this.mappings = new Mappings(attributeOrder, accessMode, version, this.adapters);
-        this.skipNull = skipNull;
-        this.skipEmptyArray = skipEmptyArray;
-        this.treatByteArrayAsBase64 = treatByteArrayAsBase64;
-        this.treatByteArrayAsBase64URL = treatByteArrayAsBase64URL;
-        this.encoding = encoding;
+        this.mappings = new Mappings(attributeOrder, config.getAccessMode(), version, this.adapters);
         this.readerHandler = ReaderHandler.create(readerFactory);
         this.closeables = closeables;
-        this.readAttributeBeforeWrite = readAttributeBeforeWrite;
     }
 
     private static JsonGenerator writePrimitives(final JsonGenerator generator, final Object value) {
@@ -245,7 +228,7 @@ public class Mapper implements Closeable {
     }
 
     public <T> void writeArray(final Collection<T> object, final OutputStream stream) {
-        writeArray(object, new OutputStreamWriter(stream, encoding));
+        writeArray(object, new OutputStreamWriter(stream, config.getEncoding()));
     }
 
     public <T> void writeArray(final Collection<T> object, final Writer stream) {
@@ -276,7 +259,7 @@ public class Mapper implements Closeable {
     }
 
     private void doCloseOrFlush(final JsonGenerator generator) {
-        if (close) {
+        if (config.isClose()) {
             generator.close();
         } else {
             generator.flush();
@@ -284,7 +267,7 @@ public class Mapper implements Closeable {
     }
 
     public <T> void writeIterable(final Iterable<T> object, final OutputStream stream) {
-        writeIterable(object, new OutputStreamWriter(stream, encoding));
+        writeIterable(object, new OutputStreamWriter(stream, config.getEncoding()));
     }
 
     public <T> void writeIterable(final Iterable<T> object, final Writer stream) {
@@ -311,7 +294,7 @@ public class Mapper implements Closeable {
             } catch (final IOException e) {
                 throw new MapperException(e);
             } finally {
-                if (close) {
+                if (config.isClose()) {
                     try {
                         stream.close();
                     } catch (final IOException e) {
@@ -332,7 +315,7 @@ public class Mapper implements Closeable {
     }
 
     public void writeObject(final Object object, final OutputStream stream) {
-        final JsonGenerator generator = generatorFactory.createGenerator(stream, encoding);
+        final JsonGenerator generator = generatorFactory.createGenerator(stream, config.getEncoding());
         doWriteHandlingNullObject(object, generator);
     }
 
@@ -435,7 +418,7 @@ public class Mapper implements Closeable {
             }
 
             if (value == null) {
-                if (skipNull && !getter.reader.isNillable()) {
+                if (config.isSkipNull() && !getter.reader.isNillable()) {
                     continue;
                 } else {
                     gen.writeNull(getterEntry.getKey());
@@ -462,7 +445,7 @@ public class Mapper implements Closeable {
             final Object key = entry.getKey();
 
             if (value == null) {
-                if (skipNull) {
+                if (config.isSkipNull()) {
                     continue;
                 } else {
                     gen.writeNull(key == null ? "null" : key.toString());
@@ -490,16 +473,16 @@ public class Mapper implements Closeable {
                                      final String key, final Object value) throws InvocationTargetException, IllegalAccessException {
         if (array) {
             final int length = Array.getLength(value);
-            if (length == 0 && skipEmptyArray) {
+            if (length == 0 && config.isSkipEmptyArray()) {
                 return generator;
             }
             
-            if(treatByteArrayAsBase64 && (type == byte[].class /*|| type == Byte[].class*/)) {
+            if(config.isTreatByteArrayAsBase64() && (type == byte[].class /*|| type == Byte[].class*/)) {
                 String base64EncodedByteArray = DatatypeConverter.printBase64Binary((byte[]) value);
                 generator.write(key, base64EncodedByteArray);
                 return generator;
             }
-            if(treatByteArrayAsBase64URL && (type == byte[].class /*|| type == Byte[].class*/)) {
+            if(config.isTreatByteArrayAsBase64URL() && (type == byte[].class /*|| type == Byte[].class*/)) {
                 return generator.write(key, String.valueOf(Adapter.class.cast(adapters.get(new AdapterKey(byte[].class, String.class))).to(value)));
             }
 
@@ -542,7 +525,7 @@ public class Mapper implements Closeable {
                 newGen = doWriteArray(Collection.class.cast(o), generator);
             } else if (o != null && o.getClass().isArray()) {
                 final int length = Array.getLength(o);
-                if (length > 0 || !skipEmptyArray) {
+                if (length > 0 || !config.isSkipEmptyArray()) {
                     newGen = generator.writeStartArray();
                     for (int i = 0; i < length; i++) {
                         newGen = writeItem(newGen, Array.get(o, i));
@@ -613,7 +596,7 @@ public class Mapper implements Closeable {
         } catch (final Exception e) {
             throw new MapperException(e);
         } finally {
-            if (close) {
+            if (config.isClose()) {
                 reader.close();
             }
         }
@@ -630,7 +613,7 @@ public class Mapper implements Closeable {
         } catch (final Exception e) {
             throw new MapperException(e);
         } finally {
-            if (close) {
+            if (config.isClose()) {
                 reader.close();
             }
         }
@@ -655,7 +638,7 @@ public class Mapper implements Closeable {
         } catch (final Exception e) {
             throw new MapperException(e);
         } finally {
-            if (close) {
+            if (config.isClose()) {
                 reader.close();
             }
         }
@@ -687,7 +670,7 @@ public class Mapper implements Closeable {
         } catch (final Exception e) {
             throw new MapperException(e);
         } finally {
-            if (close) {
+            if (config.isClose()) {
                 reader.close();
             }
         }
@@ -790,7 +773,7 @@ public class Mapper implements Closeable {
                 setterMethod.write(t, null);
             } else {
                 Object existingInstance = null;
-                if (readAttributeBeforeWrite) {
+                if (config.isReadAttributeBeforeWrite()) {
                     final Mappings.Getter getter = classMapping.getters.get(setter.getKey());
                     if (getter != null) {
                         try {
@@ -869,7 +852,7 @@ public class Mapper implements Closeable {
             throw new MapperException("Unable to parse " + jsonValue + " to boolean");
         }
 
-        if(treatByteArrayAsBase64 && jsonValue.getValueType() == ValueType.STRING && (type == byte[].class /*|| type == Byte[].class*/)) {
+        if(config.isTreatByteArrayAsBase64() && jsonValue.getValueType() == ValueType.STRING && (type == byte[].class /*|| type == Byte[].class*/)) {
             return DatatypeConverter.parseBase64Binary(((JsonString)jsonValue).getString());
         }
 
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
index e78f2f29..eb230749 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
@@ -43,6 +43,8 @@ import org.apache.johnzon.mapper.converter.URLConverter;
 import org.apache.johnzon.mapper.internal.AdapterKey;
 import org.apache.johnzon.mapper.internal.ConverterAdapter;
 
+import org.apache.johnzon.core.JsonParserFactoryImpl;
+
 import javax.json.JsonReaderFactory;
 import javax.json.spi.JsonProvider;
 import javax.json.stream.JsonGenerator;
@@ -94,27 +96,19 @@ public class MapperBuilder {
         DEFAULT_CONVERTERS.put(new AdapterKey(Locale.class, String.class), new LocaleConverter());
     }
 
+    private MapperConfig builderConfig = new MapperConfig();
+
     private JsonReaderFactory readerFactory;
     private JsonGeneratorFactory generatorFactory;
-    private boolean doCloseOnStreams = false;
     private boolean supportHiddenAccess = true;
     private int version = -1;
     private int maxSize = -1;
     private int bufferSize = -1;
     private String bufferStrategy;
     private Comparator<String> attributeOrder = null;
-    private boolean skipNull = true;
-    private boolean skipEmptyArray = false;
-    private boolean supportsComments = false;
-    protected boolean pretty;
-    private AccessMode accessMode;
-    private boolean treatByteArrayAsBase64;
-    private boolean treatByteArrayAsBase64URL;
     private final Map<AdapterKey, Adapter<?, ?>> adapters = new HashMap<AdapterKey, Adapter<?, ?>>(DEFAULT_CONVERTERS);
     private boolean supportConstructors;
-    private Charset encoding = Charset.forName(System.getProperty("johnzon.mapper.encoding", "UTF-8"));
     private boolean useGetterForCollections;
-    private boolean readAttributeBeforeWrite;
     private String accessModeName;
     private final Collection<Closeable> closeables = new ArrayList<Closeable>();
 
@@ -123,9 +117,9 @@ public class MapperBuilder {
             final JsonProvider provider = JsonProvider.provider();
             final Map<String, Object> config = new HashMap<String, Object>();
             if (bufferStrategy != null) {
-                config.put("org.apache.johnzon.buffer-strategy", bufferStrategy);
+                config.put(JsonParserFactoryImpl.BUFFER_STRATEGY, bufferStrategy);
             }
-            if (pretty) {
+            if (builderConfig.isPrettyPrint()) {
                 config.put(JsonGenerator.PRETTY_PRINTING, true);
             }
 
@@ -134,46 +128,44 @@ public class MapperBuilder {
             }
 
             config.remove(JsonGenerator.PRETTY_PRINTING); // doesnt mean anything anymore for reader
-            if (supportsComments) {
-                config.put("org.apache.johnzon.supports-comments", "true");
+            if (builderConfig.isSupportsComments()) {
+                config.put(JsonParserFactoryImpl.SUPPORTS_COMMENTS, "true");
             }
             if (maxSize > 0) {
-                config.put("org.apache.johnzon.max-string-length", maxSize);
+                config.put(JsonParserFactoryImpl.MAX_STRING_LENGTH, maxSize);
             }
             if (bufferSize > 0) {
-                config.put("org.apache.johnzon.default-char-buffer", bufferSize);
+                config.put(JsonParserFactoryImpl.BUFFER_LENGTH, bufferSize);
             }
             if (readerFactory == null) {
                 readerFactory = provider.createReaderFactory(config);
             }
         }
 
-        if (accessMode == null) {
+        if (builderConfig.getAccessMode() == null) {
             if ("field".equalsIgnoreCase(accessModeName)) {
-                this.accessMode = new FieldAccessMode(supportConstructors, supportHiddenAccess);
+                builderConfig.setAccessMode(new FieldAccessMode(supportConstructors, supportHiddenAccess));
             } else if ("method".equalsIgnoreCase(accessModeName)) {
-                this.accessMode = new MethodAccessMode(supportConstructors, supportHiddenAccess, true);
+                builderConfig.setAccessMode(new MethodAccessMode(supportConstructors, supportHiddenAccess, true));
             } else if ("strict-method".equalsIgnoreCase(accessModeName)) {
-                this.accessMode = new MethodAccessMode(supportConstructors, supportHiddenAccess, false);
+                builderConfig.setAccessMode(new MethodAccessMode(supportConstructors, supportHiddenAccess, false));
             } else if ("both".equalsIgnoreCase(accessModeName)) {
-                this.accessMode = new FieldAndMethodAccessMode(supportConstructors, supportHiddenAccess);
+                builderConfig.setAccessMode(new FieldAndMethodAccessMode(supportConstructors, supportHiddenAccess));
             } else {
-                this.accessMode = new MethodAccessMode(supportConstructors, supportHiddenAccess, useGetterForCollections);
+                builderConfig.setAccessMode(new MethodAccessMode(supportConstructors, supportHiddenAccess, useGetterForCollections));
             }
         }
 
+        // new config so builderConfig can get tweaked again.
+        MapperConfig config = builderConfig.clone();
+
         return new Mapper(
             readerFactory, generatorFactory,
-            doCloseOnStreams,
+            config,
             adapters,
             version,
             attributeOrder,
-            skipNull, skipEmptyArray,
-            accessMode,
-            treatByteArrayAsBase64, treatByteArrayAsBase64URL,
-            encoding,
-            closeables,
-            readAttributeBeforeWrite);
+            closeables);
     }
 
     public MapperBuilder addCloseable(final Closeable closeable) {
@@ -182,11 +174,11 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setIgnoreFieldsForType(final Class<?> type, final String... fields) {
-        if (BaseAccessMode.class.isInstance(accessMode)) {
+        if (BaseAccessMode.class.isInstance(builderConfig.getAccessMode())) {
             if (fields == null || fields.length == 0) {
-                BaseAccessMode.class.cast(accessMode).getFieldsToRemove().remove(type);
+                BaseAccessMode.class.cast(builderConfig.getAccessMode()).getFieldsToRemove().remove(type);
             } else {
-                BaseAccessMode.class.cast(accessMode).getFieldsToRemove().put(type, fields);
+                BaseAccessMode.class.cast(builderConfig.getAccessMode()).getFieldsToRemove().put(type, fields);
             }
         } else {
             throw new IllegalStateException("AccessMode is not an BaseAccessMode");
@@ -200,12 +192,12 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setSupportsComments(final boolean supportsComments) {
-        this.supportsComments = supportsComments;
+        builderConfig.setSupportsComments(supportsComments);
         return this;
     }
 
     public MapperBuilder setPretty(final boolean pretty) {
-        this.pretty = pretty;
+        builderConfig.setPrettyPrint(pretty);
         return this;
     }
 
@@ -225,7 +217,7 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setAccessMode(final AccessMode mode) {
-        this.accessMode = mode;
+        builderConfig.setAccessMode(mode);
         return this;
     }
 
@@ -259,7 +251,7 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setDoCloseOnStreams(final boolean doCloseOnStreams) {
-        this.doCloseOnStreams = doCloseOnStreams;
+        builderConfig.setClose(doCloseOnStreams);
         return this;
     }
 
@@ -297,22 +289,22 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setSkipNull(final boolean skipNull) {
-        this.skipNull = skipNull;
+        builderConfig.setSkipNull(skipNull);
         return this;
     }
 
     public MapperBuilder setSkipEmptyArray(final boolean skipEmptyArray) {
-        this.skipEmptyArray = skipEmptyArray;
+        builderConfig.setSkipEmptyArray(skipEmptyArray);
         return this;
     }
 
     public MapperBuilder setTreatByteArrayAsBase64(final boolean treatByteArrayAsBase64) {
-        this.treatByteArrayAsBase64 = treatByteArrayAsBase64;
+        builderConfig.setTreatByteArrayAsBase64(treatByteArrayAsBase64);
         return this;
     }
 
     public MapperBuilder setTreatByteArrayAsBase64URL(final boolean treatByteArrayAsBase64URL) {
-        this.treatByteArrayAsBase64URL = treatByteArrayAsBase64URL;
+        builderConfig.setTreatByteArrayAsBase64URL(treatByteArrayAsBase64URL);
         return this;
     }
 
@@ -322,12 +314,12 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setEncoding(final String encoding) {
-        this.encoding = Charset.forName(encoding);
+        builderConfig.setEncoding(Charset.forName(encoding));
         return this;
     }
 
     public MapperBuilder setReadAttributeBeforeWrite(final boolean readAttributeBeforeWrite) {
-        this.readAttributeBeforeWrite = readAttributeBeforeWrite;
+        builderConfig.setReadAttributeBeforeWrite(readAttributeBeforeWrite);
         return this;
     }
 }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java
new file mode 100644
index 00000000..5c51e129
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper;
+
+import java.nio.charset.Charset;
+
+import org.apache.johnzon.mapper.access.AccessMode;
+
+/**
+ * Contains internal configuration for all the mapper stuff
+ */
+class MapperConfig implements Cloneable {
+    private boolean close = false;
+    private boolean skipNull = true;
+    private boolean skipEmptyArray = false;
+    private boolean supportsComments = false;
+    private boolean treatByteArrayAsBase64;
+    private boolean treatByteArrayAsBase64URL;
+    private boolean readAttributeBeforeWrite;
+    private boolean prettyPrint;
+    private AccessMode accessMode;
+    private Charset encoding = Charset.forName(System.getProperty("johnzon.mapper.encoding", "UTF-8"));
+
+    MapperConfig() {
+    }
+
+    void setClose(boolean close) {
+        this.close = close;
+    }
+
+    public boolean isClose() {
+        return close;
+    }
+
+    public boolean isSkipNull() {
+        return skipNull;
+    }
+
+    void setSkipNull(boolean skipNull) {
+        this.skipNull = skipNull;
+    }
+
+    public boolean isSkipEmptyArray() {
+        return skipEmptyArray;
+    }
+
+    void setSkipEmptyArray(boolean skipEmptyArray) {
+        this.skipEmptyArray = skipEmptyArray;
+    }
+
+    public boolean isSupportsComments() {
+        return supportsComments;
+    }
+
+    void setSupportsComments(boolean supportsComments) {
+        this.supportsComments = supportsComments;
+    }
+
+    public boolean isTreatByteArrayAsBase64() {
+        return treatByteArrayAsBase64;
+    }
+
+    void setTreatByteArrayAsBase64(boolean treatByteArrayAsBase64) {
+        this.treatByteArrayAsBase64 = treatByteArrayAsBase64;
+    }
+
+    public boolean isTreatByteArrayAsBase64URL() {
+        return treatByteArrayAsBase64URL;
+    }
+
+    void setTreatByteArrayAsBase64URL(boolean treatByteArrayAsBase64URL) {
+        this.treatByteArrayAsBase64URL = treatByteArrayAsBase64URL;
+    }
+
+    public boolean isReadAttributeBeforeWrite() {
+        return readAttributeBeforeWrite;
+    }
+
+    void setReadAttributeBeforeWrite(boolean readAttributeBeforeWrite) {
+        this.readAttributeBeforeWrite = readAttributeBeforeWrite;
+    }
+
+    public boolean isPrettyPrint() {
+        return prettyPrint;
+    }
+
+    void setPrettyPrint(boolean prettyPrint) {
+        this.prettyPrint = prettyPrint;
+    }
+
+    public AccessMode getAccessMode() {
+        return accessMode;
+    }
+
+    void setAccessMode(AccessMode accessMode) {
+        this.accessMode = accessMode;
+    }
+
+    public Charset getEncoding() {
+        return encoding;
+    }
+
+    void setEncoding(Charset encoding) {
+        this.encoding = encoding;
+    }
+
+    @Override
+    public MapperConfig clone() {
+        try {
+            return (MapperConfig) super.clone();
+        } catch (CloneNotSupportedException e) {
+            return null;
+        }
+    }
+}
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/JsonbGenerator.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java
similarity index 96%
rename from johnzon-mapper/src/main/java/org/apache/johnzon/mapper/JsonbGenerator.java
rename to johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java
index 9edfa011..b3719a2d 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/JsonbGenerator.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java
@@ -27,7 +27,7 @@ import javax.json.stream.JsonGenerator;
  * To write JSON-P structure elements you can use the {@link #getJsonGenerator()} method.
  *
  */
-public interface JsonbGenerator {
+public interface MappingGenerator {
 
     /**
      * @return the {@link JsonGenerator} used internally to write the JSON output.
@@ -55,7 +55,7 @@ public interface JsonbGenerator {
      * @param o the object to write
      * @return itself, for easier chaining of commands
      */
-    JsonbGenerator writeObject(Object o);
+    MappingGenerator writeObject(Object o);
 
 
 }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/JsonbParser.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParser.java
similarity index 70%
rename from johnzon-mapper/src/main/java/org/apache/johnzon/mapper/JsonbParser.java
rename to johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParser.java
index ef128f38..615dfafe 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/JsonbParser.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParser.java
@@ -18,7 +18,10 @@
  */
 package org.apache.johnzon.mapper;
 
-import javax.json.stream.JsonGenerator;
+import java.lang.reflect.Type;
+
+import javax.json.JsonReader;
+import javax.json.JsonValue;
 import javax.json.stream.JsonParser;
 
 /**
@@ -28,13 +31,19 @@ import javax.json.stream.JsonParser;
  * To write JSON-P structure elements you can use the {@link #getJsonParser()} ()} method.
  *
  */
-public interface JsonbParser {
+public interface MappingParser {
 
     /**
-     * @return the {@link JsonGenerator} used internally to write the JSON output.
+     * @return the {@link JsonParser} used internally to read the JSON input.
      */
     JsonParser getJsonParser();
 
+    /**
+     * @return the {@link JsonReader} to read in full {@link javax.json.JsonValue}s from the {@link #getJsonParser()}
+     */
+    JsonReader getJsonReader();
 
+    <T> T readObject(Type targetType);
 
+    <T> T readObject(JsonValue jsonValue, Type targetType);
 }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
similarity index 96%
rename from johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java
rename to johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
index 68e5d69b..da210fcf 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
@@ -16,19 +16,14 @@
  * specific language governing permissions and limitations
  * under the License.
  */
-package org.apache.johnzon.mapper.reflection;
-
-import org.apache.johnzon.mapper.Adapter;
-import org.apache.johnzon.mapper.Converter;
-import org.apache.johnzon.mapper.JohnzonConverter;
-import org.apache.johnzon.mapper.JohnzonIgnore;
-import org.apache.johnzon.mapper.JohnzonVirtualObject;
-import org.apache.johnzon.mapper.JohnzonVirtualObjects;
+package org.apache.johnzon.mapper;
+
 import org.apache.johnzon.mapper.access.AccessMode;
 import org.apache.johnzon.mapper.converter.DateWithCopyConverter;
 import org.apache.johnzon.mapper.converter.EnumConverter;
 import org.apache.johnzon.mapper.internal.AdapterKey;
 import org.apache.johnzon.mapper.internal.ConverterAdapter;
+import org.apache.johnzon.mapper.reflection.JohnzonParameterizedType;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
@@ -58,10 +53,10 @@ import static org.apache.johnzon.mapper.reflection.Converters.matches;
 
 public class Mappings {
     public static class ClassMapping {
-        public final Class<?> clazz;
-        public final AccessMode.Factory factory;
-        public final Map<String, Getter> getters;
-        public final Map<String, Setter> setters;
+        final Class<?> clazz;
+        final AccessMode.Factory factory;
+        final Map<String, Getter> getters;
+        final Map<String, Setter> setters;
 
 
         protected ClassMapping(final Class<?> clazz, final AccessMode.Factory factory,
@@ -74,9 +69,9 @@ public class Mappings {
     }
 
     public static class CollectionMapping {
-        public final Class<?> raw;
-        public final Type arg;
-        public final boolean primitive;
+        final Class<?> raw;
+        final Type arg;
+        final boolean primitive;
 
         public CollectionMapping(final boolean primitive, final Class<?> collectionType, final Type fieldArgType) {
             this.raw = collectionType;
@@ -86,14 +81,14 @@ public class Mappings {
     }
 
     public static class Getter {
-        public final AccessMode.Reader reader;
-        public final int version;
-        public final Adapter converter;
-        public final Adapter itemConverter;
-        public final boolean primitive;
-        public final boolean array;
-        public final boolean map;
-        public final boolean collection;
+        final AccessMode.Reader reader;
+        final int version;
+        final Adapter converter;
+        final Adapter itemConverter;
+        final boolean primitive;
+        final boolean array;
+        final boolean map;
+        final boolean collection;
 
         public Getter(final AccessMode.Reader reader,
                       final boolean primitive, final boolean array,
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/ObjectConverter.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/ObjectConverter.java
index e831e80e..7f5d02d1 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/ObjectConverter.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/ObjectConverter.java
@@ -20,9 +20,6 @@ package org.apache.johnzon.mapper;
 
 import java.lang.reflect.Type;
 
-import javax.json.stream.JsonGenerator;
-import javax.json.stream.JsonParser;
-
 /**
  * Convert a given Java Type a nested JSON representation.
  * And the other way around.
@@ -33,7 +30,7 @@ import javax.json.stream.JsonParser;
  * @param <T>
  */
 public interface ObjectConverter<T> {
-    void writeJson(T instance, JsonbGenerator jsonbGenerator);
+    void writeJson(T instance, MappingGenerator jsonbGenerator);
 
-    T fromJson(JsonbParser jsonbParser, Type targetType);
+    T fromJson(MappingParser jsonbParser, Type targetType);
 }
diff --git a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/AdapterTest.java b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/AdapterTest.java
index 92df00c0..87ff40d4 100644
--- a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/AdapterTest.java
+++ b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/AdapterTest.java
@@ -62,7 +62,7 @@ public class AdapterTest {
     }
 
     public static class Root {
-        public Foo foo = new Foo();
+        Foo foo = new Foo();
     }
 
     public static class Foo {
@@ -71,8 +71,8 @@ public class AdapterTest {
     }
 
     public static class Bar {
-        public String simple;
-        public int count;
+        String simple;
+        int count;
 
         public Bar() {
             // no-op
diff --git a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/ObjectTypeTest.java b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/ObjectTypeTest.java
index 9302c6e3..21f5701b 100644
--- a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/ObjectTypeTest.java
+++ b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/ObjectTypeTest.java
@@ -19,10 +19,13 @@
 package org.apache.johnzon.mapper;
 
 
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.Arrays;
 
 
+import javax.json.JsonObject;
+
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -47,7 +50,10 @@ public class ObjectTypeTest {
                 .setAccessModeName(accessMode)
                 .build();
 
-        String jsonString = "{ \"//javaType\": \"org.apache.johnzon.mapper.ObjectTypeTest$Customer\", \"firstName\":\"Bruce\", \"lastName\":\"Wayne\" }";
+        String expectedJsonString = "{\"//javaType\":\"org.apache.johnzon.mapper.ObjectTypeTest$Mutt\"," +
+                "\"mother\":{\"//javaType\":\"org.apache.johnzon.mapper.ObjectTypeTest$Poodle\",\"name\":\"Rosa\",\"hairCut\":true}," +
+                "\"father\":{\"//javaType\":\"org.apache.johnzon.mapper.ObjectTypeTest$Beagle\"," +
+                "\"father\":{\"//javaType\":\"org.apache.johnzon.mapper.ObjectTypeTest$Beagle\",\"name\":\"Wuffi\"},\"name\":\"Gnarl\"},\"name\":\"Snoopie\"}";
 
         Poodle mum = new Poodle();
         mum.setName("Rosa");
@@ -67,18 +73,45 @@ public class ObjectTypeTest {
 
         String json = mapper.writeObjectAsString(snoopie);
         Assert.assertNotNull(json);
+        //X TODO Assert.assertEquals(expectedJsonString, json);
     }
 
 
     public static class TestWithTypeConverter implements ObjectConverter<Dog> {
         @Override
-        public void writeJson(Dog instance, JsonbGenerator jsonbGenerator) {
+        public void writeJson(Dog instance, MappingGenerator jsonbGenerator) {
             jsonbGenerator.getJsonGenerator().write("//javaType", instance.getClass().getName());
             jsonbGenerator.writeObject(instance);
         }
 
         @Override
-        public Dog fromJson(JsonbParser jsonParser, Type targetType) {
+        public Dog fromJson(MappingParser jsonParser, Type targetType) {
+            JsonObject jsonObject = jsonParser.getJsonReader().readObject();
+            String javaType = jsonObject.getString("//javaType");
+            if (javaType != null) {
+                // the following should get extracted in a utility class.
+                ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                if (cl == null) {
+                    cl = targetType.getClass().getClassLoader();
+                }
+
+                try {
+                    Class subClass = cl.loadClass(javaType);
+                    Class targetClass = null;
+                    if (targetType instanceof Class) {
+                        targetClass = (Class) targetType;
+                    } else if (targetType instanceof ParameterizedType) {
+                       targetClass = (Class)((ParameterizedType) targetType).getRawType();
+                    }
+                    if (targetClass != null && targetClass.isAssignableFrom(subClass)) {
+                        targetType = subClass;
+                    }
+                } catch (ClassNotFoundException e) {
+                    // continue without better class match
+                }
+
+                jsonParser.readObject(jsonObject, targetType);
+            }
             return null;
         }
     }
@@ -117,7 +150,7 @@ public class ObjectTypeTest {
     }
 
     public static class Poodle extends Dog {
-        boolean hairCut = false;
+        private boolean hairCut = false;
 
         public boolean isHairCut() {
             return hairCut;
