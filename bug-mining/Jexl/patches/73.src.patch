diff --git a/src/main/java/org/apache/commons/jexl3/JexlBuilder.java b/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
index c1b6205a..1fcfec49 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
@@ -85,6 +85,9 @@ public class JexlBuilder {
     /** Whether error messages will carry debugging information. */
     private Boolean debug = null;
 
+    /** Whether interrupt throws JexlException.Cancel. */
+    private Boolean cancellable = null;
+
     /** The map of 'prefix:function' to object implementing the namespaces. */
     private Map<String, Object> namespaces = null;
 
@@ -265,6 +268,23 @@ public class JexlBuilder {
         return this.debug;
     }
 
+    /**
+     * Sets the engine behavior upon interruption: throw an JexlException.Cancel or terminates the current evaluation
+     * and return null.
+     *
+     * @param flag true implies the engine throws the exception, false makes the engine return null.
+     * @return this builder
+     */
+    public JexlBuilder cancellable(boolean flag) {
+        this.cancellable = flag;
+        return this;
+    }
+
+    /** @return the cancellable information flag */
+    public Boolean cancellable() {
+        return this.cancellable;
+    }
+
     /**
      * Sets the default namespaces map the engine will use.
      * <p>
diff --git a/src/main/java/org/apache/commons/jexl3/JexlEngine.java b/src/main/java/org/apache/commons/jexl3/JexlEngine.java
index d4d5c580..f0af69ea 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlEngine.java
@@ -37,11 +37,11 @@ import java.nio.charset.Charset;
  * <li>Error reporting</li>
  * <li>Logging</li>
  * </ul>
- * 
+ *
  * <p>Note that methods that evaluate expressions may throw <em>unchecked</em> exceptions;
  * The {@link JexlException} are thrown in "non-silent" mode but since these are
  * RuntimeException, user-code <em>should</em> catch them wherever most appropriate.</p>
- * 
+ *
  * @since 2.0
  */
 public abstract class JexlEngine {
@@ -67,7 +67,7 @@ public abstract class JexlEngine {
 
     /**
      * Accesses the current thread local context.
-     * 
+     *
      * @return the context or null
      */
     public static JexlContext.ThreadLocal getThreadContext() {
@@ -78,7 +78,7 @@ public abstract class JexlEngine {
      * Sets the current thread local context.
      * <p>This should only be used carefully, for instance when re-evaluating a "stored" script that requires a
      * given Namespace resolver. Remember to synchronize access if context is shared between threads.
-     * 
+     *
      * @param tls the thread local context to set
      */
     public static void setThreadContext(JexlContext.ThreadLocal tls) {
@@ -93,13 +93,13 @@ public abstract class JexlEngine {
 
         /**
          * The charset used for parsing.
-         * 
+         *
          * @return the charset
          */
         Charset getCharset();
         /**
          * Sets whether the engine will throw a {@link JexlException} when an error is encountered during evaluation.
-         * 
+         *
          * @return true if silent, false otherwise
          */
         Boolean isSilent();
@@ -107,28 +107,34 @@ public abstract class JexlEngine {
         /**
          * Checks whether the engine considers unknown variables, methods, functions and constructors as errors or
          * evaluates them as null.
-         * 
+         *
          * @return true if strict, false otherwise
          */
         Boolean isStrict();
 
         /**
          * Checks whether the arithmetic triggers errors during evaluation when null is used as an operand.
-         * 
+         *
          * @return true if strict, false otherwise
          */
         Boolean isStrictArithmetic();
 
+        /**
+         * Whether evaluation will throw JexlException.Cancel (true) or return null (false) when interrupted.
+         * @return true when cancellable, false otherwise
+         */
+        Boolean isCancellable();
+
         /**
          * The MathContext instance used for +,-,/,*,% operations on big decimals.
-         * 
+         *
          * @return the math context
          */
         MathContext getArithmeticMathContext();
 
         /**
          * The BigDecimal scale used for comparison and coercion operations.
-         * 
+         *
          * @return the scale
          */
         int getArithmeticMathScale();
@@ -169,42 +175,42 @@ public abstract class JexlEngine {
 
     /**
      * Gets the charset used for parsing.
-     * 
+     *
      * @return the charset
      */
     public abstract Charset getCharset();
 
     /**
      * Gets this engine underlying {@link JexlUberspect}.
-     * 
+     *
      * @return the uberspect
      */
     public abstract JexlUberspect getUberspect();
 
     /**
      * Gets this engine underlying {@link JexlArithmetic}.
-     * 
+     *
      * @return the arithmetic
      */
     public abstract JexlArithmetic getArithmetic();
 
     /**
      * Checks whether this engine is in debug mode.
-     * 
+     *
      * @return true if debug is on, false otherwise
      */
     public abstract boolean isDebug();
 
     /**
      * Checks whether this engine throws JexlException during evaluation.
-     * 
+     *
      * @return true if silent, false (default) otherwise
      */
     public abstract boolean isSilent();
 
     /**
      * Checks whether the engine considers unknown variables, methods, functions and constructors as errors.
-     * 
+     *
      * @return true if strict, false otherwise
      */
     public abstract boolean isStrict();
@@ -213,14 +219,14 @@ public abstract class JexlEngine {
      * Sets the class loader used to discover classes in 'new' expressions.
      * <p>This method is <em>not</em> thread safe; it should be called as an optional step of the JexlEngine
      * initialization code before expression creation &amp; evaluation.</p>
-     * 
+     *
      * @param loader the class loader to use
      */
     public abstract void setClassLoader(ClassLoader loader);
 
     /**
      * Creates a new {@link JxltEngine} instance using this engine.
-     * 
+     *
      * @return a JEXL Template engine
      */
     public JxltEngine createJxltEngine() {
@@ -229,7 +235,7 @@ public abstract class JexlEngine {
 
     /**
      * Creates a new {@link JxltEngine} instance using this engine.
-     * 
+     *
      * @param noScript  whether the JxltEngine only allows Jexl expressions or scripts
      * @return a JEXL Template engine
      */
@@ -239,7 +245,7 @@ public abstract class JexlEngine {
 
     /**
      * Creates a new instance of {@link JxltEngine} using this engine.
-     * 
+     *
      * @param noScript  whether the JxltEngine only allows JEXL expressions or scripts
      * @param cacheSize the number of expressions in this cache, default is 256
      * @param immediate the immediate template expression character, default is '$'
@@ -459,7 +465,7 @@ public abstract class JexlEngine {
 
     /**
      * Invokes an object's method by name and arguments.
-     * 
+     *
      * @param obj  the method's invoker object
      * @param meth the method's name
      * @param args the method's arguments
@@ -470,7 +476,7 @@ public abstract class JexlEngine {
 
     /**
      * Creates a new instance of an object using the most appropriate constructor based on the arguments.
-     * 
+     *
      * @param <T>   the type of object
      * @param clazz the class to instantiate
      * @param args  the constructor arguments
@@ -480,7 +486,7 @@ public abstract class JexlEngine {
 
     /**
      * Creates a new instance of an object using the most appropriate constructor based on the arguments.
-     * 
+     *
      * @param clazz the name of the class to instantiate resolved through this engine's class loader
      * @param args  the constructor arguments
      * @return the created object instance or null on failure when silent
@@ -489,7 +495,7 @@ public abstract class JexlEngine {
 
     /**
      * Creates a JexlInfo instance.
-     * 
+     *
      * @param fn url/file/template/script user given name
      * @param l  line number
      * @param c  column number
@@ -503,7 +509,7 @@ public abstract class JexlEngine {
      * Create an information structure for dynamic set/get/invoke/new.
      * <p>This gathers the class, method and line number of the first calling method
      * outside of o.a.c.jexl3.</p>
-     * 
+     *
      * @return a JexlInfo instance
      */
     public JexlInfo createInfo() {
@@ -534,7 +540,7 @@ public abstract class JexlEngine {
 
     /**
      * Creates a string from a reader.
-     * 
+     *
      * @param reader to be read.
      * @return the contents of the reader as a String.
      * @throws IOException on any error reading the reader.
@@ -550,7 +556,7 @@ public abstract class JexlEngine {
 
     /**
      * Reads a JEXL source from a File.
-     * 
+     *
      * @param file the script file
      * @return the source
      */
@@ -577,7 +583,7 @@ public abstract class JexlEngine {
 
     /**
      * Reads a JEXL source from an URL.
-     * 
+     *
      * @param url the script url
      * @return the source
      */
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Engine.java b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
index 041a6a0b..368d773e 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Engine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
@@ -98,6 +98,12 @@ public class Engine extends JexlEngine {
      * Default is false.
      */
     protected final boolean silent;
+    /**
+     * Whether expressions evaluated by this engine will throw JexlException.Cancel (true) or return null (false) when
+     * interrupted.
+     * Default is true when not silent and strict.
+     */
+    protected final boolean cancellable;
     /**
      * Whether error messages will carry debugging information.
      */
@@ -152,9 +158,10 @@ public class Engine extends JexlEngine {
         }
         this.logger = conf.logger() == null ? LogFactory.getLog(JexlEngine.class) : conf.logger();
         this.functions = conf.namespaces() == null ? Collections.<String, Object>emptyMap() : conf.namespaces();
+        this.strict = conf.strict() == null ? true : conf.strict();
         this.silent = conf.silent() == null ? false : conf.silent();
+        this.cancellable = conf.cancellable() == null ? !silent && strict : conf.cancellable();
         this.debug = conf.debug() == null ? true : conf.debug();
-        this.strict = conf.strict() == null ? true : conf.strict();
         this.arithmetic = conf.arithmetic() == null ? new JexlArithmetic(this.strict) : conf.arithmetic();
         this.cache = conf.cache() <= 0 ? null : new SoftCache<String, ASTJexlScript>(conf.cache());
         this.cacheThreshold = conf.cacheThreshold();
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index a5f244b1..48dff36b 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -130,6 +130,8 @@ public class Interpreter extends ParserVisitor {
     protected Map<String, Object> functors;
     /** The context to store/retrieve variables. */
     protected final JexlContext context;
+    /** symbol values. */
+    protected final Scope.Frame frame;
     /** The context to store/retrieve variables. */
     protected final JexlContext.NamespaceResolver ns;
     /** Strict interpreter flag (may temporarily change when calling size and empty as functions). */
@@ -140,8 +142,8 @@ public class Interpreter extends ParserVisitor {
     protected final boolean silent;
     /** Cache executors. */
     protected final boolean cache;
-    /** symbol values. */
-    protected final Scope.Frame frame;
+    /** Throw on cancel. */
+    protected final boolean cancellable;
     /** Cancellation support. */
     protected volatile boolean cancelled = false;
     /** Empty parameters for method matching. */
@@ -162,12 +164,15 @@ public class Interpreter extends ParserVisitor {
             JexlEngine.Options opts = (JexlEngine.Options) context;
             Boolean ostrict = opts.isStrict();
             Boolean osilent = opts.isSilent();
+            Boolean ocancellable = opts.isCancellable();
             this.strictEngine = ostrict == null ? jexl.isStrict() : ostrict;
             this.silent = osilent == null ? jexl.isSilent() : osilent;
+            this.cancellable = ocancellable == null? jexl.cancellable : ocancellable;
             this.arithmetic = jexl.arithmetic.options(opts);
         } else {
             this.strictEngine = jexl.isStrict();
             this.silent = jexl.isSilent();
+            this.cancellable = jexl.cancellable;
             this.arithmetic = jexl.arithmetic;
         }
         if (this.context instanceof JexlContext.NamespaceResolver) {
@@ -203,7 +208,7 @@ public class Interpreter extends ParserVisitor {
             return xreturn.getValue();
         } catch (JexlException.Cancel xcancel) {
             cancelled |= Thread.interrupted();
-            if (!silent && strictEngine) {
+            if (cancellable) {
                 throw xcancel.clean();
             }
         } catch (JexlException xjexl) {
@@ -367,6 +372,19 @@ public class Interpreter extends ParserVisitor {
         return new JexlException(node, methodName, xany);
     }
 
+    /**
+     * Cancels this evaluation, setting the cancel flag that will result in a JexlException.Cancel to be thrown.
+     * @return false if already cancelled, true otherwise
+     */
+    protected boolean cancel() {
+        if (cancelled) {
+            return false;
+        } else {
+            cancelled = true;
+            return true;
+        }
+    }
+
     /**
      * Checks whether this interpreter execution was canceled due to thread interruption.
      * @return true if canceled, false otherwise
@@ -378,13 +396,9 @@ public class Interpreter extends ParserVisitor {
          return cancelled;
     }
 
-    /**
-     * Cancels this evaluation, setting the cancel flag that will result in a JexlException.Cancel to be thrown.
-     * @return true in all cases
-     */
-    protected boolean cancel() {
-         cancelled = true;
-         return cancelled;
+    /** @return true if interrupt throws a JexlException.Cancel. */
+    protected boolean isCancellable() {
+        return cancellable;
     }
 
     /**
@@ -767,6 +781,9 @@ public class Interpreter extends ParserVisitor {
     @Override
     protected Object visit(ASTReturnStatement node, Object data) {
         Object val = node.jjtGetChild(0).jjtAccept(this, data);
+        if (isCancelled()) {
+            throw new JexlException.Cancel(node);
+        }
         throw new JexlException.Return(node, null, val);
     }
 
@@ -796,29 +813,29 @@ public class Interpreter extends ParserVisitor {
             // get an iterator for the collection/array etc via the
             // introspector.
             Iterator<?> itemsIterator = uberspect.getIterator(iterableValue);
-            if (itemsIterator != null) {
-                while (itemsIterator.hasNext()) {
-                    if (isCancelled()) {
-                        throw new JexlException.Cancel(node);
-                    }
-                    // set loopVariable to value of iterator
-                    Object value = itemsIterator.next();
-                    if (symbol < 0) {
-                        context.set(loopVariable.getName(), value);
-                    } else {
-                        frame.set(symbol, value);
-                    }
-                    try {
-                        // execute statement
-                        result = statement.jjtAccept(this, data);
-                    } catch (JexlException.Break stmtBreak) {
-                        break;
-                    } catch (JexlException.Continue stmtContinue) {
-                        //continue;
+                if (itemsIterator != null) {
+                    while (itemsIterator.hasNext()) {
+                        if (isCancelled()) {
+                            throw new JexlException.Cancel(node);
+                        }
+                        // set loopVariable to value of iterator
+                        Object value = itemsIterator.next();
+                        if (symbol < 0) {
+                            context.set(loopVariable.getName(), value);
+                        } else {
+                            frame.set(symbol, value);
+                        }
+                        try {
+                            // execute statement
+                            result = statement.jjtAccept(this, data);
+                        } catch (JexlException.Break stmtBreak) {
+                            break;
+                        } catch (JexlException.Continue stmtContinue) {
+                            //continue;
+                        }
                     }
                 }
-            }
-        }
+                        }
         return result;
     }
 
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Script.java b/src/main/java/org/apache/commons/jexl3/internal/Script.java
index 833a5074..3ff1de8e 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Script.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Script.java
@@ -374,5 +374,27 @@ public class Script implements JexlScript, JexlExpression {
                 return result;
             }
         }
+
+        /**
+         * Soft cancel the execution.
+         * @return true if cancel was successful, false otherwise
+         */
+        public boolean cancel() {
+            return interpreter.cancel();
+        }
+
+        /**
+         * @return true if evaluation was cancelled, false otherwise
+         */
+        public boolean isCancelled() {
+            return interpreter.isCancelled();
+        }
+
+        /**
+         * @return true if interruption will throw a JexlException.Cancel, false otherwise
+         */
+        public boolean isCancellable() {
+            return interpreter.isCancellable();
+        }
     }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/jexl3/JexlEvalContext.java b/src/test/java/org/apache/commons/jexl3/JexlEvalContext.java
index cda8fc13..53ff96e1 100644
--- a/src/test/java/org/apache/commons/jexl3/JexlEvalContext.java
+++ b/src/test/java/org/apache/commons/jexl3/JexlEvalContext.java
@@ -35,6 +35,8 @@ public class JexlEvalContext implements JexlContext, JexlContext.NamespaceResolv
     private Boolean silent = null;
     /** Whether the engine should be strict. */
     private Boolean strict = null;
+    /** Whether the engine should be cancellable. */
+    private Boolean cancellable = null;
     /** Whether the arithmetic should be strict. */
     private Boolean mathStrict = null;
     /** The math scale the arithmetic should use. */
@@ -109,6 +111,7 @@ public class JexlEvalContext implements JexlContext, JexlContext.NamespaceResolv
     public void clearOptions() {
         silent = null;
         strict = null;
+        cancellable = null;
         mathScale = -1;
         mathContext = null;
     }
@@ -126,6 +129,19 @@ public class JexlEvalContext implements JexlContext, JexlContext.NamespaceResolv
         return this.silent;
     }
 
+    /**
+     * Sets whether the engine will throw JexlException.Cancel during evaluation when interrupted.
+     * @param s true means JexlException.Cancel will be thrown, false implies null will be returned
+     */
+    public void setCancellable(boolean c) {
+        this.cancellable = c ? Boolean.TRUE : Boolean.FALSE;
+    }
+
+    @Override
+    public Boolean isCancellable() {
+        return this.cancellable;
+    }
+
     /**
      * Sets the engine and arithmetic strict flags in one call.
      * @param se the engine strict flag
diff --git a/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java b/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java
index e1f3e8e6..97fe8c18 100644
--- a/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java
+++ b/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java
@@ -66,10 +66,14 @@ public final class ReadonlyContext implements JexlContext, JexlEngine.Options {
 
     @Override
     public Boolean isStrict() {
-        // egnie
         return options == null? null : options.isStrict();
     }
 
+    @Override
+    public Boolean isCancellable() {
+        return options == null? null : options.isCancellable();
+    }
+
     @Override
     public Boolean isStrictArithmetic() {
         return options == null? null : options.isStrict();
diff --git a/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java b/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java
index 8bc89392..856b9788 100644
--- a/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java
@@ -25,6 +25,7 @@ import java.util.concurrent.Future;
 import java.util.concurrent.FutureTask;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
+import org.apache.commons.jexl3.internal.Script;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -268,22 +269,27 @@ public class ScriptCallableTest extends JexlTestCase {
 
     @Test
     public void testInterruptVerboseStrict() throws Exception {
-        runInterrupt(false, true);
+        runInterrupt(new JexlBuilder().silent(false).strict(true).create());
     }
 
     @Test
     public void testInterruptVerboseLenient() throws Exception {
-        runInterrupt(false, false);
+        runInterrupt(new JexlBuilder().silent(false).strict(false).create());
     }
 
     @Test
     public void testInterruptSilentStrict() throws Exception {
-        runInterrupt(true, true);
+        runInterrupt(new JexlBuilder().silent(true).strict(true).create());
     }
 
     @Test
     public void testInterruptSilentLenient() throws Exception {
-        runInterrupt(true, true);
+        runInterrupt(new JexlBuilder().silent(true).strict(false).create());
+    }
+
+    @Test
+    public void testInterruptCancellable() throws Exception {
+        runInterrupt(new JexlBuilder().silent(true).strict(true).cancellable(true).create());
     }
 
     /**
@@ -292,46 +298,54 @@ public class ScriptCallableTest extends JexlTestCase {
      * @param strict strict (aka not lenient) engine flag
      * @throws Exception if there is a regression
      */
-    private void runInterrupt(boolean silent, boolean strict) throws Exception {
+    private void runInterrupt(JexlEngine jexl) throws Exception {
         ExecutorService exec = Executors.newFixedThreadPool(2);
         try {
             JexlContext ctxt = new TestContext();
-            JexlEngine jexl = new JexlBuilder().silent(silent).strict(strict).create();
 
             // run an interrupt
             JexlScript sint = jexl.createScript("interrupt(); return 42");
             Object t = null;
+            Script.Callable c = (Script.Callable) sint.callable(ctxt);
             try {
-                Callable<Object> c = sint.callable(ctxt);
                 t = c.call();
+                if (c.isCancellable()) {
+                    Assert.fail("should have thrown a Cancel");
+                }
             } catch (JexlException.Cancel xjexl) {
-                if (silent || !strict) {
+                if (!c.isCancellable()) {
                     Assert.fail("should not have thrown " + xjexl);
                 }
             }
+            Assert.assertTrue(c.isCancelled());
             Assert.assertNotEquals(42, t);
 
             // self interrupt
-            Future<Object> c = null;
+            Future<Object> f = null;
+            c = (Script.Callable) sint.callable(ctxt);
             try {
-                c = exec.submit(sint.callable(ctxt));
-                t = c.get();
+                f = exec.submit(c);
+                t = f.get();
+                if (c.isCancellable()) {
+                    Assert.fail("should have thrown a Cancel");
+                }
             } catch (ExecutionException xexec) {
-                if (silent || !strict) {
+                if (!c.isCancellable()) {
                     Assert.fail("should not have thrown " + xexec);
                 }
             }
+            Assert.assertTrue(c.isCancelled());
             Assert.assertNotEquals(42, t);
 
             // timeout a sleep
             JexlScript ssleep = jexl.createScript("sleep(30000); return 42");
             try {
-                c = exec.submit(ssleep.callable(ctxt));
-                t = c.get(100L, TimeUnit.MILLISECONDS);
+                f = exec.submit(ssleep.callable(ctxt));
+                t = f.get(100L, TimeUnit.MILLISECONDS);
                 Assert.fail("should timeout");
             } catch (TimeoutException xtimeout) {
-                if (c != null) {
-                    c.cancel(true);
+                if (f != null) {
+                    f.cancel(true);
                 }
             }
             Assert.assertNotEquals(42, t);
@@ -351,7 +365,7 @@ public class ScriptCallableTest extends JexlTestCase {
                     }
                 };
                 exec.submit(cancels);
-                t = c.get();
+                t = fc.get();
                 Assert.fail("should be cancelled");
             } catch (CancellationException xexec) {
                 // this is the expected result
@@ -360,12 +374,12 @@ public class ScriptCallableTest extends JexlTestCase {
             // timeout a while(true)
             JexlScript swhile = jexl.createScript("while(true); return 42");
             try {
-                c = exec.submit(swhile.callable(ctxt));
-                t = c.get(100L, TimeUnit.MILLISECONDS);
+                f = exec.submit(swhile.callable(ctxt));
+                t = f.get(100L, TimeUnit.MILLISECONDS);
                 Assert.fail("should timeout");
             } catch (TimeoutException xtimeout) {
-                if (c != null) {
-                    c.cancel(true);
+                if (f != null) {
+                    f.cancel(true);
                 }
             }
             Assert.assertNotEquals(42, t);
@@ -385,7 +399,7 @@ public class ScriptCallableTest extends JexlTestCase {
                     }
                 };
                 exec.submit(cancels);
-                t = c.get();
+                t = fc.get();
                 Assert.fail("should be cancelled");
             } catch (CancellationException xexec) {
                 // this is the expected result
