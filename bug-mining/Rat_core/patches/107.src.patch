diff --git a/apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java b/apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java
index 72ebff4b..a2814e0b 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java
@@ -137,7 +137,7 @@ public class AnalyserFactoryTest {
 
     @Test
     public void missingFileTest() {
-        final Document document = new FileDocument(
+        final Document document = new FileDocument(basedir,
                 new File(Resources.getExampleResource("exampleData"), "not_a_real_file"), DocumentNameMatcher.MATCHES_ALL);
         Defaults defaults = Defaults.builder().build();
         ReportConfiguration config = new ReportConfiguration();
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/ExclusionProcessorTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/ExclusionProcessorTest.java
index f8535a90..85d8d976 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/ExclusionProcessorTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/ExclusionProcessorTest.java
@@ -18,11 +18,14 @@
  */
 package org.apache.rat.config.exclusion;
 
+import java.nio.file.FileSystems;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Stream;
 import org.apache.commons.io.FileUtils;
 import org.apache.rat.document.DocumentNameMatcher;
 import org.apache.rat.document.DocumentName;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 
 import java.io.File;
@@ -31,26 +34,26 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+import org.mockito.Mockito;
 
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Fail.fail;
+import static org.apache.rat.document.FSInfoTest.OSX;
+import static org.apache.rat.document.FSInfoTest.UNIX;
+import static org.apache.rat.document.FSInfoTest.WINDOWS;
 
 public class ExclusionProcessorTest {
 
     final private static DocumentNameMatcher TRUE = DocumentNameMatcher.MATCHES_ALL;
     final private static DocumentNameMatcher FALSE = DocumentNameMatcher.MATCHES_NONE;
-    /** The base directory for the test. */
-    @TempDir
-    private File basedirFile;
-    private DocumentName basedir;
 
-    @BeforeEach
-    public void setup() {
-        basedir = DocumentName.builder(basedirFile).build();
-    }
+    @TempDir
+    private static Path tempDir;
 
-    private void testParseExclusion(DocumentNameMatcher nameMatcher, DocumentName name, boolean expected) {
+    private void testParseExclusion(DocumentName basedir, DocumentNameMatcher nameMatcher, DocumentName name, boolean expected) {
         assertThat(nameMatcher.matches(name)).as(() -> format("Failed on [%s %s]%n%s", basedir, name, dump(nameMatcher, name))).isEqualTo(expected);
     }
 
@@ -60,48 +63,63 @@ public class ExclusionProcessorTest {
         return sb.toString();
     }
 
-    private DocumentName mkName(String pth) {
-        File f = new File(basedirFile, pth);
-        try {
-            FileUtils.cleanDirectory(basedirFile);
-            FileUtils.touch(f);
-        } catch (IOException e) {
-            fail(e);
+    private DocumentName mkName(DocumentName baseDir, String pth) throws IOException {
+        DocumentName result = baseDir.resolve(ExclusionUtils.convertSeparator(pth, "/", baseDir.getDirectorySeparator()));
+        DocumentName mocked = Mockito.spy(result);
+
+        String fn = result.localized(FileSystems.getDefault().getSeparator());
+        File file = tempDir.resolve(fn.substring(1)).toFile();
+        File parent = file.getParentFile();
+        if (parent.exists() && !parent.isDirectory()) {
+            parent.delete();
         }
-        return DocumentName.builder(f).setBaseName(basedir.getBaseName()).build();
+        parent.mkdirs();
+        if (file.exists()) {
+            if (file.isDirectory()) {
+                FileUtils.deleteDirectory(file);
+            } else {
+                FileUtils.delete(file);
+            }
+        }
+        file.createNewFile();
+        Mockito.when(mocked.asFile()).thenReturn(file);
+        return mocked;
     }
 
-    @Test
-    public void defaultTest()  {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void defaultTest(DocumentName basedir) throws IOException {
         ExclusionProcessor p = new ExclusionProcessor();
-        testParseExclusion(p.getNameMatcher(basedir), mkName("hello"), true);
+        testParseExclusion(basedir, p.getNameMatcher(basedir), mkName(basedir, "hello"), true);
     }
 
-    @Test
-    public void addExcludedCollectionTest() {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void addExcludedCollectionTest(DocumentName basedir) throws IOException {
         ExclusionProcessor p = new ExclusionProcessor().addExcludedCollection(StandardCollection.MISC);
         // "**/*~", "**/#*#", "**/.#*", "**/%*%", "**/._*"
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("hello"), true);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("hello~"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("#hello#"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName(".#hello"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("%hello%"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("._hello"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir,"hello"), true);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir,"hello~"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "#hello#"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, ".#hello"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "%hello%"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "._hello"), false);
     }
 
-    @Test
-    public void addExcludedAndIncludedCollectionTest() {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void addExcludedAndIncludedCollectionTest(DocumentName basedir) throws IOException {
         ExclusionProcessor p = new ExclusionProcessor().addExcludedCollection(StandardCollection.MISC)
                 .addIncludedCollection(StandardCollection.HIDDEN_FILE);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("hello"), true);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("hello~"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("#hello#"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName(".#hello"), true);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("%hello%"), false);
-        testParseExclusion(p.getNameMatcher(basedir),  mkName("._hello"), true);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir,"hello"), true);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "hello~"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "#hello#"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, ".#hello"), true);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "%hello%"), false);
+        testParseExclusion(basedir, p.getNameMatcher(basedir),  mkName(basedir, "._hello"), true);
     }
 
-    private void assertExclusions(String pattern, Map<String,Boolean> expectedMap) {
+    private void assertExclusions(DocumentName basedir, String pattern, Map<String,Boolean> expectedMap) throws IOException {
         String[] paths = {"a/b/foo", "b/foo", "foo", "foo/x", "foo/x/y", "b/foo/x",
                 "b/foo/x/y", "a/b/foo/x", "a/b/foo/x/y"};
         ExclusionProcessor p = new ExclusionProcessor().addExcludedPatterns(Collections.singletonList(pattern));
@@ -111,13 +129,13 @@ public class ExclusionProcessorTest {
             if (expected == null) {
                 throw new RuntimeException("Missing expected value for " + pth + " in pattern " + pattern);
             }
-            DocumentName dn = mkName(pth);
-            testParseExclusion(pathMatcher, mkName(pth), expected);
+            testParseExclusion(basedir, pathMatcher, mkName(basedir, pth), expected);
         }
     }
 
-    @Test
-    public void addExcludedPatternsTest() {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void addExcludedPatternsTest(DocumentName basedir) throws IOException {
         Map<String,Boolean> expectedMap = new HashMap<>();
 
         expectedMap.put("a/b/foo", true);
@@ -129,7 +147,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("foo", expectedMap);
+        assertExclusions(basedir, "foo", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", true);
@@ -141,7 +159,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("foo/*", expectedMap);
+        assertExclusions(basedir, "foo/*", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", true);
@@ -153,7 +171,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("foo/**", expectedMap);
+        assertExclusions(basedir, "foo/**", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", true);
@@ -165,7 +183,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("*/foo", expectedMap);
+        assertExclusions(basedir, "*/foo", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", true);
@@ -177,7 +195,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("*/foo/*", expectedMap);
+        assertExclusions(basedir, "*/foo/*", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", true);
@@ -189,7 +207,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", false);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("*/foo/**", expectedMap);
+        assertExclusions(basedir, "*/foo/**", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", false);
@@ -201,7 +219,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", true);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("**/foo", expectedMap);
+        assertExclusions(basedir, "**/foo", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", true);
@@ -213,7 +231,7 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", true);
         expectedMap.put("a/b/foo/x", false);
         expectedMap.put("a/b/foo/x/y",true);
-        assertExclusions("**/foo/*", expectedMap);
+        assertExclusions(basedir, "**/foo/*", expectedMap);
 
         expectedMap.clear();
         expectedMap.put("a/b/foo", false);
@@ -225,11 +243,12 @@ public class ExclusionProcessorTest {
         expectedMap.put("b/foo/x/y", false);
         expectedMap.put("a/b/foo/x", false);
         expectedMap.put("a/b/foo/x/y",false);
-        assertExclusions("**/foo/**", expectedMap);
+        assertExclusions(basedir, "**/foo/**", expectedMap);
     }
 
-    @Test
-    public void orTest() {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void orTest(DocumentName basedir) {
         ExclusionProcessor underTest = new ExclusionProcessor();
         assertThat(DocumentNameMatcher.or(Arrays.asList(TRUE, FALSE)).matches(basedir)).isTrue();
         assertThat(DocumentNameMatcher.or(Arrays.asList(FALSE, TRUE)).matches(basedir)).isTrue();
@@ -237,8 +256,9 @@ public class ExclusionProcessorTest {
         assertThat(DocumentNameMatcher.or(Arrays.asList(FALSE, FALSE)).matches(basedir)).isFalse();
     }
 
-    @Test
-    public void andTest() {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void andTest(DocumentName basedir) {
         ExclusionProcessor underTest = new ExclusionProcessor();
         assertThat(DocumentNameMatcher.and(TRUE, FALSE).matches(basedir)).isFalse();
         assertThat(DocumentNameMatcher.and(FALSE, TRUE).matches(basedir)).isFalse();
@@ -246,10 +266,29 @@ public class ExclusionProcessorTest {
         assertThat(DocumentNameMatcher.and(FALSE, FALSE).matches(basedir)).isFalse();
     }
 
-    @Test
-    public void notTest() {
+    @ParameterizedTest
+    @MethodSource("getDocumentNames")
+    void notTest(DocumentName basedir) {
         ExclusionProcessor underTest = new ExclusionProcessor();
         assertThat(DocumentNameMatcher.not(TRUE).matches(basedir)).isFalse();
         assertThat(DocumentNameMatcher.not(FALSE).matches(basedir)).isTrue();
     }
+
+    private static Stream<Arguments> getDocumentNames() {
+        List<Arguments> lst = new ArrayList<>();
+
+        DocumentName.Builder builder = DocumentName.builder().setName("default");
+        lst.add(Arguments.of(builder.setBaseName(builder.directorySeparator()).build()));
+
+        builder = DocumentName.builder(WINDOWS).setName("windows");
+        lst.add(Arguments.of(builder.setBaseName(builder.directorySeparator()).build()));
+
+        builder = DocumentName.builder(UNIX).setName("unix");
+        lst.add(Arguments.of(builder.setBaseName(builder.directorySeparator()).build()));
+
+        builder = DocumentName.builder(OSX).setName("osx");
+        lst.add(Arguments.of(builder.setBaseName(builder.directorySeparator()).build()));
+
+        return lst.stream();
+    }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/document/guesser/NoteGuesserTest.java b/apache-rat-core/src/test/java/org/apache/rat/document/guesser/NoteGuesserTest.java
index 87d157a0..944f9f65 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/document/guesser/NoteGuesserTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/document/guesser/NoteGuesserTest.java
@@ -22,13 +22,15 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.stream.Stream;
 import org.apache.rat.document.DocumentName;
-import org.apache.rat.document.FSInfoTest;
 import org.apache.rat.testhelpers.TestingDocument;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.apache.rat.document.FSInfoTest.OSX;
+import static org.apache.rat.document.FSInfoTest.UNIX;
+import static org.apache.rat.document.FSInfoTest.WINDOWS;
 
 public class NoteGuesserTest {
 
@@ -42,8 +44,9 @@ public class NoteGuesserTest {
     private static Stream<Arguments> nameData() {
         List<Arguments> lst = new ArrayList<>();
 
-        final DocumentName linuxBaseName = DocumentName.builder(FSInfoTest.UNIX).setName("/").setBaseName("/").build();
-        final DocumentName windowsBaseName = DocumentName.builder(FSInfoTest.WINDOWS).setName("\\").setBaseName("\\").build();
+        final DocumentName osxBaseName = DocumentName.builder(OSX).setName("/").setBaseName("/").build();
+        final DocumentName linuxBaseName = DocumentName.builder(UNIX).setName("/").setBaseName("/").build();
+        final DocumentName windowsBaseName = DocumentName.builder(WINDOWS).setName("\\").setBaseName("\\").build();
 
         lst.add(Arguments.of(linuxBaseName.resolve("DEPENDENCIES"), true));
         lst.add(Arguments.of(linuxBaseName.resolve("LICENSE"), true));
@@ -77,6 +80,22 @@ public class NoteGuesserTest {
         lst.add(Arguments.of(windowsBaseName.resolve("src\\test\\README.txt"), true));
         lst.add(Arguments.of(windowsBaseName.resolve("src\\test\\README.shouldFail"), false));
 
+        lst.add(Arguments.of(osxBaseName.resolve("DEPENDENCIES"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("LICENSE"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("LICENSE.txt"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("NOTICE"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("NOTICE.txt"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("README"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("README.txt"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/DEPENDENCIES"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/LICENSE"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/LICENSE.txt"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/NOTICE"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/NOTICE.txt"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/README"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/README.txt"), true));
+        lst.add(Arguments.of(osxBaseName.resolve("src/test/README.shouldFail"), false));
+
         return lst.stream();
     }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
index 8a34245e..6050cbbd 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
@@ -79,7 +79,7 @@ import static org.assertj.core.api.Fail.fail;
  */
 public abstract class AbstractOptionsProvider implements ArgumentsProvider {
     /**
-     * A map of test Options to tests
+     * A map of test Options to tests.
      */
     protected final Map<String, OptionCollectionTest.OptionTest> testMap = new TreeMap<>();
     /** The list of exclude args */
@@ -116,10 +116,10 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
 
     /**
      * Copies the test data to the specified directory.
-     * @param baseDir the directory to copy the /src/test/resources to.
+     * @param baseDir the directory to copy the {@code /src/test/resources} to.
      * @return the {@code baseDir} argument.
      */
-    public static File setup(File baseDir) {
+    public static File setup(final File baseDir) {
         try {
             final File sourceDir = Resources.getResourceDirectory("OptionTools");
             FileUtils.copyDirectory(sourceDir, new File(baseDir,"/src/test/resources/OptionTools"));
@@ -129,7 +129,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         return baseDir;
     }
 
-    protected AbstractOptionsProvider(Collection<String> unsupportedArgs, File baseDir) {
+    protected AbstractOptionsProvider(final Collection<String> unsupportedArgs, final File baseDir) {
         this.baseDir = setup(baseDir);
         testMap.put("addLicense", this::addLicenseTest);
         testMap.put("config", this::configTest);
@@ -185,7 +185,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         verifyAllMethodsDefinedAndNeeded(unsupportedArgs);
     }
 
-    private void verifyAllMethodsDefinedAndNeeded(Collection<String> unsupportedArgs) {
+    private void verifyAllMethodsDefinedAndNeeded(final Collection<String> unsupportedArgs) {
         // verify all options have functions.
         final List<String> argNames = new ArrayList<>();
         Arg.getOptions().getOptions().forEach(o -> {
@@ -215,22 +215,22 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
     }
 
     @SafeVarargs
-    protected final ReportConfiguration generateConfig(Pair<Option, String[]>... args) throws IOException {
+    protected final ReportConfiguration generateConfig(final Pair<Option, String[]>... args) throws IOException {
         List<Pair<Option, String[]>> options = Arrays.asList(args);
         return generateConfig(options);
     }
 
     /**
      * Create the report configuration from the argument pairs.
-     * There must be at least one arg. It may be `ImmutablePair.nullPair()`.
+     * There must be at least one arg. It may be {@code ImmutablePair.nullPair()}.
      *
      * @param args Pairs comprising the argument option and the values for the option.
      * @return The generated ReportConfiguration.
      * @throws IOException on error.
      */
-    protected abstract ReportConfiguration generateConfig(List<Pair<Option, String[]>> args) throws IOException;
+    protected abstract ReportConfiguration generateConfig(final List<Pair<Option, String[]>> args) throws IOException;
 
-    protected File writeFile(String name, Iterable<String> lines) {
+    protected File writeFile(final String name, final Iterable<String> lines) {
         File file = new File(baseDir, name);
         try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
             lines.forEach(writer::println);
@@ -240,25 +240,31 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         return file;
     }
 
-    protected DocumentName mkDocName(String name) {
+    protected DocumentName mkDocName(final String name) {
         return DocumentName.builder(new File(baseDir, name)).build();
     }
 
-    /* Tests to be implemented */
+    /** Help test */
     protected abstract void helpTest();
 
-    /* Display the option and value under test */
-    private String displayArgAndName(Option option, String fname) {
+    /** Display the option and value under test */
+    private String displayArgAndName(final Option option, final String fname) {
         return String.format("%s %s", option.getLongOpt(), fname);
     }
 
-    private String dump(Option option, String fname, DocumentNameMatcher matcher, DocumentName name) {
+    private String dump(final DocumentNameMatcher nameMatcher, final DocumentName name) {
+        StringBuilder sb = new StringBuilder();
+        nameMatcher.decompose(name).forEach(s -> sb.append(s).append("\n"));
+        return sb.toString();
+    }
+
+    private String dump(final Option option, final String fname, final DocumentNameMatcher matcher, final DocumentName name) {
         return String.format("Argument and Name: %s%nMatcher decomposition:%n%s", displayArgAndName(option, fname),
                 DocumentNameMatcherTest.processDecompose(matcher, name));
     }
 
     // exclude tests
-    private void execExcludeTest(Option option, String[] args) {
+    private void execExcludeTest(final Option option, final String[] args) {
         String[] notExcluded = {"notbaz", "well._afile"};
         String[] excluded = {"some.foo", "B.bar", "justbaz"};
         try {
@@ -277,7 +283,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         }
     }
 
-    private void excludeFileTest(Option option) {
+    private void excludeFileTest(final Option option) {
         File outputFile = writeFile("exclude.txt", Arrays.asList(EXCLUDE_ARGS));
         execExcludeTest(option, new String[]{outputFile.getAbsolutePath()});
     }
@@ -329,7 +335,6 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
                 "**/fish", "*_fish",
                 "# some colorful directories",
                 "red/", "blue/*/"};
-
         String[] notExcluded = {"thingone", "dir/fish_two", "some/thingone", "blue/fish/dory" };
         String[] excluded = {"thingtwo", "some/things", "dir/fish", "red/fish", "blue/fish", "some/fish", "another/red_fish"};
 
@@ -340,16 +345,9 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         dir = new File(dir, "fish");
         dir.mkdirs();
 
-
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
-            for (String fname : notExcluded) {
-                final DocumentName docName = mkDocName(fname);
-                assertThat(excluder.matches(docName))
-                        .as(() -> String.format("option: %s name: %s%n%s", option.getKey(), fname, excluder.decompose(docName)))
-                        .isTrue();
-            }
             for (String fname : excluded) {
                 DocumentName docName = mkDocName(fname);
                 assertThat(excluder.matches(docName)).as(() -> dump(option, fname, excluder, docName)).isFalse();
@@ -390,7 +388,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
     }
 
     // include tests
-    private void execIncludeTest(Option option, String[] args) {
+    private void execIncludeTest(final Option option, final String[] args) {
         Option excludeOption = Arg.EXCLUDE.option();
         String[] notExcluded = {"B.bar", "justbaz", "notbaz"};
         String[] excluded = {"some.foo"};
@@ -398,12 +396,6 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args),
                     ImmutablePair.of(excludeOption, EXCLUDE_ARGS));
             DocumentNameMatcher excluder = config.getDocumentExcluder(baseName());
-            for (String fname : notExcluded) {
-                final DocumentName docName = mkDocName(fname);
-                assertThat(excluder.matches(docName))
-                        .as(() -> String.format("option: %s name: %s%n%s", option.getKey(), fname, excluder.decompose(docName)))
-                        .isTrue();
-            }
             for (String fname : excluded) {
                 DocumentName docName = mkDocName(fname);
                 assertThat(excluder.matches(docName)).as(() -> dump(option, fname, excluder, docName)).isFalse();
@@ -417,7 +409,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         }
     }
 
-    private void includeFileTest(Option option) {
+    private void includeFileTest(final Option option) {
         File outputFile = writeFile("include.txt", Arrays.asList(INCLUDE_ARGS));
         execIncludeTest(option, new String[]{outputFile.getAbsolutePath()});
     }
@@ -472,7 +464,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
     }
 
     // LICENSE tests
-    protected void execLicensesApprovedTest(Option option, String[] args) {
+    protected void execLicensesApprovedTest(final Option option, String[] args) {
         Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
         try {
             ReportConfiguration config = generateConfig(arg1);
@@ -524,7 +516,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
                 new String[]{"one", "two"});
     }
 
-    private void execLicensesDeniedTest(Option option, String[] args) {
+    private void execLicensesDeniedTest(final Option option, final String[] args) {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
             assertThat(config.getLicenseIds(LicenseSetFactory.LicenseFilter.ALL)).contains("ILLUMOS");
@@ -545,7 +537,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
                 new String[]{outputFile.getAbsolutePath()});
     }
 
-    private void execLicenseFamiliesApprovedTest(Option option, String[] args) {
+    private void execLicenseFamiliesApprovedTest(final Option option, final String[] args) {
         String catz = ILicenseFamily.makeCategory("catz");
         Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
         try {
@@ -577,7 +569,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
                 new String[]{"catz"});
     }
 
-    private void execLicenseFamiliesDeniedTest(Option option, String[] args) {
+    private void execLicenseFamiliesDeniedTest(final Option option, final String[] args) {
         String gpl = ILicenseFamily.makeCategory("GPL");
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
@@ -644,7 +636,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         }
     }
 
-    private void configTest(Option option) {
+    private void configTest(final Option option) {
         String[] args = {"src/test/resources/OptionTools/One.xml", "src/test/resources/OptionTools/Two.xml"};
         Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
         try {
@@ -674,7 +666,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         configTest(Arg.CONFIGURATION.find("config"));
     }
 
-    private void noDefaultsTest(Option arg) {
+    private void noDefaultsTest(final Option arg) {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(arg, null));
             assertThat(config.getLicenses(LicenseSetFactory.LicenseFilter.ALL)).isEmpty();
@@ -704,7 +696,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         }
     }
 
-    private void editCopyrightTest(Option option) {
+    private void editCopyrightTest(final Option option) {
         try {
             Pair<Option, String[]> arg1 = ImmutablePair.of(option, new String[]{"MyCopyright"});
             ReportConfiguration config = generateConfig(arg1);
@@ -725,7 +717,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"));
     }
 
-    private void editLicenseTest(Option option) {
+    private void editLicenseTest(final Option option) {
         try {
             ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
             assertThat(config.isAddingLicenses()).isTrue();
@@ -744,7 +736,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         editLicenseTest(Arg.EDIT_ADD.find("edit-license"));
     }
 
-    private void overwriteTest(Option option) {
+    private void overwriteTest(final Option option) {
         Pair<Option, String[]> arg1 = ImmutablePair.of(option, null);
         try {
             ReportConfiguration config = generateConfig(arg1);
@@ -785,7 +777,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         }
     }
 
-    private void archiveTest(Option option) {
+    private void archiveTest(final Option option) {
         String[] args = {null};
         try {
             for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
@@ -802,7 +794,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         archiveTest(Arg.OUTPUT_ARCHIVE.find("output-archive"));
     }
 
-    private void listFamilies(Option option) {
+    private void listFamilies(final Option option) {
         String[] args = {null};
         for (LicenseSetFactory.LicenseFilter filter : LicenseSetFactory.LicenseFilter.values()) {
             try {
@@ -823,7 +815,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         listFamilies(Arg.OUTPUT_FAMILIES.find("output-families"));
     }
 
-    private void outTest(Option option) {
+    private void outTest(final Option option) {
         File outFile = new File(baseDir, "outexample-" + option.getLongOpt());
         String[] args = new String[]{outFile.getAbsolutePath()};
         try {
@@ -851,7 +843,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         outTest(Arg.OUTPUT_FILE.find("output-file"));
     }
 
-    private void listLicenses(Option option) {
+    private void listLicenses(final Option option) {
         String[] args = {null};
         for (LicenseSetFactory.LicenseFilter filter : LicenseSetFactory.LicenseFilter.values()) {
             try {
@@ -872,7 +864,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         listLicenses(Arg.OUTPUT_LICENSES.find("output-licenses"));
     }
 
-    private void standardTest(Option option) {
+    private void standardTest(final Option option) {
         String[] args = {null};
         try {
             for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
@@ -889,7 +881,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         standardTest(Arg.OUTPUT_STANDARD.find("output-standard"));
     }
 
-    private void styleSheetTest(Option option) {
+    private void styleSheetTest(final Option option) {
         // copy the dummy stylesheet so that we have a local file for users of the testing jar.
         File file = new File(baseDir, "stylesheet-" + option.getLongOpt());
         try (
@@ -946,7 +938,7 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
     }
 
     @Override
-    final public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
+    final public Stream<? extends Arguments> provideArguments(final ExtensionContext context) {
         List<Arguments> lst = new ArrayList<>();
         List<String> missingTests = new ArrayList<>();
 
