diff --git a/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DeferrableOutputStream.java b/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DeferrableOutputStream.java
index 6f9c57f1..9925c948 100644
--- a/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DeferrableOutputStream.java
+++ b/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DeferrableOutputStream.java
@@ -87,6 +87,18 @@ public class DeferrableOutputStream extends OutputStream {
          */
         closed
     }
+    /** Interface of a listener object, that wishes to be notified about
+     * state changes.
+     */
+    public interface Listener {
+        /** Called, after {@link #persist()} has been invoked,
+         *   and the temporary file has been created.
+         * @param path Path of the temporary file, that has been
+         *   created. All in-memory data has been transferred to
+         *   that file, but it is still opened.
+         */
+         default void persisted(final Path path) { }
+    }
     /** The configured threshold, as an integer. This variable isn't actually
      * used. Instead {@link #longThreshold} is used.
      * @see #longThreshold
@@ -128,6 +140,12 @@ public class DeferrableOutputStream extends OutputStream {
      * Or, in other words: True, if a temporary file has been created.
      */
     private boolean wasPersisted;
+    /** Number of bytes, that have been written to this stream so far.
+     */
+    private long size;
+    /** The configured {@link Listener}, if any, or null.
+     */
+    private final Listener listener;
 
     /** Creates a new instance with the given threshold, and the given supplier for a
      * temporary files path.
@@ -146,10 +164,12 @@ public class DeferrableOutputStream extends OutputStream {
      * @param pathSupplier A supplier for the temporary files path. This supplier must
      *   not return null. The file's directory will be created, if necessary, by
      *   invoking {@link Files#createDirectories(Path, java.nio.file.attribute.FileAttribute...)}.
+     * @param listener An optional listener, which is being notified about important state
+     *   changes.
      * @throws IOException Creating the temporary file (in the case of threshold -1)
      *   has failed.
      */
-    public DeferrableOutputStream(final int threshold, final Supplier<Path> pathSupplier) throws IOException {
+    public DeferrableOutputStream(final int threshold, final Supplier<Path> pathSupplier, final Listener listener) throws IOException {
         if (threshold < 0) {
             this.threshold = -1;
         } else {
@@ -157,6 +177,7 @@ public class DeferrableOutputStream extends OutputStream {
         }
         longThreshold = (long) threshold;
         this.pathSupplier = pathSupplier;
+        this.listener = listener;
         checkThreshold(0);
     }
 
@@ -238,6 +259,9 @@ public class DeferrableOutputStream extends OutputStream {
         out = os;
         baos = null;
         bytes = null;
+        if (listener != null) {
+            listener.persisted(p);
+        }
         return os;
     }
 
@@ -249,6 +273,7 @@ public class DeferrableOutputStream extends OutputStream {
         }
         bytes = null;
         os.write(b);
+        size++;
     }
 
     @Override
@@ -265,6 +290,7 @@ public class DeferrableOutputStream extends OutputStream {
             }
             bytes = null;
             os.write(buffer, offset, len);
+            size += len;
         }
     }
 
@@ -366,4 +392,11 @@ public class DeferrableOutputStream extends OutputStream {
     private IllegalStateException illegalStateError() {
         throw new IllegalStateException("Expected state initialized|opened|persisted|closed, got " + state.name());
     }
+
+    /** Returns the number of bytes, that have been written to this stream.
+     * @return The number of bytes, that have been written to this stream.
+     */
+    public long getSize() {
+        return size;
+    }
 }
diff --git a/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DiskFileItem.java b/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DiskFileItem.java
index 768c48c6..565becae 100644
--- a/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DiskFileItem.java
+++ b/commons-fileupload2-core/src/main/java/org/apache/commons/fileupload2/core/DiskFileItem.java
@@ -16,10 +16,13 @@
  */
 package org.apache.commons.fileupload2.core;
 
-import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.OutputStream;
+import java.io.Reader;
+import java.io.UncheckedIOException;
+import java.io.UnsupportedEncodingException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.CopyOption;
@@ -30,12 +33,16 @@ import java.nio.file.Paths;
 import java.nio.file.StandardCopyOption;
 import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
 
+import org.apache.commons.fileupload2.core.DeferrableOutputStream.Listener;
+import org.apache.commons.fileupload2.core.DeferrableOutputStream.State;
 import org.apache.commons.fileupload2.core.FileItemFactory.AbstractFileItemBuilder;
 import org.apache.commons.io.Charsets;
+import org.apache.commons.io.FileCleaningTracker;
 import org.apache.commons.io.build.AbstractOrigin;
 import org.apache.commons.io.file.PathUtils;
-import org.apache.commons.io.output.DeferredFileOutputStream;
+
 
 /**
  * The default implementation of the {@link FileItem FileItem} interface.
@@ -103,11 +110,10 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
                     getFileItemHeaders(), getCharset());
             final var tracker = getFileCleaningTracker();
             if (tracker != null) {
-                tracker.track(diskFileItem.getTempFile().toFile(), diskFileItem);
+                diskFileItem.setFileCleaningTracker(tracker);
             }
             return diskFileItem;
         }
-
     }
 
     /**
@@ -206,11 +212,6 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     private final String fileName;
 
-    /**
-     * The size of the item, in bytes. This is used to cache the size when a file item is moved from its original location.
-     */
-    private volatile long size = -1;
-
     /**
      * The threshold above which uploads will be stored on disk.
      */
@@ -221,20 +222,10 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     private final Path repository;
 
-    /**
-     * Cached contents of the file.
-     */
-    private byte[] cachedContent;
-
     /**
      * Output stream for this item.
      */
-    private DeferredFileOutputStream dfos;
-
-    /**
-     * The temporary file to use.
-     */
-    private final Path tempFile;
+    private DeferrableOutputStream dos;
 
     /**
      * The file items headers.
@@ -246,6 +237,11 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     private Charset charsetDefault = DEFAULT_CHARSET;
 
+    /** The {@link FileCleaningTracker}, which is being used to remove
+     * temporary files.
+     */
+    private FileCleaningTracker fileCleaningTracker;
+
     /**
      * Constructs a new {@code DiskFileItem} instance.
      *
@@ -268,7 +264,24 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
         this.fileItemHeaders = fileItemHeaders;
         this.threshold = threshold;
         this.repository = repository != null ? repository : PathUtils.getTempDirectory();
-        this.tempFile = this.repository.resolve(String.format("upload_%s_%s.tmp", UID, getUniqueId()));
+    }
+
+    /** Sets the {@link FileCleaningTracker}, which is being used to remove
+     * temporary files.
+     * @param fileCleaningTracker The {@link FileCleaningTracker}, which is being used to
+     * remove temporary files.
+     */
+    public void setFileCleaningTracker(final FileCleaningTracker fileCleaningTracker) {
+        this.fileCleaningTracker = fileCleaningTracker;
+    }
+
+    /** Returns the {@link FileCleaningTracker}, which is being used to remove
+     * temporary files.
+     * @return The {@link FileCleaningTracker}, which is being used to remove
+     * temporary files.
+     */
+    public FileCleaningTracker getFileCleaningTracker() {
+        return fileCleaningTracker;
     }
 
     /**
@@ -279,10 +292,11 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     @Override
     public DiskFileItem delete() throws IOException {
-        cachedContent = null;
-        final var outputFile = getPath();
-        if (outputFile != null && !isInMemory() && Files.exists(outputFile)) {
-            Files.delete(outputFile);
+        if (dos != null) {
+            final Path path = dos.getPath();
+            if (path != null) {
+                Files.deleteIfExists(path);
+            }
         }
         return this;
     }
@@ -294,17 +308,23 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      * @return The contents of the file as an array of bytes or {@code null} if the data cannot be read.
      * @throws IOException if an I/O error occurs.
      * @throws OutOfMemoryError     See {@link Files#readAllBytes(Path)}: If an array of the required size cannot be allocated, for example the file is larger
-     *                              that {@code 2GB}
+     *                              than {@code 2GB}. If so, you should use {@link #getInputStream()}.
+     * @see #getInputStream()
+     * @deprecated Since 2.0.0, use {@link #getInputStream()}, or {@link #getReader()}, instead.
      */
     @Override
     public byte[] get() throws IOException {
-        if (isInMemory()) {
-            if (cachedContent == null && dfos != null) {
-                cachedContent = dfos.getData();
+        if (dos != null) {
+            final byte[] bytes = dos.getBytes();
+            if (bytes != null) {
+                return bytes;
+            }
+            final Path path = dos.getPath();
+            if (path != null  &&  dos.getState() == State.closed) {
+                return Files.readAllBytes(path);
             }
-            return cachedContent != null ? cachedContent.clone() : new byte[0];
         }
-        return Files.readAllBytes(dfos.getFile().toPath());
+        return null;
     }
 
     /**
@@ -368,14 +388,10 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     @Override
     public InputStream getInputStream() throws IOException {
-        if (!isInMemory()) {
-            return Files.newInputStream(dfos.getFile().toPath());
-        }
-
-        if (cachedContent == null) {
-            cachedContent = dfos.getData();
+        if (dos != null  &&  dos.getState() == State.closed) {
+            return dos.getInputStream();
         }
-        return new ByteArrayInputStream(cachedContent);
+        throw new IllegalStateException("The file item has not been fully read.");
     }
 
     /**
@@ -397,10 +413,27 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     @Override
     public OutputStream getOutputStream() {
-        if (dfos == null) {
-            dfos = DeferredFileOutputStream.builder().setThreshold(threshold).setOutputFile(getTempFile().toFile()).get();
+        if (dos == null) {
+            final Supplier<Path> pathSupplier =
+                    () -> this.repository.resolve(String.format("upload_%s_%s.tmp", UID, getUniqueId()));
+            try {
+                final Listener persistenceListener = new Listener() {
+                    @Override
+                    public void persisted(final Path pPath) {
+                        // TODO Auto-generated method stub
+                        Listener.super.persisted(pPath);
+                        final FileCleaningTracker fct = getFileCleaningTracker();
+                        if (fct != null) {
+                            fct.track(getPath(), this);
+                        }
+                        }
+                };
+                dos = new DeferrableOutputStream(threshold, pathSupplier, persistenceListener);
+            } catch (final IOException ioe) {
+                throw new UncheckedIOException(ioe);
+            }
         }
-        return dfos;
+        return dos;
     }
 
     /**
@@ -411,13 +444,10 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      * @return The data file, or {@code null} if the data is stored in memory.
      */
     public Path getPath() {
-        if (dfos == null) {
-            return null;
+        if (dos != null) {
+            return dos.getPath();
         }
-        if (isInMemory()) {
-            return null;
-        }
-        return dfos.getFile().toPath();
+        return null;
     }
 
     /**
@@ -427,27 +457,50 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     @Override
     public long getSize() {
-        if (size >= 0) {
-            return size;
-        }
-        if (cachedContent != null) {
-            return cachedContent.length;
+        if (dos != null) {
+            return dos.getSize();
         }
-        return dfos != null ? dfos.getByteCount() : 0;
+        return 0L;
     }
 
     /**
      * Gets the contents of the file as a String, using the default character encoding. This method uses {@link #get()} to retrieve the contents of the file.
-     * <p>
-     * <strong>TODO</strong> Consider making this method throw UnsupportedEncodingException.
-     * </p>
      *
-     * @return The contents of the file, as a string.
+     * @return The contents of the file, as a string, if available, or null.
      * @throws IOException if an I/O error occurs
+     * @throws OutOfMemoryError See {@link Files#readAllBytes(Path)}: If a string of the required size cannot be allocated,
+     *   for example the file is larger than {@code 2GB}. If so, you should use {@link #getReader()}.
+     * @throws UnsupportedEncodingException The chararacter set, which is
+     *   specified in the files "content-type" header, is invalid.
+     * @deprecated Since 2.0.0, use {@link #getReader()} instead.
      */
     @Override
-    public String getString() throws IOException {
-        return new String(get(), getCharset());
+    public String getString() throws IOException, UnsupportedEncodingException, OutOfMemoryError {
+        final byte[] bytes = get();
+        if (bytes == null) {
+            return null;
+        }
+        return new String(bytes, getCharset());
+    }
+
+    /** Returns the contents of the file as a {@link Reader}, using the specified
+     * {@link #getCharset()}. If the contents are not yet available, returns null.
+     * This is the case, for example, if the underlying output stream has not yet
+     * been closed.
+     * @return The contents of the file as a {@link Reader}
+     * @throws UnsupportedEncodingException The chararacter set, which is
+     *   specified in the files "content-type" header, is invalid.
+     * @throws IOException An I/O error occurred, while the
+     *   underlying {@link #getInputStream() input stream} was created.
+     */
+    public Reader getReader() throws IOException, UnsupportedEncodingException {
+        final InputStream is = getInputStream();
+        final var parser = new ParameterParser();
+        parser.setLowerCaseNames(true);
+        // Parameter parser can handle null input
+        final var params = parser.parse(getContentType(), ';');
+        final Charset cs = Charsets.toCharset(params.get("charset"), charsetDefault);
+        return new InputStreamReader(is, cs);
     }
 
     /**
@@ -472,7 +525,10 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      * @return The {@link java.io.File File} to be used for temporary storage.
      */
     protected Path getTempFile() {
-        return tempFile;
+        if (dos != null) {
+            return dos.getPath();
+        }
+        return null;
     }
 
     /**
@@ -493,10 +549,10 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
      */
     @Override
     public boolean isInMemory() {
-        if (cachedContent != null) {
-            return true;
+        if (dos != null) {
+            return dos.isInMemory();
         }
-        return dfos.isInMemory();
+        return true;
     }
 
     /**
@@ -590,8 +646,6 @@ public final class DiskFileItem implements FileItem<DiskFileItem> {
                  */
                 throw new FileUploadException("Cannot write uploaded file to disk.");
             }
-            // Save the length of the file
-            size = Files.size(outputFile);
             //
             // The uploaded file is being stored on disk in a temporary location so move it to the desired file.
             //
diff --git a/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DeferrableOutputStreamTest.java b/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DeferrableOutputStreamTest.java
index 60a0e83e..7b94a86b 100644
--- a/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DeferrableOutputStreamTest.java
+++ b/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DeferrableOutputStreamTest.java
@@ -61,7 +61,7 @@ class DeferrableOutputStreamTest {
 	void testExceedPositiveThreshold() {
 		DeferrableOutputStream[] streams = new DeferrableOutputStream[1];
 		final Consumer<Consumer<OutputStream>> tester = (consumer) -> {
-			try (final DeferrableOutputStream dos = new DeferrableOutputStream(5, testFileSupplier)) {
+			try (final DeferrableOutputStream dos = new DeferrableOutputStream(5, testFileSupplier, null)) {
 				streams[0] = dos;
 				assertTrue(dos.isInMemory());
 				assertNull(dos.getPath());
@@ -134,7 +134,7 @@ class DeferrableOutputStreamTest {
 	void testThresholdZero() {
 		DeferrableOutputStream[] streams = new DeferrableOutputStream[1];
 		final Consumer<Consumer<OutputStream>> tester = (consumer) -> {
-			try (final DeferrableOutputStream dos = new DeferrableOutputStream(0, testFileSupplier)) {
+			try (final DeferrableOutputStream dos = new DeferrableOutputStream(0, testFileSupplier, null)) {
 				streams[0] = dos;
 				assertTrue(dos.isInMemory());
 				assertNull(dos.getPath());
@@ -195,7 +195,7 @@ class DeferrableOutputStreamTest {
 	void testThresholdMinusOne() {
 		DeferrableOutputStream[] streams = new DeferrableOutputStream[1];
 		final Runnable tester = () -> {
-			try (final DeferrableOutputStream dos = new DeferrableOutputStream(-1, testFileSupplier)) {
+			try (final DeferrableOutputStream dos = new DeferrableOutputStream(-1, testFileSupplier, null)) {
 				streams[0] = dos;
 				assertFalse(dos.isInMemory());
 				assertNotNull(dos.getPath());
diff --git a/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DiskFileItemSerializeTest.java b/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DiskFileItemSerializeTest.java
index fa5687e3..76ccdf92 100644
--- a/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DiskFileItemSerializeTest.java
+++ b/commons-fileupload2-core/src/test/java/org/apache/commons/fileupload2/core/DiskFileItemSerializeTest.java
@@ -89,18 +89,19 @@ class DiskFileItemSerializeTest {
     /**
      * Create a FileItem with the specfied content bytes.
      */
-    private DiskFileItem createFileItem(final byte[] contentBytes) throws IOException {
-        return createFileItem(contentBytes, REPOSITORY);
+    private DiskFileItem createFileItem(final byte[] contentBytes, int threshold) throws IOException {
+        return createFileItem(contentBytes, REPOSITORY, threshold);
     }
 
     /**
      * Create a FileItem with the specfied content bytes and repository.
      */
-    private DiskFileItem createFileItem(final byte[] contentBytes, final Path repository) throws IOException {
+    private DiskFileItem createFileItem(final byte[] contentBytes, final Path repository, int threshold) throws IOException {
         // @formatter:off
         final FileItemFactory<DiskFileItem> factory = DiskFileItemFactory.builder()
                 .setBufferSize(THRESHOLD)
                 .setPath(repository)
+                .setBufferSize(threshold)
                 .get();
         // @formatter:on
         // @formatter:off
@@ -170,7 +171,7 @@ class DiskFileItemSerializeTest {
     void testAboveThreshold() throws IOException {
         // Create the FileItem
         final var testFieldValueBytes = createContentBytes(THRESHOLD + 1);
-        final var item = createFileItem(testFieldValueBytes);
+        final var item = createFileItem(testFieldValueBytes, THRESHOLD);
 
         // Check state is as expected
         assertFalse(item.isInMemory(), "Initial: in memory");
@@ -189,8 +190,8 @@ class DiskFileItemSerializeTest {
     @Test
     void testBelowThreshold() throws IOException {
         // Create the FileItem
-        final var testFieldValueBytes = createContentBytes(THRESHOLD - 1);
-        testInMemoryObject(testFieldValueBytes);
+        final var testFieldValueBytes = createContentBytes(THRESHOLD-1);
+        testInMemoryObject(testFieldValueBytes, THRESHOLD);
     }
 
     @Test
@@ -201,20 +202,19 @@ class DiskFileItemSerializeTest {
     /**
      * Helper method to test creation of a field.
      */
-    private void testInMemoryObject(final byte[] testFieldValueBytes) throws IOException {
-        testInMemoryObject(testFieldValueBytes, REPOSITORY);
+    private void testInMemoryObject(final byte[] testFieldValueBytes, int threshold) throws IOException {
+        testInMemoryObject(testFieldValueBytes, REPOSITORY, threshold);
     }
 
     /**
      * Helper method to test creation of a field when a repository is used.
      */
-    private void testInMemoryObject(final byte[] testFieldValueBytes, final Path repository) throws IOException {
-        final var item = createFileItem(testFieldValueBytes, repository);
+    private void testInMemoryObject(final byte[] testFieldValueBytes, final Path repository, int threshold) throws IOException {
+        final var item = createFileItem(testFieldValueBytes, repository, threshold);
 
-        // Check state is as expected
-        assertTrue(item.isInMemory(), "Initial: in memory");
+        // Check state is as expectedthreshold >= testFieldValueBytes.length, item.isInMemory(), "Initial: in memory");
         assertEquals(item.getSize(), testFieldValueBytes.length, "Initial: size");
-        compareBytes("Initial", item.get(), testFieldValueBytes);
+        compareBytes("Inititem.getSize(), testFieldValueBytes.lengthial", item.get(), testFieldValueBytes);
         testWritingToFile(item, testFieldValueBytes);
         item.delete();
     }
@@ -229,7 +229,7 @@ class DiskFileItemSerializeTest {
         // Create the FileItem
         final var testFieldValueBytes = createContentBytes(THRESHOLD);
         final var repository = PathUtils.getTempDirectory().resolve("file");
-        final var item = createFileItem(testFieldValueBytes, repository);
+        final var item = createFileItem(testFieldValueBytes, repository, THRESHOLD);
         assertThrows(IOException.class, () -> deserialize(serialize(item)));
     }
 
@@ -242,7 +242,7 @@ class DiskFileItemSerializeTest {
     void testThreshold() throws IOException {
         // Create the FileItem
         final var testFieldValueBytes = createContentBytes(THRESHOLD);
-        testInMemoryObject(testFieldValueBytes);
+        testInMemoryObject(testFieldValueBytes, THRESHOLD);
     }
 
     /**
@@ -254,7 +254,7 @@ class DiskFileItemSerializeTest {
     void testValidRepository() throws IOException {
         // Create the FileItem
         final var testFieldValueBytes = createContentBytes(THRESHOLD);
-        testInMemoryObject(testFieldValueBytes, REPOSITORY);
+        testInMemoryObject(testFieldValueBytes, REPOSITORY, THRESHOLD+1);
     }
 
     /**
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index b178f322..a250f0c5 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -44,6 +44,7 @@ The <action> type attribute can be add,update,fix,remove.
     <release version="2.0.0-M5" date="YYYY-MM-DD" description="This release requires Java 11.">
       <!-- FIX -->
       <action                        type="fix" dev="ggregory" due-to="Chenjp, Gary Gregory">Better exception message in org.apache.commons.fileupload2.core.AbstractFileUpload.parseRequest(RequestContext).</action>
+      <action issue="FILEUPLOAD-295" type="fix" dev="jochen">Clarified the precise meaning of isInMemory(), get(), getPath(), etc. in DiskFileItem</action>
       <!-- ADD -->
       <!-- UPDATE -->
       <action type="update" dev="ggregory" due-to="Gary Gregory">Bump org.apache.commons:commons-parent from 84 to 85.</action>
