diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index b4d86c19..4f11666d 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -24,6 +24,11 @@
     <release version="2.8.0" date="2020-MM-DD"
              description="Minor release with new features and updated dependencies.">
        <!-- FIX -->
+       <action issue="CONFIGURATION-753" type="fix" dev="mattjuntunen">
+         Make interpolation of collections and arrays in ConfigurationInterpolator consistent with
+         behavior of DefaultConversionHandler. Add ConfigurationInterpolator.setStringConverter to
+         allow customized string conversion behavior.
+       </action>
        <action issue="CONFIGURATION-795" type="fix" dev="ggregory" due-to="dpeger">
          Computation of blank lines after header comment #82.
        </action>
diff --git a/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java b/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java
index 1eccbed8..4f610bba 100644
--- a/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java
+++ b/src/main/java/org/apache/commons/configuration2/interpol/ConfigurationInterpolator.java
@@ -16,16 +16,19 @@
  */
 package org.apache.commons.configuration2.interpol;
 
+import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Function;
 
 import org.apache.commons.text.StringSubstitutor;
 import org.apache.commons.text.lookup.DefaultStringLookup;
@@ -65,9 +68,22 @@ import org.apache.commons.text.lookup.DefaultStringLookup;
  * result is the passed in value with variables replaced. Alternatively, the {@code resolve()} method can be called to
  * obtain the values of specific variables without performing interpolation.
  * </p>
+ * <p><strong>String Conversion</strong></p>
  * <p>
- * Implementation node: This class is thread-safe. Lookup objects can be added or removed at any time concurrent to
- * interpolation operations.
+ * When variables are part of larger interpolated strings, the variable values, which can be of any type, must be
+ * converted to strings to produce the full result. Each interpolator instance has a configurable
+ * {@link #setStringConverter() string converter} to perform this conversion. The default implementation of this
+ * function simply uses the value's {@code toString} method in the majority of cases. However, for maximum
+ * consistency with
+ * {@link org.apache.commons.configuration3convert.DefaultConversionHandler DefaultConversionHandler}, when a variable
+ * value is a container type (such as a collection or array), then only the first element of the container is converted
+ * to a string instead of the container itself. For example, if the variable {@code x} resolves to the integer array
+ * {@code [1, 2, 3]}, then the string <code>"my value = ${x}"</code> will by default be interpolated to
+ * {@code "my value = 1"}.
+ * </p>
+ * <p>
+ * <strong>Implementation note:</strong> This class is thread-safe. Lookup objects can be added or removed at any time
+ * concurrent to interpolation operations.
  * </p>
  *
  * @since 1.4
@@ -117,6 +133,9 @@ public class ConfigurationInterpolator {
     /** Stores a parent interpolator objects if the interpolator is nested hierarchically. */
     private volatile ConfigurationInterpolator parentInterpolator;
 
+    /** Function used to convert interpolated values to strings. */
+    private volatile Function<Object, String> stringConverter = DefaultStringConverter.INSTANCE;
+
     /**
      * Creates a new instance of {@code ConfigurationInterpolator}.
      */
@@ -137,6 +156,7 @@ public class ConfigurationInterpolator {
         ci.addDefaultLookups(spec.getDefaultLookups());
         ci.registerLookups(spec.getPrefixLookups());
         ci.setParentInterpolator(spec.getParentInterpolator());
+        ci.setStringConverter(spec.getStringConverter());
         return ci;
     }
 
@@ -281,13 +301,34 @@ public class ConfigurationInterpolator {
      * @return the {@code StringSubstitutor} used by this object
      */
     private StringSubstitutor initSubstitutor() {
-        return new StringSubstitutor(key -> Objects.toString(resolve(key), null));
+        return new StringSubstitutor(key -> {
+            final Object value = resolve(key);
+            return value != null
+                ? stringConverter.apply(value)
+                : null;
+        });
     }
 
     /**
-     * Performs interpolation of the passed in value. If the value is of type String, this method checks whether it contains
-     * variables. If so, all variables are replaced by their current values (if possible). For non string arguments, the
-     * value is returned without changes.
+     * Performs interpolation of the passed in value. If the value is of type {@code String}, this method checks
+     * whether it contains variables. If so, all variables are replaced by their current values (if possible). For
+     * non string arguments, the value is returned without changes. In the special case where the value is a string
+     * consisting of a single variable reference, the interpolated variable value is <em>not</em> converted to a
+     * string before returning, so that callers can access the raw value. However, if the variable is part of a larger
+     * interpolated string, then the variable value is converted to a string using the configured
+     * {@link #getStringConverter() string converter}. (See the discussion on string conversion in the class
+     * documentation for more details.)
+     *
+     * <p><strong>Examples</strong></p>
+     * <p>
+     * For the following examples, assume that the default string conversion function is in place and that the
+     * variable {@code i} maps to the integer value {@code 42}.
+     * <pre>
+     *      interpolator.interpolate(1) &rarr; 1 // non-string argument returned unchanged
+     *      interpolator.interpolate("${i}") &rarr; 42 // single variable value returned with raw type
+     *      interpolator.interpolate("answer = ${i}") &rarr; "answer = 42" // variable value converted to string
+     * </pre>
+     * </p>
      *
      * @param value the value to be interpolated
      * @return the interpolated value
@@ -320,6 +361,24 @@ public class ConfigurationInterpolator {
         return substitutor.isEnableSubstitutionInVariables();
     }
 
+    /** Get the function used to convert interpolated values to strings.
+     * @return function used to convert interpolated values to strings
+     */
+    public Function<Object, String> getStringConverter() {
+        return stringConverter;
+    }
+
+    /** Set the function used to convert interpolated values to strings. Pass
+     * {@code null} to use the default conversion function.
+     * @param stringConverter function used to convert interpolated values to strings
+     *      or {@code null} to use the default conversion function
+     */
+    public void setStringConverter(final Function<Object, String> stringConverter) {
+        this.stringConverter = stringConverter != null
+                ? stringConverter
+                : DefaultStringConverter.INSTANCE;
+    }
+
     /**
      * Checks whether a value to be interpolated seems to be a single variable. In this case, it is resolved directly
      * without using the {@code StringSubstitutor}. Note that it is okay if this method returns a false positive: In this
@@ -452,4 +511,51 @@ public class ConfigurationInterpolator {
     public void setParentInterpolator(final ConfigurationInterpolator parentInterpolator) {
         this.parentInterpolator = parentInterpolator;
     }
+
+    /** Class encapsulating the default logic to convert resolved variable values into strings.
+     * This class is thread-safe.
+     */
+    private static final class DefaultStringConverter implements Function<Object, String> {
+
+        /** Shared instance. */
+        static final DefaultStringConverter INSTANCE = new DefaultStringConverter();
+
+        /** {@inheritDoc} */
+        @Override
+        public String apply(final Object obj) {
+            return Objects.toString(extractSimpleValue(obj), null);
+        }
+
+        /** Attempt to extract a simple value from {@code obj} for use in string conversion.
+         * If the input represents a collection of some sort (e.g., an iterable or array),
+         * the first item from the collection is returned.
+         * @param obj input object
+         * @return extracted simple object
+         */
+        private Object extractSimpleValue(final Object obj) {
+            if (!(obj instanceof String)) {
+                if (obj instanceof Iterable) {
+                   return nextOrNull(((Iterable<?>) obj).iterator());
+                } else if (obj instanceof Iterator) {
+                    return nextOrNull((Iterator<?>) obj);
+                } else if (obj.getClass().isArray()) {
+                    return Array.getLength(obj) > 0
+                            ? Array.get(obj, 0)
+                            : null;
+                }
+            }
+            return obj;
+        }
+
+        /** Return the next value from {@code it} or {@code null} if no values remain.
+         * @param <T> iterated type
+         * @param it iterator
+         * @return next value from {@code it} or {@code null} if no values remain
+         */
+        private <T> T nextOrNull(final Iterator<T> it) {
+            return it.hasNext()
+                    ? it.next()
+                    : null;
+        }
+    }
 }
diff --git a/src/main/java/org/apache/commons/configuration2/interpol/InterpolatorSpecification.java b/src/main/java/org/apache/commons/configuration2/interpol/InterpolatorSpecification.java
index 4b4daf3e..58a2c140 100644
--- a/src/main/java/org/apache/commons/configuration2/interpol/InterpolatorSpecification.java
+++ b/src/main/java/org/apache/commons/configuration2/interpol/InterpolatorSpecification.java
@@ -22,6 +22,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.Map;
+import java.util.function.Function;
 
 /**
  * <p>
@@ -37,6 +38,7 @@ import java.util.Map;
  * <li>a map with {@code Lookup} objects associated with a specific prefix</li>
  * <li>a collection with default {@code Lookup} objects (without a prefix)</li>
  * <li>a parent {@code ConfigurationInterpolator}</li>
+ * <li>a function used to convert interpolated values into strings</li>
  * </ul>
  * <p>
  * When setting up a configuration it is possible to define the {@code ConfigurationInterpolator} in terms of this
@@ -62,6 +64,9 @@ public final class InterpolatorSpecification {
     /** The collection with default lookups. */
     private final Collection<Lookup> defaultLookups;
 
+    /** Function used to convert interpolated values to strings. */
+    private final Function<Object, String> stringConverter;
+
     /**
      * Creates a new instance of {@code InterpolatorSpecification} with the properties defined by the given builder object.
      *
@@ -72,6 +77,7 @@ public final class InterpolatorSpecification {
         parentInterpolator = builder.parentInterpolator;
         prefixLookups = Collections.unmodifiableMap(new HashMap<>(builder.prefixLookups));
         defaultLookups = Collections.unmodifiableCollection(new ArrayList<>(builder.defLookups));
+        stringConverter = builder.stringConverter;
     }
 
     /**
@@ -111,6 +117,17 @@ public final class InterpolatorSpecification {
         return defaultLookups;
     }
 
+    /**
+     * Returns the function used to convert interpolated values to strings or {@code null}
+     * if the default conversion function is to be used.
+     *
+     * @return function used to convert interpolated values to strings or {@code null} if
+     *      the default conversion function is to be used
+     */
+    public Function<Object, String> getStringConverter() {
+        return stringConverter;
+    }
+
     /**
      * <p>
      * A <em>builder</em> class for creating instances of {@code InterpolatorSpecification}.
@@ -133,6 +150,9 @@ public final class InterpolatorSpecification {
         /** The parent {@code ConfigurationInterpolator}. */
         private ConfigurationInterpolator parentInterpolator;
 
+        /** Function used to convert interpolated values to strings. */
+        private Function<Object, String> stringConverter;
+
         public Builder() {
             prefixLookups = new HashMap<>();
             defLookups = new LinkedList<>();
@@ -226,6 +246,20 @@ public final class InterpolatorSpecification {
             return this;
         }
 
+        /**
+         * Sets the function used to convert interpolated values to strings. Pass {@code null}
+         * if the default conversion function is to be used.
+         *
+         * @param fn function used to convert interpolated values to string or {@code null} if the
+         *      default conversion function is to be used
+         * @return a reference to this builder for method chaining
+         */
+        public Builder withStringConverter(final Function<Object, String> fn) {
+            this.stringConverter = fn;
+            return this;
+        }
+
+
         /**
          * Creates a new {@code InterpolatorSpecification} instance with the properties set so far. After that this builder
          * instance is reset so that it can be reused for creating further specification objects.
@@ -247,6 +281,7 @@ public final class InterpolatorSpecification {
             parentInterpolator = null;
             prefixLookups.clear();
             defLookups.clear();
+            stringConverter = null;
         }
 
         /**
diff --git a/src/test/java/org/apache/commons/configuration2/TestAbstractConfigurationBasicFeatures.java b/src/test/java/org/apache/commons/configuration2/TestAbstractConfigurationBasicFeatures.java
index 67d051a5..e8ec835b 100644
--- a/src/test/java/org/apache/commons/configuration2/TestAbstractConfigurationBasicFeatures.java
+++ b/src/test/java/org/apache/commons/configuration2/TestAbstractConfigurationBasicFeatures.java
@@ -200,7 +200,7 @@ public class TestAbstractConfigurationBasicFeatures {
         final BaseConfiguration config = new BaseConfiguration();
         config.addProperty(KEY_PREFIX, value);
         final String[] array = config.getStringArray(KEY_PREFIX);
-        assertEquals("Weong number of elements", 1, array.length);
+        assertEquals("Wrong number of elements", 1, array.length);
         assertEquals("Wrong value", value.toString(), array[0]);
     }
 
@@ -858,6 +858,21 @@ public class TestAbstractConfigurationBasicFeatures {
         assertEquals("Wrong interpolation", "The quick brown fox jumps over the lazy dog.", config.getString(KEY_PREFIX));
     }
 
+    /**
+     * Tests that variables with list values in interpolated string are resolved with the first element
+     * in the list.
+     */
+    @Test
+    public void testInterpolateStringWithListVariable() {
+        final PropertiesConfiguration config = new PropertiesConfiguration();
+        final List<String> values = Arrays.asList("some", "test", "values");
+        final String keyList = "testList";
+        config.addProperty(keyList, values);
+        config.addProperty(KEY_PREFIX, "result = ${" + keyList + "}");
+
+        assertEquals("Wrong interpolation", "result = some", config.getString(KEY_PREFIX));
+    }
+
     /**
      * Tests interpolate() if the configuration does not have a {@code ConfigurationInterpolator}.
      */
diff --git a/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java b/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java
index 64026590..322a59a6 100644
--- a/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java
+++ b/src/test/java/org/apache/commons/configuration2/interpol/TestConfigurationInterpolator.java
@@ -18,16 +18,21 @@ package org.apache.commons.configuration2.interpol;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
+import java.util.function.Function;
 
 import org.easymock.EasyMock;
 import org.junit.Before;
@@ -162,14 +167,20 @@ public class TestConfigurationInterpolator {
         final Lookup defLookup = EasyMock.createMock(Lookup.class);
         final Lookup preLookup = EasyMock.createMock(Lookup.class);
         EasyMock.replay(defLookup, preLookup);
-        final InterpolatorSpecification spec = new InterpolatorSpecification.Builder().withDefaultLookup(defLookup).withPrefixLookup("p", preLookup)
-            .withParentInterpolator(interpolator).create();
+        final Function<Object, String> stringConverter = obj -> Objects.toString(obj, null);
+        final InterpolatorSpecification spec = new InterpolatorSpecification.Builder()
+            .withDefaultLookup(defLookup)
+            .withPrefixLookup("p", preLookup)
+            .withParentInterpolator(interpolator)
+            .withStringConverter(stringConverter)
+            .create();
         final ConfigurationInterpolator ci = ConfigurationInterpolator.fromSpecification(spec);
         assertEquals("Wrong number of default lookups", 1, ci.getDefaultLookups().size());
         assertTrue("Wrong default lookup", ci.getDefaultLookups().contains(defLookup));
         assertEquals("Wrong number of prefix lookups", 1, ci.getLookups().size());
         assertSame("Wrong prefix lookup", preLookup, ci.getLookups().get("p"));
         assertSame("Wrong parent", interpolator, ci.getParentInterpolator());
+        assertSame("Wrong string converter", stringConverter, ci.getStringConverter());
     }
 
     /**
@@ -221,13 +232,43 @@ public class TestConfigurationInterpolator {
     }
 
     /**
-     * Tests creating an instance. Does it contain some predefined lookups?
+     * Tests that a custom string converter can be used.
+     */
+    @Test
+    public void testSetStringConverter() {
+        final Function<Object, String> stringConverter = obj -> "'" + obj + "'";
+        interpolator.addDefaultLookup(setUpTestLookup("x", Arrays.asList(1, 2)));
+        interpolator.addDefaultLookup(setUpTestLookup("y", "abc"));
+        interpolator.setStringConverter(stringConverter);
+        assertSame("Wrong string converter", stringConverter, interpolator.getStringConverter());
+        assertEquals("Wrong value", "'abc': '[1, 2]'", interpolator.interpolate("${y}: ${x}"));
+    }
+
+    /**
+     * Tests that the default string converter can be reapplied by passing {@code null}.
+     */
+    @Test
+    public void testSetStringConverterNullArgumentUsesDefault() {
+        final Function<Object, String> stringConverter = obj -> "'" + obj + "'";
+        interpolator.addDefaultLookup(setUpTestLookup("x", Arrays.asList(1, 2)));
+        interpolator.addDefaultLookup(setUpTestLookup("y", "abc"));
+        interpolator.setStringConverter(stringConverter);
+        interpolator.setStringConverter(null);
+        assertNotSame("Wrong string converter", stringConverter, interpolator.getStringConverter());
+        assertEquals("Wrong value", "abc: 1", interpolator.interpolate("${y}: ${x}"));
+    }
+
+    /**
+     * Tests creating an instance. Does it contain some predefined lookups and a default string converter?
      */
     @Test
     public void testInit() {
         assertTrue("A default lookup is set", interpolator.getDefaultLookups().isEmpty());
         assertTrue("Got predefined lookups", interpolator.getLookups().isEmpty());
         assertNull("Got a parent interpolator", interpolator.getParentInterpolator());
+        assertNotNull("Missing string converter", interpolator.getStringConverter());
+        assertEquals("Incorrect string converter value", "1",
+                interpolator.getStringConverter().apply(Arrays.asList(1, 2)));
     }
 
     /**
@@ -239,6 +280,15 @@ public class TestConfigurationInterpolator {
         assertEquals("Wrong result", value, interpolator.interpolate(value));
     }
 
+    /**
+     * Tests that a blank variable definition does not cause problems.
+     */
+    @Test
+    public void testInterpolateBlankVariable() {
+        final String value = "${ }";
+        assertEquals("Wrong result", value, interpolator.interpolate(value));
+    }
+
     /**
      * Tests interpolation of a non string argument.
      */
@@ -248,6 +298,24 @@ public class TestConfigurationInterpolator {
         assertSame("Value was changed", value, interpolator.interpolate(value));
     }
 
+    /**
+     * Tests interpolation of a collection argument.
+     */
+    @Test
+    public void testInterpolateCollection() {
+        final List<Integer> value = Arrays.asList(1, 2);
+        assertSame("Value was changed", value, interpolator.interpolate(value));
+    }
+
+    /**
+     * Tests interpolation of an array argument.
+     */
+    @Test
+    public void testInterpolateArray() {
+        final int[] value = {1, 2};
+        assertSame("Value was changed", value, interpolator.interpolate(value));
+    }
+
     /**
      * Tests a successful interpolation of a string value.
      */
@@ -278,6 +346,55 @@ public class TestConfigurationInterpolator {
         assertEquals("Wrong result", "The quick brown fox jumps over the lazy dog.", interpolator.interpolate(value));
     }
 
+    /**
+     * Tests interpolation with variables containing multiple simple non-string variables.
+     */
+    @Test
+    public void testInterpolationMultipleSimpleNonStringVariables() {
+        final String value = "${x} = ${y} is ${result}";
+        interpolator.addDefaultLookup(setUpTestLookup("x", 1));
+        interpolator.addDefaultLookup(setUpTestLookup("y", 2));
+        interpolator.addDefaultLookup(setUpTestLookup("result", false));
+        assertEquals("Wrong result", "1 = 2 is false", interpolator.interpolate(value));
+    }
+
+    /**
+     * Tests interpolation with multiple variables containing collections and iterators.
+     */
+    @Test
+    public void testInterpolationMultipleCollectionVariables() {
+        final String value = "${single}bc${multi}23${empty}${null}${multiIt}${emptyIt}${nullIt}";
+        final List<Integer> multi = Arrays.asList(1, 0, 0);
+        final List<String> single = Arrays.asList("a");
+        final List<Object> empty = Collections.emptyList();
+        final List<Object> containsNull = Arrays.asList((Object) null);
+        interpolator.addDefaultLookup(setUpTestLookup("multi", multi));
+        interpolator.addDefaultLookup(setUpTestLookup("multiIt", multi.iterator()));
+        interpolator.addDefaultLookup(setUpTestLookup("single", single));
+        interpolator.addDefaultLookup(setUpTestLookup("empty", empty));
+        interpolator.addDefaultLookup(setUpTestLookup("emptyIt", empty.iterator()));
+        interpolator.addDefaultLookup(setUpTestLookup("null", containsNull));
+        interpolator.addDefaultLookup(setUpTestLookup("nullIt", containsNull.iterator()));
+        assertEquals("Wrong result", "abc123${empty}${null}1${emptyIt}${nullIt}", interpolator.interpolate(value));
+    }
+
+    /**
+     * Tests interpolation with multiple variables containing arrays.
+     */
+    @Test
+    public void testInterpolationMultipleArrayVariables() {
+        final String value = "${single}bc${multi}23${empty}${null}";
+        final int[] multi = {1, 0, 0};
+        final String[] single = {"a"};
+        final int[] empty = {};
+        final Object[] containsNull = {null};
+        interpolator.addDefaultLookup(setUpTestLookup("multi", multi));
+        interpolator.addDefaultLookup(setUpTestLookup("single", single));
+        interpolator.addDefaultLookup(setUpTestLookup("empty", empty));
+        interpolator.addDefaultLookup(setUpTestLookup("null", containsNull));
+        assertEquals("Wrong result", "abc123${empty}${null}", interpolator.interpolate(value));
+    }
+
     /**
      * Tests an interpolation that consists of a single variable only. The variable's value should be returned verbatim.
      */
@@ -288,6 +405,28 @@ public class TestConfigurationInterpolator {
         assertEquals("Wrong result", value, interpolator.interpolate("${" + TEST_NAME + "}"));
     }
 
+    /**
+     * Tests an interpolation that consists of a single collection variable only. The variable's value
+     * should be returned verbatim.
+     */
+    @Test
+    public void testInterpolationSingleCollectionVariable() {
+        final List<Integer> value = Arrays.asList(42);
+        interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, value));
+        assertEquals("Wrong result", value, interpolator.interpolate("${" + TEST_NAME + "}"));
+    }
+
+    /**
+     * Tests an interpolation that consists of a single array variable only. The variable's value
+     * should be returned verbatim.
+     */
+    @Test
+    public void testInterpolationSingleArrayVariable() {
+        final int[] value = {42, -1};
+        interpolator.addDefaultLookup(setUpTestLookup(TEST_NAME, value));
+        assertEquals("Wrong result", value, interpolator.interpolate("${" + TEST_NAME + "}"));
+    }
+
     /**
      * Tests an interpolation that consists of a single undefined variable only with and without a default value.
      */
diff --git a/src/test/java/org/apache/commons/configuration2/interpol/TestInterpolatorSpecification.java b/src/test/java/org/apache/commons/configuration2/interpol/TestInterpolatorSpecification.java
index 0281e78b..dca6c390 100644
--- a/src/test/java/org/apache/commons/configuration2/interpol/TestInterpolatorSpecification.java
+++ b/src/test/java/org/apache/commons/configuration2/interpol/TestInterpolatorSpecification.java
@@ -24,6 +24,8 @@ import static org.junit.Assert.assertTrue;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
+import java.util.function.Function;
 
 import org.easymock.EasyMock;
 import org.junit.Before;
@@ -100,17 +102,29 @@ public class TestInterpolatorSpecification {
      */
     @Test
     public void testBuilderReuse() {
-        builder.withDefaultLookup(createLookup()).withInterpolator(createMock(ConfigurationInterpolator.class)).withPrefixLookup("test", createLookup())
-            .withParentInterpolator(createMock(ConfigurationInterpolator.class)).create();
+        builder
+            .withDefaultLookup(createLookup())
+            .withInterpolator(createMock(ConfigurationInterpolator.class))
+            .withPrefixLookup("test", createLookup())
+            .withParentInterpolator(createMock(ConfigurationInterpolator.class))
+            .withStringConverter(obj -> "test")
+            .create();
         final Lookup prefLook1 = createLookup();
         final Lookup prefLook2 = createLookup();
         final Lookup defLook1 = createLookup();
         final Lookup defLook2 = createLookup();
         final ConfigurationInterpolator parent = createMock(ConfigurationInterpolator.class);
-        final InterpolatorSpecification spec = builder.withPrefixLookup(PREFIX1, prefLook1).withPrefixLookup(PREFIX2, prefLook2)
-            .withDefaultLookups(Arrays.asList(defLook1, defLook2)).withParentInterpolator(parent).create();
+        final Function<Object, String> stringConverter = Objects::toString;
+        final InterpolatorSpecification spec = builder
+            .withPrefixLookup(PREFIX1, prefLook1)
+            .withPrefixLookup(PREFIX2, prefLook2)
+            .withDefaultLookups(Arrays.asList(defLook1, defLook2))
+            .withParentInterpolator(parent)
+            .withStringConverter(stringConverter)
+            .create();
         assertNull("Got an interpolator", spec.getInterpolator());
         assertSame("Wrong parent interpolator", parent, spec.getParentInterpolator());
+        assertSame("Wrong string converter", stringConverter, spec.getStringConverter());
         checkPrefixLookups(spec, prefLook1, prefLook2);
         checkDefaultLookups(spec, defLook1, defLook2);
     }
@@ -126,10 +140,19 @@ public class TestInterpolatorSpecification {
         final Lookup defLook2 = createLookup();
         final ConfigurationInterpolator interpolator = createMock(ConfigurationInterpolator.class);
         final ConfigurationInterpolator parent = createMock(ConfigurationInterpolator.class);
-        final InterpolatorSpecification spec = builder.withPrefixLookup(PREFIX1, prefLook1).withDefaultLookup(defLook1).withPrefixLookup(PREFIX2, prefLook2)
-            .withParentInterpolator(parent).withDefaultLookup(defLook2).withInterpolator(interpolator).create();
+        final Function<Object, String> stringConverter = Objects::toString;
+        final InterpolatorSpecification spec = builder
+            .withPrefixLookup(PREFIX1, prefLook1)
+            .withDefaultLookup(defLook1)
+            .withPrefixLookup(PREFIX2, prefLook2)
+            .withParentInterpolator(parent)
+            .withDefaultLookup(defLook2)
+            .withInterpolator(interpolator)
+            .withStringConverter(stringConverter)
+            .create();
         assertSame("Wrong interpolator", interpolator, spec.getInterpolator());
         assertSame("Wrong parent interpolator", parent, spec.getParentInterpolator());
+        assertSame("Wrong string converter", stringConverter, spec.getStringConverter());
         checkPrefixLookups(spec, prefLook1, prefLook2);
         checkDefaultLookups(spec, defLook1, defLook2);
     }
@@ -146,7 +169,10 @@ public class TestInterpolatorSpecification {
         final Map<String, Lookup> prefixLookups = new HashMap<>();
         prefixLookups.put(PREFIX1, prefLook1);
         prefixLookups.put(PREFIX2, prefLook2);
-        final InterpolatorSpecification spec = builder.withPrefixLookups(prefixLookups).withDefaultLookups(Arrays.asList(defLook1, defLook2)).create();
+        final InterpolatorSpecification spec = builder
+            .withPrefixLookups(prefixLookups)
+            .withDefaultLookups(Arrays.asList(defLook1, defLook2))
+            .create();
         checkPrefixLookups(spec, prefLook1, prefLook2);
         checkDefaultLookups(spec, defLook1, defLook2);
     }
