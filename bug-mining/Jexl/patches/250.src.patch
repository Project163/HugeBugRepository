diff --git a/src/main/java/org/apache/commons/jexl3/internal/Frame.java b/src/main/java/org/apache/commons/jexl3/internal/Frame.java
index a9377833..430388ea 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Frame.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Frame.java
@@ -24,6 +24,8 @@ import java.util.concurrent.atomic.AtomicReference;
  * @since 3.0
  */
 public class Frame {
+    /** The parent frame. */
+    private final Frame parent;
     /** The scope. */
     private final Scope scope;
     /** The actual stack frame. */
@@ -37,10 +39,16 @@ public class Frame {
      * @param r the stack frame
      * @param c the number of curried parameters
      */
-    protected Frame(final Scope s, final Object[] r, final int c) {
+    protected Frame(final Frame f, Scope s, final Object[] r, final int c) {
+        parent = f;
         scope = s;
         stack = r;
         curried = c;
+        String[] symbols = scope.getSymbols();
+        if (symbols.length != r.length) {
+            throw new IllegalArgumentException("Scope and stack frame size mismatch: "
+                    + symbols.length + " != " + r.length);
+        }
     }
 
     /**
@@ -72,7 +80,7 @@ public class Frame {
      * @return a new instance of frame
      */
     Frame newFrame(final Scope s, final Object[] r, final int c) {
-        return new Frame(s, r, c);
+        return new Frame(this, s, r, c);
     }
 
     /**
@@ -111,6 +119,14 @@ public class Frame {
         return scope;
     }
 
+    /**
+     * Gets the parent frame.
+     * @return the parent frame or null if this is the root frame
+     */
+    public Frame getParent() {
+        return parent;
+    }
+
     /**
      * Gets this script unbound parameters, i.e. parameters not bound through curry().
      * @return the parameter names
@@ -154,13 +170,13 @@ public class Frame {
  * Pass-by-reference frame.
  */
 class ReferenceFrame extends Frame {
-    ReferenceFrame(final Scope s, final Object[] r, final int c) {
-        super(s, r, c);
+    ReferenceFrame(final Frame f, final Scope s, final Object[] r, final int c) {
+        super(f, s, r, c);
     }
 
     @Override
     Frame newFrame(final Scope s, final Object[] r, final int c) {
-        return new ReferenceFrame(s, r, c);
+        return new ReferenceFrame(this, s, r, c);
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index 9d010494..0381fb44 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -373,6 +373,27 @@ public class Interpreter extends InterpreterBase {
         return node.isSafe() ? null : unsolvableProperty(jxltNode, jxltNode.getExpressionSource(), true, cause);
     }
 
+    /**
+     * Evaluates a JxltHandle node.
+     * <p>This parses and stores the JXLT template if necessary (upon first execution)</p>
+     * @param node the node
+     * @return the JXLT template evaluation.
+     * @param <NODE> the node type
+     */
+    public  <NODE extends JexlNode & JexlNode.JxltHandle> void parseJxltHandle(final NODE node) {
+        if (node.getExpression() == null) {
+            final TemplateEngine jxlt = jexl.jxlt();
+            JexlInfo info = node.jexlInfo();
+            if (this.block != null) {
+                info = new JexlNode.Info(node, info);
+            }
+            Scope newScope = new Scope(frame != null ? frame.getScope() : null);
+            final JxltEngine.Expression expr = jxlt.parseExpression(info, node.getExpressionSource(), newScope);
+            node.setExpression(expr);
+            node.setScope(newScope);
+        }
+    }
+
     /**
      * Evaluates a JxltHandle node.
      * <p>This parses and stores the JXLT template if necessary (upon first execution)</p>
@@ -388,12 +409,21 @@ public class Interpreter extends InterpreterBase {
             if (this.block != null) {
                 info = new JexlNode.Info(node, info);
             }
-            expr = jxlt.parseExpression(info, node.getExpressionSource(), frame != null ? frame.getScope() : null);
+            Scope newScope = new Scope(frame != null ? frame.getScope() : null);
+            expr = jxlt.parseExpression(info, node.getExpressionSource(), newScope);
             node.setExpression(expr);
+            node.setScope(newScope);
         }
         // internal classes to evaluate in context
         if (expr instanceof TemplateEngine.TemplateExpression) {
-            final Object eval = ((TemplateEngine.TemplateExpression) expr).evaluate(context, frame, options);
+            Scope exprScope = node.getScope();
+            String[] symbols = exprScope.getSymbols();
+            Object[] values = new Object[symbols.length];
+            for (int v = 0; v < values.length; ++v) {
+                values[v] = evalSymbol(symbols[v]);
+            }
+            Frame exprFrame = new Frame(frame, exprScope, values, 0);
+            final Object eval = ((TemplateEngine.TemplateExpression) expr).evaluate(context, exprFrame, options);
             if (eval != null) {
                 final String inter = eval.toString();
                 if (options.isStrictInterpolation()) {
@@ -406,6 +436,20 @@ public class Interpreter extends InterpreterBase {
         return null;
     }
 
+    Object evalSymbol(String symbol) {
+        Frame f = frame;
+        while (f != null) {
+            Scope scope = f.getScope();
+            Integer index = scope.getSymbol(symbol);
+            if (index != null && f.has(index)) {
+                Object value = f.get(index);
+                return value;
+            }
+            f = f.getParent();
+        }
+        return null;
+    }
+
     /**
      * Executes an assignment with an optional side effect operator.
      * @param node     the node
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Scope.java b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
index fc043bc2..35ba4a5d 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Scope.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
@@ -131,8 +131,8 @@ public final class Scope {
             newFrame = frame.newFrame(this, arguments, 0);
         } else {
             newFrame = ref
-            ? new ReferenceFrame(this, arguments, 0)
-            : new Frame(this, arguments, 0);
+            ? new ReferenceFrame(frame, this, arguments, 0)
+            : new Frame(frame, this, arguments, 0);
         }
         return newFrame.assign(args);
     }
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java b/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java
index 9a192081..212cc496 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTIdentifierAccessJxlt.java
@@ -18,12 +18,14 @@
 package org.apache.commons.jexl3.parser;
 
 import org.apache.commons.jexl3.JxltEngine;
+import org.apache.commons.jexl3.internal.Scope;
 
 /**
  * x.`expr`.
  */
 public class ASTIdentifierAccessJxlt extends ASTIdentifierAccess implements JexlNode.JxltHandle {
     protected transient JxltEngine.Expression jxltExpression;
+    private Scope scope;
 
     ASTIdentifierAccessJxlt(final int id) {
         super(id);
@@ -49,4 +51,9 @@ public class ASTIdentifierAccessJxlt extends ASTIdentifierAccess implements Jexl
         jxltExpression = tp;
     }
 
+    @Override
+    public Scope getScope() { return scope; }
+
+    @Override
+    public void setScope(final Scope scope) {  this.scope = scope; }
 }
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTJxltLiteral.java b/src/main/java/org/apache/commons/jexl3/parser/ASTJxltLiteral.java
index 4e8f2617..1e52d487 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTJxltLiteral.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTJxltLiteral.java
@@ -17,6 +17,7 @@
 package org.apache.commons.jexl3.parser;
 
 import org.apache.commons.jexl3.JxltEngine;
+import org.apache.commons.jexl3.internal.Scope;
 
 public final class ASTJxltLiteral extends JexlNode implements JexlNode.JxltHandle{
     /** Serial uid.*/
@@ -25,7 +26,13 @@ public final class ASTJxltLiteral extends JexlNode implements JexlNode.JxltHandl
     private String literal;
     /** The expression (parsed). */
     private transient JxltEngine.Expression jxltExpression;
+    /** The scope of the expression. */
+    private Scope scope;
 
+    /**
+     * Creates a Jxlt literal node.
+     * @param id the node id
+     */
     ASTJxltLiteral(final int id) {
         super(id);
     }
@@ -35,6 +42,16 @@ public final class ASTJxltLiteral extends JexlNode implements JexlNode.JxltHandl
         return literal;
     }
 
+    @Override
+    public Scope getScope() {
+        return scope;
+    }
+
+    @Override
+    public void setScope(final Scope scope) {
+        this.scope = scope;
+    }
+
     @Override
     public JxltEngine.Expression getExpression() {
         return jxltExpression;
diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java b/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java
index 0632fce7..dc75ab2e 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java
@@ -21,6 +21,7 @@ import org.apache.commons.jexl3.JexlCache;
 import org.apache.commons.jexl3.JexlContext.NamespaceFunctor;
 import org.apache.commons.jexl3.JexlInfo;
 import org.apache.commons.jexl3.JxltEngine;
+import org.apache.commons.jexl3.internal.Scope;
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.introspection.JexlPropertyGet;
 import org.apache.commons.jexl3.introspection.JexlPropertySet;
@@ -58,6 +59,18 @@ public abstract class JexlNode extends SimpleNode implements JexlCache.Reference
          * @param expr a TemplateEngine.TemplateExpression instance
          */
         void setExpression(JxltEngine.Expression expr);
+
+        /**
+         * Sets the scope of the expression.
+         * @param scope the scope
+         */
+        void setScope(Scope scope);
+
+        /**
+         * Gets the scope of the expression.
+         * @return the scope
+         */
+        Scope getScope();
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/jexl3/Issues400Test.java b/src/test/java/org/apache/commons/jexl3/Issues400Test.java
index 59640cc2..d06a67a7 100644
--- a/src/test/java/org/apache/commons/jexl3/Issues400Test.java
+++ b/src/test/java/org/apache/commons/jexl3/Issues400Test.java
@@ -140,7 +140,7 @@ public class Issues400Test {
             final String src = "var a = {'a': 1};\n" +
                 "var list = [a, a];\n" +
                 "let map1 = {:};\n" +
-                "for (var item : list) {\n" +
+                "for (let item : list) {\n" +
                 setmap +
                 "}\n " +
                 "map1";
@@ -463,7 +463,6 @@ public class Issues400Test {
     @Test
     void test429a() {
         final MapContext ctxt = new MapContext();
-        //ctxt.set("b", 1);
         final JexlFeatures features = JexlFeatures.createDefault();
         final JexlEngine jexl = new JexlBuilder()
                 .features(features)
@@ -839,7 +838,7 @@ public class Issues400Test {
     }
 
     @Test
-    public void testIssue441() throws Exception {
+    void testIssue441() {
         JexlEngine jexl = new JexlBuilder().create();
         String ctl = "\nab\nc`d\n";
         JexlExpression e = jexl.createExpression("`\nab\nc\\`d\n`");
@@ -861,8 +860,8 @@ public class Issues400Test {
         JexlContext context = new MapContext();
         String code = "var x = 'hello';\n" +
                 "function test(z) {\n" +
-                "let y = x;\n"+
-                "  return `${x} ${z}`;\n" +
+                //"x + ' ' + z\n"+
+                "`${x} ${z}`;\n" +
                 "}\n" +
                 "test('world');";
         JexlScript script = jexl.createScript(code);
