diff --git a/apache-rat-core/src/it/java/org/apache/rat/ReportTest.java b/apache-rat-core/src/it/java/org/apache/rat/ReportTest.java
index 0ca936ad..1864725c 100644
--- a/apache-rat-core/src/it/java/org/apache/rat/ReportTest.java
+++ b/apache-rat-core/src/it/java/org/apache/rat/ReportTest.java
@@ -82,7 +82,7 @@ import static org.junit.jupiter.api.Assertions.fail;
 public class ReportTest {
 
     private String[] asArgs(final List<String> argsList) {
-        return argsList.toArray(new String[argsList.size()]);
+        return argsList.toArray(new String[0]);
     }
 
     @ParameterizedTest(name = "{index} {0}")
@@ -138,14 +138,18 @@ public class ReportTest {
             for (String classPath : System.getProperty("java.class.path").split(File.pathSeparator)) {
                 shell.getClassLoader().addClasspath(classPath);
             }
-            Object value = shell.run(groovyScript, new String[]{outputFile.getAbsolutePath(), logFile.getAbsolutePath()});
-            if (value != null) {
-                fail(String.format("%s",value));
+            try {
+                Object value = shell.run(groovyScript, new String[]{outputFile.getAbsolutePath(), logFile.getAbsolutePath()});
+                if (value != null) {
+                    fail(String.format("%s", value));
+                }
+            } catch (AssertionError e) {
+                throw new AssertionError(String.format("%s: %s", testName, e.getMessage()), e);
             }
         }
     }
 
-    public static Stream<Arguments> args() throws RatException {
+    static Stream<Arguments> args() throws RatException {
         List<Arguments> results = new ArrayList<>();
         URL url = ReportTest.class.getResource("/ReportTest");
         String urlAsFile = url.getFile();
@@ -153,19 +157,20 @@ public class ReportTest {
             throw new RatException("Could not find root directory for " + url);
         }
 
-        File baseDir = new File(url.getFile());
+        File baseDir = new File(urlAsFile);
         DocumentName docName = DocumentName.builder(baseDir).build();
         AbstractFileFilter fileFilter = new NameFileFilter("commandLine.txt", docName.isCaseSensitive() ? IOCase.SENSITIVE : IOCase.INSENSITIVE);
         fileFilter = new OrFileFilter(fileFilter, DirectoryFileFilter.INSTANCE);
+
         Document document = new FileDocument(docName, baseDir, new DocumentNameMatcher(fileFilter));
         DirectoryWalker walker = new DirectoryWalker(document);
         RatReport report = new RatReport() {
             @Override
             public void report(Document document)  {
-                if (!document.isIgnored()) {
-                    String[] tokens = DocumentName.FSInfo.getDefault().tokenize(document.getName().localized());
-                    results.add(Arguments.of(tokens[1], document));
-                }
+            if (!document.isIgnored()) {
+                String[] tokens = DocumentName.FSInfo.getDefault().tokenize(document.getName().localized());
+                results.add(Arguments.of(tokens[1], document));
+            }
             }
         };
         walker.run(report);
@@ -184,7 +189,6 @@ public class ReportTest {
          */
         private Level level;
 
-
         FileLog(File logFile) throws IOException {
             this.logFile = new PrintStream(logFile);
             level = Level.INFO;
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_147/verify.groovy b/apache-rat-core/src/it/resources/ReportTest/RAT_147/verify.groovy
index 85e1bfe3..658ad09e 100644
--- a/apache-rat-core/src/it/resources/ReportTest/RAT_147/verify.groovy
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_147/verify.groovy
@@ -41,7 +41,6 @@ node = nodeList.item(0)
 attributes = node.getAttributes()
 assertEquals("false", attributes.getNamedItem("approval").getNodeValue())
 
-
 nodeList = XmlUtils.getNodeList(doc, xPath, "/rat-report/resource[@name='/windows-newlines.txt.bin']")
 assertEquals(1, nodeList.getLength())
 node = nodeList.item(0)
@@ -59,4 +58,4 @@ logOutput = new File(args[1])
 log = logOutput.text
 
 TextUtils.assertPatternNotInTarget("^ERROR:", log)
-TextUtils.assertPatternNotInTarget("^WARN:", log)
\ No newline at end of file
+TextUtils.assertPatternNotInTarget("^WARN:", log)
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_211/verify.groovy b/apache-rat-core/src/it/resources/ReportTest/RAT_211/verify.groovy
index 288fe4a6..be464bdb 100644
--- a/apache-rat-core/src/it/resources/ReportTest/RAT_211/verify.groovy
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_211/verify.groovy
@@ -53,4 +53,4 @@ logOutput = new File(args[1])
 log = logOutput.text
 
 TextUtils.assertPatternNotInTarget("^ERROR:", log)
-TextUtils.assertPatternNotInTarget("^WARN:", log)
\ No newline at end of file
+TextUtils.assertPatternNotInTarget("^WARN:", log)
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_362/commandLine.txt b/apache-rat-core/src/it/resources/ReportTest/RAT_362/commandLine.txt
new file mode 100644
index 00000000..0a6cbd33
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_362/commandLine.txt
@@ -0,0 +1,5 @@
+--output-style
+xml
+--input-exclude-parsed-scm
+GIT
+--
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_362/expected-message.txt b/apache-rat-core/src/it/resources/ReportTest/RAT_362/expected-message.txt
new file mode 100644
index 00000000..bea4ba54
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_362/expected-message.txt
@@ -0,0 +1 @@
+Issues with UNAPPROVED
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/.gitignore b/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/.gitignore
new file mode 100644
index 00000000..e994dfc1
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/.gitignore
@@ -0,0 +1,2 @@
+/foo.md
+/src.md
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/foo.md b/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/foo.md
new file mode 100644
index 00000000..e69de29b
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/src.md b/apache-rat-core/src/it/resources/ReportTest/RAT_362/src/src.md
new file mode 100644
index 00000000..e69de29b
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_362/verify.groovy b/apache-rat-core/src/it/resources/ReportTest/RAT_362/verify.groovy
new file mode 100644
index 00000000..0cae96a1
--- /dev/null
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_362/verify.groovy
@@ -0,0 +1,62 @@
+package ReportTest.RAT_362
+
+import org.apache.rat.testhelpers.XmlUtils
+import org.apache.rat.utils.DefaultLog
+import org.w3c.dom.Document
+import org.w3c.dom.NamedNodeMap
+import org.w3c.dom.NodeList
+
+import javax.xml.xpath.XPath
+import javax.xml.xpath.XPathFactory
+
+import static org.assertj.core.api.Assertions.assertThat
+
+private static Map<String, String> mapOf(String... parts) {
+    Map<String, String> map = new HashMap<>()
+    for (int i = 0; i < parts.length; i += 2) {
+        map.put(parts[i], parts[i+1])
+    }
+    return map
+}
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+output = new File(args[0])
+content = output.text
+
+DefaultLog.instance.warn(content)
+
+Document document = XmlUtils.toDom(new FileInputStream(args[0]))
+XPath xPath = XPathFactory.newInstance().newXPath()
+
+List<String> ignoredFiles = new ArrayList<>(Arrays.asList(
+        "/.gitignore",
+        "/foo.md",
+        "/src.md"))
+
+NodeList nodeList = XmlUtils.getNodeList(document, xPath, "/rat-report/resource[@type='IGNORED']")
+for (int i = 0 ; i < nodeList.getLength(); i++) {
+    NamedNodeMap attr = nodeList.item(i).getAttributes()
+    String s = attr.getNamedItem("name").getNodeValue()
+    assertThat(ignoredFiles).contains(s)
+    ignoredFiles.remove(s)
+}
+
+assertThat(ignoredFiles).isEmpty()
+
+// Document types
+XmlUtils.assertAttributes(document, xPath, "/rat-report/statistics/documentType[@name='IGNORED']",
+        mapOf("count", "3" ))
diff --git a/apache-rat-core/src/it/resources/ReportTest/RAT_81/verify.groovy b/apache-rat-core/src/it/resources/ReportTest/RAT_81/verify.groovy
index a3a78c3a..dde3e8b3 100644
--- a/apache-rat-core/src/it/resources/ReportTest/RAT_81/verify.groovy
+++ b/apache-rat-core/src/it/resources/ReportTest/RAT_81/verify.groovy
@@ -58,4 +58,4 @@ logOutput = new File(args[1])
 log = logOutput.text
 
 TextUtils.assertPatternNotInTarget("^ERROR:", log)
-TextUtils.assertPatternNotInTarget("^WARN:", log)
\ No newline at end of file
+TextUtils.assertPatternNotInTarget("^WARN:", log)
diff --git a/apache-rat-core/src/main/java/org/apache/rat/Reporter.java b/apache-rat-core/src/main/java/org/apache/rat/Reporter.java
index 7aa5929c..ec32f340 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/Reporter.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/Reporter.java
@@ -185,4 +185,12 @@ public class Reporter {
                     .append(System.lineSeparator());
         }
     }
+
+    /**
+     * Gets the document that was generated during execution.
+     * @return the document that was generated during execution.
+     */
+    public Document getDocument() {
+        return document;
+    }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/api/EnvVar.java b/apache-rat-core/src/main/java/org/apache/rat/api/EnvVar.java
new file mode 100644
index 00000000..cc5435e2
--- /dev/null
+++ b/apache-rat-core/src/main/java/org/apache/rat/api/EnvVar.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one   *
+ * or more contributor license agreements.  See the NOTICE file *
+ * distributed with this work for additional information        *
+ * regarding copyright ownership.  The ASF licenses this file   *
+ * to you under the Apache License, Version 2.0 (the            *
+ * "License"); you may not use this file except in compliance   *
+ * with the License.  You may obtain a copy of the License at   *
+ *                                                              *
+ *   http://www.apache.org/licenses/LICENSE-2.0                 *
+ *                                                              *
+ * Unless required by applicable law or agreed to in writing,   *
+ * software distributed under the License is distributed on an  *
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+ * KIND, either express or implied.  See the License for the    *
+ * specific language governing permissions and limitations      *
+ * under the License.                                           *
+ */
+
+package org.apache.rat.api;
+
+import java.util.Arrays;
+import java.util.stream.Collectors;
+
+import org.apache.rat.utils.Log;
+
+public enum EnvVar {
+    /**
+     * Ignore Git Global ignore file.
+     */
+    RAT_NO_GIT_GLOBAL_IGNORE("Ignore global ignore file when processing GIT ignore files."),
+    /**
+     * Log matcher decomposition when used.
+     */
+    RAT_DECOMPOSE_MATCHER_ON_USE("Log the decomposition of matchers on use. Messages will be logged at the minimum log level currently enabled."),
+    /**
+     * Defines the XDG home.
+     */
+    XDG_CONFIG_HOME("Where user-specific configurations are written. Generally defaults to $HOME/.config. " +
+            "Only needs to be set if it has been changed on the system."),
+    /**
+     * Defines the user HOME.
+     */
+    HOME("The home directory"),
+    /**
+     * Sets the log level for the DefaultLog when it is constructed.
+     */
+    RAT_DEFAULT_LOG_LEVEL("The default log level for the command line logger. Should be one of: " +
+            Arrays.stream(Log.Level.values()).map(Log.Level::name).collect(Collectors.joining(", ")));
+    /**
+     * The documentation for this EnvVar.
+     */
+    private final String documentation;
+
+    /**
+     * Constructor.
+     * @param documentation the documentation for the EnvVar.
+     */
+    EnvVar(final String documentation) {
+        this.documentation = documentation;
+    }
+
+    /**
+     * Gets the documentation for this EnvVar.
+     * @return the documentation for this EnvVar.
+     */
+    public String documentation() {
+        return documentation;
+    }
+
+    /**
+     * Determines if this EnvVar is set.
+     * @return {@code true} if the EnvVar is set.
+     */
+    public boolean isSet() {
+        return getValue() != null;
+    }
+
+    /**
+     * Gets the value for the EnvVar.
+     * @return the value for this EnvVar or {@code null} if not set.
+     */
+    public String getValue() {
+        return System.getenv(name());
+    }
+}
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java
index ef2bab1b..4c7f9ced 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionUtils.java
@@ -34,18 +34,17 @@ import org.apache.commons.io.IOUtils;
 import org.apache.commons.io.LineIterator;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.rat.ConfigurationException;
+import org.apache.rat.api.EnvVar;
 import org.apache.rat.config.exclusion.plexus.MatchPattern;
 import org.apache.rat.config.exclusion.plexus.SelectorUtils;
 import org.apache.rat.document.DocumentName;
 import org.apache.rat.document.DocumentNameMatcher;
-import org.apache.rat.utils.DefaultLog;
 import org.apache.rat.utils.ExtendedIterator;
-import org.apache.rat.utils.Log;
 
 import static java.lang.String.format;
 
 /**
- * Utilities for Exclusion processing.
+ * Utilities for exclusion processing.
  */
 public final class ExclusionUtils {
 
@@ -121,17 +120,8 @@ public final class ExclusionUtils {
     public static FileFilter asFileFilter(final DocumentName parent, final DocumentNameMatcher nameMatcher) {
         return file -> {
             DocumentName candidate = DocumentName.builder(file).setBaseName(parent.getBaseName()).build();
-            boolean result = nameMatcher.matches(candidate);
-            Log log = DefaultLog.getInstance();
-            if (log.isEnabled(Log.Level.DEBUG)) {
-                log.debug(format("FILTER TEST for %s -> %s", file, result));
-                if (!result) {
-                    List< DocumentNameMatcher.DecomposeData> data = nameMatcher.decompose(candidate);
-                    log.debug("Decomposition for " + candidate);
-                    data.forEach(log::debug);
-                }
-            }
-            return result;
+            return EnvVar.RAT_DECOMPOSE_MATCHER_ON_USE.isSet() ? nameMatcher.logDecompositionWhileMatching(candidate) :
+                nameMatcher.matches(candidate);
         };
     }
 
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java
index d43a2ccd..aa42967b 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/fileProcessors/GitIgnoreBuilder.java
@@ -27,6 +27,8 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.function.Consumer;
 
+import org.apache.commons.lang3.StringUtils;
+import org.apache.rat.api.EnvVar;
 import org.apache.rat.config.exclusion.ExclusionUtils;
 import org.apache.rat.config.exclusion.MatcherSet;
 import org.apache.rat.config.exclusion.plexus.MatchPatterns;
@@ -44,7 +46,7 @@ public class GitIgnoreBuilder extends AbstractFileProcessorBuilder {
     private static final String IGNORE_FILE = ".gitignore";
     /** The comment prefix */
     private static final String COMMENT_PREFIX = "#";
-    /** An escaped comment in the .gitignore file.  (Not a comment) */
+    /** An escaped comment in the .gitignore file. (Not a comment) */
     private static final String ESCAPED_COMMENT = "\\#";
     /** An escaped negation in the .gitignore file. (Not a negation) */
     private static final String ESCAPED_NEGATION = "\\!";
@@ -80,7 +82,7 @@ public class GitIgnoreBuilder extends AbstractFileProcessorBuilder {
     protected MatcherSet process(final Consumer<MatcherSet> matcherSetConsumer, final DocumentName root, final DocumentName documentName) {
       if (root.equals(documentName.getBaseDocumentName())) {
           Optional<File> globalGitIgnore = globalGitIgnore();
-          List<MatcherSet> matcherSets = new ArrayList<MatcherSet>();
+          List<MatcherSet> matcherSets = new ArrayList<>();
           matcherSets.add(super.process(matcherSetConsumer, root, documentName));
           if (globalGitIgnore.isPresent()) {
               LevelBuilder levelBuilder = getLevelBuilder(Integer.MAX_VALUE);
@@ -96,7 +98,7 @@ public class GitIgnoreBuilder extends AbstractFileProcessorBuilder {
     /**
      * Convert the string entry.
      * If the string ends with a slash an {@link DocumentNameMatcher#and} is constructed from a directory check and the file
-     * name matcher.  In this case an empty Optional is returned.
+     * name matcher. In this case an empty Optional is returned.
      * If the string starts with {@value ExclusionUtils#NEGATION_PREFIX} then the entry is placed in the include list, otherwise
      * the entry is placed in the exclude list and the name of the check returned.
      * @param documentName The name of the document being processed.
@@ -145,23 +147,22 @@ public class GitIgnoreBuilder extends AbstractFileProcessorBuilder {
 
     /**
      * The global gitignore file to process, based on the
-     * RAT_NO_GIT_GLOBAL_IGNORE, XDG_CONFIG_HOME, and HOME environment
+     * {@link EnvVar#RAT_NO_GIT_GLOBAL_IGNORE},
+     * {@link EnvVar#XDG_CONFIG_HOME} and
+     * {@link EnvVar#HOME} environment
      * variables.
      */
     protected Optional<File> globalGitIgnore() {
-        if (System.getenv("RAT_NO_GIT_GLOBAL_IGNORE") != null) {
+        if (EnvVar.RAT_NO_GIT_GLOBAL_IGNORE.isSet()) {
             return Optional.empty();
         }
 
-        String xdgConfigHome = System.getenv("XDG_CONFIG_HOME");
+        String xdgConfigHome = EnvVar.XDG_CONFIG_HOME.getValue();
         String filename;
         if (xdgConfigHome != null && !xdgConfigHome.isEmpty()) {
             filename = xdgConfigHome + File.separator + "git" + File.separator + "ignore";
         } else {
-            String home = System.getenv("HOME");
-            if (home == null) {
-                home = "";
-            }
+            String home = StringUtils.defaultIfEmpty(EnvVar.HOME.getValue(), "");
             filename = home + File.separator + ".config" + File.separator + "git" + File.separator + "ignore";
         }
         File file = new File(filename);
@@ -171,5 +172,4 @@ public class GitIgnoreBuilder extends AbstractFileProcessorBuilder {
             return Optional.empty();
         }
     }
-
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java
index 61412127..676981e9 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentNameMatcher.java
@@ -32,6 +32,8 @@ import java.util.function.Predicate;
 import org.apache.rat.ConfigurationException;
 import org.apache.rat.config.exclusion.plexus.MatchPattern;
 import org.apache.rat.config.exclusion.plexus.MatchPatterns;
+import org.apache.rat.utils.DefaultLog;
+import org.apache.rat.utils.Log;
 
 import static java.lang.String.format;
 
@@ -165,6 +167,22 @@ public final class DocumentNameMatcher {
         return name;
     }
 
+    /**
+     * Calculates the match result and logs the calculations.
+     * @param candidate the candidate to evaluate the match for.
+     * @return the result of the calculation
+     */
+    public boolean logDecompositionWhileMatching(final DocumentName candidate) {
+        boolean result = matches(candidate);
+        Log log = DefaultLog.getInstance();
+        Log.Level level = log.getLevel();
+        log.log(level, format("FILTER TEST for %s -> %s", candidate, result));
+        List<DecomposeData> data = decompose(candidate);
+        log.log(level, "Decomposition for " + candidate);
+        data.forEach(s -> log.log(level, s));
+        return result;
+    }
+
     /**
      * Decomposes the matcher execution against the candidate.
      * @param candidate the candidate to check.
diff --git a/apache-rat-core/src/main/java/org/apache/rat/document/FileDocument.java b/apache-rat-core/src/main/java/org/apache/rat/document/FileDocument.java
index d7596a3e..dfbf0141 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/document/FileDocument.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/document/FileDocument.java
@@ -72,11 +72,8 @@ public class FileDocument extends Document {
             if (files != null) {
                 FileFilter fileFilter = ExclusionUtils.asFileFilter(name, nameMatcher);
                 for (File child : files) {
-                    if (fileFilter.accept(child)) {
-                        result.add(new FileDocument(name, child, nameMatcher));
-                    } else {
-                        result.add(new IgnoredDocument(name, child, nameMatcher));
-                    }
+                    Document childDoc = fileFilter.accept(child) ? new FileDocument(name, child, nameMatcher) : new IgnoredDocument(name, child, nameMatcher);
+                    result.add(childDoc);
                 }
             }
             return result;
diff --git a/apache-rat-core/src/main/java/org/apache/rat/utils/DefaultLog.java b/apache-rat-core/src/main/java/org/apache/rat/utils/DefaultLog.java
index be8591af..0f65d6db 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/utils/DefaultLog.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/utils/DefaultLog.java
@@ -18,26 +18,19 @@
  */
 package org.apache.rat.utils;
 
-import org.apache.commons.lang3.StringUtils;
+import org.apache.rat.api.EnvVar;
 
 /**
  * A default implementation of Log that writes to {@code System.out} and {@code System.err}.
  */
 public final class DefaultLog implements Log {
-    /**
-     * The environment variable to set the default log level that RAT should log at.
-     * If not specified INFO is used.
-     * @see #setLevel(Level)
-     */
-    public static final String ENV_VAR = DefaultLog.class.getName();
-
     /**
      * The instance of the default log.
      */
     private static Log instance = new DefaultLog();
 
     /**
-     * Retrieves teh DefaultLog instance.
+     * Retrieves the DefaultLog instance.
      * @return the Default log instance.
      */
     public static Log getInstance() {
@@ -69,11 +62,11 @@ public final class DefaultLog implements Log {
 
     private DefaultLog() {
         try {
-            level = StringUtils.isNotEmpty(System.getenv(ENV_VAR)) ?
-                    Level.valueOf(System.getenv(ENV_VAR).toUpperCase()) : Level.INFO;
+            level = EnvVar.RAT_DEFAULT_LOG_LEVEL.isSet() ?
+                    Level.valueOf(EnvVar.RAT_DEFAULT_LOG_LEVEL.getValue().toUpperCase()) : Level.INFO;
         } catch (IllegalArgumentException e) {
             level = Level.INFO;
-            log(Level.WARN, "Invalid log level set in environment", e);
+            log(Level.WARN, "Invalid log level set in environment: " + EnvVar.RAT_DEFAULT_LOG_LEVEL.getValue().toUpperCase(), e);
         }
     }
 
diff --git a/apache-rat-core/src/test/java/org/apache/rat/OptionCollectionTest.java b/apache-rat-core/src/test/java/org/apache/rat/OptionCollectionTest.java
index e269e85b..fda1ba6f 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/OptionCollectionTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/OptionCollectionTest.java
@@ -18,7 +18,16 @@
  */
 package org.apache.rat;
 
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.nio.file.Path;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TreeMap;
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.DefaultParser;
 import org.apache.commons.cli.Option;
@@ -31,6 +40,7 @@ import org.apache.rat.report.IReportable;
 import org.apache.rat.test.AbstractConfigurationOptionsProvider;
 import org.apache.rat.test.utils.OptionFormatter;
 import org.apache.rat.testhelpers.TestingLog;
+import org.apache.rat.utils.CasedString;
 import org.apache.rat.utils.DefaultLog;
 import org.apache.rat.utils.Log;
 import org.junit.jupiter.api.AfterAll;
@@ -70,7 +80,90 @@ public class OptionCollectionTest {
      */
     @FunctionalInterface
     public interface OptionTest {
-        void test();
+        /**
+         * Executes the test and uses fail or asserts to generate failures.
+         */
+        void exec();
+
+        /**
+         * Execute the test and ensure any failures have the test name added.
+         */
+        default void test() {
+            try {
+                exec();
+            } catch (AssertionError e) {
+                throw new AssertionError(formatMsg(e.getMessage()), e);
+            }
+        }
+
+        /**
+         * Formats the messages by adding the test name.
+         * @param msg the message to reformat.
+         * @return the formatted message.
+         */
+        default String formatMsg(String msg) {
+            return String.format("%s: %s", this, msg);
+        }
+
+        /**
+         * Creates a named OptionTest.
+         * @param name the name of the test.
+         * @param test the test to execute.
+         * @return a named option test.
+         */
+        static OptionTest namedTest(String name, OptionTest test) {
+            return new OptionTest() {
+                @Override
+                public void exec() {
+                    test.exec();
+                }
+                @Override
+                public String toString() {
+                    return name;
+                }
+            };
+        }
+    }
+
+    /**
+     * A test function. Used to annotate methods in test providers.
+     */
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.METHOD)
+    public @interface TestFunction {
+    }
+
+    /**
+     * Process methods in a test provider.
+     * Tests are detected by looking for the {@link TestFunction} annotation.
+     * @param testProvider the test provider
+     * @return a map of named tests to a named OptionTest.
+     */
+    public static Map<String, OptionTest> processTestFunctionAnnotations(Object testProvider) {
+        final int testLength = 4;
+        final Class<?> clazz = testProvider.getClass();
+        final Map<String, OptionTest> result = new TreeMap<>();
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (method.isAnnotationPresent(TestFunction.class) && method.getParameterCount() == 0 && method.getReturnType() == void.class) {
+                String name = method.getName();
+                if (name.endsWith("Test")) {
+                    name = name.substring(0, name.length() - testLength);
+                }
+                if (name.startsWith("test")) {
+                    name = name.substring(testLength);
+                }
+                name = new CasedString(CasedString.StringCase.CAMEL, name).toCase(CasedString.StringCase.KEBAB).toLowerCase(Locale.ROOT);
+                result.put(name, OptionTest.namedTest(name, () -> {
+                            try {
+                                method.invoke(testProvider);
+                            } catch (IllegalAccessException | InvocationTargetException e) {
+                                throw new RuntimeException(e);
+                            }
+                        }
+                ));
+            }
+        }
+        return result;
     }
 
     /**
diff --git a/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsProvider.java b/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsProvider.java
new file mode 100644
index 00000000..3137eaa3
--- /dev/null
+++ b/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsProvider.java
@@ -0,0 +1,1353 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one   *
+ * or more contributor license agreements.  See the NOTICE file *
+ * distributed with this work for additional information        *
+ * regarding copyright ownership.  The ASF licenses this file   *
+ * to you under the Apache License, Version 2.0 (the            *
+ * "License"); you may not use this file except in compliance   *
+ * with the License.  You may obtain a copy of the License at   *
+ *                                                              *
+ *   http://www.apache.org/licenses/LICENSE-2.0                 *
+ *                                                              *
+ * Unless required by applicable law or agreed to in writing,   *
+ * software distributed under the License is distributed on an  *
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+ * KIND, either express or implied.  See the License for the    *
+ * specific language governing permissions and limitations      *
+ * under the License.                                           *
+ */
+package org.apache.rat;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.PrintStream;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.regex.Pattern;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
+import org.apache.commons.cli.Option;
+import org.apache.commons.cli.Options;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.rat.api.RatException;
+import org.apache.rat.commandline.Arg;
+import org.apache.rat.commandline.StyleSheets;
+import org.apache.rat.config.exclusion.StandardCollection;
+import org.apache.rat.config.results.ClaimValidator;
+import org.apache.rat.configuration.builders.SpdxBuilder;
+import org.apache.rat.help.Help;
+import org.apache.rat.license.ILicense;
+import org.apache.rat.license.ILicenseFamily;
+import org.apache.rat.license.LicenseSetFactory;
+import org.apache.rat.report.claim.ClaimStatistic;
+import org.apache.rat.test.AbstractOptionsProvider;
+import org.apache.rat.test.utils.OptionFormatter;
+import org.apache.rat.test.utils.Resources;
+import org.apache.rat.testhelpers.FileUtils;
+import org.apache.rat.testhelpers.TestingLog;
+import org.apache.rat.testhelpers.TextUtils;
+import org.apache.rat.testhelpers.XmlUtils;
+import org.apache.rat.utils.DefaultLog;
+import org.apache.rat.utils.Log;
+import org.junit.jupiter.params.provider.ArgumentsProvider;
+import org.w3c.dom.Document;
+import org.xml.sax.SAXException;
+
+import static org.apache.rat.commandline.Arg.HELP_LICENSES;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.fail;
+
+/**
+ * A class to provide the Options and tests to the testOptionsUpdateConfig.
+ */
+class ReporterOptionsProvider extends AbstractOptionsProvider implements ArgumentsProvider {
+    static File sourceDir;
+
+    /**
+     * A flag to determine if help was called
+     */
+    final AtomicBoolean helpCalled = new AtomicBoolean(false);
+
+    public ReporterOptionsProvider() {
+        super(ReporterOptionsTest.testPath.toFile());
+        processTestFunctionAnnotations();
+        testMap.put("addLicense", this::addLicenseTest);
+        testMap.remove("add-license");
+        testMap.put("dir", () -> DefaultLog.getInstance().info("--dir has no valid test"));
+        super.validate(Collections.emptyList());
+    }
+
+    /**
+     * Generate a ReportConfiguration from a set of arguments.
+     * Forces the {@code helpCalled} flag to be reset.
+     *
+     * @param args the arguments.
+     * @return A ReportConfiguration
+     * @throws IOException on critical error.
+     */
+    @Override
+    protected final ReportConfiguration generateConfig(List<Pair<Option, String[]>> args) throws IOException {
+        return generateConfig(args, false);
+    }
+
+    protected final ReportConfiguration generateConfig(List<Pair<Option, String[]>> args, boolean helpExpected) throws IOException {
+        if (sourceDir == null) {
+            throw new IOException("sourceDir not set");
+        }
+        helpCalled.set(false);
+        ReportConfiguration config = OptionCollection.parseCommands(sourceDir, extractArgs(args), o -> helpCalled.set(true), true);
+        assertThat(helpCalled.get()).as("Help was called").isEqualTo(helpExpected);
+        if (config != null && !config.hasSource()) {
+            config.addSource(OptionCollection.getReportable(sourceDir, config));
+        }
+        return config;
+    }
+
+    private void configureSourceDir(Option option) {
+        sourceDir = new File(baseDir, OptionFormatter.getName(option));
+        FileUtils.mkDir(sourceDir);
+    }
+
+    private void validateNoArgSetup() throws IOException, RatException {
+        // verify that without args the report is ok.
+        TestingLog log = new TestingLog();
+        DefaultLog.setInstance(log);
+        try {
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            ClaimValidator validator = config.getClaimValidator();
+            assertThat(validator.listIssues(claimStatistic)).isEmpty();
+        } finally {
+            DefaultLog.setInstance(null);
+        }
+
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void addLicenseTest() {
+        editLicenseTest(Arg.EDIT_ADD.find("addLicense"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void editLicenseTest() {
+        editLicenseTest(Arg.EDIT_ADD.find("edit-license"));
+    }
+
+    private void editLicenseTest(final Option option) {
+        try {
+            configureSourceDir(option);
+            ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
+            File testFile = writeFile("NoLicense.java", "class NoLicense {}");
+            File resultFile = new File(sourceDir, "NoLicense.java.new");
+            FileUtils.delete(resultFile);
+
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic).isNotNull();
+            String contents = String.join("\n", IOUtils.readLines(new FileReader(testFile)));
+            assertThat(contents).isEqualTo("class NoLicense {}");
+            assertThat(resultFile).exists();
+            contents = String.join("\n", IOUtils.readLines(new FileReader(resultFile)));
+            assertThat(contents).isEqualTo("/*\n" +
+                    " * Licensed to the Apache Software Foundation (ASF) under one\n" +
+                    " * or more contributor license agreements.  See the NOTICE file\n" +
+                    " * distributed with this work for additional information\n" +
+                    " * regarding copyright ownership.  The ASF licenses this file\n" +
+                    " * to you under the Apache License, Version 2.0 (the\n" +
+                    " * \"License\"); you may not use this file except in compliance\n" +
+                    " * with the License.  You may obtain a copy of the License at\n" +
+                    " * \n" +
+                    " *   http://www.apache.org/licenses/LICENSE-2.0\n" +
+                    " * \n" +
+                    " * Unless required by applicable law or agreed to in writing,\n" +
+                    " * software distributed under the License is distributed on an\n" +
+                    " * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n" +
+                    " * KIND, either express or implied.  See the License for the\n" +
+                    " * specific language governing permissions and limitations\n" +
+                    " * under the License.\n" +
+                    " */\n\n" +
+                    "class NoLicense {}");
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    protected File writeFile(String name) {
+        return FileUtils.writeFile(sourceDir, name, Collections.singletonList(name));
+    }
+
+    protected File writeFile(String name, String content) {
+        return FileUtils.writeFile(sourceDir, name, Collections.singletonList(content));
+    }
+
+    protected File writeFile(String name, Iterable<String> content) {
+        return FileUtils.writeFile(sourceDir, name, content);
+    }
+
+    @OptionCollectionTest.TestFunction
+    private void execLicensesDeniedTest(final Option option, final String[] args) {
+        try {
+            configureSourceDir(option);
+            File illumosFile = writeFile("illumousFile.java", "The contents of this file are " +
+                    "subject to the terms of the Common Development and Distribution License (the \"License\") You " +
+                    "may not use this file except in compliance with the License.");
+
+            validateNoArgSetup();
+
+            ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            ClaimValidator validator = config.getClaimValidator();
+            assertThat(validator.listIssues(claimStatistic)).containsExactly("UNAPPROVED");
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licensesDeniedTest() {
+        execLicensesDeniedTest(Arg.LICENSES_DENIED.find("licenses-denied"), new String[]{"ILLUMOS"});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licensesDeniedFileTest() {
+        File outputFile = FileUtils.writeFile(baseDir, "licensesDenied.txt", Collections.singletonList("ILLUMOS"));
+        execLicensesDeniedTest(Arg.LICENSES_DENIED_FILE.find("licenses-denied-file"),
+                new String[]{outputFile.getAbsolutePath()});
+    }
+
+    private void noDefaultsTest(final Option option) {
+        try {
+            configureSourceDir(option);
+            File testFile = writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Apache-2.0\n",
+                    "*/\n\n", "class Test {}\n"));
+
+            validateNoArgSetup();
+
+            ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
+            Reporter reporter = new Reporter(config);
+            try {
+                reporter.execute();
+                fail("Should have thrown exception");
+            } catch (RatException e) {
+                ClaimStatistic claimStatistic = reporter.getClaimsStatistic();
+                ClaimValidator validator = config.getClaimValidator();
+                assertThat(validator.listIssues(claimStatistic)).containsExactlyInAnyOrder("DOCUMENT_TYPES", "LICENSE_CATEGORIES", "LICENSE_NAMES", "STANDARDS");
+            }
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void noDefaultLicensesTest() {
+        noDefaultsTest(Arg.CONFIGURATION_NO_DEFAULTS.find("no-default-licenses"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void configurationNoDefaultsTest() {
+        noDefaultsTest(Arg.CONFIGURATION_NO_DEFAULTS.find("configuration-no-defaults"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void counterMaxTest() {
+        Option option = Arg.COUNTER_MAX.option();
+        String[] arg = {null};
+        try {
+            configureSourceDir(option);
+            File testFile = writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Unapproved\n",
+                    "*/\n\n", "class Test {}\n"));
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            ClaimValidator validator = config.getClaimValidator();
+            assertThat(validator.listIssues(claimStatistic)).containsExactly("UNAPPROVED");
+
+            arg[0] = "Unapproved:1";
+            config = generateConfig(ImmutablePair.of(option, arg));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            validator = config.getClaimValidator();
+            assertThat(validator.listIssues(claimStatistic)).isEmpty();
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void counterMinTest() {
+        Option option = Arg.COUNTER_MIN.option();
+        String[] arg = {null};
+
+        try {
+            configureSourceDir(option);
+            File testFile = writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Unapproved\n",
+                    "*/\n\n", "class Test {}\n"));
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            ClaimValidator validator = config.getClaimValidator();
+            assertThat(validator.listIssues(claimStatistic)).containsExactly("UNAPPROVED");
+
+            arg[0] = "Unapproved:1";
+            config = generateConfig(ImmutablePair.of(option, arg));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            validator = config.getClaimValidator();
+            assertThat(validator.listIssues(claimStatistic)).isEmpty();
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    // exclude tests
+    private void execExcludeTest(final Option option, final String[] args) {
+        String[] notExcluded = {"notbaz", "well._afile"};
+        String[] excluded = {"some.foo", "B.bar", "justbaz"};
+        try {
+            configureSourceDir(option);
+            writeFile("notbaz");
+            writeFile("well._afile");
+            writeFile("some.foo");
+            writeFile("B.bar");
+            writeFile("justbaz");
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(5);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
+
+            // filter out source
+            config = generateConfig(ImmutablePair.of(option, args));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(3);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    private void excludeFileTest(final Option option) {
+        configureSourceDir(option);
+        File outputFile = FileUtils.writeFile(baseDir, "exclude.txt", Arrays.asList(EXCLUDE_ARGS));
+        execExcludeTest(option, new String[]{outputFile.getAbsolutePath()});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void excludeFileTest() {
+        excludeFileTest(Arg.EXCLUDE_FILE.find("exclude-file"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputExcludeFileTest() {
+        excludeFileTest(Arg.EXCLUDE_FILE.find("input-exclude-file"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void excludeTest() {
+        execExcludeTest(Arg.EXCLUDE.find("exclude"), EXCLUDE_ARGS);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputExcludeTest() {
+        execExcludeTest(Arg.EXCLUDE.find("input-exclude"), EXCLUDE_ARGS);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputExcludeSizeTest() {
+        Option option = Arg.EXCLUDE_SIZE.option();
+        String[] args = {"5"};
+
+        try {
+            configureSourceDir(option);
+            writeFile("Hi.txt", "Hi");
+            writeFile("Hello.txt", "Hello");
+            writeFile("HelloWorld.txt", "HelloWorld");
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
+
+            // filter out source
+            config = generateConfig(ImmutablePair.of(option, args));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputExcludeStdTest() {
+        Option option = Arg.EXCLUDE_STD.find("input-exclude-std");
+        String[] args = {StandardCollection.MAVEN.name()};
+        // these files are excluded by default "afile~", ".#afile", "%afile%", "._afile"
+        // these files are not excluded by default "afile~more", "what.#afile", "%afile%withMore", "well._afile", "build.log"
+        // build.log is excluded by MAVEN.
+        try {
+            configureSourceDir(option);
+            writeFile("afile~");
+            writeFile(".#afile");
+            writeFile("%afile%");
+            writeFile("._afile");
+            writeFile("afile~more");
+            writeFile("what.#afile");
+            writeFile("%afile%withMore");
+            writeFile("well._afile");
+            writeFile("build.log");
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(5);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(4);
+
+            config = generateConfig(ImmutablePair.of(option, args));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(4);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(5);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputExcludeParsedScmTest() {
+        Option option = Arg.EXCLUDE_PARSE_SCM.find("input-exclude-parsed-scm");
+        String[] args = {"GIT"};
+        String[] lines = {
+                "# somethings",
+                "!thingone", "thing*", System.lineSeparator(),
+                "# some fish",
+                "**/fish", "*_fish",
+                "# some colorful directories",
+                "red/", "blue/*/"};
+
+        try {
+            configureSourceDir(option);
+
+            writeFile(".gitignore", Arrays.asList(lines));
+            writeFile("thingone");
+            writeFile("thingtwo");
+
+            File dir = new File(sourceDir, "dir");
+            FileUtils.mkDir(dir);
+            FileUtils.writeFile(dir, "fish_two");
+            FileUtils.writeFile(dir, "fish");
+
+            dir = new File(sourceDir, "red");
+            FileUtils.mkDir(dir);
+            FileUtils.writeFile(dir, "fish");
+
+            dir = new File(sourceDir, "blue/fish");
+            FileUtils.mkDir(dir);
+            FileUtils.writeFile(dir, "dory");
+
+            dir = new File(sourceDir, "some");
+            FileUtils.mkDir(dir);
+            FileUtils.writeFile(dir, "fish");
+            FileUtils.writeFile(dir, "things");
+            FileUtils.writeFile(dir, "thingone");
+
+            dir = new File(sourceDir, "another");
+            FileUtils.mkDir(dir);
+            FileUtils.writeFile(dir, "red_fish");
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(11);
+            // .gitignore is ignored by default as it is hidden but not counted
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
+
+            config = generateConfig(ImmutablePair.of(option, args));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(8);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    // include tests
+    private void execIncludeTest(final Option option, final String[] args) {
+        Option excludeOption = Arg.EXCLUDE.option();
+        String[] notExcluded = {"B.bar", "justbaz", "notbaz"};
+        String[] excluded = {"some.foo"};
+        try {
+            configureSourceDir(option);
+            writeFile("notbaz");
+            writeFile("some.foo");
+            writeFile("B.bar");
+            writeFile("justbaz");
+
+            ReportConfiguration config = generateConfig(Collections.emptyList());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(4);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
+
+            // verify exclude removes most files.
+            config = generateConfig(ImmutablePair.of(excludeOption, EXCLUDE_ARGS));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            // .gitignore is ignored by default as it is hidden but not counted
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(3);
+
+            // verify include pust them back
+            config = generateConfig(ImmutablePair.of(option, args), ImmutablePair.of(excludeOption, EXCLUDE_ARGS));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
+            // .gitignore is ignored by default as it is hidden but not counted
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    private void includeFileTest(final Option option) {
+        File outputFile = FileUtils.writeFile(baseDir, "include.txt", Arrays.asList(INCLUDE_ARGS));
+        execIncludeTest(option, new String[]{outputFile.getAbsolutePath()});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputIncludeFileTest() {
+        includeFileTest(Arg.INCLUDE_FILE.find("input-include-file"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void includesFileTest() {
+        includeFileTest(Arg.INCLUDE_FILE.find("includes-file"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void includeTest() {
+        execIncludeTest(Arg.INCLUDE.find("include"), INCLUDE_ARGS);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputIncludeTest() {
+        execIncludeTest(Arg.INCLUDE.find("input-include"), INCLUDE_ARGS);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputIncludeStdTest() {
+        Option option = Arg.INCLUDE_STD.find("input-include-std");
+        String[] args = {StandardCollection.MISC.name()};
+        try {
+            configureSourceDir(option);
+
+            writeFile("afile~more");
+            writeFile("afile~");
+            writeFile(".#afile");
+            writeFile("%afile%");
+            writeFile("._afile");
+            writeFile("what.#afile");
+            writeFile("%afile%withMore");
+            writeFile("well._afile");
+
+            ImmutablePair<Option, String[]> excludes = ImmutablePair.of(Arg.EXCLUDE.find("input-exclude"),
+                    new String[]{"*~more", "*~"});
+
+            ReportConfiguration config = generateConfig(Collections.singletonList(excludes));
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(5);
+
+            config = generateConfig(excludes, ImmutablePair.of(option, args));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(7);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void inputSourceTest() {
+        Option option = Arg.SOURCE.find("input-source");
+        try {
+            configureSourceDir(option);
+
+            writeFile("codefile");
+            File inputFile = writeFile("intput.txt", "codefile");
+            writeFile("notcodFile");
+
+            ReportConfiguration config = generateConfig();
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
+
+            config = generateConfig(ImmutablePair.of(option, new String[]{inputFile.getAbsolutePath()}));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    private ReportConfiguration addCatzLicense(ReportConfiguration config) {
+        String catz = ILicenseFamily.makeCategory("catz");
+        config.addFamily(ILicenseFamily.builder().setLicenseFamilyCategory(catz).setLicenseFamilyName("catz").build());
+        config.addLicense(ILicense.builder().setFamily(catz)
+                .setMatcher(new SpdxBuilder().setName("catz")));
+        return config;
+    }
+
+    private void execLicenseFamiliesApprovedTest(final Option option, final String[] args) {
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
+        try {
+            configureSourceDir(option);
+            // write the catz licensed text file
+            writeFile("catz.txt", "SPDX-License-Identifier: catz");
+
+            ReportConfiguration config = addCatzLicense(generateConfig());
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+            config = addCatzLicense(generateConfig(arg1));
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licenseFamiliesApprovedFileTest() {
+        Option option = Arg.FAMILIES_APPROVED_FILE.find("license-families-approved-file");
+        File outputFile = FileUtils.writeFile(baseDir, "familiesApproved.txt", Collections.singletonList("catz"));
+        execLicenseFamiliesApprovedTest(option, new String[]{outputFile.getAbsolutePath()});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licenseFamiliesApprovedTest() {
+        execLicenseFamiliesApprovedTest(Arg.FAMILIES_APPROVED.find("license-families-approved"),
+                new String[]{"catz"});
+    }
+
+    private void execLicenseFamiliesDeniedTest(final Option option, final String[] args) {
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
+        String bsd = ILicenseFamily.makeCategory("BSD-3");
+        try {
+            configureSourceDir(option);
+
+            // write the catz licensed text file
+            writeFile("bsd.txt", "SPDX-License-Identifier: BSD-3-Clause");
+
+            ReportConfiguration config = generateConfig();
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
+
+            config = generateConfig(arg1);
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licenseFamiliesDeniedFileTest() {
+        File outputFile = FileUtils.writeFile(baseDir, "familiesDenied.txt", Collections.singletonList("BSD-3"));
+        execLicenseFamiliesDeniedTest(Arg.FAMILIES_DENIED_FILE.find("license-families-denied-file"),
+                new String[]{outputFile.getAbsolutePath()});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licenseFamiliesDeniedTest() {
+        execLicenseFamiliesDeniedTest(Arg.FAMILIES_DENIED.find("license-families-denied"),
+                new String[]{"BSD-3"});
+    }
+
+
+    private void configTest(final Option option) {
+        try {
+            configureSourceDir(option);
+            String[] args = {
+                    Resources.getResourceFile("OptionTools/One.xml").getAbsolutePath(),
+                    Resources.getResourceFile("OptionTools/Two.xml").getAbsolutePath()};
+
+            Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
+
+            writeFile("bsd.txt", "SPDX-License-Identifier: BSD-3-Clause");
+            writeFile("one.txt", "one is the lonelest number");
+
+            ReportConfiguration config = generateConfig();
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+            config = generateConfig(arg1);
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
+
+            Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.CONFIGURATION_NO_DEFAULTS.find("configuration-no-defaults"), null);
+
+            config = generateConfig(arg1, arg2);
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licensesTest() {
+        configTest(Arg.CONFIGURATION.find("licenses"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void configTest() {
+        configTest(Arg.CONFIGURATION.find("config"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void execLicensesApprovedTest(final Option option, String[] args) {
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
+
+        try {
+            configureSourceDir(option);
+
+            writeFile("gpl.txt", "SPDX-License-Identifier: GPL-1.0-only");
+            writeFile("apl.txt", "SPDX-License-Identifier: Apache-2.0");
+
+            ReportConfiguration config = generateConfig();
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+            config = generateConfig(arg1);
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
+
+
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licensesApprovedFileTest() {
+        File outputFile = FileUtils.writeFile(baseDir, "licensesApproved.txt", Collections.singletonList("GPL1"));
+        execLicensesApprovedTest(Arg.LICENSES_APPROVED_FILE.find("licenses-approved-file"),
+                new String[]{outputFile.getAbsolutePath()});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void licensesApprovedTest() {
+        execLicensesApprovedTest(Arg.LICENSES_APPROVED.find("licenses-approved"),
+                new String[]{"GPL1"});
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void scanHiddenDirectoriesTest() {
+        Option option = Arg.INCLUDE_STD.find("scan-hidden-directories");
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, null);
+
+        try {
+            configureSourceDir(option);
+
+            writeFile("apl.txt", "SPDX-License-Identifier: Apache-2.0");
+
+            File hiddenDir = new File(sourceDir, ".hiddendir");
+            FileUtils.mkDir(hiddenDir);
+            FileUtils.writeFile(hiddenDir, "gpl.txt", Collections.singletonList("SPDX-License-Identifier: GPL-1.0-only"));
+
+            ReportConfiguration config = generateConfig();
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
+
+            config = generateConfig(arg1);
+            reporter = new Reporter(config);
+            claimStatistic = reporter.execute();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    private void outTest(final Option option) {
+        try {
+            configureSourceDir(option);
+            writeFile("apl.txt", "SPDX-License-Identifier: Apache-2.0");
+            File outFile = new File(sourceDir, "outexample");
+            FileUtils.delete(outFile);
+            String[] args = new String[]{outFile.getAbsolutePath()};
+
+            ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.output();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
+
+            String actualText = TextUtils.readFile(outFile);
+            TextUtils.assertContainsExactly(1, "Apache License Version 2.0: 1 ", actualText);
+            TextUtils.assertContainsExactly(1, "STANDARD: 1 ", actualText);
+
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outTest() {
+        outTest(Arg.OUTPUT_FILE.find("out"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outputFileTest() {
+        outTest(Arg.OUTPUT_FILE.find("output-file"));
+    }
+
+    private void styleSheetTest(final Option option) {
+        PrintStream origin = System.out;
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (PrintStream out = new PrintStream(baos)) {
+            System.setOut(out);
+            configureSourceDir(option);
+            // create a dummy stylesheet so that we have a local file for users of the testing jar.
+            File file = writeFile("stylesheet", "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n" +
+                    "    <xsl:template match=\"@*|node()\">\n" +
+                    "        Hello world\n" +
+                    "    </xsl:template>\n" +
+                    "</xsl:stylesheet>");
+
+            String[] args = {null};
+            for (StyleSheets sheet : StyleSheets.values()) {
+                args[0] = sheet.arg();
+                ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
+                Reporter reporter = new Reporter(config);
+                ClaimStatistic claimStatistic = reporter.output();
+                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
+                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+                String actualText = baos.toString(StandardCharsets.UTF_8.name());
+                switch (sheet) {
+                    case MISSING_HEADERS:
+                        TextUtils.assertContainsExactly(1, "Files with missing headers:" + System.lineSeparator() +
+                                "  /stylesheet", actualText);
+                        break;
+                    case PLAIN:
+                        TextUtils.assertContainsExactly(1, "Unknown license: 1 ", actualText);
+                        TextUtils.assertContainsExactly(1, "?????: 1 ", actualText);
+                        break;
+                    case XML:
+                        TextUtils.assertContainsExactly(1, "<resource encoding=\"ISO-8859-1\" mediaType=\"text/plain\" name=\"/stylesheet\" type=\"STANDARD\">", actualText);
+                        break;
+                    case UNAPPROVED_LICENSES:
+                        TextUtils.assertContainsExactly(1, "Files with unapproved licenses:" + System.lineSeparator() + "  /stylesheet", actualText);
+                        break;
+                    default:
+                        fail("No test for stylesheet " + sheet);
+                        break;
+                }
+                baos.reset();
+            }
+            args[0] = file.getAbsolutePath();
+            ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.output();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+            String actualText = baos.toString(StandardCharsets.UTF_8.name());
+            TextUtils.assertContainsExactly(1, "Hello world", actualText);
+
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        } finally {
+            System.setOut(origin);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void stylesheetTest() {
+        styleSheetTest(Arg.OUTPUT_STYLE.find("stylesheet"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outputStyleTest() {
+        styleSheetTest(Arg.OUTPUT_STYLE.find("output-style"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void xmlTest() {
+        PrintStream origin = System.out;
+        Option option = Arg.OUTPUT_STYLE.find("xml");
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        try (PrintStream out = new PrintStream(baos)) {
+            System.setOut(out);
+            configureSourceDir(option);
+            // create a dummy stylesheet so that we match the stylesheet tests.
+            File file = writeFile("stylesheet", "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n" +
+                    "    <xsl:template match=\"@*|node()\">\n" +
+                    "        Hello world\n" +
+                    "    </xsl:template>\n" +
+                    "</xsl:stylesheet>");
+
+            ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.output();
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
+
+            String actualText = baos.toString(StandardCharsets.UTF_8.name());
+            TextUtils.assertContainsExactly(1, "<resource encoding=\"ISO-8859-1\" mediaType=\"text/plain\" name=\"/stylesheet\" type=\"STANDARD\">", actualText);
+
+            try (InputStream expected = StyleSheets.getStyleSheet("xml").get();
+                 InputStream actual = config.getStyleSheet().get()) {
+                assertThat(IOUtils.contentEquals(expected, actual)).as("'xml' does not match").isTrue();
+            }
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        } finally {
+            System.setOut(origin);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void logLevelTest() {
+        PrintStream origin = System.out;
+        Option option = Arg.LOG_LEVEL.find("log-level");
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        Log.Level oldLevel = DefaultLog.getInstance().getLevel();
+        try (PrintStream out = new PrintStream(baos)) {
+            System.setOut(out);
+            configureSourceDir(option);
+
+            ReportConfiguration config = generateConfig();
+            Reporter reporter = new Reporter(config);
+            reporter.output();
+            TextUtils.assertNotContains("DEBUG", baos.toString(StandardCharsets.UTF_8.name()));
+
+            config = generateConfig(ImmutablePair.of(option, new String[]{"debug"}));
+            reporter = new Reporter(config);
+            reporter.output();
+            TextUtils.assertContains("DEBUG", baos.toString(StandardCharsets.UTF_8.name()));
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        } finally {
+            System.setOut(origin);
+            DefaultLog.getInstance().setLevel(oldLevel);
+        }
+    }
+
+    private void listLicenses(final Option option) {
+        XPath xPath = XPathFactory.newInstance().newXPath();
+        String[] args = {null};
+
+        try {
+            configureSourceDir(option);
+            File outFile = new File(sourceDir, "out.xml");
+            FileUtils.delete(outFile);
+            ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
+            ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
+            for (LicenseSetFactory.LicenseFilter filter : LicenseSetFactory.LicenseFilter.values()) {
+                args[0] = filter.name();
+                ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
+                Reporter reporter = new Reporter(config);
+                reporter.output();
+                Document document = XmlUtils.toDom(new FileInputStream(outFile));
+                switch (filter) {
+                    case ALL:
+                        XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='AL']");
+                        XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='GPL1']");
+                        break;
+                    case APPROVED:
+                        XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='AL']");
+                        XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='GPL1']");
+                        break;
+                    case NONE:
+                        XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='AL']");
+                        XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='GPL1']");
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Unexpected filter: " + filter);
+                }
+            }
+        } catch (IOException | RatException | SAXException | ParserConfigurationException |
+                 XPathExpressionException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void listLicensesTest() {
+        listLicenses(Arg.OUTPUT_LICENSES.find("list-licenses"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outputLicensesTest() {
+        listLicenses(Arg.OUTPUT_LICENSES.find("output-licenses"));
+    }
+
+    private void listFamilies(final Option option) {
+        XPath xPath = XPathFactory.newInstance().newXPath();
+        String[] args = {null};
+
+        try {
+            configureSourceDir(option);
+            File outFile = new File(sourceDir, "out.xml");
+            FileUtils.delete(outFile);
+            ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
+            ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
+            for (LicenseSetFactory.LicenseFilter filter : LicenseSetFactory.LicenseFilter.values()) {
+                args[0] = filter.name();
+                ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
+                Reporter reporter = new Reporter(config);
+                reporter.output();
+                Document document = XmlUtils.toDom(Files.newInputStream(outFile.toPath()));
+                switch (filter) {
+                    case ALL:
+                        XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='AL']");
+                        XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='GPL']");
+                        break;
+                    case APPROVED:
+                        XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='AL']");
+                        XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='GPL']");
+                        break;
+                    case NONE:
+                        XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='AL']");
+                        XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='GPL']");
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Unexpected filter: " + filter);
+                }
+            }
+        } catch (IOException | RatException | SAXException | ParserConfigurationException |
+                 XPathExpressionException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void listFamiliesTest() {
+        listFamilies(Arg.OUTPUT_FAMILIES.find("list-families"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outputFamiliesTest() {
+        listFamilies(Arg.OUTPUT_FAMILIES.find("output-families"));
+    }
+
+    private void archiveTest(final Option option) {
+        XPath xPath = XPathFactory.newInstance().newXPath();
+        String[] args = {null};
+
+        try {
+            configureSourceDir(option);
+            File outFile = new File(sourceDir, "out.xml");
+            FileUtils.delete(outFile);
+            ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
+            ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
+            File archive = Resources.getResourceFile("tikaFiles/archive/dummy.jar");
+            File localArchive = new File(sourceDir, "dummy.jar");
+            try (InputStream in = Files.newInputStream(archive.toPath());
+                 OutputStream out = Files.newOutputStream(localArchive.toPath())) {
+                IOUtils.copy(in, out);
+            }
+
+            for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
+                args[0] = proc.name();
+                ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
+                Reporter reporter = new Reporter(config);
+                reporter.output();
+
+                Document document = XmlUtils.toDom(Files.newInputStream(outFile.toPath()));
+                XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']");
+                switch (proc) {
+                    case ABSENCE:
+                        XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='AL   ']");
+                        XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='?????']");
+                        break;
+                    case PRESENCE:
+                        XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='AL   ']");
+                        XmlUtils.assertIsNotPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='?????']");
+                        break;
+                    case NOTIFICATION:
+                        XmlUtils.assertIsNotPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='AL   ']");
+                        XmlUtils.assertIsNotPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='?????']");
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Unexpected processing " + proc);
+                }
+            }
+        } catch (IOException | RatException | SAXException | ParserConfigurationException |
+                 XPathExpressionException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outputArchiveTest() {
+        archiveTest(Arg.OUTPUT_ARCHIVE.find("output-archive"));
+    }
+
+    private void standardTest(final Option option) {
+        XPath xPath = XPathFactory.newInstance().newXPath();
+        String[] args = {null};
+
+        try {
+            configureSourceDir(option);
+            File outFile = new File(sourceDir, "out.xml");
+            ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
+            ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
+
+            writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Apache-2.0\n",
+                    "*/\n\n", "class Test {}\n"));
+            writeFile("Missing.java", Arrays.asList("/* no license */\n\n", "class Test {}\n"));
+
+            String testDoc = "/rat-report/resource[@name='/Test.java']";
+            String missingDoc = "/rat-report/resource[@name='/Missing.java']";
+
+            for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
+                args[0] = proc.name();
+                ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
+                Reporter reporter = new Reporter(config);
+                reporter.output();
+
+                Document document = XmlUtils.toDom(Files.newInputStream(outFile.toPath()));
+                XmlUtils.assertIsPresent(proc.name(), document, xPath, testDoc);
+                XmlUtils.assertIsPresent(proc.name(), document, xPath, missingDoc);
+
+                switch (proc) {
+                    case ABSENCE:
+                        XmlUtils.assertIsPresent(proc.name(), document, xPath, testDoc + "/license[@family='AL   ']");
+                        XmlUtils.assertIsPresent(proc.name(), document, xPath, missingDoc + "/license[@family='?????']");
+                        break;
+                    case PRESENCE:
+                        XmlUtils.assertIsPresent(proc.name(), document, xPath, testDoc + "/license[@family='AL   ']");
+                        XmlUtils.assertIsNotPresent(proc.name(), document, xPath, missingDoc + "/license[@family='?????']");
+                        break;
+                    case NOTIFICATION:
+                        XmlUtils.assertIsNotPresent(proc.name(), document, xPath, testDoc + "/license[@family='AL   ']");
+                        XmlUtils.assertIsNotPresent(proc.name(), document, xPath, missingDoc + "/license[@family='?????']");
+                        break;
+                    default:
+                        throw new IllegalArgumentException("Unexpected processing " + proc);
+                }
+            }
+        } catch (IOException | RatException | SAXException | ParserConfigurationException |
+                 XPathExpressionException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void outputStandardTest() {
+        standardTest(Arg.OUTPUT_STANDARD.find("output-standard"));
+    }
+
+    private void editCopyrightTest(final Option option, final Option extraOption) {
+        final String myCopyright = "MyCopyright";
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, new String[]{myCopyright});
+        final boolean forced = Arg.EDIT_OVERWRITE.option().equals(extraOption);
+        final boolean dryRun = Arg.DRY_RUN.option().equals(extraOption);
+        Pair<Option, String[]> extraArg = null;
+        if (forced || dryRun) {
+            extraArg = ImmutablePair.of(extraOption, null);
+        }
+
+        try {
+            configureSourceDir(option);
+            File javaFile = writeFile("Missing.java", Arrays.asList("/* no license */\n\n", "class Test {}\n"));
+            File newJavaFile = new File(sourceDir, "Missing.java.new");
+            FileUtils.delete(newJavaFile);
+
+            ReportConfiguration config = extraArg != null ? generateConfig(arg1, extraArg) : generateConfig(arg1);
+            Reporter reporter = new Reporter(config);
+            reporter.execute();
+
+            String actualText = TextUtils.readFile(javaFile);
+            TextUtils.assertNotContains(myCopyright, actualText);
+
+            Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.EDIT_ADD.find("edit-license"), null);
+            config = extraArg != null ? generateConfig(arg1, arg2, extraArg) : generateConfig(arg1, arg2);
+            reporter = new Reporter(config);
+            reporter.execute();
+
+            actualText = TextUtils.readFile(javaFile);
+            if (forced) {
+                TextUtils.assertContains(myCopyright, actualText);
+                assertThat(newJavaFile).doesNotExist();
+            } else if (dryRun) {
+                TextUtils.assertNotContains(myCopyright, actualText);
+                assertThat(newJavaFile).doesNotExist();
+            } else {
+                TextUtils.assertNotContains(myCopyright, actualText);
+                assertThat(newJavaFile).exists();
+            }
+        } catch (IOException | RatException e) {
+            fail(e.getMessage(), e);
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void copyrightTest() {
+        editCopyrightTest(Arg.EDIT_COPYRIGHT.find("copyright"), null);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void editCopyrightTest() {
+        editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), null);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void forceTest() {
+        editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), Arg.EDIT_OVERWRITE.find("force"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void editOverwriteTest() {
+        editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), Arg.EDIT_OVERWRITE.find("edit-overwrite"));
+    }
+
+    @OptionCollectionTest.TestFunction
+    @Override
+    public void helpTest() {
+        PrintStream origin = System.out;
+        Options options = OptionCollection.buildOptions();
+        Pair<Option, String[]> arg1 = ImmutablePair.of(OptionCollection.HELP, null);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        String actualText = null;
+        try (PrintStream out = new PrintStream(baos)) {
+            System.setOut(out);
+            configureSourceDir(OptionCollection.HELP);
+
+            ReportConfiguration config = generateConfig(Arrays.asList(arg1), true);
+            assertThat(helpCalled.get()).as("Help was not called").isTrue();
+            new Help(System.out).printUsage(options);
+            actualText = baos.toString(StandardCharsets.UTF_8.name());
+        } catch (IOException e) {
+            fail(e.getMessage(), e);
+        } finally {
+            System.setOut(origin);
+        }
+
+        // verify all the options
+        assertThat(actualText).contains("====== Available Options ======");
+        for (Option option : options.getOptions()) {
+            StringBuilder regex = new StringBuilder();
+            if (option.getOpt() != null) {
+                regex.append("-").append(option.getOpt());
+                if (option.hasLongOpt()) {
+                    regex.append(",");
+                }
+            }
+            if (option.hasLongOpt()) {
+                regex.append("--").append(option.getLongOpt());
+            }
+            if (option.hasArg()) {
+                String name = option.getArgName() == null ? "arg" : option.getArgName();
+                regex.append(".+\\<").append(name).append("\\>");
+            }
+            if (option.isDeprecated()) {
+                regex.append(".+\\[Deprecated ");
+            }
+            assertThat(Pattern.compile(regex.toString()).matcher(actualText).find()).as("missing '" + regex + "'").isTrue();
+        }
+
+        assertThat(actualText).contains("====== Argument Types ======");
+        assertThat(actualText).contains("====== Standard Collections ======");
+        for (StandardCollection collection : StandardCollection.values()) {
+            assertThat(actualText).contains("<" + collection.name() + ">");
+        }
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void helpLicensesTest() {
+        PrintStream origin = System.out;
+        Option option = HELP_LICENSES.option();
+        Pair<Option, String[]> arg1 = ImmutablePair.of(option, null);
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        String actualText = null;
+        try (PrintStream out = new PrintStream(baos)) {
+            System.setOut(out);
+            configureSourceDir(option);
+            ReportConfiguration config = generateConfig(arg1);
+            actualText = baos.toString(StandardCharsets.UTF_8.name());
+        } catch (IOException e) {
+            fail(e.getMessage(), e);
+        } finally {
+            System.setOut(origin);
+        }
+
+        assertThat(actualText).isNotNull();
+        TextUtils.assertContains("====== Licenses ======", actualText);
+        TextUtils.assertContains("====== Defined Matchers ======", actualText);
+        TextUtils.assertContains("====== Defined Families ======", actualText);
+    }
+
+    @OptionCollectionTest.TestFunction
+    protected void dryRunTest() {
+        editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), Arg.DRY_RUN.find("dry-run"));
+    }
+}
diff --git a/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsTest.java b/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsTest.java
index 78310566..9c7a389c 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/ReporterOptionsTest.java
@@ -1,69 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one   *
+ * or more contributor license agreements.  See the NOTICE file *
+ * distributed with this work for additional information        *
+ * regarding copyright ownership.  The ASF licenses this file   *
+ * to you under the Apache License, Version 2.0 (the            *
+ * "License"); you may not use this file except in compliance   *
+ * with the License.  You may obtain a copy of the License at   *
+ *                                                              *
+ *   http://www.apache.org/licenses/LICENSE-2.0                 *
+ *                                                              *
+ * Unless required by applicable law or agreed to in writing,   *
+ * software distributed under the License is distributed on an  *
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+ * KIND, either express or implied.  See the License for the    *
+ * specific language governing permissions and limitations      *
+ * under the License.                                           *
+ */
 package org.apache.rat;
 
-import java.io.ByteArrayOutputStream;
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileReader;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.PrintStream;
-import java.nio.charset.StandardCharsets;
-import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.regex.Pattern;
-import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.xpath.XPath;
 import javax.xml.xpath.XPathExpressionException;
 import javax.xml.xpath.XPathFactory;
-import org.apache.commons.cli.Option;
-import org.apache.commons.cli.Options;
-import org.apache.commons.io.FileUtils;
-import org.apache.commons.io.IOUtils;
-import org.apache.commons.lang3.tuple.ImmutablePair;
-import org.apache.commons.lang3.tuple.Pair;
 import org.apache.rat.api.RatException;
-import org.apache.rat.commandline.Arg;
-import org.apache.rat.commandline.StyleSheets;
-import org.apache.rat.config.exclusion.StandardCollection;
-import org.apache.rat.config.results.ClaimValidator;
-import org.apache.rat.configuration.builders.SpdxBuilder;
-import org.apache.rat.help.Help;
-import org.apache.rat.license.ILicense;
-import org.apache.rat.license.ILicenseFamily;
-import org.apache.rat.license.LicenseSetFactory;
 import org.apache.rat.report.claim.ClaimStatistic;
 import org.apache.rat.test.AbstractConfigurationOptionsProvider;
-import org.apache.rat.test.AbstractOptionsProvider;
-import org.apache.rat.test.utils.OptionFormatter;
-import org.apache.rat.test.utils.Resources;
-import org.apache.rat.testhelpers.TestingLog;
-import org.apache.rat.testhelpers.TextUtils;
+import org.apache.rat.testhelpers.FileUtils;
 import org.apache.rat.testhelpers.XmlUtils;
 import org.apache.rat.utils.DefaultLog;
 import org.apache.rat.utils.Log;
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.condition.EnabledOnOs;
 import org.junit.jupiter.api.condition.OS;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.ArgumentsProvider;
 import org.junit.jupiter.params.provider.ArgumentsSource;
-import org.w3c.dom.Document;
-import org.xml.sax.SAXException;
 
-import static org.apache.rat.commandline.Arg.HELP_LICENSES;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Fail.fail;
 
-public class ReporterOptionsTest {
+public final class ReporterOptionsTest {
 
     @TempDir
     static Path testPath;
@@ -73,24 +54,6 @@ public class ReporterOptionsTest {
         AbstractConfigurationOptionsProvider.preserveData(testPath.toFile(), "reporterOptionsTest");
     }
 
-    private static void mkDir(File dir) {
-        boolean ignored = dir.mkdirs();
-    }
-
-    private static void delete(File file) {
-        if (file.exists()) {
-            if (file.isDirectory()) {
-                try {
-                    FileUtils.deleteDirectory(file);
-                } catch (IOException ignore) {
-                    //
-                }
-            } else {
-                boolean ignored = file.delete();
-            }
-        }
-    }
-
     /**
      * This method is a known workaround for
      * {@link <a href="https://github.com/junit-team/junit5/issues/2811">junit 5 issue #2811</a> }.
@@ -112,1311 +75,32 @@ public class ReporterOptionsTest {
      */
     @ParameterizedTest( name = "{index} {0}")
     @ArgumentsSource(ReporterOptionsProvider.class)
-    public void testOptionsUpdateConfig(String name, OptionCollectionTest.OptionTest test) {
+    void testOptionsUpdateConfig(String name, OptionCollectionTest.OptionTest test) {
         DefaultLog.getInstance().log(Log.Level.INFO, "Running test for: " + name);
-        try {
-            test.test();
-        } catch (Exception e) {
-            fail("failed running "+name, e);
-            throw e;
-        }
+        test.test();
     }
 
-    /**
-     * A class to provide the Options and tests to the testOptionsUpdateConfig.
-     */
-    static class ReporterOptionsProvider extends AbstractOptionsProvider implements ArgumentsProvider {
-        private static File sourceDir;
-
-        /**
-         * A flag to determine if help was called
-         */
-        final AtomicBoolean helpCalled = new AtomicBoolean(false);
-
-        public ReporterOptionsProvider() {
-            super(testPath.toFile());
-            testMap.put("addLicense", this::addLicenseTest);
-            testMap.put("config", this::configTest);
-            testMap.put("configuration-no-defaults", this::configurationNoDefaultsTest);
-            testMap.put("copyright", this::copyrightTest);
-            testMap.put("counter-min", this::counterMinTest);
-            testMap.put("counter-max", this::counterMaxTest);
-            testMap.put("dir", () -> DefaultLog.getInstance().info("--dir has no valid test"));
-            testMap.put("dry-run", this::dryRunTest);
-            testMap.put("edit-copyright", this::editCopyrightTest);
-            testMap.put("edit-license", this::editLicensesTest);
-            testMap.put("edit-overwrite", this::editOverwriteTest);
-            testMap.put("exclude", this::excludeTest);
-            testMap.put("exclude-file", this::excludeFileTest);
-            testMap.put("force", this::forceTest);
-            testMap.put("help", this::helpTest);
-            testMap.put("help-licenses", this::helpLicenses);
-            testMap.put("include", this::includeTest);
-            testMap.put("includes-file", this::includesFileTest);
-            testMap.put("input-exclude", this::inputExcludeTest);
-            testMap.put("input-exclude-file", this::inputExcludeFileTest);
-            testMap.put("input-exclude-parsed-scm", this::inputExcludeParsedScmTest);
-            testMap.put("input-exclude-std", this::inputExcludeStdTest);
-            testMap.put("input-exclude-size", this::inputExcludeSizeTest);
-            testMap.put("input-include", this::inputIncludeTest);
-            testMap.put("input-include-file", this::inputIncludeFileTest);
-            testMap.put("input-include-std", this::inputIncludeStdTest);
-            testMap.put("input-source", this::inputSourceTest);
-            testMap.put("license-families-approved", this::licenseFamiliesApprovedTest);
-            testMap.put("license-families-approved-file", this::licenseFamiliesApprovedFileTest);
-            testMap.put("license-families-denied", this::licenseFamiliesDeniedTest);
-            testMap.put("license-families-denied-file", this::licenseFamiliesDeniedFileTest);
-            testMap.put("licenses", this::licensesTest);
-            testMap.put("licenses-approved", this::licensesApprovedTest);
-            testMap.put("licenses-approved-file", this::licensesApprovedFileTest);
-            testMap.put("licenses-denied", this::licensesDeniedTest);
-            testMap.put("licenses-denied-file", this::licensesDeniedFileTest);
-            testMap.put("list-families", this::listFamiliesTest);
-            testMap.put("list-licenses", this::listLicensesTest);
-            testMap.put("log-level", this::logLevelTest);
-            testMap.put("no-default-licenses", this::noDefaultsTest);
-            testMap.put("out", this::outTest);
-            testMap.put("output-archive", this::outputArchiveTest);
-            testMap.put("output-families", this::outputFamiliesTest);
-            testMap.put("output-file", this::outputFileTest);
-            testMap.put("output-licenses", this::outputLicensesTest);
-            testMap.put("output-standard", this::outputStandardTest);
-            testMap.put("output-style", this::outputStyleTest);
-            testMap.put("scan-hidden-directories", this::scanHiddenDirectoriesTest);
-            testMap.put("stylesheet", this::styleSheetTest);
-            testMap.put("xml", this::xmlTest);
-            super.validate(Collections.emptyList());
-        }
-
-        /**
-         * Generate a ReportConfiguration from a set of arguments.
-         * Forces the {@code helpCalled} flag to be reset.
-         *
-         * @param args the arguments.
-         * @return A ReportConfiguration
-         * @throws IOException on critical error.
-         */
-        @Override
-        protected final ReportConfiguration generateConfig(List<Pair<Option, String[]>> args) throws IOException {
-            return generateConfig(args, false);
-        }
-
-        protected final ReportConfiguration generateConfig(List<Pair<Option, String[]>> args, boolean helpExpected) throws IOException {
-            if (sourceDir == null) {
-                throw new IOException("sourceDir not set");
-            }
-            helpCalled.set(false);
-            List<String> sArgs = new ArrayList<>();
-            for (Pair<Option, String[]> pair : args) {
-                if (pair.getKey() != null) {
-                    sArgs.add("--" + pair.getKey().getLongOpt());
-                    String[] oArgs = pair.getValue();
-                    if (oArgs != null) {
-                        Collections.addAll(sArgs, oArgs);
-                    }
-                }
-            }
-            ReportConfiguration config = OptionCollection.parseCommands(sourceDir, sArgs.toArray(new String[0]), o -> helpCalled.set(true), true);
-            assertThat(helpCalled.get()).as("Help was called").isEqualTo(helpExpected);
-            if (config != null && !config.hasSource()) {
-                config.addSource(OptionCollection.getReportable(sourceDir, config));
-            }
-            return config;
-        }
-
-        private void configureSourceDir(Option option) {
-            configureSourceDir(option, false);
-        }
-
-        private void configureSourceDir(Option option, boolean forceClean) {
-            sourceDir = new File(baseDir, OptionFormatter.getName(option));
-            if (forceClean) {
-                delete(sourceDir);
-            }
-            mkDir(sourceDir);
-        }
-
-        private void validateNoArgSetup() throws IOException, RatException {
-            // verify that without args the report is ok.
-            TestingLog log = new TestingLog();
-            DefaultLog.setInstance(log);
-            try {
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                ClaimValidator validator = config.getClaimValidator();
-                assertThat(validator.listIssues(claimStatistic)).isEmpty();
-            } finally {
-                DefaultLog.setInstance(null);
-            }
-
-        }
-
-        protected void addLicenseTest() {
-            editLicenseTest(Arg.EDIT_ADD.find("addLicense"));
-        }
-
-        protected void editLicensesTest() {
-            editLicenseTest(Arg.EDIT_ADD.find("edit-license"));
-        }
-
-        private void editLicenseTest(final Option option) {
-            try {
-                configureSourceDir(option);
-                ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
-                File testFile = writeFile("NoLicense.java", "class NoLicense {}");
-                File resultFile = new File(sourceDir, "NoLicense.java.new");
-                delete(resultFile);
-
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic).isNotNull();
-                String contents = String.join("\n", IOUtils.readLines(new FileReader(testFile)));
-                assertThat(contents).isEqualTo("class NoLicense {}");
-                assertThat(resultFile).exists();
-                contents = String.join("\n", IOUtils.readLines(new FileReader(resultFile)));
-                assertThat(contents).isEqualTo("/*\n" +
-                        " * Licensed to the Apache Software Foundation (ASF) under one\n" +
-                        " * or more contributor license agreements.  See the NOTICE file\n" +
-                        " * distributed with this work for additional information\n" +
-                        " * regarding copyright ownership.  The ASF licenses this file\n" +
-                        " * to you under the Apache License, Version 2.0 (the\n" +
-                        " * \"License\"); you may not use this file except in compliance\n" +
-                        " * with the License.  You may obtain a copy of the License at\n" +
-                        " * \n" +
-                        " *   http://www.apache.org/licenses/LICENSE-2.0\n" +
-                        " * \n" +
-                        " * Unless required by applicable law or agreed to in writing,\n" +
-                        " * software distributed under the License is distributed on an\n" +
-                        " * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n" +
-                        " * KIND, either express or implied.  See the License for the\n" +
-                        " * specific language governing permissions and limitations\n" +
-                        " * under the License.\n" +
-                        " */\n\n" +
-                        "class NoLicense {}");
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected File writeFile(File dir, String name) {
-            return writeFile(dir, name, Collections.singletonList(name));
-        }
-
-        protected File writeFile(String name) {
-            return writeFile(sourceDir, name, Collections.singletonList(name));
-        }
-
-        protected File writeFile(String name, String content) {
-            return writeFile(sourceDir, name, Collections.singletonList(content));
-        }
-
-        protected File writeFile(String name, Iterable<String> content) {
-            return writeFile(sourceDir, name, content);
-        }
-
-        private void execLicensesDeniedTest(final Option option, final String[] args) {
-            try {
-                configureSourceDir(option);
-                File illumosFile = writeFile("illumousFile.java", "The contents of this file are " +
-                        "subject to the terms of the Common Development and Distribution License (the \"License\") You " +
-                        "may not use this file except in compliance with the License.");
-
-                validateNoArgSetup();
-
-                ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                ClaimValidator validator = config.getClaimValidator();
-                assertThat(validator.listIssues(claimStatistic)).containsExactly("UNAPPROVED");
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void licensesDeniedTest() {
-            execLicensesDeniedTest(Arg.LICENSES_DENIED.find("licenses-denied"), new String[]{"ILLUMOS"});
-        }
-
-        protected void licensesDeniedFileTest() {
-            File outputFile = writeFile(baseDir, "licensesDenied.txt", Collections.singletonList("ILLUMOS"));
-            execLicensesDeniedTest(Arg.LICENSES_DENIED_FILE.find("licenses-denied-file"),
-                    new String[]{outputFile.getAbsolutePath()});
-        }
-
-        private void noDefaultsTest(final Option option) {
-            try {
-                configureSourceDir(option);
-                File testFile = writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Apache-2.0\n",
-                        "*/\n\n", "class Test {}\n"));
-
-                validateNoArgSetup();
-
-                ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
-                Reporter reporter = new Reporter(config);
-                try {
-                    reporter.execute();
-                    fail("Should have thrown exception");
-                } catch (RatException e) {
-                    ClaimStatistic claimStatistic = reporter.getClaimsStatistic();
-                    ClaimValidator validator = config.getClaimValidator();
-                    assertThat(validator.listIssues(claimStatistic)).containsExactlyInAnyOrder("DOCUMENT_TYPES", "LICENSE_CATEGORIES", "LICENSE_NAMES", "STANDARDS");
-                }
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void noDefaultsTest() {
-            noDefaultsTest(Arg.CONFIGURATION_NO_DEFAULTS.find("no-default-licenses"));
-        }
-
-        protected void configurationNoDefaultsTest() {
-            noDefaultsTest(Arg.CONFIGURATION_NO_DEFAULTS.find("configuration-no-defaults"));
-        }
-
-        protected void counterMaxTest() {
-            Option option = Arg.COUNTER_MAX.option();
-            String[] arg = {null};
-            try {
-                configureSourceDir(option);
-                File testFile = writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Unapproved\n",
-                        "*/\n\n", "class Test {}\n"));
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                ClaimValidator validator = config.getClaimValidator();
-                assertThat(validator.listIssues(claimStatistic)).containsExactly("UNAPPROVED");
-
-                arg[0] = "Unapproved:1";
-                config = generateConfig(ImmutablePair.of(option, arg));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                validator = config.getClaimValidator();
-                assertThat(validator.listIssues(claimStatistic)).isEmpty();
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void counterMinTest() {
-            Option option = Arg.COUNTER_MIN.option();
-            String[] arg = {null};
-
-            try {
-                configureSourceDir(option);
-                File testFile = writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Unapproved\n",
-                        "*/\n\n", "class Test {}\n"));
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                ClaimValidator validator = config.getClaimValidator();
-                assertThat(validator.listIssues(claimStatistic)).containsExactly("UNAPPROVED");
-
-                arg[0] = "Unapproved:1";
-                config = generateConfig(ImmutablePair.of(option, arg));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                validator = config.getClaimValidator();
-                assertThat(validator.listIssues(claimStatistic)).isEmpty();
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        // exclude tests
-        private void execExcludeTest(final Option option, final String[] args) {
-            String[] notExcluded = {"notbaz", "well._afile"};
-            String[] excluded = {"some.foo", "B.bar", "justbaz"};
-            try {
-                configureSourceDir(option);
-                writeFile("notbaz");
-                writeFile("well._afile");
-                writeFile("some.foo");
-                writeFile("B.bar");
-                writeFile("justbaz");
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(5);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
-
-                // filter out source
-                config = generateConfig(ImmutablePair.of(option, args));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(3);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        private void excludeFileTest(final Option option) {
-            configureSourceDir(option);
-            File outputFile = writeFile(baseDir, "exclude.txt", Arrays.asList(EXCLUDE_ARGS));
-            execExcludeTest(option, new String[]{outputFile.getAbsolutePath()});
-        }
-
-        protected void excludeFileTest() {
-            excludeFileTest(Arg.EXCLUDE_FILE.find("exclude-file"));
-        }
-
-        protected void inputExcludeFileTest() {
-            excludeFileTest(Arg.EXCLUDE_FILE.find("input-exclude-file"));
-        }
-
-        protected void excludeTest() {
-            execExcludeTest(Arg.EXCLUDE.find("exclude"), EXCLUDE_ARGS);
-        }
-
-        protected void inputExcludeTest() {
-            execExcludeTest(Arg.EXCLUDE.find("input-exclude"), EXCLUDE_ARGS);
-        }
-
-        private void inputExcludeSizeTest() {
-            Option option = Arg.EXCLUDE_SIZE.option();
-            String[] args = {"5"};
-
-            try {
-                configureSourceDir(option);
-                writeFile("Hi.txt", "Hi");
-                writeFile("Hello.txt", "Hello");
-                writeFile("HelloWorld.txt", "HelloWorld");
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
-
-                // filter out source
-                config = generateConfig(ImmutablePair.of(option, args));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void inputExcludeStdTest() {
-            Option option = Arg.EXCLUDE_STD.find("input-exclude-std");
-            String[] args = {StandardCollection.MAVEN.name()};
-            // these files are excluded by default "afile~", ".#afile", "%afile%", "._afile"
-            // these files are not excluded by default "afile~more", "what.#afile", "%afile%withMore", "well._afile", "build.log"
-            // build.log is excluded by MAVEN.
-            try {
-                configureSourceDir(option);
-                writeFile("afile~");
-                writeFile(".#afile");
-                writeFile("%afile%");
-                writeFile("._afile");
-                writeFile("afile~more");
-                writeFile("what.#afile");
-                writeFile("%afile%withMore");
-                writeFile("well._afile");
-                writeFile("build.log");
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(5);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(4);
-
-                config = generateConfig(ImmutablePair.of(option, args));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(4);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(5);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void inputExcludeParsedScmTest() {
-            Option option = Arg.EXCLUDE_PARSE_SCM.find("input-exclude-parsed-scm");
-            String[] args = {"GIT"};
-            String[] lines = {
-                    "# somethings",
-                    "!thingone", "thing*", System.lineSeparator(),
-                    "# some fish",
-                    "**/fish", "*_fish",
-                    "# some colorful directories",
-                    "red/", "blue/*/"};
-
-            try {
-                configureSourceDir(option);
-
-                writeFile(".gitignore", Arrays.asList(lines));
-                writeFile("thingone");
-                writeFile("thingtwo");
-
-                File dir = new File(sourceDir, "dir");
-                mkDir(dir);
-                writeFile(dir, "fish_two");
-                writeFile(dir, "fish");
-
-                dir = new File(sourceDir, "red");
-                mkDir(dir);
-                writeFile(dir, "fish");
-
-                dir = new File(sourceDir, "blue/fish");
-                mkDir(dir);
-                writeFile(dir, "dory");
-
-                dir = new File(sourceDir, "some");
-                mkDir(dir);
-                writeFile(dir, "fish");
-                writeFile(dir, "things");
-                writeFile(dir, "thingone");
-
-                dir = new File(sourceDir, "another");
-                mkDir(dir);
-                writeFile(dir, "red_fish");
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(11);
-                // .gitignore is ignored by default as it is hidden but not counted
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
-
-                config = generateConfig(ImmutablePair.of(option, args));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(8);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        // include tests
-        private void execIncludeTest(final Option option, final String[] args) {
-            Option excludeOption = Arg.EXCLUDE.option();
-            String[] notExcluded = {"B.bar", "justbaz", "notbaz"};
-            String[] excluded = {"some.foo"};
-            try {
-                configureSourceDir(option);
-                writeFile("notbaz");
-                writeFile("some.foo");
-                writeFile("B.bar");
-                writeFile("justbaz");
-
-                ReportConfiguration config = generateConfig(Collections.emptyList());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(4);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
-
-                // verify exclude removes most files.
-                config = generateConfig(ImmutablePair.of(excludeOption, EXCLUDE_ARGS));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                // .gitignore is ignored by default as it is hidden but not counted
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(3);
-
-                // verify include pust them back
-                config = generateConfig(ImmutablePair.of(option, args), ImmutablePair.of(excludeOption, EXCLUDE_ARGS));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
-                // .gitignore is ignored by default as it is hidden but not counted
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        private void includeFileTest(final Option option) {
-            File outputFile = writeFile(baseDir, "include.txt", Arrays.asList(INCLUDE_ARGS));
-            execIncludeTest(option, new String[]{outputFile.getAbsolutePath()});
-        }
-
-        protected void inputIncludeFileTest() {
-            includeFileTest(Arg.INCLUDE_FILE.find("input-include-file"));
-        }
-
-        protected void includesFileTest() {
-            includeFileTest(Arg.INCLUDE_FILE.find("includes-file"));
-        }
-
-        protected void includeTest() {
-            execIncludeTest(Arg.INCLUDE.find("include"), INCLUDE_ARGS);
-        }
-
-        protected void inputIncludeTest() {
-            execIncludeTest(Arg.INCLUDE.find("input-include"), INCLUDE_ARGS);
-        }
-
-        protected void inputIncludeStdTest() {
-            Option option = Arg.INCLUDE_STD.find("input-include-std");
-            String[] args = {StandardCollection.MISC.name()};
-            try {
-                configureSourceDir(option);
-
-                writeFile("afile~more");
-                writeFile("afile~");
-                writeFile(".#afile");
-                writeFile("%afile%");
-                writeFile("._afile");
-                writeFile("what.#afile");
-                writeFile("%afile%withMore");
-                writeFile("well._afile");
-
-                ImmutablePair<Option, String[]> excludes = ImmutablePair.of(Arg.EXCLUDE.find("input-exclude"),
-                        new String[]{"*~more", "*~"});
-
-                ReportConfiguration config = generateConfig(Collections.singletonList(excludes));
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(5);
-
-                config = generateConfig(excludes, ImmutablePair.of(option, args));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(7);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(1);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void inputSourceTest() {
-            Option option = Arg.SOURCE.find("input-source");
-            try {
-                configureSourceDir(option);
-
-                writeFile("codefile");
-                File inputFile = writeFile("intput.txt", "codefile");
-                writeFile("notcodFile");
-
-                ReportConfiguration config = generateConfig();
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(3);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
-
-                config = generateConfig(ImmutablePair.of(option, new String[]{inputFile.getAbsolutePath()}));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(0);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        private ReportConfiguration addCatzLicense(ReportConfiguration config) {
-            String catz = ILicenseFamily.makeCategory("catz");
-            config.addFamily(ILicenseFamily.builder().setLicenseFamilyCategory(catz).setLicenseFamilyName("catz").build());
-            config.addLicense(ILicense.builder().setFamily(catz)
-                    .setMatcher(new SpdxBuilder().setName("catz")));
-            return config;
-        }
-
-        private void execLicenseFamiliesApprovedTest(final Option option, final String[] args) {
-            Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
-            try {
-                configureSourceDir(option);
-                // write the catz licensed text file
-                writeFile("catz.txt", "SPDX-License-Identifier: catz");
-
-                ReportConfiguration config = addCatzLicense(generateConfig());
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-                config = addCatzLicense(generateConfig(arg1));
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void licenseFamiliesApprovedFileTest() {
-            Option option = Arg.FAMILIES_APPROVED_FILE.find("license-families-approved-file");
-            File outputFile = writeFile(baseDir, "familiesApproved.txt", Collections.singletonList("catz"));
-            execLicenseFamiliesApprovedTest(option, new String[]{outputFile.getAbsolutePath()});
-        }
-
-        protected void licenseFamiliesApprovedTest() {
-            execLicenseFamiliesApprovedTest(Arg.FAMILIES_APPROVED.find("license-families-approved"),
-                    new String[]{"catz"});
-        }
-
-        private void execLicenseFamiliesDeniedTest(final Option option, final String[] args) {
-            Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
-            String bsd = ILicenseFamily.makeCategory("BSD-3");
-            try {
-                configureSourceDir(option);
-
-                // write the catz licensed text file
-                writeFile("bsd.txt", "SPDX-License-Identifier: BSD-3-Clause");
-
-                ReportConfiguration config = generateConfig();
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
-
-                config = generateConfig(arg1);
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void licenseFamiliesDeniedFileTest() {
-            File outputFile = writeFile(baseDir,"familiesDenied.txt", Collections.singletonList("BSD-3"));
-            execLicenseFamiliesDeniedTest(Arg.FAMILIES_DENIED_FILE.find("license-families-denied-file"),
-                    new String[]{outputFile.getAbsolutePath()});
-        }
-
-        protected void licenseFamiliesDeniedTest() {
-            execLicenseFamiliesDeniedTest(Arg.FAMILIES_DENIED.find("license-families-denied"),
-                    new String[]{"BSD-3"});
-        }
-
-
-        private void configTest(final Option option) {
-            try {
-                configureSourceDir(option);
-                String[] args = {
-                        Resources.getResourceFile("OptionTools/One.xml").getAbsolutePath(),
-                        Resources.getResourceFile("OptionTools/Two.xml").getAbsolutePath()};
-
-                Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
-
-                writeFile("bsd.txt", "SPDX-License-Identifier: BSD-3-Clause");
-                writeFile("one.txt", "one is the lonelest number");
-
-                ReportConfiguration config = generateConfig();
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-                config = generateConfig(arg1);
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
-
-                Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.CONFIGURATION_NO_DEFAULTS.find("configuration-no-defaults"), null);
-
-                config = generateConfig(arg1, arg2);
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void licensesTest() {
-            configTest(Arg.CONFIGURATION.find("licenses"));
-        }
-
-        protected void configTest() {
-            configTest(Arg.CONFIGURATION.find("config"));
-        }
-
-        protected void execLicensesApprovedTest(final Option option, String[] args) {
-            Pair<Option, String[]> arg1 = ImmutablePair.of(option, args);
-
-            try {
-                configureSourceDir(option);
-
-                writeFile("gpl.txt", "SPDX-License-Identifier: GPL-1.0-only");
-                writeFile("apl.txt", "SPDX-License-Identifier: Apache-2.0");
-
-                ReportConfiguration config = generateConfig();
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-                config = generateConfig(arg1);
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
-
-
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void licensesApprovedFileTest() {
-            File outputFile = writeFile(baseDir, "licensesApproved.txt", Collections.singletonList("GPL1"));
-            execLicensesApprovedTest(Arg.LICENSES_APPROVED_FILE.find("licenses-approved-file"),
-                    new String[]{outputFile.getAbsolutePath()});
-        }
-
-        protected void licensesApprovedTest() {
-            execLicensesApprovedTest(Arg.LICENSES_APPROVED.find("licenses-approved"),
-                    new String[]{"GPL1"});
-        }
-
-        protected void scanHiddenDirectoriesTest() {
-            Option option = Arg.INCLUDE_STD.find("scan-hidden-directories");
-            Pair<Option, String[]> arg1 = ImmutablePair.of(option, null);
-
-            try {
-                configureSourceDir(option);
-
-                writeFile("apl.txt", "SPDX-License-Identifier: Apache-2.0");
-
-                File hiddenDir = new File(sourceDir, ".hiddendir");
-                mkDir(hiddenDir);
-                writeFile(hiddenDir, "gpl.txt", Collections.singletonList("SPDX-License-Identifier: GPL-1.0-only"));
-
-                ReportConfiguration config = generateConfig();
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
-
-                config = generateConfig(arg1);
-                reporter = new Reporter(config);
-                claimStatistic = reporter.execute();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(2);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        private void outTest(final Option option) {
-            try {
-                configureSourceDir(option);
-                writeFile("apl.txt", "SPDX-License-Identifier: Apache-2.0");
-                File outFile = new File(sourceDir, "outexample");
-                delete(outFile);
-                String[] args = new String[]{outFile.getAbsolutePath()};
-
-                ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.output();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(0);
-
-                String actualText = TextUtils.readFile(outFile);
-                TextUtils.assertContainsExactly(1, "Apache License Version 2.0: 1 ", actualText);
-                TextUtils.assertContainsExactly(1, "STANDARD: 1 ", actualText);
-
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void outTest() {
-            outTest(Arg.OUTPUT_FILE.find("out"));
-        }
-
-        protected void outputFileTest() {
-            outTest(Arg.OUTPUT_FILE.find("output-file"));
-        }
-
-        private void styleSheetTest(final Option option) {
-            PrintStream origin = System.out;
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            try (PrintStream out = new PrintStream(baos)) {
-                System.setOut(out);
-                configureSourceDir(option);
-                // create a dummy stylesheet so that we have a local file for users of the testing jar.
-                File file = writeFile("stylesheet", "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n" +
-                        "    <xsl:template match=\"@*|node()\">\n" +
-                        "        Hello world\n" +
-                        "    </xsl:template>\n" +
-                        "</xsl:stylesheet>");
-
-                String[] args = {null};
-                for (StyleSheets sheet : StyleSheets.values()) {
-                    args[0] = sheet.arg();
-                    ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                    Reporter reporter = new Reporter(config);
-                    ClaimStatistic claimStatistic = reporter.output();
-                    assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                    assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
-                    assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-                    String actualText = baos.toString(StandardCharsets.UTF_8.name());
-                    switch (sheet) {
-                        case MISSING_HEADERS:
-                            TextUtils.assertContainsExactly(1, "Files with missing headers:" + System.lineSeparator() +
-                                    "  /stylesheet", actualText);
-                            break;
-                        case PLAIN:
-                            TextUtils.assertContainsExactly(1, "Unknown license: 1 ", actualText);
-                            TextUtils.assertContainsExactly(1, "?????: 1 ", actualText);
-                            break;
-                        case XML:
-                            TextUtils.assertContainsExactly(1, "<resource encoding=\"ISO-8859-1\" mediaType=\"text/plain\" name=\"/stylesheet\" type=\"STANDARD\">", actualText);
-                            break;
-                        case UNAPPROVED_LICENSES:
-                            TextUtils.assertContainsExactly(1, "Files with unapproved licenses:" + System.lineSeparator() + "  /stylesheet", actualText);
-                            break;
-                        default:
-                            fail("No test for stylesheet " + sheet);
-                            break;
-                    }
-                    baos.reset();
-                }
-                args[0] = file.getAbsolutePath();
-                ReportConfiguration config = generateConfig(ImmutablePair.of(option, args));
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.output();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-                String actualText = baos.toString(StandardCharsets.UTF_8.name());
-                TextUtils.assertContainsExactly(1, "Hello world", actualText);
-
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            } finally {
-                System.setOut(origin);
-            }
-        }
-
-        protected void styleSheetTest() {
-            styleSheetTest(Arg.OUTPUT_STYLE.find("stylesheet"));
-        }
-
-        protected void outputStyleTest() {
-            styleSheetTest(Arg.OUTPUT_STYLE.find("output-style"));
-        }
-
-        protected void xmlTest() {
-            PrintStream origin = System.out;
-            Option option = Arg.OUTPUT_STYLE.find("xml");
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            try (PrintStream out = new PrintStream(baos)) {
-                System.setOut(out);
-                configureSourceDir(option);
-                // create a dummy stylesheet so that we match the stylesheet tests.
-                File file = writeFile("stylesheet", "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n" +
-                        "    <xsl:template match=\"@*|node()\">\n" +
-                        "        Hello world\n" +
-                        "    </xsl:template>\n" +
-                        "</xsl:stylesheet>");
-
-                ReportConfiguration config = generateConfig(ImmutablePair.of(option, null));
-                Reporter reporter = new Reporter(config);
-                ClaimStatistic claimStatistic = reporter.output();
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(1);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.APPROVED)).isEqualTo(0);
-                assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.UNAPPROVED)).isEqualTo(1);
-
-                String actualText = baos.toString(StandardCharsets.UTF_8.name());
-                TextUtils.assertContainsExactly(1, "<resource encoding=\"ISO-8859-1\" mediaType=\"text/plain\" name=\"/stylesheet\" type=\"STANDARD\">", actualText);
-
-                try (InputStream expected = StyleSheets.getStyleSheet("xml").get();
-                     InputStream actual = config.getStyleSheet().get()) {
-                    assertThat(IOUtils.contentEquals(expected, actual)).as("'xml' does not match").isTrue();
-                }
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            } finally {
-                System.setOut(origin);
-            }
-        }
-
-        protected void logLevelTest() {
-            PrintStream origin = System.out;
-            Option option = Arg.LOG_LEVEL.find("log-level");
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            Log.Level oldLevel = DefaultLog.getInstance().getLevel();
-            try (PrintStream out = new PrintStream(baos)) {
-                System.setOut(out);
-                configureSourceDir(option);
-
-                ReportConfiguration config = generateConfig();
-                Reporter reporter = new Reporter(config);
-                reporter.output();
-                TextUtils.assertNotContains("DEBUG", baos.toString(StandardCharsets.UTF_8.name()));
-
-                config = generateConfig(ImmutablePair.of(option, new String[]{"debug"}));
-                reporter = new Reporter(config);
-                reporter.output();
-                TextUtils.assertContains("DEBUG", baos.toString(StandardCharsets.UTF_8.name()));
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            } finally {
-                System.setOut(origin);
-                DefaultLog.getInstance().setLevel(oldLevel);
-            }
-        }
-
-        private void listLicenses(final Option option) {
-            XPath xPath = XPathFactory.newInstance().newXPath();
-            String[] args = {null};
-
-            try {
-                configureSourceDir(option);
-                File outFile = new File(sourceDir, "out.xml");
-                delete(outFile);
-                ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
-                ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
-                for (LicenseSetFactory.LicenseFilter filter : LicenseSetFactory.LicenseFilter.values()) {
-                    args[0] = filter.name();
-                    ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
-                    Reporter reporter = new Reporter(config);
-                    reporter.output();
-                    Document document = XmlUtils.toDom(new FileInputStream(outFile));
-                    switch (filter) {
-                        case ALL:
-                            XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='AL']");
-                            XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='GPL1']");
-                            break;
-                        case APPROVED:
-                            XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='AL']");
-                            XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='GPL1']");
-                            break;
-                        case NONE:
-                            XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='AL']");
-                            XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/licenses/license[@id='GPL1']");
-                            break;
-                        default:
-                            throw new IllegalArgumentException("Unexpected filter: " + filter);
-                    }
-                }
-            } catch (IOException | RatException | SAXException | ParserConfigurationException |
-                     XPathExpressionException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void listLicensesTest() {
-            listLicenses(Arg.OUTPUT_LICENSES.find("list-licenses"));
-        }
-
-        protected void outputLicensesTest() {
-            listLicenses(Arg.OUTPUT_LICENSES.find("output-licenses"));
-        }
-
-        private void listFamilies(final Option option) {
-            XPath xPath = XPathFactory.newInstance().newXPath();
-            String[] args = {null};
-
-            try {
-                configureSourceDir(option);
-                File outFile = new File(sourceDir, "out.xml");
-                delete(outFile);
-                ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
-                ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
-                for (LicenseSetFactory.LicenseFilter filter : LicenseSetFactory.LicenseFilter.values()) {
-                    args[0] = filter.name();
-                    ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
-                    Reporter reporter = new Reporter(config);
-                    reporter.output();
-                    Document document = XmlUtils.toDom(Files.newInputStream(outFile.toPath()));
-                    switch (filter) {
-                        case ALL:
-                            XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='AL']");
-                            XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='GPL']");
-                            break;
-                        case APPROVED:
-                            XmlUtils.assertIsPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='AL']");
-                            XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='GPL']");
-                            break;
-                        case NONE:
-                            XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='AL']");
-                            XmlUtils.assertIsNotPresent(filter.name(), document, xPath, "/rat-report/rat-config/families/family[@id='GPL']");
-                            break;
-                        default:
-                            throw new IllegalArgumentException("Unexpected filter: " + filter);
-                    }
-                }
-            } catch (IOException | RatException | SAXException | ParserConfigurationException |
-                     XPathExpressionException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void listFamiliesTest() {
-            listFamilies(Arg.OUTPUT_FAMILIES.find("list-families"));
-        }
-
-        protected void outputFamiliesTest() {
-            listFamilies(Arg.OUTPUT_FAMILIES.find("output-families"));
-        }
-
-        private void archiveTest(final Option option) {
-            XPath xPath = XPathFactory.newInstance().newXPath();
-            String[] args = {null};
-
-            try {
-                configureSourceDir(option);
-                File outFile = new File(sourceDir, "out.xml");
-                delete(outFile);
-                ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
-                ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
-                File archive = Resources.getResourceFile("tikaFiles/archive/dummy.jar");
-                File localArchive = new File(sourceDir, "dummy.jar");
-                try (InputStream in = Files.newInputStream(archive.toPath());
-                     OutputStream out = Files.newOutputStream(localArchive.toPath())) {
-                     IOUtils.copy(in, out);
-                }
-
-                for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
-                    args[0] = proc.name();
-                    ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
-                    Reporter reporter = new Reporter(config);
-                    reporter.output();
-
-                    Document document = XmlUtils.toDom(Files.newInputStream(outFile.toPath()));
-                    XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']");
-                    switch (proc) {
-                        case ABSENCE:
-                            XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='AL   ']");
-                            XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='?????']");
-                            break;
-                        case PRESENCE:
-                            XmlUtils.assertIsPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='AL   ']");
-                            XmlUtils.assertIsNotPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='?????']");
-                            break;
-                        case NOTIFICATION:
-                            XmlUtils.assertIsNotPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='AL   ']");
-                            XmlUtils.assertIsNotPresent(proc.name(), document, xPath, "/rat-report/resource[@name='/dummy.jar']/license[@family='?????']");
-                            break;
-                        default:
-                            throw new IllegalArgumentException("Unexpected processing " + proc);
-                    }
-                }
-            } catch (IOException | RatException | SAXException | ParserConfigurationException |
-                     XPathExpressionException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void outputArchiveTest() {
-            archiveTest(Arg.OUTPUT_ARCHIVE.find("output-archive"));
-        }
-
-        private void standardTest(final Option option) {
-            XPath xPath = XPathFactory.newInstance().newXPath();
-            String[] args = {null};
-
-            try {
-                configureSourceDir(option);
-                File outFile = new File(sourceDir, "out.xml");
-                ImmutablePair<Option, String[]> outputFile = ImmutablePair.of(Arg.OUTPUT_FILE.option(), new String[]{outFile.getAbsolutePath()});
-                ImmutablePair<Option, String[]> stylesheet = ImmutablePair.of(Arg.OUTPUT_STYLE.option(), new String[]{StyleSheets.XML.arg()});
-
-                writeFile("Test.java", Arrays.asList("/*\n", "SPDX-License-Identifier: Apache-2.0\n",
-                        "*/\n\n", "class Test {}\n"));
-                writeFile("Missing.java", Arrays.asList("/* no license */\n\n", "class Test {}\n"));
-
-                String testDoc = "/rat-report/resource[@name='/Test.java']";
-                String missingDoc = "/rat-report/resource[@name='/Missing.java']";
-
-                for (ReportConfiguration.Processing proc : ReportConfiguration.Processing.values()) {
-                    args[0] = proc.name();
-                    ReportConfiguration config = generateConfig(outputFile, stylesheet, ImmutablePair.of(option, args));
-                    Reporter reporter = new Reporter(config);
-                    reporter.output();
-
-                    Document document = XmlUtils.toDom(Files.newInputStream(outFile.toPath()));
-                    XmlUtils.assertIsPresent(proc.name(), document, xPath, testDoc);
-                    XmlUtils.assertIsPresent(proc.name(), document, xPath, missingDoc);
-
-                    switch (proc) {
-                        case ABSENCE:
-                            XmlUtils.assertIsPresent(proc.name(), document, xPath, testDoc + "/license[@family='AL   ']");
-                            XmlUtils.assertIsPresent(proc.name(), document, xPath, missingDoc + "/license[@family='?????']");
-                            break;
-                        case PRESENCE:
-                            XmlUtils.assertIsPresent(proc.name(), document, xPath, testDoc + "/license[@family='AL   ']");
-                            XmlUtils.assertIsNotPresent(proc.name(), document, xPath, missingDoc + "/license[@family='?????']");
-                            break;
-                        case NOTIFICATION:
-                            XmlUtils.assertIsNotPresent(proc.name(), document, xPath, testDoc + "/license[@family='AL   ']");
-                            XmlUtils.assertIsNotPresent(proc.name(), document, xPath, missingDoc + "/license[@family='?????']");
-                            break;
-                        default:
-                            throw new IllegalArgumentException("Unexpected processing " + proc);
-                    }
-                }
-            } catch (IOException | RatException | SAXException | ParserConfigurationException |
-                     XPathExpressionException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void outputStandardTest() {
-            standardTest(Arg.OUTPUT_STANDARD.find("output-standard"));
-        }
-
-        private void editCopyrightTest(final Option option, final Option extraOption) {
-            final String myCopyright = "MyCopyright";
-            Pair<Option, String[]> arg1 = ImmutablePair.of(option, new String[]{myCopyright});
-            final boolean forced = Arg.EDIT_OVERWRITE.option().equals(extraOption);
-            final boolean dryRun = Arg.DRY_RUN.option().equals(extraOption);
-            Pair<Option, String[]> extraArg = null;
-            if (forced || dryRun) {
-                extraArg = ImmutablePair.of(extraOption, null);
-            }
-
-            try {
-                configureSourceDir(option);
-                File javaFile = writeFile("Missing.java", Arrays.asList("/* no license */\n\n", "class Test {}\n"));
-                File newJavaFile = new File(sourceDir, "Missing.java.new");
-                delete(newJavaFile);
-
-                ReportConfiguration config = extraArg != null ? generateConfig(arg1, extraArg) : generateConfig(arg1);
-                Reporter reporter = new Reporter(config);
-                reporter.execute();
-
-                String actualText = TextUtils.readFile(javaFile);
-                TextUtils.assertNotContains(myCopyright, actualText);
-
-                Pair<Option, String[]> arg2 = ImmutablePair.of(Arg.EDIT_ADD.find("edit-license"), null);
-                config = extraArg != null ? generateConfig(arg1, arg2, extraArg) : generateConfig(arg1, arg2);
-                reporter = new Reporter(config);
-                reporter.execute();
-
-                actualText = TextUtils.readFile(javaFile);
-                if (forced) {
-                    TextUtils.assertContains(myCopyright, actualText);
-                    assertThat(newJavaFile).doesNotExist();
-                } else if (dryRun) {
-                    TextUtils.assertNotContains(myCopyright, actualText);
-                    assertThat(newJavaFile).doesNotExist();
-                } else {
-                    TextUtils.assertNotContains(myCopyright, actualText);
-                    assertThat(newJavaFile).exists();
-                }
-            } catch (IOException | RatException e) {
-                fail(e.getMessage(), e);
-            }
-        }
-
-        protected void copyrightTest() {
-            editCopyrightTest(Arg.EDIT_COPYRIGHT.find("copyright"), null);
-        }
-
-        protected void editCopyrightTest() {
-            editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), null);
-        }
-
-        protected void forceTest() {
-            editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), Arg.EDIT_OVERWRITE.find("force"));
-        }
-
-        protected void editOverwriteTest() {
-            editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), Arg.EDIT_OVERWRITE.find("edit-overwrite"));
-        }
-
-        @Override
-        public void helpTest() {
-            PrintStream origin = System.out;
-            Options options = OptionCollection.buildOptions();
-            Pair<Option, String[]> arg1 = ImmutablePair.of(OptionCollection.HELP, null);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            String actualText = null;
-            try (PrintStream out = new PrintStream(baos)) {
-                System.setOut(out);
-                configureSourceDir(OptionCollection.HELP);
-
-                ReportConfiguration config = generateConfig(Arrays.asList(arg1), true);
-                assertThat(helpCalled.get()).as("Help was not called").isTrue();
-                new Help(System.out).printUsage(options);
-                actualText = baos.toString(StandardCharsets.UTF_8.name());
-            } catch (IOException e) {
-                fail(e.getMessage(), e);
-            } finally {
-                System.setOut(origin);
-            }
-
-            // verify all the options
-            assertThat(actualText).contains("====== Available Options ======");
-            for (Option option : options.getOptions()) {
-                StringBuilder regex = new StringBuilder();
-                if (option.getOpt() != null) {
-                    regex.append("-").append(option.getOpt());
-                    if (option.hasLongOpt()) {
-                        regex.append(",");
-                    }
-                }
-                if (option.hasLongOpt()) {
-                    regex.append("--").append(option.getLongOpt());
-                }
-                if (option.hasArg()) {
-                    String name = option.getArgName() == null ? "arg" : option.getArgName();
-                    regex.append(".+\\<").append(name).append("\\>");
-                }
-                if (option.isDeprecated()) {
-                    regex.append(".+\\[Deprecated ");
-                }
-                assertThat(Pattern.compile(regex.toString()).matcher(actualText).find()).as("missing '" + regex + "'").isTrue();
-            }
-
-            assertThat(actualText).contains("====== Argument Types ======");
-            assertThat(actualText).contains("====== Standard Collections ======");
-            for (StandardCollection collection : StandardCollection.values()) {
-                assertThat(actualText).contains("<" + collection.name() + ">");
-            }
-        }
-
-        protected void helpLicenses() {
-            PrintStream origin = System.out;
-            Option option = HELP_LICENSES.option();
-            Pair<Option, String[]> arg1 = ImmutablePair.of(option, null);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            String actualText = null;
-            try (PrintStream out = new PrintStream(baos)) {
-                System.setOut(out);
-                configureSourceDir(option);
-                ReportConfiguration config = generateConfig(arg1);
-                actualText = baos.toString(StandardCharsets.UTF_8.name());
-            } catch (IOException e) {
-                fail(e.getMessage(), e);
-            } finally {
-                System.setOut(origin);
-            }
-
-            assertThat(actualText).isNotNull();
-            TextUtils.assertContains("====== Licenses ======", actualText);
-            TextUtils.assertContains("====== Defined Matchers ======", actualText);
-            TextUtils.assertContains("====== Defined Families ======", actualText);
-        }
-
-        protected void dryRunTest() {
-            editCopyrightTest(Arg.EDIT_COPYRIGHT.find("edit-copyright"), Arg.DRY_RUN.find("dry-run"));
+    @Test
+    void testRat362() {
+        File testDir = new File(testPath.toFile(), "RAT_362");
+        String[] args = {"--output-style", "xml", "--input-exclude-parsed-scm", "GIT", "--", testDir.getAbsolutePath()};
+        try {
+            FileUtils.mkDir(testDir);
+            FileUtils.writeFile(testDir, ".gitignore", "/foo.md");
+            FileUtils.writeFile(testDir, "foo.md");
+            ReportConfiguration config = OptionCollection.parseCommands(testDir, args, o -> fail("Help called"), true);
+            Reporter reporter = new Reporter(config);
+            ClaimStatistic claimStatistic = reporter.execute();
+            XmlUtils.printDocument(System.out, reporter.getDocument());
+            XPath xpath = XPathFactory.newInstance().newXPath();
+            XmlUtils.assertIsPresent(reporter.getDocument(), xpath, "/rat-report/resource[@name='/foo.md']");
+            XmlUtils.assertAttributes(reporter.getDocument(), xpath, "/rat-report/resource[@name='/foo.md']",
+                    XmlUtils.mapOf("type", "IGNORED"));
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.STANDARDS)).isEqualTo(0);
+            assertThat(claimStatistic.getCounter(ClaimStatistic.Counter.IGNORED)).isEqualTo(2);
+        } catch (IOException | RatException | XPathExpressionException e) {
+            fail(e);
         }
     }
+
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractConfigurationOptionsProvider.java b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractConfigurationOptionsProvider.java
index 2e332176..62287847 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractConfigurationOptionsProvider.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractConfigurationOptionsProvider.java
@@ -25,6 +25,7 @@ import org.apache.commons.io.FileUtils;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.tuple.ImmutablePair;
 import org.apache.commons.lang3.tuple.Pair;
+import org.apache.rat.OptionCollectionTest;
 import org.apache.rat.ReportConfiguration;
 import org.apache.rat.ReporterTest;
 import org.apache.rat.commandline.Arg;
@@ -99,56 +100,56 @@ public abstract class AbstractConfigurationOptionsProvider extends AbstractOptio
 
     protected AbstractConfigurationOptionsProvider(final Collection<String> unsupportedArgs, final File baseDir) {
         super(setup(baseDir));
-        testMap.put("addLicense", this::addLicenseTest);
-        testMap.put("config", this::configTest);
-        testMap.put("configuration-no-defaults", this::configurationNoDefaultsTest);
-        testMap.put("copyright", this::copyrightTest);
-        testMap.put("counter-min", this::counterMinTest);
-        testMap.put("counter-max", this::counterMaxTest);
-        testMap.put("dir", () -> DefaultLog.getInstance().info("--dir has no valid test"));
-        testMap.put("dry-run", this::dryRunTest);
-        testMap.put("edit-copyright", this::editCopyrightTest);
-        testMap.put("edit-license", this::editLicensesTest);
-        testMap.put("edit-overwrite", this::editOverwriteTest);
-        testMap.put("exclude", this::excludeTest);
-        testMap.put("exclude-file", this::excludeFileTest);
-        testMap.put("force", this::forceTest);
-        testMap.put("help", this::helpTest);
-        testMap.put("help-licenses", this::helpLicenses);
-        testMap.put("include", this::includeTest);
-        testMap.put("includes-file", this::includesFileTest);
-        testMap.put("input-exclude", this::inputExcludeTest);
-        testMap.put("input-exclude-file", this::inputExcludeFileTest);
-        testMap.put("input-exclude-parsed-scm", this::inputExcludeParsedScmTest);
-        testMap.put("input-exclude-std", this::inputExcludeStdTest);
-        testMap.put("input-exclude-size", this::inputExcludeSizeTest);
-        testMap.put("input-include", this::inputIncludeTest);
-        testMap.put("input-include-file", this::inputIncludeFileTest);
-        testMap.put("input-include-std", this::inputIncludeStdTest);
-        testMap.put("input-source", this::inputSourceTest);
-        testMap.put("license-families-approved", this::licenseFamiliesApprovedTest);
-        testMap.put("license-families-approved-file", this::licenseFamiliesApprovedFileTest);
-        testMap.put("license-families-denied", this::licenseFamiliesDeniedTest);
-        testMap.put("license-families-denied-file", this::licenseFamiliesDeniedFileTest);
-        testMap.put("licenses", this::licensesTest);
-        testMap.put("licenses-approved", this::licensesApprovedTest);
-        testMap.put("licenses-approved-file", this::licensesApprovedFileTest);
-        testMap.put("licenses-denied", this::licensesDeniedTest);
-        testMap.put("licenses-denied-file", this::licensesDeniedFileTest);
-        testMap.put("list-families", this::listFamiliesTest);
-        testMap.put("list-licenses", this::listLicensesTest);
-        testMap.put("log-level", this::logLevelTest);
-        testMap.put("no-default-licenses", this::noDefaultsTest);
-        testMap.put("out", this::outTest);
-        testMap.put("output-archive", this::outputArchiveTest);
-        testMap.put("output-families", this::outputFamiliesTest);
-        testMap.put("output-file", this::outputFileTest);
-        testMap.put("output-licenses", this::outputLicensesTest);
-        testMap.put("output-standard", this::outputStandardTest);
-        testMap.put("output-style", this::outputStyleTest);
-        testMap.put("scan-hidden-directories", this::scanHiddenDirectoriesTest);
-        testMap.put("stylesheet", this::styleSheetTest);
-        testMap.put("xml", this::xmlTest);
+        addTest(OptionCollectionTest.OptionTest.namedTest("addLicense", this::addLicenseTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("config", this::configTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("configuration-no-defaults", this::configurationNoDefaultsTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("copyright", this::copyrightTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("counter-min", this::counterMinTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("counter-max", this::counterMaxTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("dir", () -> DefaultLog.getInstance().info("--dir has no valid test")));
+        addTest(OptionCollectionTest.OptionTest.namedTest("dry-run", this::dryRunTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("edit-copyright", this::editCopyrightTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("edit-license", this::editLicenseTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("edit-overwrite", this::editOverwriteTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("exclude", this::excludeTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("exclude-file", this::excludeFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("force", this::forceTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("help", this::helpTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("help-licenses", this::helpLicenses));
+        addTest(OptionCollectionTest.OptionTest.namedTest("include", this::includeTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("includes-file", this::includesFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-exclude", this::inputExcludeTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-exclude-file", this::inputExcludeFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-exclude-parsed-scm", this::inputExcludeParsedScmTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-exclude-std", this::inputExcludeStdTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-exclude-size", this::inputExcludeSizeTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-include", this::inputIncludeTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-include-file", this::inputIncludeFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-include-std", this::inputIncludeStdTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("input-source", this::inputSourceTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("license-families-approved", this::licenseFamiliesApprovedTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("license-families-approved-file", this::licenseFamiliesApprovedFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("license-families-denied", this::licenseFamiliesDeniedTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("license-families-denied-file", this::licenseFamiliesDeniedFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("licenses", this::licensesTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("licenses-approved", this::licensesApprovedTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("licenses-approved-file", this::licensesApprovedFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("licenses-denied", this::licensesDeniedTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("licenses-denied-file", this::licensesDeniedFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("list-families", this::listFamiliesTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("list-licenses", this::listLicensesTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("log-level", this::logLevelTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("no-default-licenses", this::noDefaultsTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("out", this::outTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("output-archive", this::outputArchiveTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("output-families", this::outputFamiliesTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("output-file", this::outputFileTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("output-licenses", this::outputLicensesTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("output-standard", this::outputStandardTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("output-style", this::outputStyleTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("scan-hidden-directories", this::scanHiddenDirectoriesTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("stylesheet", this::styleSheetTest));
+        addTest(OptionCollectionTest.OptionTest.namedTest("xml", this::xmlTest));
         super.validate(unsupportedArgs);
     }
 
@@ -628,7 +629,7 @@ public abstract class AbstractConfigurationOptionsProvider extends AbstractOptio
         editLicenseTest(Arg.EDIT_ADD.find("addLicense"));
     }
 
-    protected void editLicensesTest() {
+    protected void editLicenseTest() {
         editLicenseTest(Arg.EDIT_ADD.find("edit-license"));
     }
 
diff --git a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
index 24153f1e..dac4b415 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/test/AbstractOptionsProvider.java
@@ -19,14 +19,13 @@
 package org.apache.rat.test;
 
 import java.io.File;
-import java.io.FileWriter;
 import java.io.IOException;
-import java.io.PrintWriter;
 import java.nio.file.FileSystems;
 import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.TreeMap;
@@ -81,6 +80,14 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
         }
     }
 
+    protected void processTestFunctionAnnotations() {
+        testMap.putAll(OptionCollectionTest.processTestFunctionAnnotations(this));
+    }
+
+    protected void addTest(OptionCollectionTest.OptionTest test) {
+        testMap.put(test.toString(), test);
+    }
+
     /**
      * Gets the document name based on the baseDir.
      * @return The document name based on the baseDir.
@@ -143,21 +150,27 @@ public abstract class AbstractOptionsProvider implements ArgumentsProvider {
      */
     protected abstract ReportConfiguration generateConfig(final List<Pair<Option, String[]>> args) throws IOException;
 
-    protected File writeFile(final String name, final Iterable<String> lines) {
-        return writeFile(baseDir, name, lines);
+    /**
+     * Converts each {@code Pair<Option, String[]>} into the option string and its arguments.
+     * @param args the argument paris to process.
+     * @return an array of arguments for the processing.
+     */
+    public static String[] extractArgs(List<Pair<Option, String[]>> args) {
+        List<String> sArgs = new ArrayList<>();
+        for (Pair<Option, String[]> pair : args) {
+            if (pair.getKey() != null) {
+                sArgs.add("--" + pair.getKey().getLongOpt());
+                String[] oArgs = pair.getValue();
+                if (oArgs != null) {
+                    Collections.addAll(sArgs, oArgs);
+                }
+            }
+        }
+        return sArgs.toArray(new String[0]);
     }
 
-    final protected File writeFile(File baseDir, final String name, final Iterable<String> lines) {
-        if (baseDir == null) {
-            fail("base directory not specified");
-        }
-        File file = new File(baseDir, name);
-        try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
-            lines.forEach(writer::println);
-        } catch (IOException e) {
-            fail(e.getMessage());
-        }
-        return file;
+    protected File writeFile(final String name, final Iterable<String> lines) {
+        return org.apache.rat.testhelpers.FileUtils.writeFile(baseDir, name, lines);
     }
 
     final protected DocumentName mkDocName(final String name) {
diff --git a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/FileUtils.java b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/FileUtils.java
new file mode 100644
index 00000000..5681e797
--- /dev/null
+++ b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/FileUtils.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one   *
+ * or more contributor license agreements.  See the NOTICE file *
+ * distributed with this work for additional information        *
+ * regarding copyright ownership.  The ASF licenses this file   *
+ * to you under the Apache License, Version 2.0 (the            *
+ * "License"); you may not use this file except in compliance   *
+ * with the License.  You may obtain a copy of the License at   *
+ *                                                              *
+ *   http://www.apache.org/licenses/LICENSE-2.0                 *
+ *                                                              *
+ * Unless required by applicable law or agreed to in writing,   *
+ * software distributed under the License is distributed on an  *
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+ * KIND, either express or implied.  See the License for the    *
+ * specific language governing permissions and limitations      *
+ * under the License.                                           *
+ */
+package org.apache.rat.testhelpers;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.Collections;
+
+import static org.assertj.core.api.Fail.fail;
+
+public class FileUtils {
+
+    /**
+     * Creates a directory if it does not exist.
+     * @param dir the directory to make.
+     */
+    public static void mkDir(File dir) {
+        boolean ignored = dir.mkdirs();
+    }
+
+    /**
+     * Deletes a file if it exists.
+     * @param file the file to delete.
+     */
+    public static void delete(File file) {
+        if (file.exists()) {
+            if (file.isDirectory()) {
+                try {
+                    org.apache.commons.io.FileUtils.deleteDirectory(file);
+                } catch (IOException ignore) {
+                    //
+                }
+            } else {
+                boolean ignored = file.delete();
+            }
+        }
+    }
+
+    /**
+     * Writes a test file.
+     * @param dir The directory to write the file in.
+     * @param name the name of the file.
+     * @param lines the lines to write into the file.
+     * @return the new File.
+     */
+    static public File writeFile(File dir, final String name, final Iterable<String> lines) {
+        if (dir == null) {
+            fail("base directory not specified");
+        }
+        File file = new File(dir, name);
+        try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
+            lines.forEach(writer::println);
+        } catch (IOException e) {
+            fail(e.getMessage());
+        }
+        return file;
+    }
+
+    /**
+     * Writes a test file.
+     * @param dir The directory to write the file in.
+     * @param name the name of the file.
+     * @param lines the lines to write into the file.
+     * @return the new File.
+     */
+    static public File writeFile(File dir, final String name, final String... lines) {
+        return writeFile(dir, name, Arrays.asList(lines));
+    }
+
+    /**
+     * Writes a text file containing the name of the file.
+     * @param dir The directory to write the file into.
+     * @param name the name of the file.
+     * @return the new file.
+     */
+    public static File writeFile(File dir, String name) {
+        return writeFile(dir, name, Collections.singletonList(name));
+    }
+}
