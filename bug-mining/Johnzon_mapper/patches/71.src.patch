diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/DynamicMappingGenerator.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/DynamicMappingGenerator.java
index f8598dee..86a80b6a 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/DynamicMappingGenerator.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/DynamicMappingGenerator.java
@@ -48,16 +48,21 @@ public class DynamicMappingGenerator implements MappingGenerator {
                 delegate.getJsonGenerator(), writeStart, keyName) : generator;
     }
 
+    @Override
+    public MappingGenerator writeObject(final String key, final Object o, final JsonGenerator generator) {
+        return delegate.writeObject(key, o, ensureGenerator(generator));
+    }
+
     @Override
     public MappingGenerator writeObject(final Object o, final JsonGenerator generator) {
+        return delegate.writeObject(o, ensureGenerator(generator));
+    }
+
+    private JsonGenerator ensureGenerator(final JsonGenerator generator) {
         if (this.generator != null && this.generator != generator && this.generator.delegate != generator) {
             this.generator = null;
         }
-        getJsonGenerator(); // ensure we wrap it
-
-        final MappingGenerator mappingGenerator = delegate.writeObject(o, this.generator);
-        flushIfNeeded();
-        return mappingGenerator;
+        return getJsonGenerator(); // ensure we wrap it
     }
 
     public void flushIfNeeded() {
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java
index 8dd1e1a8..3e52812b 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGenerator.java
@@ -57,4 +57,8 @@ public interface MappingGenerator {
      * @return itself, for easier chaining of commands
      */
     MappingGenerator writeObject(Object o, JsonGenerator generator);
+
+    default MappingGenerator writeObject(final String key, final Object o, final JsonGenerator generator) {
+        return writeObject(o, generator);
+    }
 }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java
index b7d16298..f022562e 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java
@@ -18,6 +18,8 @@
  */
 package org.apache.johnzon.mapper;
 
+import static java.util.Collections.emptyList;
+
 import org.apache.johnzon.mapper.internal.JsonPointerTracker;
 
 import javax.json.JsonValue;
@@ -57,7 +59,50 @@ public class MappingGeneratorImpl implements MappingGenerator {
     }
 
     @Override
-    public MappingGenerator writeObject(Object object, JsonGenerator generator) {
+    public MappingGenerator writeObject(final String key, final Object object, final JsonGenerator generator) {
+        if (object == null) {
+            return this;
+        } else if (object instanceof JsonValue) {
+            generator.write(key, JsonValue.class.cast(object));
+        } else {
+            final Class<?> objectClass = object.getClass();
+            try {
+                if (Map.class.isInstance(object)) {
+                    writeValue(Map.class, false, false, false, false, true, null, key, object,
+                            null, emptyList(), isDeduplicateObjects ? new JsonPointerTracker(null, "/") : null, generator);
+                } else if(writePrimitives(key, objectClass, object, generator)) {
+                    // no-op
+                } else if (objectClass.isEnum()) {
+                    final Adapter adapter = config.findAdapter(objectClass);
+                    final String adaptedValue = adapter.from(object).toString(); // we know it ends as String for enums
+                    generator.write(key, adaptedValue);
+                } else if (objectClass.isArray()) {
+                    writeValue(Map.class, false, false, true, false, false, null, key, object,
+                            null, emptyList(), isDeduplicateObjects ? new JsonPointerTracker(null, "/") : null, generator);
+                } else if (Iterable.class.isInstance(object)) {
+                    writeValue(Map.class, false, false, false, true, false, null, key, object,
+                            null, emptyList(), isDeduplicateObjects ? new JsonPointerTracker(null, "/") : null, generator);
+                } else {
+                    final ObjectConverter.Writer objectConverter = config.findObjectConverterWriter(objectClass);
+                    if (objectConverter != null) {
+                        final DynamicMappingGenerator dynamicMappingGenerator = new DynamicMappingGenerator(this,
+                                generator::writeStartObject, generator::writeEnd, null);
+                        objectConverter.writeJson(object, dynamicMappingGenerator);
+                        dynamicMappingGenerator.flushIfNeeded();
+                    } else {
+                        writeValue(objectClass, false, false, false, false, false, null, key, object,
+                                null, emptyList(), isDeduplicateObjects ? new JsonPointerTracker(null, "/") : null, generator);
+                    }
+                }
+            } catch (final InvocationTargetException | IllegalAccessException e) {
+                throw new MapperException(e);
+            }
+        }
+        return this;
+    }
+
+    @Override
+    public MappingGenerator writeObject(final Object object, final JsonGenerator generator) {
         if (object == null) {
             return this;
         } else if (object instanceof JsonValue) {
@@ -124,9 +169,7 @@ public class MappingGeneratorImpl implements MappingGenerator {
                     generator.writeEnd();
                 }
             }
-        } catch (final InvocationTargetException e) {
-            throw new MapperException(e);
-        } catch (final IllegalAccessException e) {
+        } catch (final InvocationTargetException | IllegalAccessException e) {
             throw new MapperException(e);
         }
     }
