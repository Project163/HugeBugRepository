diff --git a/src/main/java/org/apache/commons/jexl/util/introspection/IntrospectorBase.java b/src/main/java/org/apache/commons/jexl/util/introspection/IntrospectorBase.java
index 94e4671c..1ed47d68 100644
--- a/src/main/java/org/apache/commons/jexl/util/introspection/IntrospectorBase.java
+++ b/src/main/java/org/apache/commons/jexl/util/introspection/IntrospectorBase.java
@@ -174,7 +174,7 @@ public class IntrospectorBase {
                         l.add(ictor);
                     }
                     // try to find one
-                    ctor = MethodKey.CONSTRUCTORS.getMostSpecific(l, key.getParameters());
+                    ctor = key.getMostSpecific(l);
                     if (ctor != null) {
                         constructorsMap.put(key, ctor);
                     } else {
diff --git a/src/main/java/org/apache/commons/jexl/util/introspection/MethodKey.java b/src/main/java/org/apache/commons/jexl/util/introspection/MethodKey.java
index 95ca7f0b..3ff5c747 100644
--- a/src/main/java/org/apache/commons/jexl/util/introspection/MethodKey.java
+++ b/src/main/java/org/apache/commons/jexl/util/introspection/MethodKey.java
@@ -40,7 +40,7 @@ import java.util.Arrays;
  * A key can be constructed either from arguments (array of objects) or from parameters
  * (array of class).
  * Roughly 3x faster than string key to access the map & uses less memory.
- * 
+ *
  * For the parameters methods:
  * @author <a href="mailto:jvanzyl@apache.org">Jason van Zyl</a>
  * @author <a href="mailto:bob@werken.com">Bob McWhirter</a>
@@ -180,6 +180,26 @@ public final class MethodKey {
         return builder.toString();
     }
 
+    /**
+     * Gets the most specific method that is applicable to the parameters of this key.
+     * @param methods a list of methods.
+     * @return the most specific method.
+     * @throws MethodKey.AmbiguousException if there is more than one.
+     */
+    public Method getMostSpecific(List<Method> methods) {
+        return METHODS.getMostSpecific(methods, params);
+    }
+
+    /**
+     * Gets the most specific constructor that is applicable to the parameters of this key.
+     * @param methods a list of constructors.
+     * @return the most specific constructor.
+     * @throws MethodKey.AmbiguousException if there is more than one.
+     */
+    public Constructor<?> getMostSpecific(List<Constructor<?>> methods) {
+        return CONSTRUCTORS.getMostSpecific(methods, params);
+    }
+
     /**
      * whether a method/ctor is more specific than a previously compared one.
      */
@@ -207,9 +227,9 @@ public final class MethodKey {
 
     /**
      * Utility for parameters matching.
-     * @param <T> method or contructor
+     * @param <T> Method or Constructor
      */
-     public abstract static class Parameters<T> {
+     private abstract static class Parameters<T> {
         /**
          * Extract the parameter types from its applicable argument.
          * @param app a method or constructor
@@ -225,7 +245,7 @@ public final class MethodKey {
          * @return the most specific method.
          * @throws MethodKey.AmbiguousException if there is more than one.
          */
-        protected T getMostSpecific(List<T> methods, Class<?>[] classes) {
+        private T getMostSpecific(List<T> methods, Class<?>[] classes) {
             LinkedList<T> applicables = getApplicables(methods, classes);
 
             if (applicables.isEmpty()) {
@@ -357,7 +377,7 @@ public final class MethodKey {
          *         formal and actual arguments matches, and argument types are assignable
          *         to formal types through a method invocation conversion).
          */
-        protected LinkedList<T> getApplicables(List<T> methods, Class<?>[] classes) {
+        private LinkedList<T> getApplicables(List<T> methods, Class<?>[] classes) {
             LinkedList<T> list = new LinkedList<T>();
 
             for (Iterator<T> imethod = methods.iterator(); imethod.hasNext();) {
@@ -438,13 +458,8 @@ public final class MethodKey {
          */
         private boolean isConvertible(Class<?> formal, Class<?> actual,
                 boolean possibleVarArg) {
-            // if we see Void.class as the class of an argument most likely
-            // obtained through a MethodKey, we consider it
-            // as a wildcard; non primitives are thus convertible.
-            if (actual.equals(Void.class) && !formal.isPrimitive()) {
-                return true;
-            }
-            return isInvocationConvertible(formal, actual, possibleVarArg);
+            // if we see Void.class, the argument was null
+            return isInvocationConvertible(formal, actual.equals(Void.class)? null : actual, possibleVarArg);
         }
 
         /**
@@ -458,7 +473,8 @@ public final class MethodKey {
          */
         private boolean isStrictConvertible(Class<?> formal, Class<?> actual,
                 boolean possibleVarArg) {
-            return isStrictInvocationConvertible(formal, actual, possibleVarArg);
+            // if we see Void.class, the argument was null
+            return isStrictInvocationConvertible(formal, actual.equals(Void.class)? null : actual, possibleVarArg);
         }
 
     }
@@ -531,7 +547,7 @@ public final class MethodKey {
 
         /* Check for vararg conversion. */
         if (possibleVarArg && formal.isArray()) {
-            if (actual.isArray()) {
+            if (actual != null && actual.isArray()) {
                 actual = actual.getComponentType();
             }
             return isInvocationConvertible(formal.getComponentType(),
@@ -595,7 +611,7 @@ public final class MethodKey {
 
         /* Check for vararg conversion. */
         if (possibleVarArg && formal.isArray()) {
-            if (actual.isArray()) {
+            if (actual != null && actual.isArray()) {
                 actual = actual.getComponentType();
             }
             return isStrictInvocationConvertible(formal.getComponentType(),
@@ -607,7 +623,7 @@ public final class MethodKey {
     /**
      * The parameter matching service for methods.
      */
-    public static final Parameters<Method> METHODS = new Parameters<Method>() {
+    private static final Parameters<Method> METHODS = new Parameters<Method>() {
         @Override
         protected Class<?>[] getParameterTypes(Method app) {
             return app.getParameterTypes();
@@ -618,7 +634,7 @@ public final class MethodKey {
     /**
      * The parameter matching service for constructors.
      */
-    public static final Parameters<Constructor<?>> CONSTRUCTORS = new Parameters<Constructor<?>>() {
+    private static final Parameters<Constructor<?>> CONSTRUCTORS = new Parameters<Constructor<?>>() {
         @Override
         protected Class<?>[] getParameterTypes(Constructor<?> app) {
             return app.getParameterTypes();
diff --git a/src/main/java/org/apache/commons/jexl/util/introspection/MethodMap.java b/src/main/java/org/apache/commons/jexl/util/introspection/MethodMap.java
index 627d8d48..beeaf0ba 100644
--- a/src/main/java/org/apache/commons/jexl/util/introspection/MethodMap.java
+++ b/src/main/java/org/apache/commons/jexl/util/introspection/MethodMap.java
@@ -122,21 +122,7 @@ final class MethodMap {
         if (methodList == null) {
             return null;
         }
-        return MethodKey.METHODS.getMostSpecific(methodList, methodKey.getParameters());
+        return methodKey.getMostSpecific(methodList);
     } // CSON: RedundantThrows
 
-
-    /**
-     * Simple distinguishable exception, used when
-     * we run across ambiguous overloading.  Caught
-     * by the introspector.
-     */
-    public static class AmbiguousException extends RuntimeException {
-        /**
-         * Version Id for serializable.
-         */
-        private static final long serialVersionUID = -2314636505414551663L;
-    }
-
-
 }
\ No newline at end of file
