diff --git a/src/main/java/org/apache/commons/jexl3/JexlBuilder.java b/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
index c244ad01..c9212e52 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
@@ -186,11 +186,21 @@ public class JexlBuilder {
      * Sets the features the engine will use as a base by default.
      * <p>Note that the script flag will be ignored; the engine will be able to parse expressions and scripts.
      * <p>Note also that these will apply to template expressions and scripts.
+     * <p>As a last remark, if lexical or lexicalShade are set as features, this
+     * method will also set the corresponding options.
      * @param f the features
      * @return this builder
      */
     public JexlBuilder features(JexlFeatures f) {
         this.features = f;
+        if (features != null) {
+            if (features.isLexical()) {
+                options.setLexical(true);
+            }
+            if (features.isLexicalShade()) {
+                options.setLexicalShade(true);
+            }
+        }
         return this;
     }
 
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Engine.java b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
index f470fd93..ae008655 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Engine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
@@ -36,23 +36,24 @@ import org.apache.commons.jexl3.parser.ASTIdentifier;
 import org.apache.commons.jexl3.parser.ASTIdentifierAccess;
 import org.apache.commons.jexl3.parser.ASTJexlScript;
 import org.apache.commons.jexl3.parser.ASTMethodNode;
+import org.apache.commons.jexl3.parser.ASTNumberLiteral;
+import org.apache.commons.jexl3.parser.ASTStringLiteral;
 import org.apache.commons.jexl3.parser.JexlNode;
 import org.apache.commons.jexl3.parser.Parser;
 
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+
 import java.io.StringReader;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
-import java.nio.charset.Charset;
 import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.commons.jexl3.parser.ASTNumberLiteral;
-import org.apache.commons.jexl3.parser.ASTStringLiteral;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 
 /**
  * A JexlEngine implementation.
@@ -322,7 +323,7 @@ public class Engine extends JexlEngine {
             JexlOptions jexlo = ((JexlContext.OptionsHandle) context).getEngineOptions();
             if (jexlo != null) {
                 return jexlo.isSharedInstance()? jexlo : jexlo.copy();
-            } 
+            }
         } else if (context instanceof JexlEngine.Options) {
             // This condition and block for compatibility between 3.1 and 3.2
             JexlOptions jexlo = options.copy();
@@ -348,18 +349,17 @@ public class Engine extends JexlEngine {
      * @return the options
      */
     protected JexlOptions options(ASTJexlScript script, JexlContext context) {
-        final JexlOptions opts = options(context);
+        final JexlOptions opts = options(context); 
+        if (opts != options) {
+            // when feature lexical, try hard to run lexical
+            if (scriptFeatures.isLexical()) {
+                opts.setLexical(true);
+            }
+            if (scriptFeatures.isLexicalShade()) {
+                opts.setLexicalShade(true);
+            }
+        }
         if (script != null) {
-            // when parsing lexical, try hard to run lexical
-           JexlFeatures features = script.getFeatures();
-           if (features != null) {
-               if (features.isLexical()) {
-                   opts.setLexical(true);
-               }
-               if (features.isLexicalShade()) {
-                   opts.setLexicalShade(true);
-               }
-           }
            // process script pragmas if any
            processPragmas(script, context, opts);
         }
diff --git a/src/test/java/org/apache/commons/jexl3/JXLTTest.java b/src/test/java/org/apache/commons/jexl3/JXLTTest.java
index 811fa630..ceba48f6 100644
--- a/src/test/java/org/apache/commons/jexl3/JXLTTest.java
+++ b/src/test/java/org/apache/commons/jexl3/JXLTTest.java
@@ -29,7 +29,6 @@ import java.io.Writer;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
-import org.apache.commons.jexl3.internal.Engine;
 
 import org.junit.After;
 import org.junit.Assert;
@@ -67,7 +66,6 @@ public class JXLTTest extends JexlTestCase {
             .cache(128).strict(true).create(),
           
          new JexlBuilder().features(f).silent(false)
-            .lexical(true).lexicalShade(true)
             .cache(128).strict(true).create(),
          
          new JexlBuilder().silent(false)
@@ -1070,6 +1068,12 @@ public class JXLTTest extends JexlTestCase {
     @Test
     public void testTemplatePragmaPro50() throws Exception {
         JexlOptions opts = new JexlOptions();
+        opts.setCancellable(false);
+        opts.setStrict(false);
+        opts.setSafe(true);
+        opts.setLexical(false);
+        opts.setLexicalShade(false);
+        opts.setSharedInstance(true);
         JexlContext ctxt = new PragmaticContext(opts);
         String src = "$$ #pragma script.mode pro50\n"
                 + "$$ var tab = null;\n"
