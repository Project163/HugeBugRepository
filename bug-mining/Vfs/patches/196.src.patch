diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/impl/DefaultFileSystemManager.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/impl/DefaultFileSystemManager.java
index 781d98ab..e2d073ab 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/impl/DefaultFileSystemManager.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/impl/DefaultFileSystemManager.java
@@ -66,6 +66,11 @@ public class DefaultFileSystemManager implements FileSystemManager {
      */
     private final Map<String, FileProvider> providers = new HashMap<>();
 
+    /**
+     * List of the schemes of virtual filesystems added.
+     */
+    private final List<String> virtualFileSystemSchemes = new ArrayList<>();
+
     /**
      * All components used by this manager.
      */
@@ -520,8 +525,6 @@ public class DefaultFileSystemManager implements FileSystemManager {
         for (final FileProvider provider : providers.values()) {
             closeComponent(provider);
         }
-        // unregister all
-        providers.clear();
 
         // Close the other components
         closeComponent(vfsProvider);
@@ -530,6 +533,11 @@ public class DefaultFileSystemManager implements FileSystemManager {
         closeComponent(filesCache);
         closeComponent(defaultProvider);
 
+
+        // unregister all providers here, so if any components have local file references
+        // they can still resolve against the supported schemes
+        providers.clear();
+
         // FileOperations are components, too
         for (final List<FileOperationProvider> opproviders : operationProviders.values()) {
             for (final FileOperationProvider p : opproviders) {
@@ -551,6 +559,9 @@ public class DefaultFileSystemManager implements FileSystemManager {
         // managed components
         vfsProvider = null;
 
+        // virtual schemas
+        virtualFileSystemSchemes.clear();
+
         // setters and derived state
         defaultProvider = null;
         baseFile = null;
@@ -697,7 +708,7 @@ public class DefaultFileSystemManager implements FileSystemManager {
         }
 
         // Extract the scheme
-        final String scheme = UriParser.extractScheme(uri);
+        final String scheme = UriParser.extractScheme(getSchemes(),uri);
         if (scheme != null) {
             // An absolute URI - locate the provider
             final FileProvider provider = providers.get(scheme);
@@ -764,7 +775,7 @@ public class DefaultFileSystemManager implements FileSystemManager {
 
         // Adjust separators
         UriParser.fixSeparators(buffer);
-        String scheme = UriParser.extractScheme(buffer.toString());
+        String scheme = UriParser.extractScheme(getSchemes(), buffer.toString());
 
         // Determine whether to prepend the base path
         if (name.length() == 0 || (scheme == null && buffer.charAt(0) != FileName.SEPARATOR_CHAR)) {
@@ -829,7 +840,7 @@ public class DefaultFileSystemManager implements FileSystemManager {
         }
 
         // Extract the scheme
-        final String scheme = UriParser.extractScheme(uri);
+        final String scheme = UriParser.extractScheme(getSchemes(), uri);
         if (scheme != null) {
             // An absolute URI - locate the provider
             final FileProvider provider = providers.get(scheme);
@@ -919,7 +930,9 @@ public class DefaultFileSystemManager implements FileSystemManager {
      */
     @Override
     public FileObject createVirtualFileSystem(final FileObject rootFile) throws FileSystemException {
-        return vfsProvider.createFileSystem(rootFile);
+        FileObject fileObject = vfsProvider.createFileSystem(rootFile);
+        addVirtualFileSystemScheme(rootFile.getName().getScheme());
+        return fileObject;
     }
 
     /**
@@ -931,7 +944,17 @@ public class DefaultFileSystemManager implements FileSystemManager {
      */
     @Override
     public FileObject createVirtualFileSystem(final String rootUri) throws FileSystemException {
-        return vfsProvider.createFileSystem(rootUri);
+        FileObject fileObject = vfsProvider.createFileSystem(rootUri);
+        addVirtualFileSystemScheme(rootUri);
+        return fileObject;
+    }
+
+
+    protected void addVirtualFileSystemScheme(String rootUri) {
+        if (rootUri.indexOf(':') != -1) {
+            rootUri = rootUri.substring(0, rootUri.indexOf(':'));
+        }
+        virtualFileSystemSchemes.add(rootUri);
     }
 
     /**
@@ -1014,9 +1037,10 @@ public class DefaultFileSystemManager implements FileSystemManager {
      */
     @Override
     public String[] getSchemes() {
-        final String[] schemes = new String[providers.size()];
-        providers.keySet().toArray(schemes);
-        return schemes;
+        final List<String> schemes = new ArrayList<>(providers.size() + virtualFileSystemSchemes.size());
+        schemes.addAll(providers.keySet());
+        schemes.addAll(virtualFileSystemSchemes);
+        return schemes.toArray(new String[]{});
     }
 
     /**
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/AbstractFileObject.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/AbstractFileObject.java
index e9080526..4ae6e1eb 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/AbstractFileObject.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/AbstractFileObject.java
@@ -47,6 +47,7 @@ import org.apache.commons.vfs2.FileUtil;
 import org.apache.commons.vfs2.NameScope;
 import org.apache.commons.vfs2.RandomAccessContent;
 import org.apache.commons.vfs2.Selectors;
+import org.apache.commons.vfs2.VFS;
 import org.apache.commons.vfs2.operations.DefaultFileOperations;
 import org.apache.commons.vfs2.operations.FileOperations;
 import org.apache.commons.vfs2.util.FileObjectUtils;
@@ -1308,9 +1309,9 @@ public abstract class AbstractFileObject<AFS extends AbstractFileSystem> impleme
         try {
             return AccessController.doPrivileged(new PrivilegedExceptionAction<URL>() {
                 @Override
-                public URL run() throws MalformedURLException {
+                public URL run() throws MalformedURLException, FileSystemException {
                     final StringBuilder buf = new StringBuilder();
-                    final String scheme = UriParser.extractScheme(fileName.getURI(), buf);
+                    final String scheme = UriParser.extractScheme(VFS.getManager().getSchemes(), fileName.getURI(), buf);
                     return new URL(scheme, "", -1, buf.toString(),
                             new DefaultURLStreamHandler(fileSystem.getContext(), fileSystem.getFileSystemOptions()));
                 }
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/CompositeFileProvider.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/CompositeFileProvider.java
index 1f52ce11..1f2f4f12 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/CompositeFileProvider.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/CompositeFileProvider.java
@@ -19,6 +19,7 @@ package org.apache.commons.vfs2.provider;
 import org.apache.commons.vfs2.FileObject;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileSystemOptions;
+import org.apache.commons.vfs2.VFS;
 
 /**
  * Description.
@@ -51,7 +52,7 @@ public abstract class CompositeFileProvider extends AbstractFileProvider {
             throws FileSystemException {
         final StringBuilder buf = new StringBuilder(INITIAL_BUFSZ);
 
-        UriParser.extractScheme(uri, buf);
+        UriParser.extractScheme(VFS.getManager().getSchemes(), uri, buf);
 
         final String[] schemes = getSchemes();
         for (final String scheme : schemes) {
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/DefaultURLStreamHandler.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/DefaultURLStreamHandler.java
index ab001197..6423de1d 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/DefaultURLStreamHandler.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/DefaultURLStreamHandler.java
@@ -24,6 +24,7 @@ import java.net.URLStreamHandler;
 import org.apache.commons.vfs2.FileObject;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileSystemOptions;
+import org.apache.commons.vfs2.VFS;
 
 /**
  * A default URL stream handler that will work for most file systems.
@@ -66,7 +67,7 @@ public class DefaultURLStreamHandler extends URLStreamHandler {
 
             final String url = newURL.getName().getURI();
             final StringBuilder filePart = new StringBuilder();
-            final String protocolPart = UriParser.extractScheme(url, filePart);
+            final String protocolPart = UriParser.extractScheme(VFS.getManager().getSchemes(), url, filePart);
 
             setURL(u, protocolPart, "", -1, null, null, filePart.toString(), null, null);
         } catch (final FileSystemException fse) {
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/HostFileNameParser.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/HostFileNameParser.java
index d08b486f..eabf53c5 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/HostFileNameParser.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/HostFileNameParser.java
@@ -19,6 +19,7 @@ package org.apache.commons.vfs2.provider;
 import org.apache.commons.vfs2.FileName;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileType;
+import org.apache.commons.vfs2.VFS;
 import org.apache.commons.vfs2.util.Cryptor;
 import org.apache.commons.vfs2.util.CryptorFactory;
 
@@ -71,7 +72,7 @@ public class HostFileNameParser extends AbstractFileNameParser {
         final Authority auth = new Authority();
 
         // Extract the scheme
-        auth.scheme = UriParser.extractScheme(uri, name);
+        auth.scheme = UriParser.extractScheme(VFS.getManager().getSchemes(), uri, name);
 
         // Expecting "//"
         if (name.length() < 2 || name.charAt(0) != '/' || name.charAt(1) != '/') {
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/LayeredFileNameParser.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/LayeredFileNameParser.java
index 3ff8fd0e..47064557 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/LayeredFileNameParser.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/LayeredFileNameParser.java
@@ -19,6 +19,7 @@ package org.apache.commons.vfs2.provider;
 import org.apache.commons.vfs2.FileName;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileType;
+import org.apache.commons.vfs2.VFS;
 
 /**
  * Implementation for layered filesystems.
@@ -63,7 +64,7 @@ public class LayeredFileNameParser extends AbstractFileNameParser {
         final StringBuilder name = new StringBuilder();
 
         // Extract the scheme
-        final String scheme = UriParser.extractScheme(filename, name);
+        final String scheme = UriParser.extractScheme(VFS.getManager().getSchemes(), filename, name);
 
         // Extract the Layered file URI
         final String rootUriName = extractRootName(name);
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/UriParser.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/UriParser.java
index 6e90ea45..d146caf9 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/UriParser.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/UriParser.java
@@ -16,6 +16,7 @@
  */
 package org.apache.commons.vfs2.provider;
 
+import java.util.Set;
 import org.apache.commons.vfs2.FileName;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileType;
@@ -46,205 +47,72 @@ public final class UriParser {
 
     private static final char LOW_MASK = 0x0F;
 
-    private UriParser() {
-    }
-
     /**
-     * Extracts the first element of a path.
+     * Encodes and appends a string to a StringBuilder.
      *
-     * @param name StringBuilder containing the path.
-     * @return The first element of the path.
+     * @param buffer The StringBuilder to append to.
+     * @param unencodedValue The String to encode and append.
+     * @param reserved characters to encode.
      */
-    public static String extractFirstElement(final StringBuilder name) {
-        final int len = name.length();
-        if (len < 1) {
-            return null;
-        }
-        int startPos = 0;
-        if (name.charAt(0) == SEPARATOR_CHAR) {
-            startPos = 1;
-        }
-        for (int pos = startPos; pos < len; pos++) {
-            if (name.charAt(pos) == SEPARATOR_CHAR) {
-                // Found a separator
-                final String elem = name.substring(startPos, pos);
-                name.delete(startPos, pos + 1);
-                return elem;
-            }
-        }
-
-        // No separator
-        final String elem = name.substring(startPos);
-        name.setLength(0);
-        return elem;
+    public static void appendEncoded(final StringBuilder buffer, final String unencodedValue, final char[] reserved) {
+        final int offset = buffer.length();
+        buffer.append(unencodedValue);
+        encode(buffer, offset, unencodedValue.length(), reserved);
     }
 
-    /**
-     * Normalises a path. Does the following:
-     * <ul>
-     * <li>Removes empty path elements.
-     * <li>Handles '.' and '..' elements.
-     * <li>Removes trailing separator.
-     * </ul>
-     *
-     * Its assumed that the separators are already fixed.
-     *
-     * @param path The path to normalize.
-     * @return The FileType.
-     * @throws FileSystemException if an error occurs.
-     *
-     * @see #fixSeparators
-     */
-    public static FileType normalisePath(final StringBuilder path) throws FileSystemException {
-        FileType fileType = FileType.FOLDER;
-        if (path.length() == 0) {
-            return fileType;
-        }
-
-        if (path.charAt(path.length() - 1) != '/') {
-            fileType = FileType.FILE;
-        }
-
-        // Adjust separators
-        // fixSeparators(path);
-
-        // Determine the start of the first element
-        int startFirstElem = 0;
-        if (path.charAt(0) == SEPARATOR_CHAR) {
-            if (path.length() == 1) {
-                return fileType;
-            }
-            startFirstElem = 1;
-        }
-
-        // Iterate over each element
-        int startElem = startFirstElem;
-        int maxlen = path.length();
-        while (startElem < maxlen) {
-            // Find the end of the element
-            int endElem = startElem;
-            for (; endElem < maxlen && path.charAt(endElem) != SEPARATOR_CHAR; endElem++) {
-            }
-
-            final int elemLen = endElem - startElem;
-            if (elemLen == 0) {
-                // An empty element - axe it
-                path.delete(endElem, endElem + 1);
-                maxlen = path.length();
-                continue;
-            }
-            if (elemLen == 1 && path.charAt(startElem) == '.') {
-                // A '.' element - axe it
-                path.delete(startElem, endElem + 1);
-                maxlen = path.length();
-                continue;
-            }
-            if (elemLen == 2 && path.charAt(startElem) == '.' && path.charAt(startElem + 1) == '.') {
-                // A '..' element - remove the previous element
-                if (startElem == startFirstElem) {
-                    // Previous element is missing
-                    throw new FileSystemException("vfs.provider/invalid-relative-path.error");
+    public static void canonicalizePath(final StringBuilder buffer, final int offset, final int length,
+            final FileNameParser fileNameParser) throws FileSystemException {
+        int index = offset;
+        int count = length;
+        for (; count > 0; count--, index++) {
+            final char ch = buffer.charAt(index);
+            if (ch == '%') {
+                if (count < 3) {
+                    throw new FileSystemException("vfs.provider/invalid-escape-sequence.error",
+                            buffer.substring(index, index + count));
                 }
 
-                // Find start of previous element
-                int pos = startElem - 2;
-                for (; pos >= 0 && path.charAt(pos) != SEPARATOR_CHAR; pos--) {
+                // Decode
+                final int dig1 = Character.digit(buffer.charAt(index + 1), HEX_BASE);
+                final int dig2 = Character.digit(buffer.charAt(index + 2), HEX_BASE);
+                if (dig1 == -1 || dig2 == -1) {
+                    throw new FileSystemException("vfs.provider/invalid-escape-sequence.error",
+                            buffer.substring(index, index + 3));
                 }
-                startElem = pos + 1;
-
-                path.delete(startElem, endElem + 1);
-                maxlen = path.length();
-                continue;
-            }
-
-            // A regular element
-            startElem = endElem + 1;
-        }
+                final char value = (char) (dig1 << BITS_IN_HALF_BYTE | dig2);
 
-        // Remove trailing separator
-        if (!VFS.isUriStyle() && maxlen > 1 && path.charAt(maxlen - 1) == SEPARATOR_CHAR) {
-            path.delete(maxlen - 1, maxlen);
-        }
+                final boolean match = value == '%' || fileNameParser.encodeCharacter(value);
 
-        return fileType;
-    }
+                if (match) {
+                    // this is a reserved character, not allowed to decode
+                    index += 2;
+                    count -= 2;
+                    continue;
+                }
 
-    /**
-     * Normalises the separators in a name.
-     *
-     * @param name The StringBuilder containing the name
-     * @return true if the StringBuilder was modified.
-     */
-    public static boolean fixSeparators(final StringBuilder name) {
-        boolean changed = false;
-        final int maxlen = name.length();
-        for (int i = 0; i < maxlen; i++) {
-            final char ch = name.charAt(i);
-            if (ch == TRANS_SEPARATOR) {
-                name.setCharAt(i, SEPARATOR_CHAR);
-                changed = true;
+                // Replace
+                buffer.setCharAt(index, value);
+                buffer.delete(index + 1, index + 3);
+                count -= 2;
+            } else if (fileNameParser.encodeCharacter(ch)) {
+                // Encode
+                final char[] digits = { Character.forDigit((ch >> BITS_IN_HALF_BYTE) & LOW_MASK, HEX_BASE),
+                        Character.forDigit(ch & LOW_MASK, HEX_BASE) };
+                buffer.setCharAt(index, '%');
+                buffer.insert(index + 1, digits);
+                index += 2;
             }
         }
-        return changed;
-    }
-
-    /**
-     * Extracts the scheme from a URI.
-     *
-     * @param uri The URI.
-     * @return The scheme name. Returns null if there is no scheme.
-     */
-    public static String extractScheme(final String uri) {
-        return extractScheme(uri, null);
     }
 
     /**
-     * Extracts the scheme from a URI. Removes the scheme and ':' delimiter from the front of the URI.
+     * Decodes the String.
      *
-     * @param uri The URI.
-     * @param buffer Returns the remainder of the URI.
-     * @return The scheme name. Returns null if there is no scheme.
+     * @param uri The String to decode.
+     * @throws FileSystemException if an error occurs.
      */
-    public static String extractScheme(final String uri, final StringBuilder buffer) {
-        if (buffer != null) {
-            buffer.setLength(0);
-            buffer.append(uri);
-        }
-
-        final int maxPos = uri.length();
-        for (int pos = 0; pos < maxPos; pos++) {
-            final char ch = uri.charAt(pos);
-
-            if (ch == ':') {
-                // Found the end of the scheme
-                final String scheme = uri.substring(0, pos);
-                if (scheme.length() <= 1 && Os.isFamily(Os.OS_FAMILY_WINDOWS)) {
-                    // This is not a scheme, but a Windows drive letter
-                    return null;
-                }
-                if (buffer != null) {
-                    buffer.delete(0, pos + 1);
-                }
-                return scheme.intern();
-            }
-
-            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
-                // A scheme character
-                continue;
-            }
-            if (pos > 0 && ((ch >= '0' && ch <= '9') || ch == '+' || ch == '-' || ch == '.')) {
-                // A scheme character (these are not allowed as the first
-                // character of the scheme, but can be used as subsequent
-                // characters.
-                continue;
-            }
-
-            // Not a scheme character
-            break;
-        }
-
-        // No scheme in URI
-        return null;
+    public static void checkUriEncoding(final String uri) throws FileSystemException {
+        decode(uri);
     }
 
     /**
@@ -305,66 +173,21 @@ public final class UriParser {
     }
 
     /**
-     * Encodes and appends a string to a StringBuilder.
+     * Removes %nn encodings from a string.
      *
-     * @param buffer The StringBuilder to append to.
-     * @param unencodedValue The String to encode and append.
-     * @param reserved characters to encode.
+     * @param decodedStr The decoded String.
+     * @return The encoded String.
      */
-    public static void appendEncoded(final StringBuilder buffer, final String unencodedValue, final char[] reserved) {
-        final int offset = buffer.length();
-        buffer.append(unencodedValue);
-        encode(buffer, offset, unencodedValue.length(), reserved);
+    public static String encode(final String decodedStr) {
+        return encode(decodedStr, null);
     }
 
     /**
-     * Encodes a set of reserved characters in a StringBuilder, using the URI %nn encoding. Always encodes % characters.
+     * Converts "special" characters to their %nn value.
      *
-     * @param buffer The StringBuilder to append to.
-     * @param offset The position in the buffer to start encoding at.
-     * @param length The number of characters to encode.
-     * @param reserved characters to encode.
-     */
-    public static void encode(final StringBuilder buffer, final int offset, final int length, final char[] reserved) {
-        int index = offset;
-        int count = length;
-        for (; count > 0; index++, count--) {
-            final char ch = buffer.charAt(index);
-            boolean match = ch == '%';
-            if (reserved != null) {
-                for (int i = 0; !match && i < reserved.length; i++) {
-                    if (ch == reserved[i]) {
-                        match = true;
-                    }
-                }
-            }
-            if (match) {
-                // Encode
-                final char[] digits = { Character.forDigit((ch >> BITS_IN_HALF_BYTE) & LOW_MASK, HEX_BASE),
-                        Character.forDigit(ch & LOW_MASK, HEX_BASE) };
-                buffer.setCharAt(index, '%');
-                buffer.insert(index + 1, digits);
-                index += 2;
-            }
-        }
-    }
-
-    /**
-     * Removes %nn encodings from a string.
-     *
-     * @param decodedStr The decoded String.
-     * @return The encoded String.
-     */
-    public static String encode(final String decodedStr) {
-        return encode(decodedStr, null);
-    }
-
-    /**
-     * Converts "special" characters to their %nn value.
-     *
-     * @param decodedStr The decoded String.
-     * @param reserved Characters to encode.
-     * @return The encoded String
+     * @param decodedStr The decoded String.
+     * @param reserved Characters to encode.
+     * @return The encoded String
      */
     public static String encode(final String decodedStr, final char[] reserved) {
         if (decodedStr == null) {
@@ -392,50 +215,27 @@ public final class UriParser {
     }
 
     /**
-     * Decodes the String.
+     * Encodes a set of reserved characters in a StringBuilder, using the URI %nn encoding. Always encodes % characters.
      *
-     * @param uri The String to decode.
-     * @throws FileSystemException if an error occurs.
+     * @param buffer The StringBuilder to append to.
+     * @param offset The position in the buffer to start encoding at.
+     * @param length The number of characters to encode.
+     * @param reserved characters to encode.
      */
-    public static void checkUriEncoding(final String uri) throws FileSystemException {
-        decode(uri);
-    }
-
-    public static void canonicalizePath(final StringBuilder buffer, final int offset, final int length,
-            final FileNameParser fileNameParser) throws FileSystemException {
+    public static void encode(final StringBuilder buffer, final int offset, final int length, final char[] reserved) {
         int index = offset;
         int count = length;
-        for (; count > 0; count--, index++) {
+        for (; count > 0; index++, count--) {
             final char ch = buffer.charAt(index);
-            if (ch == '%') {
-                if (count < 3) {
-                    throw new FileSystemException("vfs.provider/invalid-escape-sequence.error",
-                            buffer.substring(index, index + count));
-                }
-
-                // Decode
-                final int dig1 = Character.digit(buffer.charAt(index + 1), HEX_BASE);
-                final int dig2 = Character.digit(buffer.charAt(index + 2), HEX_BASE);
-                if (dig1 == -1 || dig2 == -1) {
-                    throw new FileSystemException("vfs.provider/invalid-escape-sequence.error",
-                            buffer.substring(index, index + 3));
-                }
-                final char value = (char) (dig1 << BITS_IN_HALF_BYTE | dig2);
-
-                final boolean match = value == '%' || fileNameParser.encodeCharacter(value);
-
-                if (match) {
-                    // this is a reserved character, not allowed to decode
-                    index += 2;
-                    count -= 2;
-                    continue;
+            boolean match = ch == '%';
+            if (reserved != null) {
+                for (int i = 0; !match && i < reserved.length; i++) {
+                    if (ch == reserved[i]) {
+                        match = true;
+                    }
                 }
-
-                // Replace
-                buffer.setCharAt(index, value);
-                buffer.delete(index + 1, index + 3);
-                count -= 2;
-            } else if (fileNameParser.encodeCharacter(ch)) {
+            }
+            if (match) {
                 // Encode
                 final char[] digits = { Character.forDigit((ch >> BITS_IN_HALF_BYTE) & LOW_MASK, HEX_BASE),
                         Character.forDigit(ch & LOW_MASK, HEX_BASE) };
@@ -446,6 +246,36 @@ public final class UriParser {
         }
     }
 
+    /**
+     * Extracts the first element of a path.
+     *
+     * @param name StringBuilder containing the path.
+     * @return The first element of the path.
+     */
+    public static String extractFirstElement(final StringBuilder name) {
+        final int len = name.length();
+        if (len < 1) {
+            return null;
+        }
+        int startPos = 0;
+        if (name.charAt(0) == SEPARATOR_CHAR) {
+            startPos = 1;
+        }
+        for (int pos = startPos; pos < len; pos++) {
+            if (name.charAt(pos) == SEPARATOR_CHAR) {
+                // Found a separator
+                final String elem = name.substring(startPos, pos);
+                name.delete(startPos, pos + 1);
+                return elem;
+            }
+        }
+
+        // No separator
+        final String elem = name.substring(startPos);
+        name.setLength(0);
+        return elem;
+    }
+
     /**
      * Extract the query String from the URI.
      *
@@ -463,4 +293,228 @@ public final class UriParser {
 
         return null;
     }
+
+    /**
+     * Extracts the scheme from a URI. Removes the scheme and ':' delimiter from the front of the URI.
+     * <p>
+     * The scheme is extracted based on the currently supported schemes in the system.  That is to say the schemes
+     * supported by the registered providers.
+     * </p>
+     * <p>
+     * This allows us to handle varying scheme's without making assumptions based on the ':' character.  Specifically
+     * handle scheme extraction calls for URI parameters that are not actually uri's, but may be names with ':' in them.
+     * </p>
+     * @param schemes The schemes to check.
+     * @param uri The potential URI. May also be a name.
+     * @return The scheme name. Returns null if there is no scheme.
+     */
+    public static String extractScheme(final String[] schemes, final String uri) {
+        return extractScheme(schemes, uri, null);
+    }
+
+    /**
+     * Extracts the scheme from a URI. Removes the scheme and ':' delimiter from the front of the URI.
+     * <p>
+     * The scheme is extracted based on the given set of schemes. Normally, that is to say the schemes
+     * supported by the registered providers.
+     * </p>
+     * <p>
+     * This allows us to handle varying scheme's without making assumptions based on the ':' character. Specifically
+     * handle scheme extraction calls for URI parameters that are not actually uri's, but may be names with ':' in them.
+     * </p>
+     * @param schemes The schemes to check.
+     * @param uri The potential URI. May also just be a name.
+     * @param buffer Returns the remainder of the URI.
+     * @return The scheme name. Returns null if there is no scheme.
+     */
+    public static String extractScheme(final String[] schemes, final String uri, StringBuilder buffer) {
+        if (buffer != null) {
+            buffer.setLength(0);
+            buffer.append(uri);
+        }
+        for(String scheme : schemes) {
+            if(uri.startsWith(scheme + ":")) {
+                if (buffer != null) {
+                    buffer.delete(0, uri.indexOf(':') + 1);
+                }
+                return scheme;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Extracts the scheme from a URI.
+     *
+     * @param uri The URI.
+     * @return The scheme name. Returns null if there is no scheme.
+     * @deprecated Use instead {@link #extractScheme}.  Will be removed in 3.0.
+     */
+    @Deprecated
+    public static String extractScheme(final String uri) {
+        return extractScheme(uri, null);
+    }
+
+    /**
+     * Extracts the scheme from a URI. Removes the scheme and ':' delimiter from the front of the URI.
+     *
+     * @param uri The URI.
+     * @param buffer Returns the remainder of the URI.
+     * @return The scheme name. Returns null if there is no scheme.
+     * @deprecated Use instead {@link #extractScheme}.  Will be removed in 3.0.
+     */
+    @Deprecated
+    public static String extractScheme(final String uri, final StringBuilder buffer) {
+        if (buffer != null) {
+            buffer.setLength(0);
+            buffer.append(uri);
+        }
+
+        final int maxPos = uri.length();
+        for (int pos = 0; pos < maxPos; pos++) {
+            final char ch = uri.charAt(pos);
+
+            if (ch == ':') {
+                // Found the end of the scheme
+                final String scheme = uri.substring(0, pos);
+                if (scheme.length() <= 1 && Os.isFamily(Os.OS_FAMILY_WINDOWS)) {
+                    // This is not a scheme, but a Windows drive letter
+                    return null;
+                }
+                if (buffer != null) {
+                    buffer.delete(0, pos + 1);
+                }
+                return scheme.intern();
+            }
+
+            if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
+                // A scheme character
+                continue;
+            }
+            if (pos > 0 && ((ch >= '0' && ch <= '9') || ch == '+' || ch == '-' || ch == '.')) {
+                // A scheme character (these are not allowed as the first
+                // character of the scheme, but can be used as subsequent
+                // characters.
+                continue;
+            }
+
+            // Not a scheme character
+            break;
+        }
+
+        // No scheme in URI
+        return null;
+    }
+
+    /**
+     * Normalises the separators in a name.
+     *
+     * @param name The StringBuilder containing the name
+     * @return true if the StringBuilder was modified.
+     */
+    public static boolean fixSeparators(final StringBuilder name) {
+        boolean changed = false;
+        final int maxlen = name.length();
+        for (int i = 0; i < maxlen; i++) {
+            final char ch = name.charAt(i);
+            if (ch == TRANS_SEPARATOR) {
+                name.setCharAt(i, SEPARATOR_CHAR);
+                changed = true;
+            }
+        }
+        return changed;
+    }
+
+    /**
+     * Normalises a path. Does the following:
+     * <ul>
+     * <li>Removes empty path elements.
+     * <li>Handles '.' and '..' elements.
+     * <li>Removes trailing separator.
+     * </ul>
+     *
+     * Its assumed that the separators are already fixed.
+     *
+     * @param path The path to normalize.
+     * @return The FileType.
+     * @throws FileSystemException if an error occurs.
+     *
+     * @see #fixSeparators
+     */
+    public static FileType normalisePath(final StringBuilder path) throws FileSystemException {
+        FileType fileType = FileType.FOLDER;
+        if (path.length() == 0) {
+            return fileType;
+        }
+
+        if (path.charAt(path.length() - 1) != '/') {
+            fileType = FileType.FILE;
+        }
+
+        // Adjust separators
+        // fixSeparators(path);
+
+        // Determine the start of the first element
+        int startFirstElem = 0;
+        if (path.charAt(0) == SEPARATOR_CHAR) {
+            if (path.length() == 1) {
+                return fileType;
+            }
+            startFirstElem = 1;
+        }
+
+        // Iterate over each element
+        int startElem = startFirstElem;
+        int maxlen = path.length();
+        while (startElem < maxlen) {
+            // Find the end of the element
+            int endElem = startElem;
+            for (; endElem < maxlen && path.charAt(endElem) != SEPARATOR_CHAR; endElem++) {
+            }
+
+            final int elemLen = endElem - startElem;
+            if (elemLen == 0) {
+                // An empty element - axe it
+                path.delete(endElem, endElem + 1);
+                maxlen = path.length();
+                continue;
+            }
+            if (elemLen == 1 && path.charAt(startElem) == '.') {
+                // A '.' element - axe it
+                path.delete(startElem, endElem + 1);
+                maxlen = path.length();
+                continue;
+            }
+            if (elemLen == 2 && path.charAt(startElem) == '.' && path.charAt(startElem + 1) == '.') {
+                // A '..' element - remove the previous element
+                if (startElem == startFirstElem) {
+                    // Previous element is missing
+                    throw new FileSystemException("vfs.provider/invalid-relative-path.error");
+                }
+
+                // Find start of previous element
+                int pos = startElem - 2;
+                for (; pos >= 0 && path.charAt(pos) != SEPARATOR_CHAR; pos--) {
+                }
+                startElem = pos + 1;
+
+                path.delete(startElem, endElem + 1);
+                maxlen = path.length();
+                continue;
+            }
+
+            // A regular element
+            startElem = endElem + 1;
+        }
+
+        // Remove trailing separator
+        if (!VFS.isUriStyle() && maxlen > 1 && path.charAt(maxlen - 1) == SEPARATOR_CHAR) {
+            path.delete(maxlen - 1, maxlen);
+        }
+
+        return fileType;
+    }
+
+    private UriParser() {
+    }
 }
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/local/LocalFileNameParser.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/local/LocalFileNameParser.java
index cdf65ac2..cd4b6794 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/local/LocalFileNameParser.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/local/LocalFileNameParser.java
@@ -19,6 +19,7 @@ package org.apache.commons.vfs2.provider.local;
 import org.apache.commons.vfs2.FileName;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileType;
+import org.apache.commons.vfs2.VFS;
 import org.apache.commons.vfs2.provider.AbstractFileNameParser;
 import org.apache.commons.vfs2.provider.UriParser;
 import org.apache.commons.vfs2.provider.VfsComponentContext;
@@ -61,7 +62,7 @@ public abstract class LocalFileNameParser extends AbstractFileNameParser {
         final StringBuilder name = new StringBuilder();
 
         // Extract the scheme
-        String scheme = UriParser.extractScheme(uri, name);
+        String scheme = UriParser.extractScheme(context.getFileSystemManager().getSchemes(), uri, name);
         if (scheme == null) {
             scheme = "file";
         }
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/res/ResourceFileProvider.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/res/ResourceFileProvider.java
index 126ced2c..c7862efe 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/res/ResourceFileProvider.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/res/ResourceFileProvider.java
@@ -27,6 +27,7 @@ import org.apache.commons.vfs2.FileSystem;
 import org.apache.commons.vfs2.FileSystemConfigBuilder;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileSystemOptions;
+import org.apache.commons.vfs2.VFS;
 import org.apache.commons.vfs2.provider.AbstractFileProvider;
 import org.apache.commons.vfs2.provider.UriParser;
 
@@ -57,7 +58,7 @@ public class ResourceFileProvider extends AbstractFileProvider {
     public FileObject findFile(final FileObject baseFile, final String uri, final FileSystemOptions fileSystemOptions)
             throws FileSystemException {
         final StringBuilder buf = new StringBuilder(BUFFER_SIZE);
-        UriParser.extractScheme(uri, buf);
+        UriParser.extractScheme(VFS.getManager().getSchemes(), uri, buf);
         final String resourceName = buf.toString();
 
         ClassLoader classLoader = ResourceFileSystemConfigBuilder.getInstance().getClassLoader(fileSystemOptions);
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/temp/TemporaryFileProvider.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/temp/TemporaryFileProvider.java
index 75eb4f0e..a1994b7b 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/temp/TemporaryFileProvider.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/temp/TemporaryFileProvider.java
@@ -25,6 +25,7 @@ import org.apache.commons.vfs2.FileObject;
 import org.apache.commons.vfs2.FileSystem;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileSystemOptions;
+import org.apache.commons.vfs2.VFS;
 import org.apache.commons.vfs2.provider.AbstractFileProvider;
 import org.apache.commons.vfs2.provider.UriParser;
 import org.apache.commons.vfs2.provider.local.DefaultLocalFileProvider;
@@ -81,7 +82,7 @@ public class TemporaryFileProvider extends AbstractFileProvider implements Compa
             final FileSystemOptions properties) throws FileSystemException {
         // Parse the name
         final StringBuilder buffer = new StringBuilder(uri);
-        final String scheme = UriParser.extractScheme(uri, buffer);
+        final String scheme = UriParser.extractScheme(VFS.getManager().getSchemes(), uri, buffer);
         UriParser.fixSeparators(buffer);
         UriParser.normalisePath(buffer);
         final String path = buffer.toString();
diff --git a/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/UriParserTestCase.java b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/UriParserTestCase.java
index a82b3011..4e506780 100644
--- a/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/UriParserTestCase.java
+++ b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/UriParserTestCase.java
@@ -17,6 +17,7 @@
 package org.apache.commons.vfs2.provider;
 
 import org.junit.Assert;
+import org.junit.BeforeClass;
 import org.junit.Test;
 
 /**
@@ -25,14 +26,56 @@ import org.junit.Test;
  */
 public class UriParserTestCase {
 
-    @Test
-    public void testColonInFileName() {
-        Assert.assertEquals(null, UriParser.extractScheme("some/path/some:file"));
-    }
+	private static final String[] schemes = new String[2];
 
-    @Test
-    public void testNormalScheme() {
-        Assert.assertEquals("ftp", UriParser.extractScheme("ftp://user:pass@host/some/path/some:file"));
-    }
+	@BeforeClass
+	public static void setupSchemes() {
+		schemes[0] = "ftp";
+		schemes[1] = "file";
+	}
+
+	@Test
+	public void testColonInFileNameAndNotSupportedScheme() {
+		Assert.assertEquals(null, UriParser.extractScheme(schemes, "some:file"));
+	}
+
+	@Test
+	public void testColonInFileNameWithPath() {
+		Assert.assertEquals(null, UriParser.extractScheme(schemes, "some/path/some:file"));
+	}
+
+	@Test
+	public void testNormalScheme() {
+		Assert.assertEquals("ftp", UriParser.extractScheme(schemes, "ftp://user:pass@host/some/path/some:file"));
+	}
+
+	@Test
+	public void testOneSlashScheme() {
+		Assert.assertEquals("file", UriParser.extractScheme(schemes, "file:/user:pass@host/some/path/some:file"));
+	}
+
+	@Test
+	public void testColonNotFollowedBySlash() {
+		Assert.assertEquals("file", UriParser.extractScheme(schemes, "file:user/subdir/some/path/some:file"));
+	}
+
+	@Test
+	public void testNormalSchemeWithBuffer() {
+		StringBuilder buffer = new StringBuilder();
+		UriParser.extractScheme(schemes, "ftp://user:pass@host/some/path/some:file", buffer);
+		Assert.assertEquals("//user:pass@host/some/path/some:file", buffer.toString());
+	}
+
+	@Test
+	public void testOneSlashSchemeWithBuffer() {
+		StringBuilder buffer = new StringBuilder();
+		UriParser.extractScheme(schemes, "file:/user:pass@host/some/path/some:file", buffer);
+		Assert.assertEquals("/user:pass@host/some/path/some:file", buffer.toString());
+	}
+
+	@Test
+	public void testColonInFileName() {
+		Assert.assertEquals(null, UriParser.extractScheme("some/path/some:file"));
+	}
 
 }
diff --git a/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/local/test/FileNameTests.java b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/local/test/FileNameTests.java
index 8104d8a3..bd674c9c 100644
--- a/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/local/test/FileNameTests.java
+++ b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/local/test/FileNameTests.java
@@ -17,7 +17,7 @@
 package org.apache.commons.vfs2.provider.local.test;
 
 import java.io.File;
-
+import org.apache.commons.vfs2.FileName;
 import org.apache.commons.vfs2.FileObject;
 import org.apache.commons.vfs2.impl.DefaultFileSystemManager;
 import org.apache.commons.vfs2.test.AbstractProviderTestCase;
diff --git a/pom.xml b/pom.xml
index 2070289c..01585c8e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -135,6 +135,10 @@
       <name>Jose Juan Montiel</name>
       <email>josejuan.montiel -at- gmail.com</email>
     </contributor>
+    <contributor>
+      <name>Otto Fowler</name>
+      <email>otto -at- apache.org</email>
+    </contributor>
   </contributors>
 
   <properties>
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 9400bd7f..cc80413e 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -116,6 +116,9 @@ The <action> type attribute can be add,update,fix,remove.
       <action issue="VFS-679" dev="ggregory" type="fix" due-to="Boris Petrov, Gary Gregory">
         NullPointerException in FtpFileObject.doGetLastModifiedTime().
       </action>
+      <action issue="VFS-398" dev="ggregory" type="fix" due-to="Otto Fowler">
+        FtpFileObject.getChildren() fails when a folder contains a file with a colon in the name.
+      </action>
     </release>
     <release version="2.2" date="2017-10-06" description="New features and bug fix release.">
       <action issue="VFS-642" dev="pschumacher" type="update" due-to="ilangoldfeld">
