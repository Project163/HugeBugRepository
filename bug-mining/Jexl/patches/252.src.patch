diff --git a/src/main/java/org/apache/commons/jexl3/internal/Engine.java b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
index b6a7adb0..aa68e9de 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Engine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
@@ -785,20 +785,6 @@ public class Engine extends JexlEngine implements JexlUberspect.ConstantResolver
         return opts;
     }
 
-    /**
-     * Parses an expression.
-     *
-     * @param info      information structure
-     * @param expr     whether we parse an expression or a feature
-     * @param src      the expression to parse
-     * @param scope     the script frame
-     * @return the parsed tree
-     * @throws JexlException if any error occurred during parsing
-     */
-    protected ASTJexlScript parse(final JexlInfo info, final boolean expr, final String src, final Scope scope) {
-        return parser.jxltParse(info, expr? this.expressionFeatures : this.scriptFeatures, src, scope);
-    }
-
     /**
      * Parses an expression.
      *
@@ -825,12 +811,14 @@ public class Engine extends JexlEngine implements JexlUberspect.ConstantResolver
         try {
             // if parser not in use...
             if (parsing.compareAndSet(false, true)) {
-                try {
-                    // lets parse
-                    script = parser.parse(ninfo, features, src, scope);
-                } finally {
-                    // no longer in use
-                    parsing.set(false);
+                synchronized (parsing) {
+                    try {
+                        // lets parse
+                        script = parser.parse(ninfo, features, src, scope);
+                    } finally {
+                        // no longer in use
+                        parsing.set(false);
+                    }
                 }
             } else {
                 // ...otherwise parser was in use, create a new temporary one
@@ -848,7 +836,6 @@ public class Engine extends JexlEngine implements JexlUberspect.ConstantResolver
 
     /**
      * Parses a Jexl expression or script.
-     * <p>This is a convenience method that uses the default parser and the script features.
      * @param info the JexlInfo
      * @param expr whether to parse an expression or a script
      * @param src the source to parse
@@ -856,7 +843,9 @@ public class Engine extends JexlEngine implements JexlUberspect.ConstantResolver
      * @return the parsed tree
      */
     protected ASTJexlScript jxltParse(final JexlInfo info, final boolean expr, final String src, final Scope scope) {
-        return parse(info, expr, src, scope);
+        synchronized(parsing) {
+            return parser.jxltParse(info, expr ? this.expressionFeatures : this.scriptFeatures, src, scope);
+        }
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Frame.java b/src/main/java/org/apache/commons/jexl3/internal/Frame.java
index eed58905..e86d498f 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Frame.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Frame.java
@@ -37,7 +37,7 @@ public class Frame {
      * @param r the stack frame
      * @param c the number of curried parameters
      */
-    protected Frame(Scope s, final Object[] r, final int c) {
+    protected Frame(final Scope s, final Object[] r, final int c) {
         scope = s;
         stack = r;
         curried = c;
diff --git a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
index 64e91583..d4e87201 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
@@ -515,7 +515,7 @@ public final class TemplateEngine extends JxltEngine {
         @Override
         protected TemplateExpression prepare(final Interpreter interpreter) {
             final String value = interpreter.interpret(node).toString();
-            final JexlNode dnode = jexl.parse(node.jexlInfo(), noscript, value, null);
+            final JexlNode dnode = jexl.jxltParse(node.jexlInfo(), noscript, value, null);
             return new ImmediateExpression(value, dnode, this);
         }
     }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java b/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java
index a210a56e..990045cc 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/TemplateScript.java
@@ -18,12 +18,10 @@ package org.apache.commons.jexl3.internal;
 
 import java.io.Reader;
 import java.io.Writer;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import java.util.TreeMap;
 
 import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlException;
@@ -45,48 +43,114 @@ import org.apache.commons.jexl3.parser.JexlNode;
  */
 public final class TemplateScript implements JxltEngine.Template {
     /**
-     * Collects the scope surrounding a call to jexl:print(i).
-     * <p>This allows to later parse the blocks with the known symbols
-     * in the frame visible to the parser.
+     * Collects the call-site surrounding a call to jexl:print(i).
+     * <p>This allows parsing the blocks with the known symbols
+     * in the frame visible to the parser.</p>
      * @param node the visited node
-     * @param minfo the map of printed expression number to node info
+     * @param callSites the map of printed expression number to node info
      */
-    private static void collectPrintScope(final JexlNode node, final Map<Integer, JexlNode.Info> minfo) {
+    private static void collectPrintScope(final JexlNode node, final JexlNode.Info[] callSites) {
         final int nc = node.jjtGetNumChildren();
         if (node instanceof ASTFunctionNode && nc == 2) {
-            // 0 must be the prefix jexl:
+            // is child[0] jexl:print()?
             final ASTIdentifier nameNode = (ASTIdentifier) node.jjtGetChild(0);
             if ("print".equals(nameNode.getName()) && "jexl".equals(nameNode.getNamespace())) {
+                // is there one argument?
                 final ASTArguments argNode = (ASTArguments) node.jjtGetChild(1);
                 if (argNode.jjtGetNumChildren() == 1) {
-                    // seek the epression number
+                    // seek the expression number
                     final JexlNode arg0 = argNode.jjtGetChild(0);
                     if (arg0 instanceof ASTNumberLiteral) {
                         final int exprNumber = ((ASTNumberLiteral) arg0).getLiteral().intValue();
-                        minfo.put(exprNumber, new JexlNode.Info(nameNode));
+                        callSites[exprNumber] = new JexlNode.Info(nameNode);
                         return;
                     }
                 }
             }
         }
         for (int c = 0; c < nc; ++c) {
-            collectPrintScope(node.jjtGetChild(c), minfo);
+            collectPrintScope(node.jjtGetChild(c), callSites);
         }
     }
+
     /**
-     * Gets the scope from an info.
+     * Gets the scope from a node info.
      * @param info the node info
+     * @param scope the outer scope
      * @return the scope
      */
-    private static Scope scopeOf(final JexlNode.Info info) {
+    private static Scope scopeOf(final JexlNode.Info info, final Scope scope) {
+        Scope found = null;
         JexlNode walk = info.getNode();
-        while(walk != null) {
+        while (walk != null) {
             if (walk instanceof ASTJexlScript) {
-                return ((ASTJexlScript) walk).getScope();
+                found = ((ASTJexlScript) walk).getScope();
+                break;
             }
             walk = walk.jjtGetParent();
         }
-        return null;
+        return found != null ? found : scope;
+    }
+
+    /**
+     * Creates the expression array from the list of blocks.
+     * @param scope the outer scope
+     * @param blocks the list of blocks
+     * @return the array of expressions
+     */
+    private TemplateExpression[] calleeScripts(final Scope scope, final Block[] blocks, final JexlNode.Info[] callSites) {
+        final TemplateExpression[] expressions = new TemplateExpression[callSites.length];
+        // jexl:print(...) expression counter
+        int jpe = 0;
+        // create the expressions using the intended scopes
+        for (final Block block : blocks) {
+            if (block.getType() == BlockType.VERBATIM) {
+                final JexlNode.Info ji = callSites[jpe];
+                // no node info means this verbatim is surrounded by comments markers;
+                // expr at this index is never called
+                final TemplateExpression te = ji != null
+                    ? jxlt.parseExpression(ji, block.getBody(), scopeOf(ji, scope))
+                    : jxlt.new ConstantExpression(block.getBody(), null);
+                expressions[jpe++] = te;
+            }
+        }
+        return expressions;
+    }
+
+    /**
+     * Creates the script calling the list of blocks.
+     * <p>This is used to create a script from a list of blocks
+     * that were parsed from a template.</p>
+     * @param blocks the list of blocks
+     * @return the script source
+     */
+    private static String callerScript(Block[] blocks) {
+        final StringBuilder strb = new StringBuilder();
+        int nuexpr = 0;
+        int line = 1;
+        for (final Block block : blocks) {
+            final int bl = block.getLine();
+            while (line < bl) {
+                strb.append("//\n");
+                line += 1;
+            }
+            if (block.getType() == BlockType.VERBATIM) {
+                strb.append("jexl:print(");
+                strb.append(nuexpr++);
+                strb.append(");\n");
+                line += 1;
+            } else {
+                final String body = block.getBody();
+                strb.append(body);
+                // keep track of the line number
+                for (int c = 0; c < body.length(); ++c) {
+                    if (body.charAt(c) == '\n') {
+                        line += 1;
+                    }
+                }
+            }
+        }
+        return strb.toString();
     }
 
     /** The prefix marker. */
@@ -129,73 +193,28 @@ public final class TemplateScript implements JxltEngine.Template {
         Objects.requireNonNull(reader, "reader");
         this.jxlt = engine;
         this.prefix = directive;
-        final List<Block> blocks = jxlt.readTemplate(prefix, reader);
-        final List<TemplateExpression> uexprs = new ArrayList<>();
-        final StringBuilder strb = new StringBuilder();
-        int nuexpr = 0;
-        int codeStart = -1;
-        int line = 1;
-        for (int b = 0; b < blocks.size(); ++b) {
-            final Block block = blocks.get(b);
-            final int bl = block.getLine();
-            while(line < bl) {
-                strb.append("//\n");
-                line += 1;
-            }
-            if (block.getType() == BlockType.VERBATIM) {
-                strb.append("jexl:print(");
-                strb.append(nuexpr++);
-                strb.append(");\n");
-                line += 1;
-            } else {
-                // keep track of first block of code, the frame creator
-                if (codeStart < 0) {
-                    codeStart = b;
-                }
-                final String body = block.getBody();
-                strb.append(body);
-                for(int c = 0; c < body.length(); ++c) {
-                    if (body.charAt(c) == '\n') {
-                        line += 1;
-                    }
-                }
+        final Engine jexl = jxlt.getEngine();
+        // create the caller script
+        final Block[] blocks = jxlt.readTemplate(prefix, reader).toArray(new Block[0]);
+        int verbatims = 0;
+        for(Block b : blocks) {
+            if (BlockType.VERBATIM == b.getType()) {
+                verbatims += 1;
             }
         }
-        // create the script
-        final JexlInfo info = jexlInfo == null ? jxlt.getEngine().createInfo() : jexlInfo;
+        final String scriptSource = callerScript(blocks);
         // allow lambda defining params
+        final JexlInfo info = jexlInfo == null ? jexl.createInfo() : jexlInfo;
         final Scope scope = parms == null ? null : new Scope(null, parms);
-        script = jxlt.getEngine().parse(info.at(1, 1), false, strb.toString(), scope).script();
+        ASTJexlScript callerScript = jexl.jxltParse(info.at(1, 1), false, scriptSource, scope).script();
         // seek the map of expression number to scope so we can parse Unified
         // expression blocks with the appropriate symbols
-        final Map<Integer, JexlNode.Info> minfo = new TreeMap<>();
-        collectPrintScope(script.script(), minfo);
-        // jexl:print(...) expression counter
-        int jpe = 0;
-        // create the exprs using the intended scopes
-        for (final Block block : blocks) {
-            if (block.getType() == BlockType.VERBATIM) {
-                final JexlNode.Info ji = minfo.get(jpe);
-                TemplateExpression te;
-                // no node info means this verbatim is surrounded by comments markers;
-                // expr at this index is never called
-                if (ji != null) {
-                    Scope es = scopeOf(ji);
-                    if (es == null) {
-                        // if the scope is null, it means the verbatim is at the top level
-                        // of the script, so we use the script scope
-                        es = scope;
-                    }
-                    te = jxlt.parseExpression(ji, block.getBody(), es);
-                } else {
-                    te = jxlt.new ConstantExpression(block.getBody(), null);
-                }
-                uexprs.add(te);
-                jpe += 1;
-            }
-        }
-        source = blocks.toArray(new Block[0]);
-        exprs = uexprs.toArray(new TemplateExpression[0]);
+        final JexlNode.Info[] callSites = new JexlNode.Info[verbatims];
+        collectPrintScope(callerScript.script(), callSites);
+        // create the expressions from the blocks
+        this.exprs = calleeScripts(scope, blocks, callSites);
+        this.script = callerScript;
+        this.source = blocks;
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
index da33ecbe..9c7e3ff5 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
@@ -32,6 +32,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.commons.jexl3.JexlEngine;
@@ -156,11 +157,8 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
      */
     protected static String stringify(final Iterable<String> lstr) {
         final StringBuilder strb = new StringBuilder();
-        boolean dot = false;
         for(final String str : lstr) {
-            if (!dot) {
-               dot = true;
-            } else {
+            if (strb.length() > 0) {
                strb.append('.');
             }
             strb.append(str);
@@ -196,19 +194,16 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * The optional class name and constant resolver.
      */
-    protected JexlUberspect.ClassConstantResolver fqcnResolver = null;
+    protected final AtomicReference<JexlUberspect.ClassConstantResolver> fqcnResolver;
     /**
      * The list of imports.
      * <p>Imports are used to resolve simple class names into fully qualified class names.</p>
      */
-    protected List<String> imports = new ArrayList<>();
+    protected final List<String> imports;
 
 
     void addImport(String importName) {
         if (importName != null && !importName.isEmpty()) {
-            if (imports == null) {
-                imports = new ArrayList<>();
-            }
             if (!imports.contains(importName)) {
                 imports.add(importName);
             }
@@ -216,11 +211,12 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     }
 
     Object resolveConstant(String name) {
-        JexlUberspect.ClassConstantResolver resolver = fqcnResolver;
+        JexlUberspect.ClassConstantResolver resolver = fqcnResolver.get();
         if (resolver == null) {
             JexlEngine engine = JexlEngine.getThreadEngine();
             if (engine instanceof JexlUberspect.ConstantResolverFactory) {
-                fqcnResolver = resolver = ((JexlUberspect.ConstantResolverFactory) engine).createConstantResolver(imports);
+                resolver = ((JexlUberspect.ConstantResolverFactory) engine).createConstantResolver(imports);
+                fqcnResolver.set(resolver);
             }
         }
         return resolver != null
@@ -239,7 +235,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * The number of nested loops.
      */
-    protected int loopCount;
+    protected AtomicInteger loopCount;
     /**
      * Stack of parsing loop counts.
      */
@@ -247,7 +243,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * The current lexical block.
      */
-    protected AtomicReference<LexicalUnit> blockReference;
+    protected final AtomicReference<LexicalUnit> blockReference;
     /**
      * Stack of lexical blocks.
      */
@@ -300,10 +296,13 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
             featureController = new FeatureController(JexlEngine.DEFAULT_FEATURES);
             scopeReference = new AtomicReference<>();
             blockReference = new AtomicReference<>();
+            fqcnResolver = new AtomicReference<>();
+            loopCount = new AtomicInteger(0);
             scopes = new ArrayDeque<>();
             loopCounts = new ArrayDeque<>();
             blocks = new ArrayDeque<>();
             blockScopes = new IdentityHashMap<>();
+            imports = new ArrayList<>();
         }
     }
 
@@ -481,7 +480,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
                     // captured are declared in all cases
                     identifier.setCaptured(true);
                 } else {
-                    LexicalUnit unit = blockReference.get();
+                    LexicalUnit unit = getUnit();
                     declared = unit.hasSymbol(symbol);
                     // one of the lexical blocks above should declare it
                     if (!declared) {
@@ -527,10 +526,10 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
             scopes.clear();
             pragmas = null;
             namespaces = null;
-            fqcnResolver = null;
+            fqcnResolver.set(null);
             imports.clear();
             loopCounts.clear();
-            loopCount = 0;
+            loopCount.set(0);
             blocks.clear();
             blockReference.set(null);
             blockScopes.clear();
@@ -570,7 +569,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
         // function is const fun...
         if (declareSymbol(symbol)) {
             scope.addLexical(symbol);
-            LexicalUnit block = blockReference.get();
+            LexicalUnit block = getUnit();
             block.setConstant(symbol);
         } else {
             if (getFeatures().isLexical()) {
@@ -603,7 +602,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
         final int symbol = scope.declareParameter(identifier);
         // not sure how declaring a parameter could fail...
         // lexical feature error
-        LexicalUnit block = blockReference.get();
+        LexicalUnit block = getUnit();
         if (!block.declareSymbol(symbol)) {
             if (lexical || getFeatures().isLexical()) {
                 final JexlInfo xinfo = info.at(token.beginLine, token.beginColumn);
@@ -683,7 +682,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
                 break;
             }
         }
-        LexicalUnit block = blockReference.get();
+        LexicalUnit block = getUnit();
         return block == null || block.declareSymbol(symbol);
     }
 
@@ -726,7 +725,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
         } else if (lexical) {
             scope.addLexical(symbol);
             if (constant) {
-                LexicalUnit block = blockReference.get();
+                LexicalUnit block = getUnit();
                 block.setConstant(symbol);
             }
         }
@@ -764,6 +763,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     protected LexicalUnit getUnit() {
         return blockReference.get();
     }
+
     /**
      * Default implementation does nothing but is overridden by generated code.
      * @param top whether the identifier is beginning an l/r value
@@ -781,11 +781,11 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
      */
     private boolean isConstant(final int symbol) {
         if (symbol >= 0) {
-            LexicalUnit block = blockReference.get();
+            LexicalUnit block = getUnit();
             if (block != null && block.hasSymbol(symbol)) {
                 return block.isConstant(symbol);
             }
-            Scope blockScope = blockScopes.get(blockReference.get());
+            Scope blockScope = blockScopes.get(block);
             int lexical = symbol;
             for (final LexicalUnit unit : blocks) {
                 final Scope unitScope = blockScopes.get(unit);
@@ -961,7 +961,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
 
     /**
      * Parses an embedded Jexl expression within an interpolation node.
-     * <p>This creates a sub-parser that shares the scopes and of the parent parser.</p>
+     * <p>This creates a sub-parser that shares the scopes of the parent parser.</p>
      * @param info the JexlInfo
      * @param src the source to parse
      * @return the parsed tree
@@ -1005,7 +1005,7 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
         Scope scope = scopes.isEmpty() ? null : scopes.pop();
         scopeReference.set(scope);
         if (!loopCounts.isEmpty()) {
-            loopCount = loopCounts.pop();
+            loopCount.set(loopCounts.pop());
         }
     }
 
@@ -1024,16 +1024,14 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     /**
      * Create a new local variable scope and push it as current.
      */
-    protected Scope pushScope() {
+    protected void pushScope() {
         Scope scope = scopeReference.get();
         if (scope != null) {
             scopes.push(scope);
         }
         scope = new Scope(scope, (String[]) null);
         scopeReference.set(scope);
-        loopCounts.push(loopCount);
-        loopCount = 0;
-        return scope;
+        loopCounts.push(loopCount.getAndSet(0));
     }
 
     /**
@@ -1051,13 +1049,12 @@ public abstract class JexlParser extends StringParser implements JexlScriptParse
     }
 
     protected void pushLoop() {
-        loopCounts.push(loopCount);
-        loopCount = 0;
+        loopCounts.push(loopCount.getAndSet(0));
     }
 
     protected void popLoop() {
         if (!loopCounts.isEmpty()) {
-            loopCount = loopCounts.pop();
+            loopCount.set(loopCounts.pop());
         }
     }
 
diff --git a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
index edc6e234..5537abc9 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
@@ -500,12 +500,12 @@ LOOKAHEAD(2) Var() | Identifier(true)
 
 void WhileStatement() : {}
 {
-    <WHILE> <LPAREN> Expression() <RPAREN>  { loopCount += 1; }  (LOOKAHEAD(1) Block() | StatementNoVar()) { loopCount -= 1; }
+    <WHILE> <LPAREN> Expression() <RPAREN>  { loopCount.incrementAndGet(); }  (LOOKAHEAD(1) Block() | StatementNoVar()) { loopCount.decrementAndGet(); }
 }
 
 void DoWhileStatement() : {}
 {
-    <DO> { loopCount += 1; } (LOOKAHEAD(1) Block() | StatementNoVar()) <WHILE> <LPAREN> Expression() <RPAREN> { loopCount -= 1; }
+    <DO> { loopCount.incrementAndGet(); } (LOOKAHEAD(1) Block() | StatementNoVar()) <WHILE> <LPAREN> Expression() <RPAREN> { loopCount.decrementAndGet(); }
 }
 
 void ReturnStatement() : {
@@ -526,14 +526,14 @@ void Continue() #Continue : {
     Token t;
 }
 {
-    t=<CONTINUE> { if (loopCount == 0) { throwParsingException(t); } }
+    t=<CONTINUE> { if (loopCount.get() == 0) { throwParsingException(t); } }
 }
 
 void Break() #Break : {
     Token t;
 }
 {
-    t=<BREAK> { if (loopCount == 0) { throwParsingException(t); } }
+    t=<BREAK> { if (loopCount.get() == 0) { throwParsingException(t); } }
 }
 
 void ForeachStatement() : {
@@ -553,11 +553,11 @@ void ForeachStatement() : {
     )
     <RPAREN>
     {
-        loopCount += 1;
+        loopCount.incrementAndGet();
     }
         (LOOKAHEAD(1) Block() | StatementNoVar() )
     {
-        loopCount -= 1;
+        loopCount.decrementAndGet();
         jjtThis.setLoopForm(loopForm);
         popUnit(jjtThis);
     }
@@ -633,7 +633,7 @@ void SwitchStatementCase(SwitchSet cases) #CaseStatement :
 {
     Object constant;
     List<Object> constants;
-    loopCount += 1;
+    loopCount.incrementAndGet();
 }
 {
     ( ( LOOKAHEAD(2) <CASE> constant=constLiteral() <COLON>
@@ -642,7 +642,7 @@ void SwitchStatementCase(SwitchSet cases) #CaseStatement :
         <CASE_DEFAULT> <COLON> )
     ( LOOKAHEAD(<LCURLY>) Block() | (StatementNoVar())+ )?
 {
-    loopCount -= 1;
+    loopCount.decrementAndGet();
 }
 }
 
diff --git a/src/test/java/org/apache/commons/jexl3/Issues400Test.java b/src/test/java/org/apache/commons/jexl3/Issues400Test.java
index d06a67a7..efc84ae4 100644
--- a/src/test/java/org/apache/commons/jexl3/Issues400Test.java
+++ b/src/test/java/org/apache/commons/jexl3/Issues400Test.java
@@ -724,6 +724,11 @@ public class Issues400Test {
         public ASTJexlScript parse(final JexlInfo info, final JexlFeatures features, final String src, final Scope scope) {
             return parser.parse(info, features, transcodeSQLExpr(src), scope);
         }
+
+        @Override
+        public ASTJexlScript jxltParse(final JexlInfo info, final JexlFeatures features, final String src, final Scope scope) {
+            return new Parser(parser).parse(info, features, transcodeSQLExpr(src), scope);
+        }
     }
 
 
