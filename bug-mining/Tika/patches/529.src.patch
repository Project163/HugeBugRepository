diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/pdf/PDFParser.java b/tika-parsers/src/main/java/org/apache/tika/parser/pdf/PDFParser.java
index 6003777f9..d765db862 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/pdf/PDFParser.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/pdf/PDFParser.java
@@ -24,6 +24,8 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
+import org.apache.jempbox.xmp.XMPSchema;
+import org.apache.jempbox.xmp.XMPSchemaDublinCore;
 import org.apache.jempbox.xmp.pdfa.XMPSchemaPDFAId;
 import org.apache.pdfbox.cos.COSArray;
 import org.apache.pdfbox.cos.COSBase;
@@ -160,10 +162,24 @@ public class PDFParser extends AbstractParser {
 
     private void extractMetadata(PDDocument document, Metadata metadata)
             throws TikaException {
+
+        org.apache.jempbox.xmp.XMPMetadata xmp = null;
+        XMPSchemaDublinCore dcSchema = null;
+        try{
+            if (document.getDocumentCatalog().getMetadata() != null){
+                xmp = document.getDocumentCatalog().getMetadata().exportXMPMetadata();
+            }
+            if (xmp != null){
+                dcSchema = xmp.getDublinCoreSchema();
+            }
+        } catch (IOException e){
+            //swallow
+        }
         PDDocumentInformation info = document.getDocumentInformation();
         metadata.set(PagedText.N_PAGES, document.getNumberOfPages());
-        addMetadata(metadata, TikaCoreProperties.TITLE, info.getTitle());
-        addMetadata(metadata, TikaCoreProperties.CREATOR, info.getAuthor());
+        extractDublinCoreListItems(metadata, TikaCoreProperties.TITLE, info.getTitle(), dcSchema);
+        extractDublinCoreListItems(metadata, TikaCoreProperties.CREATOR, info.getAuthor(), dcSchema);
+        extractDublinCoreListItems(metadata, TikaCoreProperties.CONTRIBUTOR, null, dcSchema);
         addMetadata(metadata, TikaCoreProperties.CREATOR_TOOL, info.getCreator());
         addMetadata(metadata, TikaCoreProperties.KEYWORDS, info.getKeywords());
         addMetadata(metadata, "producer", info.getProducer());
@@ -215,8 +231,7 @@ public class PDFParser extends AbstractParser {
             MEDIA_TYPE.toString()+"; version="+Float.toString(document.getDocument().getVersion()));
 
         try {           
-            if( document.getDocumentCatalog().getMetadata() != null ) {
-                org.apache.jempbox.xmp.XMPMetadata xmp = document.getDocumentCatalog().getMetadata().exportXMPMetadata();
+            if( xmp != null ) {
                 xmp.addXMLNSMapping(XMPSchemaPDFAId.NAMESPACE, XMPSchemaPDFAId.class);
                 XMPSchemaPDFAId pdfaxmp = (XMPSchemaPDFAId) xmp.getSchemaByClass(XMPSchemaPDFAId.class);
                 if( pdfaxmp != null ) {
@@ -259,6 +274,68 @@ public class PDFParser extends AbstractParser {
         }
     }
 
+    /**
+     * This tries to read a list from a particular property in
+     * XMPSchemaDublinCore.
+     * If it can't find the information, it falls back to the 
+     * pdfboxBaseline.  The pdfboxBaseline should be the value
+     * that pdfbox returns from its PDDocumentInformation object
+     * (e.g. getAuthor()) This method is designed include the pdfboxBaseline,
+     * and it should not duplicate the pdfboxBaseline.
+     * <p>
+     * Until PDFBOX-1803/TIKA-1233 are fixed, do not call this
+     * on dates!
+     * 
+     * @param property
+     * @param pdfBoxBaseline
+     * @param dc
+     * @param metadata
+     */
+    private void extractDublinCoreListItems(Metadata metadata, Property property, 
+            String pdfBoxBaseline, XMPSchemaDublinCore dc){
+        //if no dc, add baseline and return
+        if (dc == null){
+            if (pdfBoxBaseline != null && pdfBoxBaseline.length() > 0){
+                addMetadata(metadata, property, pdfBoxBaseline);
+            }
+            return;
+        }
+        List<String> items = getXMPBagOrSeqList(dc, property.getName());
+        if (items == null){
+            if (pdfBoxBaseline != null && pdfBoxBaseline.length() > 0){
+                addMetadata(metadata, property, pdfBoxBaseline);
+            }
+            return;
+        }
+        for (String item : items){
+            if (pdfBoxBaseline != null && ! item.equals(pdfBoxBaseline)){
+                addMetadata(metadata, property, item);
+            }
+        }
+        //finally, add the baseline
+        if (pdfBoxBaseline != null && pdfBoxBaseline.length() > 0){
+            addMetadata(metadata, property, pdfBoxBaseline);
+        }    
+    }
+
+    /**
+     * As of this writing, XMPSchema can contain bags or sequence lists
+     * for some attributes...despite standards documentation.  
+     * JempBox expects one or the other for specific attributes.
+     * Until more flexibility is added to JempBox, Tika will have to handle both.
+     * 
+     * @param schema
+     * @param name
+     * @return list of values or null
+     */
+    private List<String> getXMPBagOrSeqList(XMPSchema schema, String name){
+        List<String> ret = schema.getBagList(name);
+        if (ret == null){
+            ret = schema.getSequenceList(name);
+        }
+        return ret;
+    }
+
     private void addMetadata(Metadata metadata, Property property, String value) {
         if (value != null) {
             metadata.add(property, value);
diff --git a/tika-parsers/src/test/java/org/apache/tika/parser/pdf/PDFParserTest.java b/tika-parsers/src/test/java/org/apache/tika/parser/pdf/PDFParserTest.java
index 42a969443..52c0a5cb9 100644
--- a/tika-parsers/src/test/java/org/apache/tika/parser/pdf/PDFParserTest.java
+++ b/tika-parsers/src/test/java/org/apache/tika/parser/pdf/PDFParserTest.java
@@ -737,7 +737,34 @@ public class PDFParserTest extends TikaTest {
         assertEquals("pdfaid:part", m.get("pdfaid:part"), "1");
     }
 
-
+    public void testMultipleAuthors() throws Exception {
+        String fName = "testPDF_twoAuthors.pdf";
+        InputStream is = PDFParserTest.class.getResourceAsStream(
+                "/test-documents/"+fName);
+        Parser p = new AutoDetectParser();
+        Metadata m = new Metadata();
+        ParseContext c = new ParseContext();
+        ContentHandler h = new BodyContentHandler();
+        p.parse(is, h, m, c);
+        is.close();
+        
+        String[] keys = new String[]{
+                "dc:creator",
+                "meta:author",
+                "creator",
+                "Author"
+        };
+
+        for (String k : keys){
+            String[] vals = m.getValues(k);
+            assertEquals("number of authors == 2 for key: "+ k, 2, vals.length);
+            Set<String> set = new HashSet<String>();
+            set.add(vals[0]);
+            set.add(vals[1]);
+            assertTrue("Sample Author 1", set.contains("Sample Author 1"));
+            assertTrue("Sample Author 2", set.contains("Sample Author 2"));
+        }
+    }
     /**
      * This is a workaround until PDFBox-1922 is fixed.
      * The goal is to test for equality but skip the version issue.
diff --git a/tika-parsers/src/test/resources/test-documents/testPDF_twoAuthors.pdf b/tika-parsers/src/test/resources/test-documents/testPDF_twoAuthors.pdf
new file mode 100644
index 000000000..6a3d96fdd
Binary files /dev/null and b/tika-parsers/src/test/resources/test-documents/testPDF_twoAuthors.pdf differ
