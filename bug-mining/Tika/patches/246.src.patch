diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHM2XHTML.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHM2XHTML.java
index 9a8472820..7dbca5e04 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHM2XHTML.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHM2XHTML.java
@@ -37,11 +37,10 @@ public class CHM2XHTML {
                 handler.characters(text.toCharArray(), 0, text.length());
                 new CHM2XHTML(chmDoc, handler);
             } else
-                /* The error handling should be added */
-                System.err.println("Could not extract content");
+                throw new TikaException("Could not extract content");
 
         } catch (SAXException e) {
-            // System.err.println(ChmParserUtils.getStackTrace(e.getStackTrace()));
+            throw new RuntimeException(e);
         }
     }
 
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHMDocumentInformation.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHMDocumentInformation.java
index eca73898e..44ce7c2bb 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHMDocumentInformation.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/CHMDocumentInformation.java
@@ -21,13 +21,11 @@ import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Iterator;
-
 import org.apache.tika.exception.TikaException;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.parser.ParseContext;
 import org.apache.tika.parser.chm.accessor.DirectoryListingEntry;
 import org.apache.tika.parser.chm.core.ChmExtractor;
-import org.apache.tika.parser.chm.exception.ChmParsingException;
 import org.apache.tika.parser.html.HtmlParser;
 import org.apache.tika.sax.BodyContentHandler;
 import org.xml.sax.SAXException;
@@ -47,8 +45,10 @@ public class CHMDocumentInformation {
      *            InputStream
      * 
      * @return chm document information
+     * @throws TikaException 
+     * @throws IOException 
      */
-    public static CHMDocumentInformation load(InputStream is) {
+    public static CHMDocumentInformation load(InputStream is) throws TikaException, IOException {
         return new CHMDocumentInformation().getInstance(is);
     }
 
@@ -59,8 +59,10 @@ public class CHMDocumentInformation {
      *            InputStream
      * 
      * @return
+     * @throws TikaException 
+     * @throws IOException 
      */
-    private CHMDocumentInformation getInstance(InputStream is) {
+    private CHMDocumentInformation getInstance(InputStream is) throws TikaException, IOException {
         setChmExtractor(new ChmExtractor(is));
         return this;
     }
@@ -73,9 +75,10 @@ public class CHMDocumentInformation {
     private String getContent() {
         StringBuilder sb = new StringBuilder();
         DirectoryListingEntry entry;
+        
         for (Iterator<DirectoryListingEntry> it = getChmExtractor()
-                .getChmDirList().getDirectoryListingEntryList().iterator(); it
-                .hasNext();) {
+                .getChmDirList().getDirectoryListingEntryList().iterator(); it.hasNext();) 
+        {
             try {
                 entry = it.next();
                 if (isRightEntry(entry)) {
@@ -84,8 +87,8 @@ public class CHMDocumentInformation {
                         sb.append(extract(tmp));
                     }
                 }
-            } catch (ChmParsingException e) {// catch (IOException e) {
-                System.out.println(e.getMessage());
+            } catch (TikaException e) {
+                //ignore
             } // catch (IOException e) {//Pushback exception from tagsoup
             // System.err.println(e.getMessage());
         }
@@ -173,21 +176,19 @@ public class CHMDocumentInformation {
                     htmlParser.parse(stream, handler, metadata, parser);
                 } catch (TikaException e) {
                     wBuf.append(new String(byteObject[i]));
-                    System.err.println("\n"
-                            + CHMDocumentInformation.class.getName()
-                            + " extract " + e.getMessage());
+//                    System.err.println("\n"
+//                            + CHMDocumentInformation.class.getName()
+//                            + " extract " + e.getMessage());
                 } finally {
                     wBuf.append(handler.toString()
                             + System.getProperty("line.separator"));
                     stream.close();
                 }
             }
-        } catch (ChmParsingException e) {
-            System.err.println(e.getMessage());
         } catch (SAXException e) {
-            System.err.println(e.getMessage());
-        } catch (IOException e) {// Pushback overflow from tagsoup
-        // System.err.println(e.getMessage());
+            throw new RuntimeException(e);
+        } catch (IOException e) {// 
+        // Pushback overflow from tagsoup
         }
         return wBuf.toString();
     }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmAccessor.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmAccessor.java
index d40dbb611..42b083056 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmAccessor.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmAccessor.java
@@ -18,6 +18,8 @@ package org.apache.tika.parser.chm.accessor;
 
 import java.io.Serializable;
 
+import org.apache.tika.exception.TikaException;
+
 /**
  * 
  * Defines an accessor interface
@@ -31,6 +33,7 @@ public interface ChmAccessor<T> extends Serializable {
      * @param data
      *            chm file
      * @param chmAccessor
+     * @throws TikaException 
      */
-    void parse(byte[] data, T chmAccessor);
+    void parse(byte[] data, T chmAccessor) throws TikaException;
 }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmDirectoryListingSet.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmDirectoryListingSet.java
index fb2a5545c..995ce62d4 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmDirectoryListingSet.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmDirectoryListingSet.java
@@ -20,6 +20,7 @@ import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.core.ChmCommons;
 import org.apache.tika.parser.chm.core.ChmConstants;
 
@@ -44,9 +45,10 @@ public class ChmDirectoryListingSet {
      *            byte[]
      * @param chmItsHeader
      * @param chmItspHeader
+     * @throws TikaException 
      */
     public ChmDirectoryListingSet(byte[] data, ChmItsfHeader chmItsHeader,
-            ChmItspHeader chmItspHeader) {
+            ChmItspHeader chmItspHeader) throws TikaException {
         setDirectoryListingEntryList(new ArrayList<DirectoryListingEntry>());
         ChmCommons.assertByteArrayNotNull(data);
         setData(data);
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItsfHeader.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItsfHeader.java
index 2c93d9e3c..2f3c12d4e 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItsfHeader.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItsfHeader.java
@@ -17,6 +17,8 @@
 package org.apache.tika.parser.chm.accessor;
 
 import java.math.BigInteger;
+
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmConstants;
 import org.apache.tika.parser.chm.exception.ChmParsingException;
@@ -319,9 +321,10 @@ public class ChmItsfHeader implements ChmAccessor<ChmItsfHeader> {
      * @param data
      * @param chmItsfHeader
      * @param count
+     * @throws TikaException 
      */
     private void unmarshalCharArray(byte[] data, ChmItsfHeader chmItsfHeader,
-            int count) {
+            int count) throws TikaException {
         ChmAssert.assertChmAccessorParameters(data, chmItsfHeader, count);
         System.arraycopy(data, 0, chmItsfHeader.signature, 0, count);
         this.setCurrentPlace(this.getCurrentPlace() + count);
@@ -349,13 +352,14 @@ public class ChmItsfHeader implements ChmAccessor<ChmItsfHeader> {
      * @param data
      * @param dest
      * @return
+     * @throws TikaException 
      */
-    private long unmarshalUint64(byte[] data, long dest) {
+    private long unmarshalUint64(byte[] data, long dest) throws TikaException{
         byte[] temp = new byte[8];
         int i, j;
 
         if (8 > this.getDataRemained())
-            throw new ChmParsingException("8 > this.getDataRemained()");
+            throw new TikaException("8 > this.getDataRemained()");
 
         for (i = 8, j = 7; i > 0; i--) {
             temp[j--] = data[this.getCurrentPlace()];
@@ -367,11 +371,11 @@ public class ChmItsfHeader implements ChmAccessor<ChmItsfHeader> {
         return dest;
     }
 
-    private int unmarshalInt32(byte[] data, int dest) {
+    private int unmarshalInt32(byte[] data, int dest) throws TikaException{
         ChmAssert.assertByteArrayNotNull(data);
 
         if (4 > this.getDataRemained())
-            throw new ChmParsingException("4 > dataLenght");
+            throw new TikaException("4 > dataLenght");
         dest = data[this.getCurrentPlace()]
                 | data[this.getCurrentPlace() + 1] << 8
                 | data[this.getCurrentPlace() + 2] << 16
@@ -382,10 +386,10 @@ public class ChmItsfHeader implements ChmAccessor<ChmItsfHeader> {
         return dest;
     }
 
-    private long unmarshalUInt32(byte[] data, long dest) {
+    private long unmarshalUInt32(byte[] data, long dest) throws TikaException{
         ChmAssert.assertByteArrayNotNull(data);
         if (4 > getDataRemained())
-            throw new ChmParsingException("4 > dataLenght");
+            throw new TikaException("4 > dataLenght");
         dest = data[this.getCurrentPlace()]
                 | data[this.getCurrentPlace() + 1] << 8
                 | data[this.getCurrentPlace() + 2] << 16
@@ -436,46 +440,33 @@ public class ChmItsfHeader implements ChmAccessor<ChmItsfHeader> {
     }
 
     // @Override
-    public void parse(byte[] data, ChmItsfHeader chmItsfHeader) {
+    public void parse(byte[] data, ChmItsfHeader chmItsfHeader) throws TikaException {
         if (data.length < ChmConstants.CHM_ITSF_V2_LEN
                 || data.length > ChmConstants.CHM_ITSF_V3_LEN)
-            throw new ChmParsingException(
-                    "we only know how to deal with the 0x58 and 0x60 byte structures");
+            throw new TikaException("we only know how to deal with the 0x58 and 0x60 byte structures");
 
         chmItsfHeader.setDataRemained(data.length);
-        chmItsfHeader.unmarshalCharArray(data, chmItsfHeader,
-                ChmConstants.CHM_SIGNATURE_LEN);
-        chmItsfHeader.setVersion(chmItsfHeader.unmarshalInt32(data,
-                chmItsfHeader.getVersion()));
-        chmItsfHeader.setHeaderLen(chmItsfHeader.unmarshalInt32(data,
-                chmItsfHeader.getHeaderLen()));
-        chmItsfHeader.setUnknown_000c(chmItsfHeader.unmarshalInt32(data,
-                chmItsfHeader.getUnknown_000c()));
-        chmItsfHeader.setLastModified(chmItsfHeader.unmarshalUInt32(data,
-                chmItsfHeader.getLastModified()));
-        chmItsfHeader.setLangId(chmItsfHeader.unmarshalUInt32(data,
-                chmItsfHeader.getLangId()));
-        chmItsfHeader.setDir_uuid(chmItsfHeader.unmarshalUuid(data,
-                chmItsfHeader.getDir_uuid(), 16));
-        chmItsfHeader.setStream_uuid(chmItsfHeader.unmarshalUuid(data,
-                chmItsfHeader.getStream_uuid(), 16));
-        chmItsfHeader.setUnknownOffset(chmItsfHeader.unmarshalUint64(data,
-                chmItsfHeader.getUnknownOffset()));
-        chmItsfHeader.setUnknownLen(chmItsfHeader.unmarshalUint64(data,
-                chmItsfHeader.getUnknownLen()));
-        chmItsfHeader.setDirOffset(chmItsfHeader.unmarshalUint64(data,
-                chmItsfHeader.getDirOffset()));
-        chmItsfHeader.setDirLen(chmItsfHeader.unmarshalUint64(data,
-                chmItsfHeader.getDirLen()));
+        chmItsfHeader.unmarshalCharArray(data, chmItsfHeader, ChmConstants.CHM_SIGNATURE_LEN);
+        chmItsfHeader.setVersion(chmItsfHeader.unmarshalInt32(data, chmItsfHeader.getVersion()));
+        chmItsfHeader.setHeaderLen(chmItsfHeader.unmarshalInt32(data, chmItsfHeader.getHeaderLen()));
+        chmItsfHeader.setUnknown_000c(chmItsfHeader.unmarshalInt32(data, chmItsfHeader.getUnknown_000c()));
+        chmItsfHeader.setLastModified(chmItsfHeader.unmarshalUInt32(data, chmItsfHeader.getLastModified()));
+        chmItsfHeader.setLangId(chmItsfHeader.unmarshalUInt32(data, chmItsfHeader.getLangId()));
+        chmItsfHeader.setDir_uuid(chmItsfHeader.unmarshalUuid(data, chmItsfHeader.getDir_uuid(), 16));
+        chmItsfHeader.setStream_uuid(chmItsfHeader.unmarshalUuid(data, chmItsfHeader.getStream_uuid(), 16));
+        chmItsfHeader.setUnknownOffset(chmItsfHeader.unmarshalUint64(data, chmItsfHeader.getUnknownOffset()));
+        chmItsfHeader.setUnknownLen(chmItsfHeader.unmarshalUint64(data, chmItsfHeader.getUnknownLen()));
+        chmItsfHeader.setDirOffset(chmItsfHeader.unmarshalUint64(data, chmItsfHeader.getDirOffset()));
+        chmItsfHeader.setDirLen(chmItsfHeader.unmarshalUint64(data, chmItsfHeader.getDirLen()));
 
         if (!new String(chmItsfHeader.getSignature()).equals(ChmConstants.ITSF))
-            throw new ChmParsingException("seems not valid file");
+            throw new TikaException("seems not valid file");
         if (chmItsfHeader.getVersion() == ChmConstants.CHM_VER_2) {
             if (chmItsfHeader.getHeaderLen() < ChmConstants.CHM_ITSF_V2_LEN)
-                throw new ChmParsingException("something wrong with header");
+                throw new TikaException("something wrong with header");
         } else if (chmItsfHeader.getVersion() == ChmConstants.CHM_VER_3) {
             if (chmItsfHeader.getHeaderLen() < ChmConstants.CHM_ITSF_V3_LEN)
-                throw new ChmParsingException("unknown v3 header lenght");
+                throw new TikaException("unknown v3 header lenght");
         } else
             throw new ChmParsingException("unsupported chm format");
 
@@ -488,8 +479,7 @@ public class ChmItsfHeader implements ChmAccessor<ChmItsfHeader> {
                 chmItsfHeader.setDataOffset(chmItsfHeader.getDirOffset()
                         + chmItsfHeader.getDirLen());
             else
-                throw new ChmParsingException(
-                        "cannot set data offset, no data remained");
+                throw new TikaException("cannot set data offset, no data remained");
         } else
             chmItsfHeader.setDataOffset(chmItsfHeader.getDirOffset()
                     + chmItsfHeader.getDirLen());
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItspHeader.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItspHeader.java
index fc57e7392..38b0ea923 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItspHeader.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmItspHeader.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tika.parser.chm.accessor;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmCommons;
 import org.apache.tika.parser.chm.core.ChmConstants;
@@ -116,9 +117,10 @@ public class ChmItspHeader implements ChmAccessor<ChmItspHeader> {
      * @param data
      * @param chmItspHeader
      * @param count
+     * @throws TikaException 
      */
     private void unmarshalCharArray(byte[] data, ChmItspHeader chmItspHeader,
-            int count) {
+            int count) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         ChmAssert.assertChmAccessorNotNull(chmItspHeader);
         this.setDataRemained(data.length);
@@ -127,10 +129,10 @@ public class ChmItspHeader implements ChmAccessor<ChmItspHeader> {
         this.setDataRemained(this.getDataRemained() - count);
     }
 
-    private int unmarshalInt32(byte[] data, int dataLenght, int dest) {
+    private int unmarshalInt32(byte[] data, int dataLenght, int dest) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         if (4 > this.getDataRemained())
-            throw new ChmParsingException("4 > dataLenght");
+            throw new TikaException("4 > dataLenght");
         dest = data[this.getCurrentPlace()]
                 | data[this.getCurrentPlace() + 1] << 8
                 | data[this.getCurrentPlace() + 2] << 16
@@ -141,10 +143,10 @@ public class ChmItspHeader implements ChmAccessor<ChmItspHeader> {
         return dest;
     }
 
-    private long unmarshalUInt32(byte[] data, int dataLenght, long dest) {
+    private long unmarshalUInt32(byte[] data, int dataLenght, long dest) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         if (4 > dataLenght)
-            throw new ChmParsingException("4 > dataLenght");
+            throw new TikaException("4 > dataLenght");
         dest = data[this.getCurrentPlace()]
                 | data[this.getCurrentPlace() + 1] << 8
                 | data[this.getCurrentPlace() + 2] << 16
@@ -469,15 +471,13 @@ public class ChmItspHeader implements ChmAccessor<ChmItspHeader> {
     }
 
     // @Override
-    public void parse(byte[] data, ChmItspHeader chmItspHeader) {
+    public void parse(byte[] data, ChmItspHeader chmItspHeader) throws TikaException {
         /* we only know how to deal with the 0x58 and 0x60 byte structures */
         if (data.length != ChmConstants.CHM_ITSP_V1_LEN)
-            throw new ChmParsingException(
-                    "we only know how to deal with the 0x58 and 0x60 byte structures");
+            throw new ChmParsingException("we only know how to deal with the 0x58 and 0x60 byte structures");
 
         /* unmarshal common fields */
-        chmItspHeader.unmarshalCharArray(data, chmItspHeader,
-                ChmConstants.CHM_SIGNATURE_LEN);
+        chmItspHeader.unmarshalCharArray(data, chmItspHeader, ChmConstants.CHM_SIGNATURE_LEN);
         // ChmCommons.unmarshalCharArray(data, chmItspHeader,
         // ChmConstants.CHM_SIGNATURE_LEN);
         chmItspHeader.setVersion(chmItspHeader.unmarshalInt32(data,
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcControlData.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcControlData.java
index 09cc446d5..695f2918c 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcControlData.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcControlData.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tika.parser.chm.accessor;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmConstants;
 import org.apache.tika.parser.chm.exception.ChmParsingException;
@@ -216,7 +217,7 @@ public class ChmLzxcControlData implements ChmAccessor<ChmLzxcControlData> {
         this.unknown_18 = unknown_18;
     }
 
-    private long unmarshalUInt32(byte[] data, long dest) {
+    private long unmarshalUInt32(byte[] data, long dest) throws ChmParsingException {
         assert (data != null && data.length > 0);
         if (4 > getDataRemained())
             throw new ChmParsingException("4 > dataLenght");
@@ -231,7 +232,7 @@ public class ChmLzxcControlData implements ChmAccessor<ChmLzxcControlData> {
     }
 
     private void unmarshalCharArray(byte[] data,
-            ChmLzxcControlData chmLzxcControlData, int count) {
+            ChmLzxcControlData chmLzxcControlData, int count) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         ChmAssert.assertChmAccessorNotNull(chmLzxcControlData);
         ChmAssert.assertPositiveInt(count);
@@ -261,12 +262,11 @@ public class ChmLzxcControlData implements ChmAccessor<ChmLzxcControlData> {
     }
 
     // @Override
-    public void parse(byte[] data, ChmLzxcControlData chmLzxcControlData) {
+    public void parse(byte[] data, ChmLzxcControlData chmLzxcControlData) throws TikaException {
         if (data == null || (data.length < ChmConstants.CHM_LZXC_MIN_LEN))
             throw new ChmParsingException("we want at least 0x18 bytes");
         chmLzxcControlData.setDataRemained(data.length);
-        chmLzxcControlData.setSize(unmarshalUInt32(data,
-                chmLzxcControlData.getSize()));
+        chmLzxcControlData.setSize(unmarshalUInt32(data, chmLzxcControlData.getSize()));
         chmLzxcControlData.unmarshalCharArray(data, chmLzxcControlData,
                 ChmConstants.CHM_SIGNATURE_LEN);
         chmLzxcControlData.setVersion(unmarshalUInt32(data,
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcResetTable.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcResetTable.java
index 516e9358b..561358ff0 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcResetTable.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmLzxcResetTable.java
@@ -19,6 +19,7 @@ package org.apache.tika.parser.chm.accessor;
 import java.math.BigInteger;
 import java.util.Arrays;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmConstants;
 import org.apache.tika.parser.chm.exception.ChmParsingException;
@@ -111,8 +112,9 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
      * @param data
      * 
      * @return byte[] of addresses
+     * @throws TikaException 
      */
-    private long[] enumerateBlockAddresses(byte[] data) {
+    private long[] enumerateBlockAddresses(byte[] data) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         /* we have limit of number of blocks to be extracted */
         if (getBlockCount() > 5000)
@@ -129,7 +131,7 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
             try {
                 addresses[i] = unmarshalUint64(data, num);
             } catch (Exception e) {
-                // System.err.println(e.getMessage());
+                throw new TikaException(e.getMessage());
             }
         }
         return addresses;
@@ -142,9 +144,10 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
      * @param chmLzxcResetTable
      * 
      * @return boolean
+     * @throws TikaException 
      */
     private boolean validateParamaters(byte[] data,
-            ChmLzxcResetTable chmLzxcResetTable) {
+            ChmLzxcResetTable chmLzxcResetTable) throws TikaException {
         int goodParameter = 0;
         ChmAssert.assertByteArrayNotNull(data);
         ++goodParameter;
@@ -153,7 +156,7 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
         return (goodParameter == 2);
     }
 
-    private long unmarshalUInt32(byte[] data, long dest) {
+    private long unmarshalUInt32(byte[] data, long dest) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         dest = data[this.getCurrentPlace()]
                 | data[this.getCurrentPlace() + 1] << 8
@@ -165,7 +168,7 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
         return dest;
     }
 
-    private long unmarshalUint64(byte[] data, long dest) {
+    private long unmarshalUint64(byte[] data, long dest) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         byte[] temp = new byte[8];
         int i, j;// counters
@@ -175,8 +178,7 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
                 temp[j--] = data[this.getCurrentPlace()];
                 this.setCurrentPlace(this.getCurrentPlace() + 1);
             } else
-                throw new ChmParsingException(
-                        "data is too small to calculate address block");
+                throw new TikaException("data is too small to calculate address block");
         }
         dest = new BigInteger(temp).longValue();
         this.setDataRemained(this.getDataRemained() - 8);
@@ -324,24 +326,17 @@ public class ChmLzxcResetTable implements ChmAccessor<ChmLzxcResetTable> {
     }
 
     // @Override
-    public void parse(byte[] data, ChmLzxcResetTable chmLzxcResetTable) {
+    public void parse(byte[] data, ChmLzxcResetTable chmLzxcResetTable) throws TikaException {
         setDataRemained(data.length);
         if (validateParamaters(data, chmLzxcResetTable)) {
             /* unmarshal fields */
-            chmLzxcResetTable.setVersion(unmarshalUInt32(data,
-                    chmLzxcResetTable.getVersion()));
-            chmLzxcResetTable.setBlockCount(unmarshalUInt32(data,
-                    chmLzxcResetTable.getBlockCount()));
-            chmLzxcResetTable.setUnknown(unmarshalUInt32(data,
-                    chmLzxcResetTable.getUnknown()));
-            chmLzxcResetTable.setTableOffset(unmarshalUInt32(data,
-                    chmLzxcResetTable.getTableOffset()));
-            chmLzxcResetTable.setUncompressedLen(unmarshalUint64(data,
-                    chmLzxcResetTable.getUncompressedLen()));
-            chmLzxcResetTable.setCompressedLen(unmarshalUint64(data,
-                    chmLzxcResetTable.getCompressedLen()));
-            chmLzxcResetTable.setBlockLlen(unmarshalUint64(data,
-                    chmLzxcResetTable.getBlockLen()));
+            chmLzxcResetTable.setVersion(unmarshalUInt32(data, chmLzxcResetTable.getVersion()));
+            chmLzxcResetTable.setBlockCount(unmarshalUInt32(data, chmLzxcResetTable.getBlockCount()));
+            chmLzxcResetTable.setUnknown(unmarshalUInt32(data, chmLzxcResetTable.getUnknown()));
+            chmLzxcResetTable.setTableOffset(unmarshalUInt32(data, chmLzxcResetTable.getTableOffset()));
+            chmLzxcResetTable.setUncompressedLen(unmarshalUint64(data, chmLzxcResetTable.getUncompressedLen()));
+            chmLzxcResetTable.setCompressedLen(unmarshalUint64(data, chmLzxcResetTable.getCompressedLen()));
+            chmLzxcResetTable.setBlockLlen(unmarshalUint64(data, chmLzxcResetTable.getBlockLen()));
             chmLzxcResetTable.setBlockAddress(enumerateBlockAddresses(data));
         }
 
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmgiHeader.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmgiHeader.java
index 842d4b621..a84841295 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmgiHeader.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmgiHeader.java
@@ -18,6 +18,7 @@ package org.apache.tika.parser.chm.accessor;
 
 import java.util.Arrays;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmCommons;
 import org.apache.tika.parser.chm.core.ChmConstants;
@@ -70,7 +71,7 @@ public class ChmPmgiHeader implements ChmAccessor<ChmPmgiHeader> {
     }
 
     private void unmarshalCharArray(byte[] data, ChmPmgiHeader chmPmgiHeader,
-            int count) {
+            int count) throws ChmParsingException {
         int index = -1;
         ChmAssert.assertByteArrayNotNull(data);
         ChmAssert.assertChmAccessorNotNull(chmPmgiHeader);
@@ -80,14 +81,15 @@ public class ChmPmgiHeader implements ChmAccessor<ChmPmgiHeader> {
                 ChmConstants.CHM_PMGI_MARKER.getBytes());
         if (index >= 0)
             System.arraycopy(data, index, chmPmgiHeader.getSignature(), 0, count);
-        else
-            System.err.println(ChmPmgiHeader.class.getName()
-                    + " does not exist a PMGI, use PMGL instead");
+        else{
+            //Some chm documents (actually most of them) do not contain
+            //PMGI header, in this case, we just notice about it.
+        }
         this.setCurrentPlace(this.getCurrentPlace() + count);
         this.setDataRemained(this.getDataRemained() - count);
     }
 
-    private long unmarshalUInt32(byte[] data, long dest) {
+    private long unmarshalUInt32(byte[] data, long dest) throws ChmParsingException {
         ChmAssert.assertByteArrayNotNull(data);
 
         if (4 > getDataRemained())
@@ -150,22 +152,19 @@ public class ChmPmgiHeader implements ChmAccessor<ChmPmgiHeader> {
     }
 
     // @Override
-    public void parse(byte[] data, ChmPmgiHeader chmPmgiHeader) {
+    public void parse(byte[] data, ChmPmgiHeader chmPmgiHeader) throws TikaException {
         /* we only know how to deal with a 0x8 byte structures */
         if (data.length < ChmConstants.CHM_PMGI_LEN)
-            throw new ChmParsingException(
-                    "we only know how to deal with a 0x8 byte structures");
+            throw new TikaException("we only know how to deal with a 0x8 byte structures");
 
         /* unmarshal fields */
-        chmPmgiHeader.unmarshalCharArray(data, chmPmgiHeader,
-                ChmConstants.CHM_SIGNATURE_LEN);
-        chmPmgiHeader.setFreeSpace(chmPmgiHeader.unmarshalUInt32(data,
-                chmPmgiHeader.getFreeSpace()));
+        chmPmgiHeader.unmarshalCharArray(data, chmPmgiHeader, ChmConstants.CHM_SIGNATURE_LEN);
+        chmPmgiHeader.setFreeSpace(chmPmgiHeader.unmarshalUInt32(data, chmPmgiHeader.getFreeSpace()));
 
         /* check structure */
         if (!Arrays.equals(chmPmgiHeader.getSignature(),
                 ChmConstants.CHM_PMGI_MARKER.getBytes()))
-            throw new ChmParsingException(
+            throw new TikaException(
                     "it does not seem to be valid a PMGI signature, check ChmItsp index_root if it was -1, means no PMGI, use PMGL insted");
 
     }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmglHeader.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmglHeader.java
index d7cdf047c..8f024be58 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmglHeader.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/ChmPmglHeader.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tika.parser.chm.accessor;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmConstants;
 import org.apache.tika.parser.chm.exception.ChmParsingException;
@@ -104,7 +105,7 @@ public class ChmPmglHeader implements ChmAccessor<ChmPmglHeader> {
     }
 
     protected void unmarshalCharArray(byte[] data, ChmPmglHeader chmPmglHeader,
-            int count) {
+            int count) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         this.setDataRemained(data.length);
         System.arraycopy(data, 0, chmPmglHeader.signature, 0, count);
@@ -112,10 +113,10 @@ public class ChmPmglHeader implements ChmAccessor<ChmPmglHeader> {
         this.setDataRemained(this.getDataRemained() - count);
     }
 
-    private int unmarshalInt32(byte[] data, int dest) {
+    private int unmarshalInt32(byte[] data, int dest) throws TikaException {
         ChmAssert.assertByteArrayNotNull(data);
         if (4 > this.getDataRemained())
-            throw new ChmParsingException("4 > dataLenght");
+            throw new TikaException("4 > dataLenght");
         dest = data[this.getCurrentPlace()]
                 | data[this.getCurrentPlace() + 1] << 8
                 | data[this.getCurrentPlace() + 2] << 16
@@ -126,7 +127,7 @@ public class ChmPmglHeader implements ChmAccessor<ChmPmglHeader> {
         return dest;
     }
 
-    private long unmarshalUInt32(byte[] data, long dest) {
+    private long unmarshalUInt32(byte[] data, long dest) throws ChmParsingException {
         ChmAssert.assertByteArrayNotNull(data);
         if (4 > getDataRemained())
             throw new ChmParsingException("4 > dataLenght");
@@ -141,9 +142,9 @@ public class ChmPmglHeader implements ChmAccessor<ChmPmglHeader> {
     }
 
     // @Override
-    public void parse(byte[] data, ChmPmglHeader chmPmglHeader) {
+    public void parse(byte[] data, ChmPmglHeader chmPmglHeader) throws TikaException {
         if (data.length < ChmConstants.CHM_PMGL_LEN)
-            throw new ChmParsingException(ChmPmglHeader.class.getName()
+            throw new TikaException(ChmPmglHeader.class.getName()
                     + " we only know how to deal with a 0x14 byte structures");
 
         /* unmarshal fields */
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/DirectoryListingEntry.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/DirectoryListingEntry.java
index dc7bbf96d..c11d49311 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/DirectoryListingEntry.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/accessor/DirectoryListingEntry.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tika.parser.chm.accessor;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmCommons;
 
@@ -59,11 +60,11 @@ public class DirectoryListingEntry {
      *            int
      * @param length
      *            int
+     * @throws TikaException 
      */
     public DirectoryListingEntry(int name_length, String name,
-            ChmCommons.EntryType isCompressed, int offset, int length) {
-        ChmAssert.assertDirectoryListingEntry(name_length, name, isCompressed,
-                offset, length);
+            ChmCommons.EntryType isCompressed, int offset, int length) throws TikaException {
+        ChmAssert.assertDirectoryListingEntry(name_length, name, isCompressed, offset, length);
         setNameLength(name_length);
         setName(name);
         setEntryType(isCompressed);
@@ -73,13 +74,10 @@ public class DirectoryListingEntry {
 
     public String toString() {
         StringBuilder sb = new StringBuilder();
-        sb.append("name_length:=" + getNameLength()
-                + System.getProperty("line.separator"));
+        sb.append("name_length:=" + getNameLength() + System.getProperty("line.separator"));
         sb.append("name:=" + getName() + System.getProperty("line.separator"));
-        sb.append("entryType:=" + getEntryType()
-                + System.getProperty("line.separator"));
-        sb.append("offset:=" + getOffset()
-                + System.getProperty("line.separator"));
+        sb.append("entryType:=" + getEntryType() + System.getProperty("line.separator"));
+        sb.append("offset:=" + getOffset() + System.getProperty("line.separator"));
         sb.append("length:=" + getLength());
         return sb.toString();
     }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/assertion/ChmAssert.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/assertion/ChmAssert.java
index f026113ab..a332690e2 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/assertion/ChmAssert.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/assertion/ChmAssert.java
@@ -16,8 +16,10 @@
  */
 package org.apache.tika.parser.chm.assertion;
 
+import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.accessor.ChmAccessor;
 import org.apache.tika.parser.chm.accessor.ChmLzxcResetTable;
 import org.apache.tika.parser.chm.core.ChmCommons;
@@ -40,30 +42,31 @@ public class ChmAssert {
      *            int
      * @param lzxcBlockLength
      *            int
+     * @throws TikaException 
      */
     public static final void assertChmBlockSegment(byte[] data,
             ChmLzxcResetTable resetTable, int blockNumber, int lzxcBlockOffset,
-            int lzxcBlockLength) {
+            int lzxcBlockLength) throws TikaException {
         if ((data == null))
-            throw new ChmParsingException("data[] is null");
+            throw new TikaException("data[] is null");
 
         if ((data.length <= 0))
-            throw new ChmParsingException("data[] length should be greater than zero");
+            throw new TikaException("data[] length should be greater than zero");
 
         if (resetTable == null)
-            throw new ChmParsingException("resetTable is null");
+            throw new TikaException("resetTable is null");
 
         if (resetTable.getBlockAddress().length <= 1)
-            throw new ChmParsingException("resetTable.getBlockAddress().length should be greater than zero");
+            throw new TikaException("resetTable.getBlockAddress().length should be greater than zero");
 
         if (blockNumber < 0)
-            throw new ChmParsingException("blockNumber should be positive number");
+            throw new TikaException("blockNumber should be positive number");
 
         if (lzxcBlockOffset < 0)
-            throw new ChmParsingException("lzxcBlockOffset should be positive number");
+            throw new TikaException("lzxcBlockOffset should be positive number");
 
         if (lzxcBlockLength < 0)
-            throw new ChmParsingException("lzxcBlockLength should be positive number");
+            throw new TikaException("lzxcBlockLength should be positive number");
     }
 
     /**
@@ -71,10 +74,12 @@ public class ChmAssert {
      * 
      * @param is
      *            InputStream
+     * @throws ChmParsingException 
+     * @throws IOException 
      */
-    public static final void assertInputStreamNotNull(InputStream is) {
+    public static final void assertInputStreamNotNull(InputStream is) throws IOException {
         if (is == null)
-            throw new ChmParsingException("input sream is null");
+            throw new IOException("input sream is null");
     }
 
     /**
@@ -83,9 +88,10 @@ public class ChmAssert {
      * @param data
      * @param chmItsfHeader
      * @param count
+     * @throws ChmParsingException 
      */
     public static final void assertChmAccessorParameters(byte[] data,
-            ChmAccessor<?> chmAccessor, int count) {
+            ChmAccessor<?> chmAccessor, int count) throws ChmParsingException {
         assertByteArrayNotNull(data);
         assertChmAccessorNotNull(chmAccessor);
     }
@@ -94,8 +100,9 @@ public class ChmAssert {
      * Checks if byte[] is not null
      * 
      * @param data
+     * @throws ChmParsingException 
      */
-    public static final void assertByteArrayNotNull(byte[] data) {
+    public static final void assertByteArrayNotNull(byte[] data) throws ChmParsingException {
         if (data == null)
             throw new ChmParsingException("byte[] data is null");
     }
@@ -104,8 +111,9 @@ public class ChmAssert {
      * Checks if ChmAccessor is not null In case of null throws exception
      * 
      * @param ChmAccessor
+     * @throws ChmParsingException 
      */
-    public static final void assertChmAccessorNotNull(ChmAccessor<?> chmAccessor) {
+    public static final void assertChmAccessorNotNull(ChmAccessor<?> chmAccessor) throws ChmParsingException {
         if (chmAccessor == null)
             throw new ChmParsingException("chm header is null");
     }
@@ -122,9 +130,10 @@ public class ChmAssert {
      *            EntryType
      * @param offset
      * @param length
+     * @throws ChmParsingException 
      */
     public static final void assertDirectoryListingEntry(int name_length,
-            String name, ChmCommons.EntryType entryType, int offset, int length) {
+            String name, ChmCommons.EntryType entryType, int offset, int length) throws ChmParsingException {
         if (name_length < 0)
             throw new ChmParsingException("invalid name length");
         if (name == null)
@@ -141,7 +150,7 @@ public class ChmAssert {
             throw new ChmParsingException("invalid length");
     }
 
-    public static void assertCopyingDataIndex(int index, int dataLength) {
+    public static void assertCopyingDataIndex(int index, int dataLength) throws ChmParsingException {
         if (index >= dataLength)
             throw new ChmParsingException("cannot parse chm file index > data.length");
     }
@@ -151,8 +160,9 @@ public class ChmAssert {
      * exception
      * 
      * @param param
+     * @throws ChmParsingException 
      */
-    public static void assertPositiveInt(int param) {
+    public static void assertPositiveInt(int param) throws ChmParsingException {
         if (param <= 0)
             throw new ChmParsingException("resetTable.getBlockAddress().length should be greater than zero");
     }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmCommons.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmCommons.java
index 7f8d98958..14de922da 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmCommons.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmCommons.java
@@ -24,6 +24,7 @@ import java.io.InputStream;
 import java.util.Iterator;
 import java.util.List;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.accessor.ChmLzxcResetTable;
 import org.apache.tika.parser.chm.accessor.DirectoryListingEntry;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
@@ -34,9 +35,9 @@ public class ChmCommons {
     private ChmCommons() {
     }
 
-    public static void assertByteArrayNotNull(byte[] data) {
+    public static void assertByteArrayNotNull(byte[] data) throws TikaException {
         if (data == null)
-            throw new ChmParsingException("byte[] is null");
+            throw new TikaException("byte[] is null");
     }
 
     /**
@@ -88,8 +89,9 @@ public class ChmCommons {
 
     public static byte[] getChmBlockSegment(byte[] data,
             ChmLzxcResetTable resetTable, int blockNumber, int lzxcBlockOffset,
-            int lzxcBlockLength) {
-        ChmAssert.assertChmBlockSegment(data, resetTable, blockNumber, lzxcBlockOffset, lzxcBlockLength);
+            int lzxcBlockLength) throws TikaException {
+        ChmAssert.assertChmBlockSegment(data, resetTable, blockNumber,
+                lzxcBlockOffset, lzxcBlockLength);
         int blockLength = -1;
         // TODO add int_max_value checking
         if (blockNumber < (resetTable.getBlockAddress().length - 1)) {
@@ -203,8 +205,9 @@ public class ChmCommons {
      * @param buffer
      * @param fileToBeSaved
      *            file name
+     * @throws TikaException 
      */
-    public static void writeFile(byte[][] buffer, String fileToBeSaved) {
+    public static void writeFile(byte[][] buffer, String fileToBeSaved) throws TikaException {
         FileOutputStream output = null;
         if (buffer != null && fileToBeSaved != null
                 && !ChmCommons.isEmpty(fileToBeSaved)) {
@@ -215,8 +218,7 @@ public class ChmCommons {
                         output.write(buffer[i]);
                     }
             } catch (FileNotFoundException e) {
-                System.err.println("The " + fileToBeSaved
-                        + " does not seem correct");
+                throw new TikaException(e.getMessage());
             } catch (IOException e) {
                 e.printStackTrace();
             } finally {
@@ -261,8 +263,9 @@ public class ChmCommons {
      * @return byte array
      * 
      * @throws IOException
+     * @throws TikaException 
      */
-    public static byte[] toByteArray(InputStream is) throws IOException {
+    public static byte[] toByteArray(InputStream is) throws IOException, TikaException {
         if (is != null) {
             ByteArrayOutputStream buffer = new ByteArrayOutputStream();
             int nRead;
@@ -275,11 +278,11 @@ public class ChmCommons {
                 is.close();
                 buffer.close();
             } catch (Exception e) {
-                System.err.println(e.getMessage());
+                throw new TikaException(e.getMessage());
             }
             return buffer.toByteArray();
         } else
-            throw new ChmParsingException("InputStream is null");
+            throw new IOException("InputStream is null");
     }
 
     /**
@@ -288,8 +291,9 @@ public class ChmCommons {
      * @param text
      * @param pattern
      * @return index of the reset table
+     * @throws ChmParsingException 
      */
-    public static final int indexOfResetTableBlock(byte[] text, byte[] pattern) {
+    public static final int indexOfResetTableBlock(byte[] text, byte[] pattern) throws ChmParsingException {
         return (indexOf(text, pattern)) - 4;
     }
 
@@ -301,8 +305,9 @@ public class ChmCommons {
      * @param pattern
      *            byte[]
      * @return an index, if nothing found returns -1
+     * @throws ChmParsingException 
      */
-    public static int indexOf(byte[] text, byte[] pattern) {
+    public static int indexOf(byte[] text, byte[] pattern) throws ChmParsingException {
         int[] next = null;
         int i = 0, j = -1;
 
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmExtractor.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmExtractor.java
index ff9fc29c4..d4c873799 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmExtractor.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/core/ChmExtractor.java
@@ -21,7 +21,7 @@ import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
-
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.accessor.ChmDirectoryListingSet;
 import org.apache.tika.parser.chm.accessor.ChmItsfHeader;
 import org.apache.tika.parser.chm.accessor.ChmItspHeader;
@@ -30,7 +30,6 @@ import org.apache.tika.parser.chm.accessor.ChmLzxcResetTable;
 import org.apache.tika.parser.chm.accessor.DirectoryListingEntry;
 import org.apache.tika.parser.chm.assertion.ChmAssert;
 import org.apache.tika.parser.chm.core.ChmCommons.EntryType;
-import org.apache.tika.parser.chm.exception.ChmParsingException;
 import org.apache.tika.parser.chm.lzx.ChmBlockInfo;
 import org.apache.tika.parser.chm.lzx.ChmLzxBlock;
 
@@ -143,7 +142,7 @@ public class ChmExtractor {
         this.data = data;
     }
 
-    public ChmExtractor(InputStream is) {
+    public ChmExtractor(InputStream is) throws TikaException, IOException {
         ChmAssert.assertInputStreamNotNull(is);
         try {
             setData(ChmCommons.toByteArray(is));
@@ -152,10 +151,8 @@ public class ChmExtractor {
             setChmItsfHeader(new ChmItsfHeader());
             // getChmItsfHeader().parse(Arrays.copyOfRange(getData(), 0,
             // ChmConstants.CHM_ITSF_V3_LEN - 1), getChmItsfHeader());
-            getChmItsfHeader().parse(
-                    ChmCommons.copyOfRange(getData(), 0,
-                            ChmConstants.CHM_ITSF_V3_LEN - 1),
-                    getChmItsfHeader());
+            getChmItsfHeader().parse(ChmCommons.copyOfRange(getData(), 0,
+                            ChmConstants.CHM_ITSF_V3_LEN - 1), getChmItsfHeader());
 
             /* Creates and parses chm itsp header */
             setChmItspHeader(new ChmItspHeader());
@@ -165,9 +162,8 @@ public class ChmExtractor {
             // ChmConstants.CHM_ITSP_V1_LEN), getChmItspHeader());
             getChmItspHeader().parse(
                     ChmCommons.copyOfRange(getData(), (int) getChmItsfHeader()
-                            .getDirOffset(), (int) getChmItsfHeader()
-                            .getDirOffset() + ChmConstants.CHM_ITSP_V1_LEN),
-                    getChmItspHeader());
+                            .getDirOffset(), (int) getChmItsfHeader().getDirOffset() + 
+                            ChmConstants.CHM_ITSP_V1_LEN), getChmItspHeader());
 
             /* Creates instance of ChmDirListingContainer */
             setChmDirList(new ChmDirectoryListingSet(getData(),
@@ -178,13 +174,8 @@ public class ChmExtractor {
                     ChmConstants.LZXC.getBytes());
             byte[] dir_chunk = null;
             if (indexOfResetData > 0)
-                dir_chunk = ChmCommons.copyOfRange(
-                        getData(),
-                        indexOfResetData,
-                        indexOfResetData
-                                + getChmDirList()
-                                        .getDirectoryListingEntryList()
-                                        .get(indexOfControlData).getLength());
+                dir_chunk = ChmCommons.copyOfRange( getData(), indexOfResetData, indexOfResetData  
+                        + getChmDirList().getDirectoryListingEntryList().get(indexOfControlData).getLength());
             // dir_chunk = Arrays.copyOfRange(getData(), indexOfResetData,
             // indexOfResetData
             // +
@@ -207,25 +198,21 @@ public class ChmExtractor {
             // dir_chunk = Arrays.copyOfRange(getData(), startIndex, startIndex
             // +
             // getChmDirList().getDirectoryListingEntryList().get(indexOfResetTable).getLength());
-            dir_chunk = ChmCommons.copyOfRange(getData(), startIndex,
-                    startIndex
-                            + getChmDirList().getDirectoryListingEntryList()
-                                    .get(indexOfResetTable).getLength());
+            dir_chunk = ChmCommons.copyOfRange(getData(), startIndex, startIndex
+                            + getChmDirList().getDirectoryListingEntryList().get(indexOfResetTable).getLength());
 
             getChmLzxcResetTable().parse(dir_chunk, getChmLzxcResetTable());
 
-            setIndexOfContent(ChmCommons.indexOf(getChmDirList()
-                    .getDirectoryListingEntryList(), ChmConstants.CONTENT));
-            setLzxBlockOffset((getChmDirList().getDirectoryListingEntryList()
-                    .get(getIndexOfContent()).getOffset() + getChmItsfHeader()
-                    .getDataOffset()));
-            setLzxBlockLength(getChmDirList().getDirectoryListingEntryList()
-                    .get(getIndexOfContent()).getLength());
+            setIndexOfContent(ChmCommons.indexOf(getChmDirList().getDirectoryListingEntryList(), 
+                    ChmConstants.CONTENT));
+            setLzxBlockOffset((getChmDirList().getDirectoryListingEntryList().get(getIndexOfContent()).getOffset() 
+                    + getChmItsfHeader().getDataOffset()));
+            setLzxBlockLength(getChmDirList().getDirectoryListingEntryList().get(getIndexOfContent()).getLength());
 
             setLzxBlocksCache(new ArrayList<ChmLzxBlock>());
 
         } catch (IOException e) {
-            System.err.println(e.getMessage());
+            // ignore
         }
     }
 
@@ -248,8 +235,9 @@ public class ChmExtractor {
      * @param directoryListingEntry
      * 
      * @return decompressed data
+     * @throws TikaException 
      */
-    public byte[][] extractChmEntry(DirectoryListingEntry directoryListingEntry) {
+    public byte[][] extractChmEntry(DirectoryListingEntry directoryListingEntry) throws TikaException {
         byte[][] tmp = null;
         byte[] dataSegment = null;
         ChmLzxBlock lzxBlock = null;
@@ -364,9 +352,8 @@ public class ChmExtractor {
                     }
                 }
             }
-        } catch (ChmParsingException e) {
-            // e.printStackTrace();
-            // System.err.println("Unknown exception");
+        } catch (Exception e) {
+            throw new TikaException(e.getMessage());
         }
         return (tmp != null) ? tmp : (new byte[1][]);
     }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/exception/ChmParsingException.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/exception/ChmParsingException.java
index 9c52ca06e..fbed9086c 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/exception/ChmParsingException.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/exception/ChmParsingException.java
@@ -16,12 +16,10 @@
  */
 package org.apache.tika.parser.chm.exception;
 
-public class ChmParsingException extends RuntimeException {
-    private static final long serialVersionUID = 6497936044733665210L;
+import org.apache.tika.exception.TikaException;
 
-    public ChmParsingException() {
-        super();
-    }
+public class ChmParsingException extends TikaException {
+    private static final long serialVersionUID = 6497936044733665210L;
 
     public ChmParsingException(String description) {
         super(description);
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmBlockInfo.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmBlockInfo.java
index 50869c496..5d51e1744 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmBlockInfo.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmBlockInfo.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tika.parser.chm.lzx;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.accessor.ChmLzxcControlData;
 import org.apache.tika.parser.chm.accessor.DirectoryListingEntry;
 import org.apache.tika.parser.chm.exception.ChmParsingException;
@@ -55,10 +56,11 @@ public class ChmBlockInfo {
      *            - ChmBlockInfo
      * 
      * @return ChmBlockInfo
+     * @throws TikaException 
      */
     protected ChmBlockInfo getChmBlockInfo(DirectoryListingEntry dle,
             int bytesPerBlock, ChmLzxcControlData clcd,
-            ChmBlockInfo chmBlockInfo) {
+            ChmBlockInfo chmBlockInfo) throws TikaException {
         if (!validateParameters(dle, bytesPerBlock, clcd, chmBlockInfo))
             throw new ChmParsingException("Please check you parameters");
 
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxBlock.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxBlock.java
index 3819cd281..6ab07a1c8 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxBlock.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxBlock.java
@@ -18,6 +18,7 @@ package org.apache.tika.parser.chm.lzx;
 
 import java.math.BigInteger;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.core.ChmCommons;
 import org.apache.tika.parser.chm.core.ChmCommons.IntelState;
 import org.apache.tika.parser.chm.core.ChmCommons.LzxState;
@@ -73,14 +74,10 @@ public class ChmLzxBlock {
                 if (prevBlock != null && prevBlock.getState() != null)
                     previousBlockType = prevBlock.getState().getBlockType();
 
-                try {
-                    extractContent();
-                } catch (ChmParsingException e) {
-                    // System.err.println(e.getMessage());
-                }
+                extractContent();
             } else
-                System.err.println("Check your chm lzx block parameters");
-        } catch (ChmParsingException e) {
+                throw new TikaException("Check your chm lzx block parameters");
+        } catch (Exception e) {
             // TODO: handle exception
         }
     }
@@ -101,12 +98,12 @@ public class ChmLzxBlock {
         this.chmSection = chmSection;
     }
 
-    private void assertStateNotNull() {
+    private void assertStateNotNull() throws TikaException {
         if (getState() == null)
             throw new ChmParsingException("state is null");
     }
 
-    private void extractContent() {
+    private void extractContent() throws TikaException {
         assertStateNotNull();
         if (getChmSection().getData() != null) {
             while (getContentLength() < getBlockLength()) {// && tempStopLoop
@@ -252,7 +249,7 @@ public class ChmLzxBlock {
         return tmp;
     }
 
-    private void createLengthTreeTable() {
+    private void createLengthTreeTable() throws TikaException {
         short[] prelentable = createPreLenTable();
 
         if (prelentable == null) {
@@ -299,7 +296,7 @@ public class ChmLzxBlock {
         }
     }
 
-    public void decompressAlignedBlock(int len, byte[] prevcontent) {
+    public void decompressAlignedBlock(int len, byte[] prevcontent) throws TikaException {
 
         if ((getChmSection() == null) || (getState() == null)
                 || (getState().getMainTreeTable() == null))
@@ -445,12 +442,12 @@ public class ChmLzxBlock {
         setContentLength(len);
     }
 
-    private void assertShortArrayNotNull(short[] array) {
+    private void assertShortArrayNotNull(short[] array) throws TikaException {
         if (array == null)
             throw new ChmParsingException("short[] is null");
     }
 
-    private void decompressVerbatimBlock(int len, byte[] prevcontent) {
+    private void decompressVerbatimBlock(int len, byte[] prevcontent) throws TikaException {
         short s;
         int x, i;
         int matchlen = 0, matchfooter = 0, extra, rundest, runsrc;
@@ -560,7 +557,7 @@ public class ChmLzxBlock {
     }
 
     private void createLengthTreeLenTable(int offset, int tablelen,
-            short[] pretreetable, short[] prelentable) {
+            short[] pretreetable, short[] prelentable) throws TikaException {
         if (prelentable == null || getChmSection() == null
                 || pretreetable == null || prelentable == null)
             throw new ChmParsingException("is null");
@@ -621,7 +618,7 @@ public class ChmLzxBlock {
         }
     }
 
-    private void createMainTreeTable() {
+    private void createMainTreeTable() throws TikaException {
         short[] prelentable = createPreLenTable();
         short[] pretreetable = createTreeTable2(prelentable,
                 (1 << ChmConstants.LZX_PRETREE_TABLEBITS)
@@ -650,7 +647,7 @@ public class ChmLzxBlock {
     }
 
     private void createMainTreeLenTable(int offset, int tablelen,
-            short[] pretreetable, short[] prelentable) {
+            short[] pretreetable, short[] prelentable) throws TikaException {
         if (pretreetable == null)
             throw new ChmParsingException("pretreetable is null");
         int i = offset;
@@ -712,7 +709,7 @@ public class ChmLzxBlock {
         }
     }
 
-    private void assertInRange(short[] array, int index) {
+    private void assertInRange(short[] array, int index) throws ChmParsingException {
         if (index >= array.length)
             throw new ChmParsingException(index + " is bigger than "
                     + array.length);
@@ -849,7 +846,7 @@ public class ChmLzxBlock {
         this.content = new byte[contentLength];
     }
 
-    private void checkLzxBlock(ChmLzxBlock chmPrevLzxBlock) {
+    private void checkLzxBlock(ChmLzxBlock chmPrevLzxBlock) throws TikaException {
         if (chmPrevLzxBlock == null && getBlockLength() < Integer.MAX_VALUE)
             setState(new ChmLzxState((int) getBlockLength()));
         else
@@ -857,7 +854,7 @@ public class ChmLzxBlock {
     }
 
     private boolean validateConstructorParams(int blockNumber,
-            byte[] dataSegment, long blockLength) {
+            byte[] dataSegment, long blockLength) throws TikaException {
         int goodParameter = 0;
         if (blockNumber >= 0)
             ++goodParameter;
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxState.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxState.java
index 77401de94..272a34294 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxState.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmLzxState.java
@@ -18,6 +18,7 @@ package org.apache.tika.parser.chm.lzx;
 
 import java.util.concurrent.CancellationException;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.core.ChmCommons;
 import org.apache.tika.parser.chm.core.ChmConstants;
 import org.apache.tika.parser.chm.core.ChmCommons.IntelState;
@@ -64,7 +65,7 @@ public class ChmLzxState {
         this.alignedTreeTable = alignedTreeTable;
     }
 
-    protected short[] getLengthTreeTable() {
+    protected short[] getLengthTreeTable() throws TikaException {
         if (lengthTreeTable != null)
             return this.lengthTreeTable;
         else
@@ -130,15 +131,15 @@ public class ChmLzxState {
         return sb.toString();
     }
 
-    public ChmLzxState(int window) {
+    public ChmLzxState(int window) throws TikaException {
         if (window >= 0) {
             int position_slots;
             int win = ChmCommons.getWindowSize(window);
             setWindowSize(1 << win);
             /* LZX supports window sizes of 2^15 (32Kb) through 2^21 (2Mb) */
             if (win < 15 || win > 21)
-                System.err
-                        .println("window less than 15 or window greater than 21");
+                throw new ChmParsingException("window less than 15 or window greater than 21");
+
             /* Calculates required position slots */
             if (win == 20)
                 position_slots = 42;
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmSection.java b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmSection.java
index 39ffa31f1..65347d0cf 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmSection.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/chm/lzx/ChmSection.java
@@ -19,6 +19,7 @@ package org.apache.tika.parser.chm.lzx;
 import java.math.BigInteger;
 import java.util.Arrays;
 
+import org.apache.tika.exception.TikaException;
 import org.apache.tika.parser.chm.core.ChmCommons;
 
 public class ChmSection {
@@ -27,13 +28,13 @@ public class ChmSection {
     private int total;// remains
     private int buffer;// val
 
-    public ChmSection(byte[] data) {
+    public ChmSection(byte[] data) throws TikaException {
         ChmCommons.assertByteArrayNotNull(data);
         setData(data);
     }
 
     /* Utilities */
-    public byte[] reverseByteOrder(byte[] toBeReversed) {
+    public byte[] reverseByteOrder(byte[] toBeReversed) throws TikaException {
         ChmCommons.assertByteArrayNotNull(toBeReversed);
         ChmCommons.reverse(toBeReversed);
         return toBeReversed;
@@ -195,10 +196,9 @@ public class ChmSection {
 
     /**
      * @param args
+     * @throws TikaException 
      */
-    public static void main(String[] args) {
-        int result = 8 & 255;
-        System.out.println("result " + result);
+    public static void main(String[] args) throws TikaException {
         byte[] array = { 4, 78, -67, 90, 1, -33 };
         ChmSection chmSection = new ChmSection(array);
         System.out.println("before " + Arrays.toString(array));
