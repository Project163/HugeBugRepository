diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index b96a11a6..fd8ac719 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -27,6 +27,10 @@
   <body>
     <release version="2.0" date="in SVN"
       description="TBD">
+      <action dev="oheger" type="update" issue="CONFIGURATION-546" due-to="Justin Couch">
+        BeanHelper can now process BeanDefinitions initializing properties of
+        collection types of their target beans.
+      </action>
       <action dev="oheger" type="update" issue="CONFIGURATION-542">
         The mechanism for synchronizing configurations has been completely
         redesigned. It is now based on Synchronizer objects which can be
diff --git a/src/main/java/org/apache/commons/configuration/beanutils/BeanHelper.java b/src/main/java/org/apache/commons/configuration/beanutils/BeanHelper.java
index a05724d7..5d34d02f 100644
--- a/src/main/java/org/apache/commons/configuration/beanutils/BeanHelper.java
+++ b/src/main/java/org/apache/commons/configuration/beanutils/BeanHelper.java
@@ -19,6 +19,7 @@ package org.apache.commons.configuration.beanutils;
 import java.beans.PropertyDescriptor;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -26,6 +27,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 
 import org.apache.commons.beanutils.BeanUtils;
 import org.apache.commons.beanutils.PropertyUtils;
@@ -209,8 +211,27 @@ public final class BeanHelper
                 {
                     String propName = e.getKey();
                     Class<?> defaultClass = getDefaultClass(bean, propName);
-                    initProperty(bean, propName, createBean(
-                        (BeanDeclaration) e.getValue(), defaultClass));
+
+                    Object prop = e.getValue();
+
+                    if (prop instanceof Collection)
+                    {
+                        Collection<Object> beanCollection =
+                                createPropertyCollection(propName, defaultClass);
+
+                        for (Object elemDef : (Collection<?>) prop)
+                        {
+                            beanCollection
+                                    .add(createBean((BeanDeclaration) elemDef));
+                        }
+
+                        initProperty(bean, propName, beanCollection);
+                    }
+                    else
+                    {
+                        initProperty(bean, propName, createBean(
+                            (BeanDeclaration) e.getValue(), defaultClass));
+                    }
                 }
             }
         }
@@ -292,6 +313,39 @@ public final class BeanHelper
         }
     }
 
+    /**
+     * Creates a concrete collection instance to populate a property of type
+     * collection. This method tries to guess an appropriate collection type.
+     * Mostly the type of the property will be one of the collection interfaces
+     * rather than a concrete class; so we have to create a concrete equivalent.
+     *
+     * @param propName the name of the collection property
+     * @param propertyClass the type of the property
+     * @return the newly created collection
+     */
+    private static Collection<Object> createPropertyCollection(String propName,
+            Class<?> propertyClass)
+    {
+        Collection<Object> beanCollection = null;
+
+        if (List.class.isAssignableFrom(propertyClass))
+        {
+            beanCollection = new ArrayList<Object>();
+        }
+        else if (Set.class.isAssignableFrom(propertyClass))
+        {
+            beanCollection = new TreeSet<Object>();
+        }
+        else
+        {
+            throw new UnsupportedOperationException(
+                    "Unable to handle collection of type : "
+                            + propertyClass.getName() + " for property "
+                            + propName);
+        }
+        return beanCollection;
+    }
+
     /**
      * Set a property on the bean only if the property exists
      *
diff --git a/src/test/java/org/apache/commons/configuration/beanutils/BeanCreationTestBeanWithListChild.java b/src/test/java/org/apache/commons/configuration/beanutils/BeanCreationTestBeanWithListChild.java
new file mode 100644
index 00000000..39ea1d7e
--- /dev/null
+++ b/src/test/java/org/apache/commons/configuration/beanutils/BeanCreationTestBeanWithListChild.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.configuration.beanutils;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * A simple bean class used for testing bean creation operations that has 
+ * a list of children of a different bean type.
+ *
+ * @version $Id: $
+ */
+public class BeanCreationTestBeanWithListChild
+{
+    private String stringValue;
+
+    private int intValue;
+
+    private List<BeanCreationTestBean> children = new ArrayList<BeanCreationTestBean>();
+
+    public List<BeanCreationTestBean> getChildren()
+    {
+        return children;
+    }
+
+    public void setChildren(List<BeanCreationTestBean> buddies)
+    {
+        this.children.clear();
+        this.children.addAll(buddies);
+    }
+
+    public int getIntValue()
+    {
+        return intValue;
+    }
+
+    public void setIntValue(int intValue)
+    {
+        this.intValue = intValue;
+    }
+
+    public String getStringValue()
+    {
+        return stringValue;
+    }
+
+    public void setStringValue(String stringValue)
+    {
+        this.stringValue = stringValue;
+    }
+}
diff --git a/src/test/java/org/apache/commons/configuration/beanutils/TestBeanHelper.java b/src/test/java/org/apache/commons/configuration/beanutils/TestBeanHelper.java
index 4fe43a7d..bbaca622 100644
--- a/src/test/java/org/apache/commons/configuration/beanutils/TestBeanHelper.java
+++ b/src/test/java/org/apache/commons/configuration/beanutils/TestBeanHelper.java
@@ -27,6 +27,7 @@ import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.commons.configuration.ConfigurationRuntimeException;
@@ -217,6 +218,21 @@ public class TestBeanHelper
         assertNull("A parameter was passed", factory.parameter);
     }
 
+    /**
+     * Tests whether a bean with a property of type collection can be created.
+     */
+    @Test
+    public void testCreateBeanWithListChildBean()
+    {
+        TestBeanFactory factory = new TestBeanFactory();
+        BeanHelper.registerBeanFactory(TEST_FACTORY, factory);
+        BeanDeclarationTestImpl data = setUpBeanDeclarationWithListChild();
+        data.setBeanFactoryName(TEST_FACTORY);
+        data.setBeanClassName(BeanCreationTestBeanWithListChild.class.getName());
+        checkBean((BeanCreationTestBeanWithListChild) BeanHelper.createBean(data, null));
+        assertNull("A parameter was passed", factory.parameter);
+    }
+
     /**
      * Tests creating a bean when no bean declaration is provided. This should
      * cause an exception.
@@ -449,12 +465,60 @@ public class TestBeanHelper
         {
             buddyData.setBeanFactoryName(TEST_FACTORY);
         }
+
         Map<String, Object> nested = new HashMap<String, Object>();
         nested.put("buddy", buddyData);
         data.setNestedBeanDeclarations(nested);
         return data;
     }
 
+    /**
+     * Same as setUpBeanDeclaration, but returns a nested array of beans
+     * as a single property. Tests multi-value (Collection<BeanDeclaration>)
+     * children construction.
+     *
+     * @return The bean declaration with a list child bean proerty
+     */
+    private BeanDeclarationTestImpl setUpBeanDeclarationWithListChild()
+    {
+        BeanDeclarationTestImpl data = new BeanDeclarationTestImpl();
+        Map<String, Object> properties = new HashMap<String, Object>();
+        properties.put("stringValue", TEST_STRING);
+        properties.put("intValue", String.valueOf(TEST_INT));
+        data.setBeanProperties(properties);
+
+        List<BeanDeclaration> childData = new ArrayList<BeanDeclaration>();
+        childData.add(createChildBean("child1"));
+        childData.add(createChildBean("child2"));
+        Map<String, Object> nested = new HashMap<String, Object>();
+        nested.put("children", childData);
+        data.setNestedBeanDeclarations(nested);
+        return data;
+    }
+
+    /**
+     * Create a simple bean declaration that has no children for testing
+     * of nested children bean declarations.
+     *
+     * @param name A name prefix that can be used to disambiguate the children
+     * @return A simple declaration
+     */
+    private BeanDeclarationTestImpl createChildBean(String name)
+    {
+        BeanDeclarationTestImpl childBean = new BeanDeclarationTestImpl();
+        Map<String, Object> properties2 = new HashMap<String, Object>();
+        properties2.put("stringValue", name + " Another test string");
+        properties2.put("intValue", new Integer(100));
+        childBean.setBeanProperties(properties2);
+        childBean.setBeanClassName(BeanCreationTestBean.class.getName());
+        if (BeanHelper.getDefaultBeanFactory() == null)
+        {
+            childBean.setBeanFactoryName(TEST_FACTORY);
+        }
+
+        return childBean;
+    }
+
     /**
      * Tests if the bean was correctly initialized from the data of the test
      * bean declaration.
@@ -473,6 +537,24 @@ public class TestBeanHelper
         assertEquals("Wrong int property in buddy", 100, buddy.getIntValue());
     }
 
+    /**
+     * Tests if the bean was correctly initialized from the data of the test
+     * bean declaration.
+     *
+     * @param bean the bean to be checked
+     */
+    private void checkBean(BeanCreationTestBeanWithListChild bean)
+    {
+        assertEquals("Wrong string property", TEST_STRING, bean
+                .getStringValue());
+        assertEquals("Wrong int property", TEST_INT, bean.getIntValue());
+        List<BeanCreationTestBean> children = bean.getChildren();
+        assertNotNull("Children were not set", children);
+        assertEquals("Wrong number of children created", children.size(), 2);
+        assertNotNull("First child was set as null", children.get(0));
+        assertNotNull("Second child was set as null", children.get(1));
+    }
+
     /**
      * An implementation of the BeanFactory interface used for testing. This
      * implementation is really simple: If the BeanCreationTestBean class is provided, a new
@@ -494,6 +576,12 @@ public class TestBeanHelper
                 BeanHelper.initBean(bean, data);
                 return bean;
             }
+            else if (BeanCreationTestBeanWithListChild.class.equals(beanClass))
+            {
+                BeanCreationTestBeanWithListChild bean = new BeanCreationTestBeanWithListChild();
+                BeanHelper.initBean(bean, data);
+                return bean;
+            }
             else
             {
                 throw new IllegalArgumentException("Unsupported class: "
