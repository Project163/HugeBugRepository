diff --git a/src/main/java/org/apache/commons/crypto/stream/CTRCipherInputStream.java b/src/main/java/org/apache/commons/crypto/stream/CTRCipherInputStream.java
index 6c3c6573..f286ad88 100644
--- a/src/main/java/org/apache/commons/crypto/stream/CTRCipherInputStream.java
+++ b/src/main/java/org/apache/commons/crypto/stream/CTRCipherInputStream.java
@@ -24,7 +24,6 @@
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
 import java.util.Properties;
-
 import javax.crypto.BadPaddingException;
 import javax.crypto.IllegalBlockSizeException;
 import javax.crypto.ShortBufferException;
@@ -67,28 +66,78 @@ public class CTRCipherInputStream extends CipherInputStream {
    */
   private boolean cipherReset = false;
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the input stream.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(Properties props, InputStream in,
-                              byte[] key, byte[] iv)
+      byte[] key, byte[] iv)
       throws IOException {
     this(props, in, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the ReadableByteChannel instance.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(Properties props, ReadableByteChannel in,
-                              byte[] key, byte[] iv)
+      byte[] key, byte[] iv)
       throws IOException {
     this(props, in, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param in the input stream.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(InputStream in, Cipher cipher, int bufferSize,
-                              byte[] key, byte[] iv) throws IOException {
+      byte[] key, byte[] iv) throws IOException {
     this(in, cipher, bufferSize, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param in the ReadableByteChannel instance.
+   * @param cipher the cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(ReadableByteChannel in, Cipher cipher,
-                              int bufferSize, byte[] key, byte[] iv) throws IOException {
+      int bufferSize, byte[] key, byte[] iv) throws IOException {
     this(in, cipher, bufferSize, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param input the input data.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(
       Input input,
       Cipher cipher,
@@ -98,30 +147,85 @@ public CTRCipherInputStream(
     this(input, cipher, bufferSize, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the InputStream instance.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the stream.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(Properties props, InputStream in,
-                              byte[] key, byte[] iv, long streamOffset)
+      byte[] key, byte[] iv, long streamOffset)
       throws IOException {
     this(in, Utils.getCipherInstance(CipherTransformation.AES_CTR_NOPADDING, props),
         Utils.getBufferSize(props), key, iv, streamOffset);
   }
 
+  /**
+   *Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the ReadableByteChannel instance.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the stream.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(Properties props, ReadableByteChannel in,
-                              byte[] key, byte[] iv, long streamOffset)
+      byte[] key, byte[] iv, long streamOffset)
       throws IOException {
     this(in, Utils.getCipherInstance(CipherTransformation.AES_CTR_NOPADDING, props),
         Utils.getBufferSize(props), key, iv, streamOffset);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param in the InputStream instance.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the stream.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(InputStream in, Cipher cipher, int bufferSize,
-                              byte[] key, byte[] iv, long streamOffset) throws IOException {
+      byte[] key, byte[] iv, long streamOffset) throws IOException {
     this(new StreamInput(in, bufferSize), cipher, bufferSize, key, iv, streamOffset);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param in the ReadableByteChannel instance.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the stream.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(ReadableByteChannel in, Cipher cipher,
-                              int bufferSize, byte[] key, byte[] iv, long streamOffset) throws IOException {
+      int bufferSize, byte[] key, byte[] iv, long streamOffset) throws IOException {
     this(new ChannelInput(in), cipher, bufferSize, key, iv, streamOffset);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherInputStream}.
+   *
+   * @param input the input data.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the stream.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherInputStream(
       Input input,
       Cipher cipher,
@@ -136,7 +240,15 @@ public CTRCipherInputStream(
     resetStreamOffset(streamOffset);
   }
 
-  /** Skip n bytes */
+  /**
+   * Overrides the {@link org.apache.commons.crypto.stream.CipherInputStream#skip(long)}.
+   * Skips over and discards <code>n</code> bytes of data from this input
+   * stream.
+   *
+   * @param n the number of bytes to be skipped.
+   * @return the actual number of bytes skipped.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public long skip(long n) throws IOException {
     Utils.checkArgument(n >= 0, "Negative skip length.");
@@ -167,7 +279,15 @@ public long skip(long n) throws IOException {
     }
   }
 
-  /** ByteBuffer read. */
+  /**
+   * Overrides the {@link org.apache.commons.crypto.stream.CTRCipherInputStream#read(ByteBuffer)}.
+   * Reads a sequence of bytes from this channel into the given buffer.
+   *
+   * @param buf The buffer into which bytes are to be transferred.
+   * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the
+   *          channel has reached end-of-stream.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public int read(ByteBuffer buf) throws IOException {
     checkStream();
@@ -207,10 +327,10 @@ public int read(ByteBuffer buf) throws IOException {
   }
 
   /**
-   * Seek the stream to a specific position relative to start of the under layer stream.
+   * Seeks the stream to a specific position relative to start of the under layer stream.
    * 
-   * @param position The position to seek to
-   * @throws IOException if seek failed
+   * @param position the given position in the data.
+   * @throws IOException if an I/O error occurs.
    */
   public void seek(long position) throws IOException {
     Utils.checkArgument(position >= 0, "Cannot seek to negative offset.");
@@ -230,19 +350,30 @@ public void seek(long position) throws IOException {
     }
   }
 
+  /**
+   * Gets the offset of the stream.
+   *
+   * @return the stream offset.
+   */
   protected long getStreamOffset() {
     return streamOffset;
   }
 
+  /**
+   * Gets the position of the stream.
+   *
+   * @return the position of the stream.
+   */
   protected long getStreamPosition() {
     return streamOffset - outBuffer.remaining();
   }
 
   /**
-   * Decrypt more data by reading the under layer stream. The decrypted data will
+   * Decrypts more data by reading the under layer stream. The decrypted data will
    * be put in the output buffer.
    *
-   * @return The number of decrypted data. -1 if end of the decrypted stream
+   * @return The number of decrypted data. -1 if end of the decrypted stream.
+   * @throws IOException if an I/O error occurs.
    */
   protected int decryptMore() throws IOException {
     int n = input.read(inBuffer);
@@ -257,9 +388,11 @@ protected int decryptMore() throws IOException {
   }
 
   /**
-   * Do the decryption using inBuffer as input and outBuffer as output.
+   * Does the decryption using inBuffer as input and outBuffer as output.
    * Upon return, inBuffer is cleared; the decrypted data starts at
-   * outBuffer.position() and ends at outBuffer.limit();
+   * outBuffer.position() and ends at outBuffer.limit().
+   *
+   * @throws IOException if an I/O error occurs.
    */
   protected void decrypt() throws IOException {
     Utils.checkState(inBuffer.position() >= padding);
@@ -284,11 +417,14 @@ protected void decrypt() throws IOException {
   }
 
   /**
-   * Do the decryption using inBuffer as input and buf as output.
+   * Does the decryption using inBuffer as input and buf as output.
    * Upon return, inBuffer is cleared; the buf's position will be equal to
    * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i> where <i>p</i> is the position before
    * decryption, <i>n</i> is the number of bytes decrypted.
    * The buf's limit will not have changed.
+   *
+   * @param buf The buffer into which bytes are to be transferred.
+   * @throws IOException if an I/O error occurs.
    */
   protected void decryptInPlace(ByteBuffer buf) throws IOException {
     Utils.checkState(inBuffer.position() >= padding);
@@ -306,9 +442,14 @@ protected void decryptInPlace(ByteBuffer buf) throws IOException {
   }
 
   /**
-   * Decrypt all data in buf: total n bytes from given start position.
+   * Decrypts all data in buf: total n bytes from given start position.
    * Output is also buf and same start position.
    * buf.position() and buf.limit() should be unchanged after decryption.
+   *
+   * @param buf The buffer into which bytes are to be transferred.
+   * @param offset the start offset in the data.
+   * @param len the the maximum number of decrypted data bytes to read.
+   * @throws IOException if an I/O error occurs.
    */
   protected void decrypt(ByteBuffer buf, int offset, int len)
       throws IOException {
@@ -334,8 +475,11 @@ protected void decrypt(ByteBuffer buf, int offset, int len)
   }
 
   /**
-   * This method is executed immediately after decryption. Check whether
+   * This method is executed immediately after decryption. Checks whether
    * cipher should be updated and recalculate padding if needed.
+   *
+   * @param position the given position in the data..
+   * @return the byte.
    */
   protected byte postDecryption(long position) throws IOException {
     byte padding = 0;
@@ -353,22 +497,42 @@ protected byte postDecryption(long position) throws IOException {
     return padding;
   }
 
+  /**
+   * Gets the counter for input stream position.
+   *
+   * @param position the given position in the data.
+   * @return the counter for input stream position.
+   */
   protected long getCounter(long position) {
     return position / cipher.getTransformation().getAlgorithmBlockSize();
   }
 
+  /**
+   * Gets the padding for input stream position.
+   *
+   * @param position the given position in the data.
+   * @return the padding for input stream position.
+   */
   protected byte getPadding(long position) {
     return (byte)(position % cipher.getTransformation().getAlgorithmBlockSize());
   }
 
-  /** Initialize the cipher. */
+  /**
+   * Overrides the {@link CTRCipherInputStream#initCipher()}.
+   * Initializes the cipher.
+   */
   @Override
   protected void initCipher() {
     // Do nothing for initCipher
     // Will reset the cipher when reset the stream offset
   }
 
-  /** Calculate the counter and iv, reset the cipher. */
+  /**
+   * Calculates the counter and iv, resets the cipher.
+   *
+   * @param position the given position in the data.
+   * @throws IOException if an I/O error occurs.
+   */
   protected void resetCipher(long position)
       throws IOException {
     final long counter = getCounter(position);
@@ -384,8 +548,11 @@ protected void resetCipher(long position)
   }
 
   /**
-   * Reset the underlying stream offset; clear {@link #inBuffer} and
+   * Resets the underlying stream offset; clear {@link #inBuffer} and
    * {@link #outBuffer}. This Typically happens during {@link #skip(long)}.
+   *
+   * @param offset the offset of the stream.
+   * @throws IOException if an I/O error occurs.
    */
   protected void resetStreamOffset(long offset) throws IOException {
     streamOffset = offset;
@@ -397,6 +564,12 @@ protected void resetStreamOffset(long offset) throws IOException {
     inBuffer.position(padding); // Set proper position for input data.
   }
 
+  /**
+   * Does the decryption using out as output.
+   *
+   * @param out the output ByteBuffer.
+   * @throws IOException if an I/O error occurs.
+   */
   protected void decryptBuffer(ByteBuffer out)
       throws IOException {
     int inputSize = inBuffer.remaining();
diff --git a/src/main/java/org/apache/commons/crypto/stream/CTRCipherOutputStream.java b/src/main/java/org/apache/commons/crypto/stream/CTRCipherOutputStream.java
index 13ac2568..5577b089 100644
--- a/src/main/java/org/apache/commons/crypto/stream/CTRCipherOutputStream.java
+++ b/src/main/java/org/apache/commons/crypto/stream/CTRCipherOutputStream.java
@@ -65,41 +65,113 @@ public class CTRCipherOutputStream extends CipherOutputStream {
    */
   private boolean cipherReset = false;
 
-  public CTRCipherOutputStream(Properties props, OutputStream out,
-                               byte[] key, byte[] iv)
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param out the output stream.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CTRCipherOutputStream(Properties props, OutputStream out, byte[] key,
+                               byte[] iv)
       throws IOException {
     this(props, out, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param out the WritableByteChannel instance.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherOutputStream(Properties props, WritableByteChannel out,
                                byte[] key, byte[] iv)
       throws IOException {
     this(props, out, key, iv, 0);
   }
 
-  public CTRCipherOutputStream(OutputStream out, Cipher cipher,
-                               int bufferSize, byte[] key, byte[] iv) throws IOException {
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param out the output stream.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CTRCipherOutputStream(OutputStream out, Cipher cipher, int bufferSize,
+                               byte[] key, byte[] iv) throws IOException {
     this(out, cipher, bufferSize, key, iv, 0);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param channel the WritableByteChannel instance.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherOutputStream(WritableByteChannel channel, Cipher cipher,
                                int bufferSize, byte[] key, byte[] iv) throws IOException {
     this(channel, cipher, bufferSize, key, iv, 0);
   }
 
-  public CTRCipherOutputStream(Output output, Cipher cipher,
-                               int bufferSize, byte[] key, byte[] iv)
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param output the Output instance.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CTRCipherOutputStream(Output output, Cipher cipher, int bufferSize,
+                               byte[] key, byte[] iv)
       throws IOException {
     this(output, cipher, bufferSize, key, iv, 0);
   }
 
-  public CTRCipherOutputStream(Properties props, OutputStream out,
-                               byte[] key, byte[] iv, long streamOffset)
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param out the output stream.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CTRCipherOutputStream(Properties props, OutputStream out, byte[] key,
+                               byte[] iv, long streamOffset)
       throws IOException {
     this(out, Utils.getCipherInstance(CipherTransformation.AES_CTR_NOPADDING, props),
         Utils.getBufferSize(props), key, iv, streamOffset);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param out the WritableByteChannel instance.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherOutputStream(Properties props, WritableByteChannel out,
                                byte[] key, byte[] iv, long streamOffset)
       throws IOException {
@@ -107,20 +179,54 @@ public CTRCipherOutputStream(Properties props, WritableByteChannel out,
         Utils.getBufferSize(props), key, iv, streamOffset);
   }
 
-  public CTRCipherOutputStream(OutputStream out, Cipher cipher,
-                               int bufferSize, byte[] key, byte[] iv, long streamOffset) throws IOException {
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param out the output stream.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CTRCipherOutputStream(OutputStream out, Cipher cipher, int bufferSize,
+                               byte[] key, byte[] iv, long streamOffset) throws IOException {
     this(new StreamOutput(out, bufferSize), cipher,
         bufferSize, key, iv, streamOffset);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param channel the WritableByteChannel instance.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
   public CTRCipherOutputStream(WritableByteChannel channel, Cipher cipher,
-                               int bufferSize, byte[] key, byte[] iv, long streamOffset) throws IOException {
+                               int bufferSize, byte[] key, byte[] iv,
+                               long streamOffset) throws IOException {
     this(new ChannelOutput(channel), cipher,
         bufferSize, key, iv, streamOffset);
   }
 
-  public CTRCipherOutputStream(Output output, Cipher cipher,
-                               int bufferSize, byte[] key, byte[] iv, long streamOffset)
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CTRCipherOutputStream}.
+   *
+   * @param output the output stream.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CTRCipherOutputStream(Output output, Cipher cipher, int bufferSize,
+                               byte[] key, byte[] iv, long streamOffset)
       throws IOException {
     super(output, cipher, bufferSize, key, iv);
 
@@ -131,8 +237,10 @@ public CTRCipherOutputStream(Output output, Cipher cipher,
   }
 
   /**
-   * Do the encryption, input is {@link #inBuffer} and output is
+   * Does the encryption, input is {@link #inBuffer} and output is
    * {@link #outBuffer}.
+   *
+   * @throws IOException if an I/O error occurs.
    */
   @Override
   protected void encrypt() throws IOException {
@@ -171,7 +279,9 @@ protected void encrypt() throws IOException {
   }
 
   /**
-   * Do final encryption of the last data
+   * Does final encryption of the last data.
+   *
+   * @throws IOException if an I/O error occurs.
    */
   @Override
   protected void encryptFinal() throws IOException {
@@ -179,14 +289,21 @@ protected void encryptFinal() throws IOException {
     encrypt();
   }
 
-  /** Initialize the cipher. */
+  /**
+   * Overrides the {@link CipherOutputStream#initCipher()}.
+   * Initializes the cipher.
+   */
   @Override
   protected void initCipher() {
     // Do nothing for initCipher
     // Will reset the cipher considering the stream offset
   }
 
-  /** Reset the {@link #cipher}: calculate counter and {@link #padding}. */
+  /**
+   * Resets the {@link #cipher}: calculate counter and {@link #padding}.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   private void resetCipher() throws IOException {
     final long counter =
         streamOffset / cipher.getTransformation().getAlgorithmBlockSize();
@@ -205,6 +322,12 @@ private void resetCipher() throws IOException {
     cipherReset = false;
   }
 
+  /**
+   * Does the encryption if the ByteBuffer data.
+   *
+   * @param out the output ByteBuffer.
+   * @throws IOException if an I/O error occurs.
+   */
   private void encryptBuffer(ByteBuffer out)
       throws IOException {
     int inputSize = inBuffer.remaining();
diff --git a/src/main/java/org/apache/commons/crypto/stream/CipherInputStream.java b/src/main/java/org/apache/commons/crypto/stream/CipherInputStream.java
index 47a1c4b7..0692550c 100644
--- a/src/main/java/org/apache/commons/crypto/stream/CipherInputStream.java
+++ b/src/main/java/org/apache/commons/crypto/stream/CipherInputStream.java
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
 import java.nio.channels.ReadableByteChannel;
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
@@ -36,7 +37,7 @@
 import org.apache.commons.crypto.utils.Utils;
 
 /**
- * CipherInputStream reads input data and decrypts data in stream manner. It supports
+ * CryptoInputStream reads input data and decrypts data in stream manner. It supports
  * any mode of operations such as AES CBC/CTR/GCM mode in concept.It is not thread-safe.
  *
  */
@@ -45,16 +46,28 @@ public class CipherInputStream extends InputStream implements
     ReadableByteChannel {
   private final byte[] oneByteBuf = new byte[1];
 
+  /**The Cipher instance.*/
   protected final Cipher cipher;
+
+  /**The buffer size.*/
   protected final int bufferSize;
 
+  /**Crypto key for the cipher.*/
   protected final byte[] key;
+
+  /**The initial IV.*/
   protected final byte[] initIV;
+
+  /** Initialization vector for the cipher.*/
   protected byte[] iv;
 
+  /** Flag to mark whether the input stream is closed.*/
   protected boolean closed;
+
+  /** Flag to mark whether do final of the cipher to end the decrypting stream.*/
   protected boolean finalDone = false;
 
+  /**The input data.*/
   protected Input input;
 
   /**
@@ -65,40 +78,90 @@ public class CipherInputStream extends InputStream implements
 
   /**
    * The decrypted data buffer. The data starts at outBuffer.position() and
-   * ends at outBuffer.limit();
+   * ends at outBuffer.limit().
    */
   protected ByteBuffer outBuffer;
 
+  /**
+   * Constructs a {@link CipherInputStream}.
+   *
+   * @param transformation the CipherTransformation instance.
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the input stream.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherInputStream(CipherTransformation transformation,
-                           Properties props, InputStream in, byte[] key, byte[] iv)
+                           Properties props, InputStream in, byte[] key,
+                           byte[] iv)
       throws IOException {
     this(in, Utils.getCipherInstance(transformation, props),
         Utils.getBufferSize(props), key, iv);
   }
 
+  /**
+   * Constructs a {@link CipherInputStream}.
+   *
+   * @param transformation the CipherTransformation instance.
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the ReadableByteChannel object.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherInputStream(CipherTransformation transformation,
-                           Properties props, ReadableByteChannel in, byte[] key, byte[] iv)
+                           Properties props, ReadableByteChannel in, byte[] key,
+                           byte[] iv)
       throws IOException {
     this(in, Utils.getCipherInstance(transformation, props),
         Utils.getBufferSize(props), key, iv);
   }
 
+  /**
+   * Constructs a {@link CipherInputStream}.
+   *
+   * @param cipher the cipher instance.
+   * @param in the input stream.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherInputStream(InputStream in, Cipher cipher, int bufferSize,
                            byte[] key, byte[] iv) throws IOException {
     this(new StreamInput(in, bufferSize), cipher, bufferSize, key, iv);
   }
 
+  /**
+   * Constructs a {@link CipherInputStream}.
+   *
+   * @param in the ReadableByteChannel instance.
+   * @param cipher the cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherInputStream(ReadableByteChannel in, Cipher cipher,
                            int bufferSize, byte[] key, byte[] iv) throws IOException {
     this(new ChannelInput(in), cipher, bufferSize, key, iv);
   }
 
-  public CipherInputStream(
-      Input input,
-      Cipher cipher,
-      int bufferSize,
-      byte[] key,
-      byte[] iv) throws IOException {
+  /**
+   * Constructs a {@link CipherInputStream}.
+   *
+   * @param input the input data.
+   * @param cipher the cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CipherInputStream(Input input, Cipher cipher, int bufferSize,
+                           byte[] key, byte[] iv) throws IOException {
     this.input = input;
     this.cipher = cipher;
     this.bufferSize = Utils.checkBufferSize(cipher, bufferSize);
@@ -114,6 +177,14 @@ public CipherInputStream(
     initCipher();
   }
 
+  /**
+   * Overrides the {@link java.io.InputStream#read()}.
+   * Reads the next byte of data from the input stream.
+   *
+   * @return the next byte of data, or <code>-1</code> if the end of the
+   *         stream is reached.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public int read() throws IOException {
     int n;
@@ -122,15 +193,17 @@ public int read() throws IOException {
   }
 
   /**
+   * Overrides the {@link java.io.InputStream#read(byte[], int, int)}.
    * Decryption is buffer based.
    * If there is data in {@link #outBuffer}, then read it out of this buffer.
    * If there is no data in {@link #outBuffer}, then read more from the
    * underlying stream and do the decryption.
+   *
    * @param b the buffer into which the decrypted data is read.
    * @param off the buffer offset.
    * @param len the maximum number of decrypted data bytes to read.
    * @return int the total number of decrypted data bytes read into the buffer.
-   * @throws IOException
+   * @throws IOException if an I/O error occurs.
    */
   @Override
   public int read(byte[] b, int off, int len) throws IOException {
@@ -161,6 +234,15 @@ public int read(byte[] b, int off, int len) throws IOException {
     }
   }
 
+  /**
+   * Overrides the {@link java.io.InputStream#skip(long)}.
+   * Skips over and discards <code>n</code> bytes of data from this input
+   * stream.
+   *
+   * @param n the number of bytes to be skipped.
+   * @return the actual number of bytes skipped.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public long skip(long n) throws IOException {
     Utils.checkArgument(n >= 0, "Negative skip length.");
@@ -195,6 +277,17 @@ public long skip(long n) throws IOException {
     return n - remaining;
   }
 
+  /**
+   * Overrides the {@link InputStream#available()}.
+   * Returns an estimate of the number of bytes that can be read (or
+   * skipped over) from this input stream without blocking by the next
+   * invocation of a method for this input stream.
+   *
+   * @return an estimate of the number of bytes that can be read (or skipped
+   *         over) from this input stream without blocking or {@code 0} when
+   *          it reaches the end of the input stream.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public int available() throws IOException {
     checkStream();
@@ -202,6 +295,13 @@ public int available() throws IOException {
     return input.available() + outBuffer.remaining();
   }
 
+  /**
+   * Overrides the {@link InputStream#close()}.
+   * Closes this input stream and releases any system resources associated
+   * with the stream.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public void close() throws IOException {
     if (closed) {
@@ -215,25 +315,57 @@ public void close() throws IOException {
     closed = true;
   }
 
+  /**
+   * Overrides the {@link java.io.InputStream#mark(int)}.
+   * For {@link CipherInputStream},we don't support the mark method.
+   *
+   * @param readlimit the maximum limit of bytes that can be read before
+   *                  the mark position becomes invalid.
+   */
   @Override
   public void mark(int readlimit) {
   }
 
+  /**
+   * Overrides the {@link InputStream#reset()}.
+   * For {@link CipherInputStream},we don't support the reset method.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public void reset() throws IOException {
     throw new IOException("Mark/reset not supported");
   }
 
+  /**
+   * Overrides the {@link InputStream#markSupported()}.
+   *
+   * @return false,the {@link CTRCryptoInputStream} don't support the mark method.
+   */
   @Override
   public boolean markSupported() {
     return false;
   }
 
+  /**
+   * Overrides the {@link Channel#isOpen()}.
+   *
+   * @return <tt>true</tt> if, and only if, this channel is open.
+   */
   @Override
   public boolean isOpen() {
     return !closed;
   }
 
+  /**
+   * Overrides the {@link java.nio.channels.ReadableByteChannel#read(ByteBuffer)}.
+   * Reads a sequence of bytes from this channel into the given buffer.
+   *
+   * @param dst The buffer into which bytes are to be transferred.
+   * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the
+   *         channel has reached end-of-stream.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public int read(ByteBuffer dst) throws IOException {
     checkStream();
@@ -262,34 +394,46 @@ public int read(ByteBuffer dst) throws IOException {
   }
 
   /**
-   * Get the buffer size
+   * Gets the buffer size.
+   *
+   * @return the bufferSize.
    */
   protected int getBufferSize() {
     return bufferSize;
   }
 
   /**
-   * Get the key
+   * Gets the key.
+   *
+   * @return the key.
    */
   protected byte[] getKey() {
     return key;
   }
 
   /**
-   * Get the initialization vector
+   * Gets the initialization vector.
+   *
+   * @return the initIV.
    */
   protected byte[] getInitIV() {
     return initIV;
   }
 
   /**
-   * Get the internal Cipher
+   * Gets the internal Cipher.
+   *
+   * @return the cipher instance.
    */
   protected Cipher getCipher() {
     return cipher;
   }
 
-  /** Initialize the cipher. */
+  /**
+   * Initializes the cipher.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   protected void initCipher()
       throws IOException {
     try {
@@ -302,11 +446,11 @@ protected void initCipher()
   }
 
   /**
-   * Decrypt more data by reading the under layer stream. The decrypted data will
+   * Decrypts more data by reading the under layer stream. The decrypted data will
    * be put in the output buffer. If the end of the under stream reached, we will
    * do final of the cipher to finish all the decrypting of data.
    *
-   * @return The number of decrypted data. -1 if end of the decrypted stream
+   * @return The number of decrypted data. -1 if end of the decrypted stream.
    */
   protected int decryptMore() throws IOException {
     if(finalDone) {
@@ -336,9 +480,11 @@ protected int decryptMore() throws IOException {
   }
 
   /**
-   * Do the decryption using inBuffer as input and outBuffer as output.
+   * Does the decryption using inBuffer as input and outBuffer as output.
    * Upon return, inBuffer is cleared; the decrypted data starts at
-   * outBuffer.position() and ends at outBuffer.limit();
+   * outBuffer.position() and ends at outBuffer.limit().
+   *
+   * @throws IOException if an I/O error occurs.
    */
   protected void decrypt() throws IOException {
     // Prepare the input buffer and clear the out buffer
@@ -357,7 +503,9 @@ protected void decrypt() throws IOException {
   }
 
   /**
-   * Do final of the cipher to end the decrypting stream
+   * Does final of the cipher to end the decrypting stream.
+   *
+   *@throws IOException if an I/O error occurs.
    */
   protected void decryptFinal() throws IOException {
     // Prepare the input buffer and clear the out buffer
@@ -380,6 +528,11 @@ protected void decryptFinal() throws IOException {
     outBuffer.flip();
   }
 
+  /**
+   * Checks whether the stream is closed.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   protected void checkStream() throws IOException {
     if (closed) {
       throw new IOException("Stream closed");
diff --git a/src/main/java/org/apache/commons/crypto/stream/CipherOutputStream.java b/src/main/java/org/apache/commons/crypto/stream/CipherOutputStream.java
index b0a0f96c..01060558 100644
--- a/src/main/java/org/apache/commons/crypto/stream/CipherOutputStream.java
+++ b/src/main/java/org/apache/commons/crypto/stream/CipherOutputStream.java
@@ -21,6 +21,7 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
 import java.nio.channels.WritableByteChannel;
 import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
@@ -38,22 +39,34 @@
 import org.apache.commons.crypto.utils.Utils;
 
 /**
- * CipherOutputStream encrypts data and writes to the under layer output. It supports
- * any mode of operations such as AES CBC/CTR/GCM mode in concept. It is not thread-safe.
+ * {@link CipherOutputStream} encrypts data and writes to the under layer
+ * output. It supports any mode of operations such as AES CBC/CTR/GCM mode
+ * in concept. It is not thread-safe.
  */
 
 public class CipherOutputStream extends OutputStream implements
     WritableByteChannel {
   private final byte[] oneByteBuf = new byte[1];
 
+  /** The output.*/
   protected Output output;
+
+  /**the Cipher instance*/
   protected final Cipher cipher;
+
+  /**The buffer size.*/
   protected final int bufferSize;
 
+  /**Crypto key for the cipher.*/
   protected final byte[] key;
+
+  /**The initial IV.*/
   protected final byte[] initIV;
+
+  /** Initialization vector for the cipher.*/
   protected byte[] iv;
 
+  /** Flag to mark whether the output stream is closed.*/
   protected boolean closed;
 
   /**
@@ -64,36 +77,90 @@ public class CipherOutputStream extends OutputStream implements
 
   /**
    * Encrypted data buffer. The data starts at outBuffer.position() and ends at
-   * outBuffer.limit();
+   * outBuffer.limit().
    */
   protected ByteBuffer outBuffer;
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CipherOutputStream}.
+   *
+   * @param transformation the CipherTransformation instance.
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param out the output stream.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherOutputStream(CipherTransformation transformation,
-                            Properties props, OutputStream out, byte[] key, byte[] iv)
+                            Properties props, OutputStream out, byte[] key,
+                            byte[] iv)
       throws IOException {
     this(out, Utils.getCipherInstance(transformation, props),
         Utils.getBufferSize(props), key, iv);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CipherOutputStream}.
+   *
+   * @param transformation the CipherTransformation instance.
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param out the WritableByteChannel instance.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherOutputStream(CipherTransformation transformation,
-                            Properties props, WritableByteChannel out, byte[] key, byte[] iv)
+                            Properties props, WritableByteChannel out,
+                            byte[] key, byte[] iv)
       throws IOException {
     this(out, Utils.getCipherInstance(transformation, props),
         Utils.getBufferSize(props), key, iv);
   }
 
-  public CipherOutputStream(OutputStream out, Cipher cipher,
-                            int bufferSize, byte[] key, byte[] iv) throws IOException {
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CipherOutputStream}.
+   *
+   * @param out the output stream.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
+  public CipherOutputStream(OutputStream out, Cipher cipher, int bufferSize,
+                            byte[] key, byte[] iv) throws IOException {
     this(new StreamOutput(out, bufferSize), cipher, bufferSize, key, iv);
   }
 
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CipherOutputStream}.
+   *
+   * @param channel the WritableByteChannel instance.
+   * @param cipher the cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
   public CipherOutputStream(WritableByteChannel channel, Cipher cipher,
                             int bufferSize, byte[] key, byte[] iv) throws IOException {
     this(new ChannelOutput(channel), cipher, bufferSize, key, iv);
   }
 
-  protected CipherOutputStream(Output output, Cipher cipher,
-                               int bufferSize, byte[] key, byte[] iv)
+  /**
+   * Constructs a {@link org.apache.commons.crypto.stream.CipherOutputStream}.
+   *
+   * @param output the output stream.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @throws IOException if an I/O error occurs.
+   */
+  protected CipherOutputStream(Output output, Cipher cipher, int bufferSize,
+                               byte[] key, byte[] iv)
       throws IOException {
 
     this.output = output;
@@ -109,21 +176,30 @@ protected CipherOutputStream(Output output, Cipher cipher,
     initCipher();
   }
 
+  /**
+   * Overrides the {@link java.io.OutputStream#write(byte[])}.
+   * Writes the specified byte to this output stream.
+   *
+   * @param b the data.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public void write(int b) throws IOException {
-    oneByteBuf[0] = (byte)(b & 0xff);
+    oneByteBuf[0] = (byte) (b & 0xff);
     write(oneByteBuf, 0, oneByteBuf.length);
   }
 
   /**
+   * Overrides the {@link java.io.OutputStream#write(byte[], int, int)}.
    * Encryption is buffer based.
    * If there is enough room in {@link #inBuffer}, then write to this buffer.
    * If {@link #inBuffer} is full, then do encryption and write data to the
    * underlying stream.
+   *
    * @param b the data.
    * @param off the start offset in the data.
    * @param len the number of bytes to write.
-   * @throws IOException
+   * @throws IOException if an I/O error occurs.
    */
   public void write(byte[] b, int off, int len) throws IOException {
     checkStream();
@@ -149,8 +225,11 @@ public void write(byte[] b, int off, int len) throws IOException {
   }
 
   /**
+   * Overrides the {@link OutputStream#flush()}.
    * To flush, we need to encrypt the data in the buffer and write to the
    * underlying stream, then do the flush.
+   *
+   * @throws IOException if an I/O error occurs.
    */
   @Override
   public void flush() throws IOException {
@@ -160,6 +239,13 @@ public void flush() throws IOException {
     super.flush();
   }
 
+  /**
+   * Overrides the {@link OutputStream#close()}.
+   * Closes this output stream and releases any system resources
+   * associated with this stream.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public void close() throws IOException {
     if (closed) {
@@ -177,11 +263,25 @@ public void close() throws IOException {
     }
   }
 
+  /**
+   * Overrides the {@link Channel#isOpen()}.
+   * Tells whether or not this channel is open.
+   *
+   * @return <tt>true</tt> if, and only if, this channel is open
+   */
   @Override
   public boolean isOpen() {
     return !closed;
   }
 
+  /**
+   * Overrides the {@link java.nio.channels.WritableByteChannel#write(ByteBuffer)}.
+   * Writes a sequence of bytes to this channel from the given buffer.
+   *
+   * @param src The buffer from which bytes are to be retrieved.
+   * @return The number of bytes written, possibly zero.
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public int write(ByteBuffer src) throws IOException {
     checkStream();
@@ -211,7 +311,11 @@ public int write(ByteBuffer src) throws IOException {
     return len;
   }
 
-  /** Initialize the cipher. */
+  /**
+   * Initializes the cipher.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   protected void initCipher()
       throws IOException {
     try {
@@ -224,8 +328,10 @@ protected void initCipher()
   }
 
   /**
-   * Do the encryption, input is {@link #inBuffer} and output is
+   * Does the encryption, input is {@link #inBuffer} and output is
    * {@link #outBuffer}.
+   *
+   *@throws IOException if an I/O error occurs.
    */
   protected void encrypt() throws IOException {
 
@@ -246,7 +352,9 @@ protected void encrypt() throws IOException {
   }
 
   /**
-   * Do final encryption of the last data
+   * Does final encryption of the last data.
+   *
+   * @throws IOException if an I/O error occurs.
    */
   protected void encryptFinal() throws IOException {
     inBuffer.flip();
diff --git a/src/main/java/org/apache/commons/crypto/stream/PositionedCipherInputStream.java b/src/main/java/org/apache/commons/crypto/stream/PositionedCipherInputStream.java
index c6a41695..27b6a28e 100644
--- a/src/main/java/org/apache/commons/crypto/stream/PositionedCipherInputStream.java
+++ b/src/main/java/org/apache/commons/crypto/stream/PositionedCipherInputStream.java
@@ -57,26 +57,49 @@ public class PositionedCipherInputStream extends CTRCipherInputStream {
   private final Queue<CipherState> cipherPool = new
       ConcurrentLinkedQueue<CipherState>();
 
-  public PositionedCipherInputStream(Properties props, Input in,
-                                     byte[] key, byte[] iv, long streamOffset) throws IOException {
+  /**
+   * Constructs a {@link PositionedCipherInputStream}.
+   *
+   * @param props The <code>Properties</code> class represents a set of
+   *              properties.
+   * @param in the input data.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
+  public PositionedCipherInputStream(Properties props, Input in, byte[] key,
+                                     byte[] iv, long streamOffset) throws IOException {
     this(in, Utils.getCipherInstance(AES_CTR_NOPADDING, props),
         Utils.getBufferSize(props), key, iv, streamOffset);
   }
 
-  public PositionedCipherInputStream(
-      Input input,
-      Cipher cipher,
-      int bufferSize,
-      byte[] key,
-      byte[] iv,
-      long streamOffset) throws IOException {
+  /**
+   * Constructs a {@link PositionedCipherInputStream}.
+   *
+   * @param input the input data.
+   * @param cipher the Cipher instance.
+   * @param bufferSize the bufferSize.
+   * @param key crypto key for the cipher.
+   * @param iv Initialization vector for the cipher.
+   * @param streamOffset the start offset in the data.
+   * @throws IOException if an I/O error occurs.
+   */
+  public PositionedCipherInputStream(Input input, Cipher cipher, int bufferSize,
+                                     byte[] key, byte[] iv, long streamOffset) throws IOException {
     super(input, cipher, bufferSize, key, iv, streamOffset);
   }
 
   /**
-   * Read upto the specified number of bytes from a given position
+   * Reads up to the specified number of bytes from a given position
    * within a stream and return the number of bytes read. This does not
    * change the current offset of the stream, and is thread-safe.
+   *
+   * @param buffer the buffer into which the data is read.
+   * @param length the maximum number of bytes to read.
+   * @param offset the start offset in the data.
+   * @param position the offset from the start of the stream.
+   * @throws IOException if an I/O error occurs.
    */
   public int read(long position, byte[] buffer, int offset, int length)
       throws IOException {
@@ -90,8 +113,14 @@ public int read(long position, byte[] buffer, int offset, int length)
   }
 
   /**
-   * Read the specified number of bytes from a given position within a stream.
+   * Reads the specified number of bytes from a given position within a stream.
    * This does not change the current offset of the stream and is thread-safe.
+   *
+   * @param buffer the buffer into which the data is read.
+   * @param length the maximum number of bytes to read.
+   * @param offset the start offset in the data.
+   * @param position the offset from the start of the stream.
+   * @throws IOException if an I/O error occurs.
    */
   public void readFully(long position, byte[] buffer, int offset, int length)
       throws IOException {
@@ -103,13 +132,27 @@ public void readFully(long position, byte[] buffer, int offset, int length)
     }
   }
 
+  /**
+   * Reads the specified number of bytes from a given position within a stream.
+   * This does not change the current offset of the stream and is thread-safe.
+   *
+   * @param position the offset from the start of the stream.
+   * @param buffer the buffer into which the data is read.
+   * @throws IOException if an I/O error occurs.
+   */
   public void readFully(long position, byte[] buffer) throws IOException {
     readFully(position, buffer, 0, buffer.length);
   }
 
   /**
-   * Decrypt length bytes in buffer starting at offset. Output is also put
+   * Decrypts length bytes in buffer starting at offset. Output is also put
    * into buffer starting at offset. It is thread-safe.
+   *
+   * @param buffer the buffer into which the data is read.
+   * @param offset the start offset in the data.
+   * @param position the offset from the start of the stream.
+   * @param length the maximum number of bytes to read.
+   * @throws IOException if an I/O error occurs.
    */
   protected void decrypt(long position, byte[] buffer, int offset, int length)
       throws IOException {
@@ -143,9 +186,9 @@ protected void decrypt(long position, byte[] buffer, int offset, int length)
   }
 
   /**
-   * Do the decryption using inBuffer as input and outBuffer as output.
+   * Does the decryption using inBuffer as input and outBuffer as output.
    * Upon return, inBuffer is cleared; the decrypted data starts at
-   * outBuffer.position() and ends at outBuffer.limit();
+   * outBuffer.position() and ends at outBuffer.limit()
    */
   private void decrypt(CipherState state, ByteBuffer inBuffer,
       ByteBuffer outBuffer, byte padding) throws IOException {
@@ -269,6 +312,13 @@ private void returnBuffer(ByteBuffer buf) {
     }
   }
 
+  /**
+   * Overrides the {@link CipherInputStream#close()}.
+   * Closes this input stream and releases any system resources associated
+   * with the stream.
+   *
+   * @throws IOException if an I/O error occurs.
+   */
   @Override
   public void close() throws IOException {
     if (!isOpen()) {
