diff --git a/src/main/java/org/apache/commons/jexl2/Debugger.java b/src/main/java/org/apache/commons/jexl2/Debugger.java
index 4048e4b6..acb375a3 100644
--- a/src/main/java/org/apache/commons/jexl2/Debugger.java
+++ b/src/main/java/org/apache/commons/jexl2/Debugger.java
@@ -56,6 +56,7 @@ import org.apache.commons.jexl2.parser.ASTNotNode;
 import org.apache.commons.jexl2.parser.ASTNullLiteral;
 import org.apache.commons.jexl2.parser.ASTOrNode;
 import org.apache.commons.jexl2.parser.ASTReference;
+import org.apache.commons.jexl2.parser.ASTReferenceExpression;
 import org.apache.commons.jexl2.parser.ASTSizeFunction;
 import org.apache.commons.jexl2.parser.ASTSizeMethod;
 import org.apache.commons.jexl2.parser.ASTStringLiteral;
@@ -638,4 +639,11 @@ final class Debugger implements ParserVisitor {
     public Object visit(ASTAmbiguous node, Object data) {
         throw new UnsupportedOperationException("unexpected type of node");
     }
+
+    public Object visit(ASTReferenceExpression node, Object data) {
+        builder.append("(");
+        accept(node.jjtGetChild(0), data);
+        builder.append(")");
+        return data;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/apache/commons/jexl2/Interpreter.java b/src/main/java/org/apache/commons/jexl2/Interpreter.java
index bd27c688..41a6742d 100644
--- a/src/main/java/org/apache/commons/jexl2/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl2/Interpreter.java
@@ -25,6 +25,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
+import org.apache.commons.jexl2.parser.ASTReferenceExpression;
 
 import org.apache.commons.jexl2.parser.SimpleNode;
 import org.apache.commons.logging.Log;
@@ -1066,6 +1067,10 @@ public class Interpreter implements ParserVisitor {
         return result;
     }
 
+    public Object visit(ASTReferenceExpression node, Object data) {
+        return node.jjtGetChild(0).jjtAccept(this, data);
+    }
+    
     /**
      * Check if a null evaluated expression is protected by a ternary expression.
      * The rationale is that the ternary / elvis expressions are meant for the user to explictly take
@@ -1364,4 +1369,5 @@ public class Interpreter implements ParserVisitor {
     public Object visit(ASTAmbiguous node, Object data) {
         throw new UnsupportedOperationException("unexpected type of node");
     }
+
 }
diff --git a/src/main/java/org/apache/commons/jexl2/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl2/parser/Parser.jjt
index dbe82032..a5986ab3 100644
--- a/src/main/java/org/apache/commons/jexl2/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl2/parser/Parser.jjt
@@ -130,7 +130,7 @@ PARSER_END(Parser)
     | < SEMICOL : ";" >
     | < COLON : ":" >
     | < COMMA : "," >
-    | <DOT : "." >
+    | < DOT : "." >
 }
 
 <*> TOKEN : { /* CONDITIONALS */
@@ -257,15 +257,12 @@ void ForeachStatement() : {}
 
 void Expression() #void : {}
 {
-    LOOKAHEAD( Reference() <assign> )  Assignment()
-|
-    ConditionalExpression()
+    ConditionalExpression() ( <assign> Expression() #Assignment(2) )?
 }
 
-
 void Assignment() #Assignment(2) : {}
 {
-    Reference() <assign> Expression()
+    ConditionalExpression() <assign> Expression()
 }
 
 /***************************************
@@ -528,11 +525,7 @@ void Constructor() #ConstructorNode() : {}
 
 void PrimaryExpression() #void : {}
 {
-  Literal()
-|
   LOOKAHEAD(3)  Reference()
-|
-  LOOKAHEAD( <LPAREN> ) <LPAREN> Expression() <RPAREN>
 |
   LOOKAHEAD( <EMPTY> ) EmptyFunction()
 |
@@ -543,9 +536,10 @@ void PrimaryExpression() #void : {}
   LOOKAHEAD( <LCURLY> MapEntry() ) MapLiteral()
 |
   LOOKAHEAD( <LBRACKET> Expression() ) ArrayLiteral()
+|
+  Literal()
 }
 
-
 void ArrayAccess() : {}
 {
     Identifier() (LOOKAHEAD(2) <LBRACKET> Expression() <RBRACKET>)+
@@ -570,18 +564,29 @@ void DotReference() #void : {}
 
 void Reference() : {}
 {
-  ( LOOKAHEAD(<NEW>) Constructor()
+  (
+   LOOKAHEAD(<NEW>) Constructor()
 |
    LOOKAHEAD(Identifier() <LBRACKET> ) ArrayAccess()
 |
    LOOKAHEAD(Identifier() <COLON> Identifier() <LPAREN>) Function()
 |
    LOOKAHEAD(Identifier() <LPAREN>) Method()
-|
-   Identifier()
 |
    LOOKAHEAD(<LCURLY>) MapLiteral()
 |
-   LOOKAHEAD(<LBRACKET>) ArrayLiteral() ) DotReference()
+   LOOKAHEAD(<LBRACKET>) ArrayLiteral()
+|
+   LOOKAHEAD( <LPAREN> Expression() ) ReferenceExpression()
+|
+   StringLiteral()
+|
+   Identifier()
+  )  DotReference()
+}
+
+void ReferenceExpression() : {}
+{
+    <LPAREN> Expression() <RPAREN>
 }
 
diff --git a/src/test/java/org/apache/commons/jexl2/IssuesTest.java b/src/test/java/org/apache/commons/jexl2/IssuesTest.java
index 648e0a91..c8ffe6b0 100644
--- a/src/test/java/org/apache/commons/jexl2/IssuesTest.java
+++ b/src/test/java/org/apache/commons/jexl2/IssuesTest.java
@@ -452,4 +452,33 @@ public class IssuesTest extends JexlTestCase {
             //ok  to fail
         }
     }
+
+    public void test107() throws Exception {
+        JexlContext context = new MapContext();
+        context.set("Q4", "Q4");
+        JexlEngine jexl = new JexlEngine();
+        Expression expr;
+        Object value;
+        expr = jexl.createExpression("'Q4'.toLowerCase()");
+        value = expr.evaluate(context);
+        assertEquals("q4", value);
+        expr = jexl.createExpression("(Q4).toLowerCase()");
+        value = expr.evaluate(context);
+        assertEquals("q4", value);
+        expr = jexl.createExpression("(4).toString()");
+        value = expr.evaluate(context);
+        assertEquals("4", value);
+        value = jexl.createExpression("(1 + 3).toString()");
+        value = expr.evaluate(context);
+        assertEquals("4", value);
+        expr = jexl.createExpression("({ 'Q4' : 'Q4'}).get('Q4').toLowerCase()");
+        value = expr.evaluate(context);
+        assertEquals("q4", value);
+        expr = jexl.createExpression("{ 'Q4' : 'Q4'}.get('Q4').toLowerCase()");
+        value = expr.evaluate(context);
+        assertEquals("q4", value);
+        expr = jexl.createExpression("({ 'Q4' : 'Q4'}).get('Q4').toLowerCase()");
+        value = expr.evaluate(context);
+        assertEquals("q4", value);
+    }
 }
