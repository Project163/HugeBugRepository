diff --git a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java
index 58521775..4526c720 100644
--- a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java
+++ b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java
@@ -29,8 +29,10 @@ import org.apache.johnzon.jsonb.serializer.JohnzonDeserializationContext;
 import org.apache.johnzon.jsonb.serializer.JohnzonSerializationContext;
 import org.apache.johnzon.jsonb.spi.JohnzonAdapterFactory;
 import org.apache.johnzon.mapper.Adapter;
+import org.apache.johnzon.mapper.Converter;
 import org.apache.johnzon.mapper.JohnzonAny;
 import org.apache.johnzon.mapper.JohnzonConverter;
+import org.apache.johnzon.mapper.MapperConverter;
 import org.apache.johnzon.mapper.ObjectConverter;
 import org.apache.johnzon.mapper.TypeAwareAdapter;
 import org.apache.johnzon.mapper.access.AccessMode;
@@ -711,7 +713,7 @@ public class JsonbAccessMode implements AccessMode, Closeable {
             validateAnnotations(annotationHolder, adapter, dateFormat, numberFormat, johnzonConverter);
 
             try {
-                converter = adapter == null && dateFormat == null && numberFormat == null ?
+                converter = adapter == null && dateFormat == null && numberFormat == null && johnzonConverter == null ?
                         defaultConverters.get(new AdapterKey(annotationHolder.getType(), String.class)) :
                         toConverter(annotationHolder.getType(), adapter, dateFormat, numberFormat);
             } catch (final InstantiationException | IllegalAccessException e) {
@@ -730,7 +732,12 @@ public class JsonbAccessMode implements AccessMode, Closeable {
                         instance.getValue().deserialize(parserFactory.get().createParser(jsonObject), new JohnzonDeserializationContext(parser), targetType);
             } else if (johnzonConverter != null) {
                 try {
-                    reader = (ObjectConverter.Reader) johnzonConverter.value().newInstance();
+                    MapperConverter mapperConverter = johnzonConverter.value().newInstance();
+                    if (mapperConverter instanceof Converter) {
+                        converter = new ConverterAdapter<>((Converter) mapperConverter);
+                    } else if (mapperConverter instanceof ObjectConverter.Reader) {
+                        reader = (ObjectConverter.Reader) mapperConverter;
+                    }
                 } catch (final InstantiationException | IllegalAccessException e) {
                     throw new IllegalArgumentException(e);
                 }
@@ -751,7 +758,7 @@ public class JsonbAccessMode implements AccessMode, Closeable {
             validateAnnotations(initialReader, adapter, dateFormat, numberFormat, johnzonConverter);
 
             try {
-                converter = adapter == null && dateFormat == null && numberFormat == null ?
+                converter = adapter == null && dateFormat == null && numberFormat == null && johnzonConverter == null ?
                         defaultConverters.get(new AdapterKey(initialReader.getType(), String.class)) :
                         toConverter(initialReader.getType(), adapter, dateFormat, numberFormat);
             } catch (final InstantiationException | IllegalAccessException e) {
@@ -770,7 +777,12 @@ public class JsonbAccessMode implements AccessMode, Closeable {
                         instance.getValue().serialize(instance1, jsonbGenerator.getJsonGenerator(), new JohnzonSerializationContext(jsonbGenerator));
             } else if (johnzonConverter != null) {
                 try {
-                    writer = (ObjectConverter.Writer) johnzonConverter.value().newInstance();
+                    MapperConverter mapperConverter = johnzonConverter.value().newInstance();
+                    if (mapperConverter instanceof Converter) {
+                        converter = new ConverterAdapter<>((Converter) mapperConverter) ;
+                    } else if (mapperConverter instanceof ObjectConverter.Writer) {
+                        writer = (ObjectConverter.Writer) mapperConverter;
+                    }
                 } catch (final InstantiationException | IllegalAccessException e) {
                     throw new IllegalArgumentException(e);
                 }
diff --git a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JohnzonConverterInJsonbTest.java b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JohnzonConverterInJsonbTest.java
index 75023d3a..f9de06a1 100644
--- a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JohnzonConverterInJsonbTest.java
+++ b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JohnzonConverterInJsonbTest.java
@@ -16,17 +16,25 @@
  */
 package org.apache.johnzon.jsonb;
 
+import java.lang.reflect.Type;
 import java.time.Instant;
 import java.time.LocalDateTime;
 import java.time.ZoneId;
+import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
 
+import javax.json.JsonObject;
 import javax.json.bind.Jsonb;
 import javax.json.bind.spi.JsonbProvider;
 
 import org.apache.johnzon.mapper.Converter;
 import org.apache.johnzon.mapper.JohnzonConverter;
+import org.apache.johnzon.mapper.MappingGenerator;
+import org.apache.johnzon.mapper.MappingParser;
+import org.apache.johnzon.mapper.ObjectConverter;
 import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 /**
@@ -42,6 +50,53 @@ public class JohnzonConverterInJsonbTest {
         Jsonb jsonb = JsonbProvider.provider().create().build();
         String json = jsonb.toJson(dto);
         assertNotNull(json);
+
+        TestDTO deserialized = jsonb.fromJson(json, TestDTO.class);
+        assertEquals(dto.instant, deserialized.instant);
+    }
+
+    @Test
+    public void testObjectConverter() {
+        TestDTOWithOC dto = new TestDTOWithOC();
+        dto.dto = new TestDTO();
+        dto.dto.instant = Instant.now();
+
+        Jsonb jsonb = JsonbProvider.provider().create().build();
+        String json = jsonb.toJson(dto);
+        assertNotNull(json);
+
+        TestDTOWithOC deserialized = jsonb.fromJson(json, TestDTOWithOC.class);
+        assertEquals(deserialized.dto.instant, dto.dto.instant);
+    }
+
+    public static class TestDTOWithOC {
+        @JohnzonConverter(TestDTOConverter.class)
+        private TestDTO dto;
+
+        public TestDTO getDto() {
+            return dto;
+        }
+
+        public void setDto(TestDTO dto) {
+            this.dto = dto;
+        }
+    }
+
+    public static class TestDTOConverter implements ObjectConverter.Codec<TestDTO> {
+
+        private static final String TIMESTAMP_JSON_KEY = "timestamp";
+
+        @Override
+        public void writeJson(TestDTO instance, MappingGenerator jsonbGenerator) {
+            jsonbGenerator.getJsonGenerator().write(TIMESTAMP_JSON_KEY, instance.instant.atZone(ZoneId.of("UTC")).toString());
+        }
+
+        @Override
+        public TestDTO fromJson(JsonObject jsonObject, Type targetType, MappingParser parser) {
+            TestDTO dto = new TestDTO();
+            dto.instant = ZonedDateTime.parse(jsonObject.getString(TIMESTAMP_JSON_KEY)).toInstant();
+            return dto;
+        }
     }
 
     public static class TestDTO {
