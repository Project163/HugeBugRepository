diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/JDBCTableReader.java b/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/JDBCTableReader.java
index 5b10d9763..3e7cdbb60 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/JDBCTableReader.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/JDBCTableReader.java
@@ -17,6 +17,8 @@ package org.apache.tika.parser.jdbc;
  */
 
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+
 import java.io.ByteArrayInputStream;
 import java.io.IOException;
 import java.io.InputStream;
@@ -52,8 +54,6 @@ import org.xml.sax.ContentHandler;
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.AttributesImpl;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-
 /**
  * General base class to iterate through rows of a JDBC table
  */
@@ -112,7 +112,7 @@ class JDBCTableReader {
                 handleClob(tableName, rsmd.getColumnName(i), rows, results, i, handler, context);
                 break;
             case Types.BOOLEAN:
-                handleBoolean(results.getBoolean(i), handler);
+                handleBoolean(results, i, handler);
                 break;
             case Types.DATE:
                 handleDate(results, i, handler);
@@ -121,18 +121,27 @@ class JDBCTableReader {
                 handleTimeStamp(results, i, handler);
                 break;
             case Types.INTEGER:
-                handleInteger(rsmd.getColumnTypeName(i), results, i, handler);
+                handleInteger(results, i, handler);
                 break;
             case Types.FLOAT:
                 //this is necessary to handle rounding issues in presentation
                 //Should we just use getString(i)?
-                addAllCharacters(Float.toString(results.getFloat(i)), handler);
+                float f = results.getFloat(i);
+                if (! results.wasNull()) {
+                    addAllCharacters(Float.toString(f), handler);
+                }
                 break;
             case Types.DOUBLE:
-                addAllCharacters(Double.toString(results.getDouble(i)), handler);
+                double d = results.getDouble(i);
+                if (! results.wasNull()) {
+                    addAllCharacters(Double.toString(d), handler);
+                }
                 break;
             default:
-                addAllCharacters(results.getString(i), handler);
+                String s = results.getString(i);
+                if (!results.wasNull()) {
+                    addAllCharacters(s, handler);
+                }
                 break;
         }
     }
@@ -154,12 +163,18 @@ class JDBCTableReader {
         return headers;
     }
 
-    protected void handleInteger(String columnTypeName, ResultSet rs, int columnIndex, ContentHandler handler) throws SQLException, SAXException {
-        addAllCharacters(Integer.toString(rs.getInt(columnIndex)), handler);
+    protected void handleInteger(ResultSet rs, int columnIndex, ContentHandler handler) throws SQLException, SAXException {
+        int i = rs.getInt(columnIndex);
+        if (! rs.wasNull()) {
+            addAllCharacters(Integer.toString(i), handler);
+        }
     }
 
-    private void handleBoolean(boolean aBoolean, ContentHandler handler) throws SAXException {
-        addAllCharacters(Boolean.toString(aBoolean), handler);
+    private void handleBoolean(ResultSet rs, int columnIndex, ContentHandler handler) throws SAXException, SQLException {
+        boolean b = rs.getBoolean(columnIndex);
+        if (! rs.wasNull()) {
+            addAllCharacters(Boolean.toString(b), handler);
+        }
     }
 
 
@@ -167,6 +182,9 @@ class JDBCTableReader {
                               ResultSet resultSet, int columnIndex,
                               ContentHandler handler, ParseContext context) throws SQLException, IOException, SAXException {
         Clob clob = resultSet.getClob(columnIndex);
+        if (resultSet.wasNull()) {
+            return;
+        }
         boolean truncated = clob.length() > Integer.MAX_VALUE || clob.length() > maxClobLength;
 
         int readSize = (clob.length() < maxClobLength ? (int) clob.length() : maxClobLength);
@@ -201,8 +219,11 @@ class JDBCTableReader {
         InputStream is = null;
         EmbeddedDocumentExtractor ex = AbstractDBParser.getEmbeddedDocumentExtractor(context);
         try {
-            is = TikaInputStream.get(getInputStreamFromBlob(resultSet, columnIndex, blob, m));
-
+            blob = getBlob(resultSet, columnIndex, m);
+            if (blob == null) {
+                return;
+            }
+            is = TikaInputStream.get(blob, m);
             Attributes attrs = new AttributesImpl();
             ((AttributesImpl) attrs).addAttribute("", "type", "type", "CDATA", "blob");
             ((AttributesImpl) attrs).addAttribute("", "column_name", "column_name", "CDATA", columnName);
@@ -236,8 +257,20 @@ class JDBCTableReader {
         handler.endElement("", "span", "span");
     }
 
-    protected InputStream getInputStreamFromBlob(ResultSet resultSet, int columnIndex, Blob blob, Metadata metadata) throws SQLException {
-        return TikaInputStream.get(blob, metadata);
+    /**
+     *
+     * @param resultSet result set to grab value from
+     * @param columnIndex index in result set
+     * @param metadata metadata to populate or use for each implementation
+     * @return the blob or <code>null</code> if the value was null
+     * @throws SQLException
+     */
+    protected Blob getBlob(ResultSet resultSet, int columnIndex, Metadata metadata) throws SQLException {
+        Blob blob = resultSet.getBlob(columnIndex);
+        if (! resultSet.wasNull()) {
+            return blob;
+        }
+        return null;
     }
 
     protected void handleDate(ResultSet resultSet, int columnIndex, ContentHandler handler) throws SAXException, SQLException {
@@ -249,6 +282,9 @@ class JDBCTableReader {
     }
 
     protected void addAllCharacters(String s, ContentHandler handler) throws SAXException {
+        if (s == null) {
+            return;
+        }
         char[] chars = s.toCharArray();
         handler.characters(chars, 0, chars.length);
     }
diff --git a/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/SQLite3TableReader.java b/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/SQLite3TableReader.java
index 8671d098d..ae6cb139d 100644
--- a/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/SQLite3TableReader.java
+++ b/tika-parsers/src/main/java/org/apache/tika/parser/jdbc/SQLite3TableReader.java
@@ -16,17 +16,13 @@ package org.apache.tika.parser.jdbc;
  * limitations under the License.
  */
 
+import javax.sql.rowset.serial.SerialBlob;
 import java.io.IOException;
-import java.io.InputStream;
 import java.sql.Blob;
 import java.sql.Connection;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Locale;
 
-import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.parser.ParseContext;
 import org.xml.sax.ContentHandler;
@@ -37,17 +33,12 @@ import org.xml.sax.SAXException;
  * Concrete class for SQLLite table parsing.  This overrides
  * column type handling from JDBCRowHandler.
  * <p/>
- * This class is not designed to be thread safe (because of DateFormat)!
- * Need to call a new instance for each parse, as AbstractDBParser does.
- * <p/>
  * For now, this silently skips cells of type CLOB, because xerial's jdbc connector
  * does not currently support them.
  */
 class SQLite3TableReader extends JDBCTableReader {
 
 
-    DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd", Locale.ROOT);
-
     public SQLite3TableReader(Connection connection, String tableName, ParseContext context) {
         super(connection, tableName, context);
     }
@@ -74,36 +65,12 @@ class SQLite3TableReader extends JDBCTableReader {
         //no-op for now.
     }
 
-    /**
-     * The jdbc connection to Sqlite does not yet implement blob, have to getBytes().
-     *
-     * @param resultSet   resultSet
-     * @param columnIndex columnIndex for blob
-     * @return
-     * @throws java.sql.SQLException
-     */
     @Override
-    protected InputStream getInputStreamFromBlob(ResultSet resultSet, int columnIndex, Blob blob, Metadata m) throws SQLException {
-        return TikaInputStream.get(resultSet.getBytes(columnIndex), m);
-    }
-
-    @Override
-    protected void handleInteger(String columnTypeName, ResultSet rs, int columnIndex,
-                                 ContentHandler handler) throws SQLException, SAXException {
-        //As of this writing, with xerial's sqlite jdbc connector, a timestamp is
-        //stored as a column of type Integer, but the columnTypeName is TIMESTAMP, and the
-        //value is a string representing a Long.
-        if (columnTypeName.equals("TIMESTAMP")) {
-            addAllCharacters(parseDateFromLongString(rs.getString(columnIndex)), handler);
-        } else {
-            addAllCharacters(Integer.toString(rs.getInt(columnIndex)), handler);
+    protected Blob getBlob(ResultSet resultSet, int columnIndex, Metadata m) throws SQLException {
+        byte[] bytes = resultSet.getBytes(columnIndex);
+        if (!resultSet.wasNull()) {
+            return new SerialBlob(bytes);
         }
-
-    }
-
-    private String parseDateFromLongString(String longString) throws SAXException {
-        java.sql.Date d = new java.sql.Date(Long.parseLong(longString));
-        return dateFormat.format(d);
-
+        return null;
     }
 }
diff --git a/tika-parsers/src/test/java/org/apache/tika/parser/jdbc/SQLite3ParserTest.java b/tika-parsers/src/test/java/org/apache/tika/parser/jdbc/SQLite3ParserTest.java
index 7ea27fa06..4ba68e1a0 100644
--- a/tika-parsers/src/test/java/org/apache/tika/parser/jdbc/SQLite3ParserTest.java
+++ b/tika-parsers/src/test/java/org/apache/tika/parser/jdbc/SQLite3ParserTest.java
@@ -70,7 +70,7 @@ public class SQLite3ParserTest extends TikaTest {
             XMLResult result = getXML(stream, p, metadata);
             String x = result.xml;
             //first table name
-            assertContains("<table name=\"my_table1\"><thead><tr>\t<th>INT_COL</th>", x);
+            assertContains("<table name=\"my_table1\"><thead><tr>\t<th>PK</th>", x);
             //non-ascii
             assertContains("<td>普林斯顿大学</td>", x);
             //boolean
@@ -227,6 +227,12 @@ public class SQLite3ParserTest extends TikaTest {
         assertEquals(8, byteCopier.bytes.size());
     }
 
+    @Test
+    public void testNulls() throws Exception {
+        String xml = getXML(TEST_FILE_NAME).xml.replaceAll("\\s+", "");
+        //everything except for the first key column should be empty
+        assertContains("<tr><td>2</td><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr>", xml);
+    }
 
     public static class InputStreamResettingHandler implements EmbeddedResourceHandler {
 
@@ -274,12 +280,13 @@ public class SQLite3ParserTest extends TikaTest {
 
     @Test
     public void testCreateDB() throws Exception {
-        Connection c = getConnection("testSQLLite3b.db");
+        Connection c = getConnection("testSqlite3d.db");
         Statement st = c.createStatement();
         String sql = "DROP TABLE if exists my_table1";
         st.execute(sql);
         sql = "CREATE TABLE my_table1 (" +
-                "INT_COL INT PRIMARY KEY, "+
+                "PK INT PRIMARY KEY, "+
+                "INT_COL INTEGER, "+
                 "FLOAT_COL FLOAT, " +
                 "DOUBLE_COL DOUBLE, " +
                 "CHAR_COL CHAR(30), "+
@@ -287,12 +294,13 @@ public class SQLite3ParserTest extends TikaTest {
                 "BOOLEAN_COL BOOLEAN,"+
                 "DATE_COL DATE,"+
                 "TIME_STAMP_COL TIMESTAMP,"+
+                "CLOB_COL CLOB, "+
                 "BYTES_COL BYTES" +
         ")";
         st.execute(sql);
-        sql = "insert into my_table1 (INT_COL, FLOAT_COL, DOUBLE_COL, CHAR_COL, " +
-                "VARCHAR_COL, BOOLEAN_COL, DATE_COL, TIME_STAMP_COL, BYTES_COL) " +
-                "values (?,?,?,?,?,?,?,?,?)";
+        sql = "insert into my_table1 (PK, INT_COL, FLOAT_COL, DOUBLE_COL, CHAR_COL, " +
+                "VARCHAR_COL, BOOLEAN_COL, DATE_COL, TIME_STAMP_COL, CLOB_COL, BYTES_COL) " +
+                "values (?,?,?,?,?,?,?,?,?,?,?)";
         SimpleDateFormat f = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
         java.util.Date d = f.parse("2015-01-03 15:17:03");
         System.out.println(d.getTime());
@@ -300,29 +308,44 @@ public class SQLite3ParserTest extends TikaTest {
         long d2Long = 1420316223000L;// 2015-01-03 15:17:03
         PreparedStatement ps = c.prepareStatement(sql);
         ps.setInt(1, 0);
-        ps.setFloat(2, 2.3f);
-        ps.setDouble(3, 2.4d);
-        ps.setString(4, "lorem");
-        ps.setString(5, "普林斯顿大学");
-        ps.setBoolean(6, true);
-        ps.setString(7, "2015-01-02");
-        ps.setString(8, "2015-01-03 15:17:03");
-//        ps.setClob(9, new StringReader(clobString));
-        ps.setBytes(9, getByteArray(this.getClass().getResourceAsStream("/test-documents/testWORD_1img.doc")));//contains "quick brown fox"
+        ps.setInt(2, 10);
+        ps.setFloat(3, 2.3f);
+        ps.setDouble(4, 2.4d);
+        ps.setString(5, "lorem");
+        ps.setString(6, "普林斯顿大学");
+        ps.setBoolean(7, true);
+        ps.setString(8, "2015-01-02");
+        ps.setString(9, "2015-01-03 15:17:03");
+//        ps.setClob(10, new StringReader(sql));
+        ps.setBytes(10, getByteArray(this.getClass().getResourceAsStream("/test-documents/testWORD_1img.doc")));//contains "quick brown fox"
         ps.executeUpdate();
         ps.clearParameters();
 
         ps.setInt(1, 1);
-        ps.setFloat(2, 4.6f);
-        ps.setDouble(3, 4.8d);
-        ps.setString(4, "dolor");
-        ps.setString(5, "sit");
-        ps.setBoolean(6, false);
-        ps.setString(7, "2015-01-04");
-        ps.setString(8, "2015-01-03 15:17:03");
+        ps.setInt(2, 20);
+        ps.setFloat(3, 4.6f);
+        ps.setDouble(4, 4.8d);
+        ps.setString(5, "dolor");
+        ps.setString(6, "sit");
+        ps.setBoolean(7, false);
+        ps.setString(8, "2015-01-04");
+        ps.setString(9, "2015-01-03 15:17:03");
         //ps.setClob(9, new StringReader("consectetur adipiscing elit"));
-        ps.setBytes(9, getByteArray(this.getClass().getResourceAsStream("/test-documents/testWORD_1img.docx")));//contains "The end!"
+        ps.setBytes(10, getByteArray(this.getClass().getResourceAsStream("/test-documents/testWORD_1img.docx")));//contains "The end!"
 
+        ps.executeUpdate();
+        //now add a fully null row
+        ps.clearParameters();
+        ps.setInt(1, 2);
+        ps.setNull(2, Types.INTEGER);
+        ps.setNull(3, Types.FLOAT);
+        ps.setNull(4, Types.DOUBLE);
+        ps.setNull(5, Types.CHAR);
+        ps.setNull(6, Types.VARCHAR);
+        ps.setNull(7, Types.BOOLEAN);
+        ps.setNull(8, Types.DATE);
+        ps.setNull(9, Types.TIMESTAMP);
+        ps.setNull(10, Types.BLOB);
         ps.executeUpdate();
 
         //build table2
@@ -352,5 +375,4 @@ public class SQLite3ParserTest extends TikaTest {
 
 */
 
-
 }
diff --git a/tika-parsers/src/test/resources/test-documents/testSqlite3b.db b/tika-parsers/src/test/resources/test-documents/testSqlite3b.db
index fa933a316..735762b38 100644
Binary files a/tika-parsers/src/test/resources/test-documents/testSqlite3b.db and b/tika-parsers/src/test/resources/test-documents/testSqlite3b.db differ
