diff --git a/mailet/standard/src/main/java/org/apache/james/transport/mailets/ContactExtractor.java b/mailet/standard/src/main/java/org/apache/james/transport/mailets/ContactExtractor.java
index 6c8f23e313..c363f06e40 100644
--- a/mailet/standard/src/main/java/org/apache/james/transport/mailets/ContactExtractor.java
+++ b/mailet/standard/src/main/java/org/apache/james/transport/mailets/ContactExtractor.java
@@ -21,13 +21,19 @@ package org.apache.james.transport.mailets;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Optional;
+import java.util.function.Function;
+import java.util.stream.Stream;
 
 import javax.mail.Address;
+import javax.mail.Message;
+import javax.mail.Message.RecipientType;
 import javax.mail.MessagingException;
+import javax.mail.internet.InternetAddress;
 import javax.mail.internet.MimeMessage;
 
 import org.apache.james.core.MailAddress;
 import org.apache.james.mime4j.util.MimeUtil;
+import org.apache.james.util.StreamUtils;
 import org.apache.mailet.Mail;
 import org.apache.mailet.Mailet;
 import org.apache.mailet.MailetException;
@@ -95,26 +101,45 @@ public class ContactExtractor extends GenericMailet implements Mailet {
         }
     }
 
-    private Optional<String> extractContacts(Mail mail) throws MessagingException, IOException {
-        MimeMessage message = mail.getMessage();
+    @VisibleForTesting
+    Optional<String> extractContacts(Mail mail) throws MessagingException, IOException {
+        ImmutableList<String> allRecipients = getAllRecipients(mail.getMessage());
 
-        return Optional.of(mail.getSender())
-            .map(MailAddress::asString)
-            .filter(Throwing.predicate(sender -> hasRecipients(message)))
-            .map(Throwing.function(sender -> new ExtractedContacts(sender, recipients(message))))
-            .map(Throwing.function(extractedContacts -> objectMapper.writeValueAsString(extractedContacts)));
+        if (hasRecipient(allRecipients)) {
+            return Optional.of(mail.getSender())
+                .map(MailAddress::asString)
+                .map(sender -> new ExtractedContacts(sender, allRecipients))
+                .map(Throwing.function(extractedContacts -> objectMapper.writeValueAsString(extractedContacts)));
+        }
+
+        return Optional.empty();
+    }
+
+    private boolean hasRecipient(ImmutableList<String> allRecipients) {
+        return !allRecipients.isEmpty();
     }
 
-    @VisibleForTesting boolean hasRecipients(MimeMessage mimeMessage) throws MessagingException {
-        return mimeMessage.getAllRecipients() != null 
-                && mimeMessage.getAllRecipients().length > 0;
+    private ImmutableList<String> getAllRecipients(MimeMessage mimeMessage) throws MessagingException {
+        return StreamUtils
+            .flatten(
+                getRecipients(mimeMessage, Message.RecipientType.TO),
+                getRecipients(mimeMessage, Message.RecipientType.CC),
+                getRecipients(mimeMessage, Message.RecipientType.BCC))
+            .collect(Guavate.toImmutableList());
     }
 
-    private ImmutableList<String> recipients(MimeMessage mimeMessage) throws MessagingException {
-        return Arrays.stream(mimeMessage.getAllRecipients())
-                .map(Address::toString)
-                .map(MimeUtil::unscrambleHeaderValue)
-                .collect(Guavate.toImmutableList());
+    private Stream<String> getRecipients(MimeMessage mimeMessage, RecipientType recipientType) throws MessagingException {
+        boolean notStrict = false;
+        Function<String, InternetAddress[]> parseRecipient =
+            Throwing
+                .function((String header) -> InternetAddress.parseHeader(header, notStrict))
+                .sneakyThrow();
+        return Optional.ofNullable(mimeMessage.getHeader(recipientType.toString(), ","))
+            .map(parseRecipient)
+            .map(Arrays::stream)
+            .orElse(Stream.empty())
+            .map(Address::toString)
+            .map(MimeUtil::unscrambleHeaderValue);
     }
 
     public static class ExtractedContacts {
diff --git a/mailet/standard/src/test/java/org/apache/james/transport/mailets/ContactExtractorTest.java b/mailet/standard/src/test/java/org/apache/james/transport/mailets/ContactExtractorTest.java
index ccde3d6d87..7546025cbc 100644
--- a/mailet/standard/src/test/java/org/apache/james/transport/mailets/ContactExtractorTest.java
+++ b/mailet/standard/src/test/java/org/apache/james/transport/mailets/ContactExtractorTest.java
@@ -161,6 +161,66 @@ public class ContactExtractorTest {
         assertThatJson(mail.getAttribute(ATTRIBUTE).toString()).isEqualTo(expectedMessage);
     }
 
+    @Test
+    public void serviceShouldUnscrambleRecipientsWhenNameContainsSuperiors() throws Exception {
+        String rawMessage = "From: sender@example.com\r\n"
+            + "To: =?UTF-8?Q?recip_>>_Fr=c3=a9d=c3=a9ric_RECIPIENT?= <frecipient@example.com>\r\n"
+            + "Subject: extract this recipient please\r\n"
+            + "\r\n"
+            + "Please!";
+        MimeMessage message = MimeMessageBuilder.mimeMessageFromBytes(rawMessage.getBytes());
+        FakeMail mail = FakeMail.builder().mimeMessage(message)
+            .sender(new MailAddress(SENDER))
+            .recipient(new MailAddress("frecipient@example.com"))
+            .build();
+        mailet.init(mailetConfig);
+
+        String expectedMessage = "{\"userEmail\" : \"" + SENDER + "\", \"emails\" : [ \"\\\"recip >> Frédéric RECIPIENT\\\" <frecipient@example.com>\" ]}";
+        mailet.service(mail);
+
+        assertThatJson(mail.getAttribute(ATTRIBUTE).toString()).isEqualTo(expectedMessage);
+    }
+
+    @Test
+    public void serviceShouldParseMultipleRecipients() throws Exception {
+        String rawMessage = "From: sender@example.com\r\n"
+            + "To: User 1 <user1@example.com>, =?UTF-8?Q?recip_>>_Fr=c3=a9d=c3=a9ric_RECIPIENT?= <frecipient@example.com>\r\n"
+            + "Subject: extract this recipient please\r\n"
+            + "\r\n"
+            + "Please!";
+        MimeMessage message = MimeMessageBuilder.mimeMessageFromBytes(rawMessage.getBytes());
+        FakeMail mail = FakeMail.builder().mimeMessage(message)
+            .sender(new MailAddress(SENDER))
+            .recipient(new MailAddress("frecipient@example.com"))
+            .build();
+        mailet.init(mailetConfig);
+
+        String expectedMessage = "{\"userEmail\" : \"" + SENDER + "\", \"emails\" : [ \"User 1 <user1@example.com>\", \"\\\"recip >> Frédéric RECIPIENT\\\" <frecipient@example.com>\" ]}";
+        mailet.service(mail);
+
+        assertThatJson(mail.getAttribute(ATTRIBUTE).toString()).isEqualTo(expectedMessage);
+    }
+
+    @Test
+    public void serviceShouldParseRecipientWithCommaInName() throws Exception {
+        String rawMessage = "From: sender@example.com\r\n"
+            + "To: \"User, the first one\" <user1@example.com>\r\n"
+            + "Subject: extract this recipient please\r\n"
+            + "\r\n"
+            + "Please!";
+        MimeMessage message = MimeMessageBuilder.mimeMessageFromBytes(rawMessage.getBytes());
+        FakeMail mail = FakeMail.builder().mimeMessage(message)
+            .sender(new MailAddress(SENDER))
+            .recipient(new MailAddress("frecipient@example.com"))
+            .build();
+        mailet.init(mailetConfig);
+
+        String expectedMessage = "{\"userEmail\" : \"" + SENDER + "\", \"emails\" : [ \"\\\"User, the first one\\\" <user1@example.com>\" ]}";
+        mailet.service(mail);
+
+        assertThatJson(mail.getAttribute(ATTRIBUTE).toString()).isEqualTo(expectedMessage);
+    }
+
     @Test
     public void serviceShouldNotOverwriteSenderWhenDifferentFromField() throws Exception {
         MimeMessage message = MimeMessageBuilder.mimeMessageBuilder()
@@ -236,15 +296,16 @@ public class ContactExtractorTest {
     }
 
     @Test
-    public void hasRecipientsShouldNotThrowWhenNoRecipient() throws Exception {
+    public void extractContactsShouldNotThrowWhenNoRecipient() throws Exception {
         MimeMessage message = MimeMessageBuilder.mimeMessageBuilder()
                 .setSender(SENDER)
                 .setSubject("Contact collection Rocks")
                 .setText("This is my email")
                 .build();
+        FakeMail mail = FakeMail.builder().mimeMessage(message)
+            .sender(new MailAddress(SENDER))
+            .build();
 
-        boolean hasRecipients = mailet.hasRecipients(message);
-
-        assertThat(hasRecipients).isFalse();
+        mailet.extractContacts(mail);
     }
 }
\ No newline at end of file
