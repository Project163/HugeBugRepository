diff --git a/src/test/java/org/apache/sling/discovery/commons/providers/base/DummyScheduler.java b/src/test/java/org/apache/sling/discovery/commons/providers/base/DummyScheduler.java
index 405db7b..4ca4b3f 100644
--- a/src/test/java/org/apache/sling/discovery/commons/providers/base/DummyScheduler.java
+++ b/src/test/java/org/apache/sling/discovery/commons/providers/base/DummyScheduler.java
@@ -28,6 +28,50 @@ import org.apache.sling.commons.scheduler.Scheduler;
 
 public class DummyScheduler implements Scheduler {
 
+    class DummyScheduleOptions implements ScheduleOptions {
+
+        private String name;
+        private Map<String, Serializable> config;
+        private Date date;
+
+        @Override
+        public ScheduleOptions config(Map<String, Serializable> config) {
+            this.config = config;
+            return this;
+        }
+
+        @Override
+        public ScheduleOptions name(String name) {
+            this.name = name;
+            return this;
+        }
+
+        @Override
+        public ScheduleOptions canRunConcurrently(boolean flag) {
+            return this;
+        }
+
+        @Override
+        public ScheduleOptions onLeaderOnly(boolean flag) {
+            return this;
+        }
+
+        @Override
+        public ScheduleOptions onSingleInstanceOnly(boolean flag) {
+            return this;
+        }
+
+        @Override
+        public ScheduleOptions onInstancesOnly(String[] slingIds) {
+            return this;
+        }
+
+        public ScheduleOptions date(Date date) {
+            this.date = date;
+            return this;
+        }
+    }
+
     private boolean failMode;
 
     @Override
@@ -109,7 +153,13 @@ public class DummyScheduler implements Scheduler {
 
     @Override
     public boolean schedule(Object job, ScheduleOptions options) {
-        throw new IllegalStateException("not yet impl");
+        DummyScheduleOptions dOptions = (DummyScheduleOptions) options;
+        try {
+            fireJobAt(dOptions.name, job, dOptions.config, dOptions.date);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+        return true;
     }
 
     @Override
@@ -119,7 +169,7 @@ public class DummyScheduler implements Scheduler {
 
     @Override
     public ScheduleOptions NOW() {
-        throw new IllegalStateException("not yet impl");
+        return new DummyScheduleOptions().date(new Date());
     }
 
     @Override
@@ -129,7 +179,7 @@ public class DummyScheduler implements Scheduler {
 
     @Override
     public ScheduleOptions AT(Date date) {
-        throw new IllegalStateException("not yet impl");
+        return new DummyScheduleOptions().date(date);
     }
 
     @Override
diff --git a/src/test/java/org/apache/sling/discovery/commons/providers/base/TestOakViewStateManager.java b/src/test/java/org/apache/sling/discovery/commons/providers/base/TestOakViewStateManager.java
index aae7ec4..4619413 100644
--- a/src/test/java/org/apache/sling/discovery/commons/providers/base/TestOakViewStateManager.java
+++ b/src/test/java/org/apache/sling/discovery/commons/providers/base/TestOakViewStateManager.java
@@ -23,12 +23,14 @@ import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.util.UUID;
+import java.util.concurrent.Callable;
 import java.util.concurrent.locks.ReentrantLock;
 
 import org.apache.jackrabbit.oak.plugins.memory.MemoryNodeStore;
 import org.apache.log4j.Level;
 import org.apache.log4j.spi.RootLogger;
 import org.apache.sling.api.resource.ResourceResolverFactory;
+import org.apache.sling.commons.scheduler.Scheduler;
 import org.apache.sling.discovery.DiscoveryService;
 import org.apache.sling.discovery.TopologyEvent;
 import org.apache.sling.discovery.TopologyView;
@@ -50,7 +52,7 @@ import org.junit.Test;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class TestOakViewStateManager {
+public class TestOakViewStateManager implements DiscoveryService {
 
     protected static final Logger logger = LoggerFactory.getLogger(TestOakViewStateManager.class);
 
@@ -68,6 +70,10 @@ public class TestOakViewStateManager {
     private IdMapService idMapService1;
     private String slingId1;
 
+    private Scheduler scheduler;
+
+    private TopologyView view;
+
     @Before
     public void setup() throws Exception {
         logger.info("setup: start");
@@ -96,6 +102,7 @@ public class TestOakViewStateManager {
         slingId1 = UUID.randomUUID().toString();
         idMapService1 = IdMapService.testConstructor(new SimpleCommonsConfig(), new DummySlingSettingsService(slingId1),
                 factory1);
+        scheduler = new DummyScheduler();
         logger.info("setup: end");
     }
 
@@ -147,24 +154,17 @@ public class TestOakViewStateManager {
 
     @Test
     public void testSyncServiceDelayOnFirstView_withEventDelaying() throws Exception {
-        mgr.installMinEventDelayHandler(new DiscoveryService() {
-
-            @Override
-            public TopologyView getTopology() {
-                throw new IllegalStateException("not yet impl");
-            }
-        }, null, 1);
         doTestSyncServiceDelayOnFirstView(true);
     }
 
     private void doTestSyncServiceDelayOnFirstView(boolean minEventDelayHandler) throws InterruptedException {
         final DummyListener listener = new DummyListener();
-        mgr.bind(listener);
 
         final String slingId1 = UUID.randomUUID().toString();
         final String slingId2 = UUID.randomUUID().toString();
         final String slingId3 = UUID.randomUUID().toString();
         final String clusterId = UUID.randomUUID().toString();
+        final DummyTopologyView view0 = new DummyTopologyView().addInstance(slingId1, new DefaultClusterView(clusterId), true, true);
         final DefaultClusterView cluster = new DefaultClusterView(clusterId);
         final DummyTopologyView view1 = new DummyTopologyView().addInstance(slingId1, cluster, true, true)
                 .addInstance(slingId2, cluster, false, false).addInstance(slingId3, cluster, false, false);
@@ -178,10 +178,31 @@ public class TestOakViewStateManager {
 
         try {
             mgr = new ViewStateManagerImpl(new ReentrantLock(), chain);
+            mgr.bind(listener);
+            if (minEventDelayHandler) {
+                mgr.installMinEventDelayHandler(this, scheduler, 1);
+            }
             logger.info("testSyncServiceDelayOnFirstView: start");
             mgr.handleActivated();
-            logger.info("testSyncServiceDelayOnFirstView: first call to handleNewView");
+            s1.setCheckResult(true);
+            s2.setCheckResult(true);
+            this.view = view0;
+            mgr.handleNewView(view0);
+            assertTrue(waitForCondition(new Callable<Boolean>() {
+
+                @Override
+                public Boolean call() throws Exception {
+                    return listener.countEvents() == 1;
+                }
+
+            }, 5000));
+            logger.info("testSyncServiceDelayOnFirstView: second call to handleNewView");
+            s1.setCheckResult(false);
+            s2.setCheckResult(false);
+            s1.resetCounter();
+            s2.resetCounter();
             s1.setCheckSemaphoreSetPermits(2);
+            this.view = view1;
             mgr.handleNewView(view1);
             // waiting for at least 2 calls to check()
             // first is synchronous, second in the background
@@ -230,4 +251,33 @@ public class TestOakViewStateManager {
         }
     }
 
+    private boolean waitForCondition(Callable<Boolean> condition, long timeoutMillis) {
+        if (timeoutMillis < 0) {
+            throw new IllegalArgumentException("timeoutMillis must be 0 or positive, is: " + timeoutMillis);
+        }
+        final long timeout = System.currentTimeMillis() + timeoutMillis;
+        try {
+            while (!condition.call()) {
+                final long delta = Math.min(10, timeout - System.currentTimeMillis());
+                if (delta <= 0) {
+                    // timeout
+                    break;
+                } else {
+                    try {
+                        Thread.sleep(delta);
+                    } catch (InterruptedException e) {
+                        e.printStackTrace();
+                    }
+                }
+            }
+            return condition.call();
+        } catch (Exception e) {
+            throw new AssertionError("Got Exception: " + e, e);
+        }
+    }
+
+    @Override
+    public TopologyView getTopology() {
+        return view;
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/DummyClusterSyncService.java b/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/DummyClusterSyncService.java
index a1eed7b..c79ada0 100644
--- a/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/DummyClusterSyncService.java
+++ b/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/DummyClusterSyncService.java
@@ -125,6 +125,10 @@ public class DummyClusterSyncService extends AbstractServiceWithBackgroundCheck
         }, timeoutMillis);
     }
 
+    public void resetCounter() {
+        checkCounter.set(0);
+    }
+
     public long getCheckCounter() {
         return checkCounter.get();
     }
diff --git a/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/TestClusterSyncServiceChain.java b/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/TestClusterSyncServiceChain.java
index be0fd57..761c85f 100644
--- a/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/TestClusterSyncServiceChain.java
+++ b/src/test/java/org/apache/sling/discovery/commons/providers/spi/base/TestClusterSyncServiceChain.java
@@ -1,3 +1,21 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
 package org.apache.sling.discovery.commons.providers.spi.base;
 
 import static org.junit.Assert.assertEquals;
