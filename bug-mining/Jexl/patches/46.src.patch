diff --git a/src/main/java/org/apache/commons/jexl3/JexlBuilder.java b/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
index 6c9a97b8..0f2cb31f 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlBuilder.java
@@ -16,12 +16,16 @@
  */
 package org.apache.commons.jexl3;
 
-import java.nio.charset.Charset;
+
 import org.apache.commons.jexl3.internal.Engine;
-import java.util.Map;
-import org.apache.commons.jexl3.introspection.JexlUberspect;
 import org.apache.commons.jexl3.introspection.JexlSandbox;
-import org.apache.commons.logging.Log;
+import org.apache.commons.jexl3.introspection.JexlUberspect;
+
+import org.apache.log4j.Logger;
+
+import java.util.Map;
+
+import java.nio.charset.Charset;
 
 /**
  * Configure and builds a JexlEngine.
@@ -69,7 +73,7 @@ public class JexlBuilder {
     /**
      * The Log to which all JexlEngine messages will be logged.
      */
-    protected Log logger = null;
+    protected Logger logger = null;
     /**
      * Whether expressions evaluated by this engine will throw exceptions (false) or
      * return null (true) on errors. Default is false.
@@ -158,13 +162,13 @@ public class JexlBuilder {
      * @param l the logger
      * @return this builder
      */
-    public JexlBuilder logger(Log l) {
+    public JexlBuilder logger(Logger l) {
         this.logger = l;
         return this;
     }
 
     /** @return the logger */
-    public Log logger() {
+    public Logger logger() {
         return this.logger;
     }
 
diff --git a/src/main/java/org/apache/commons/jexl3/JexlContext.java b/src/main/java/org/apache/commons/jexl3/JexlContext.java
index 39ab75cb..138f1ff9 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlContext.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlContext.java
@@ -82,4 +82,33 @@ public interface JexlContext {
          */
         Object resolveNamespace(String name);
     }
+
+    /**
+     * Namespace type that allows creating an instance to delegate namespace methods calls to.
+     * <p>The functor is created once during the lifetime of a script evaluation.</p>
+     */
+    public interface NamespaceFunctor {
+        /**
+         * Creates the functor object that will be used instead of the namespace.
+         * @param context the context
+         * @return the namespace functor instance
+         */
+        Object createFunctor(JexlContext context);
+    }
+
+    /**
+     * A marker interface that indicates the interpreter to put this context in the JexlEngine thread local context
+     * instance during evaluation.
+     * This allows user functions or methods to access the context during a call.
+     * Note that the usual caveats wrt using thread local apply (caching/leaking references, etc.); in particular, keeping
+     * a reference to such a context is to be considered with great care and caution.
+     * It should also be noted that sharing such a context between threads should implicate synchronizing variable access
+     * in the implementation class.
+     * @see JexlEngine#setThreadContext()
+     * @see JexlEngine#getThreadContext()
+     */
+    public interface ThreadLocal extends JexlContext {
+        // no specific method
+    }
+
 }
diff --git a/src/main/java/org/apache/commons/jexl3/JexlEngine.java b/src/main/java/org/apache/commons/jexl3/JexlEngine.java
index d704cad1..243b07ca 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlEngine.java
@@ -44,6 +44,35 @@ import java.nio.charset.Charset;
  * @since 2.0
  */
 public abstract class JexlEngine {
+    /**
+     * The thread local context.
+     */
+    protected static final java.lang.ThreadLocal<JexlContext.ThreadLocal> CONTEXT =
+            new java.lang.ThreadLocal<JexlContext.ThreadLocal>() {
+                @Override
+                protected JexlContext.ThreadLocal initialValue() {
+                    return null;
+                }
+            };
+
+    /**
+     * Accesses the current thread local context.
+     * @return the context or null
+     */
+    public static JexlContext.ThreadLocal getThreadContext() {
+        return CONTEXT.get();
+    }
+
+    /**
+     * Sets the current thread local context.
+     * <p>This should only be used carefully, for instance when re-evaluating a "stored" script that requires a
+     * given Namespace resolver. Remember to synchronize access if context is shared between threads.
+     * @param tls the thread local context to set
+     */
+    public static void setThreadContext(JexlContext.ThreadLocal tls) {
+        CONTEXT.set(tls);
+    }
+
     /**
      * Script evaluation options.
      * <p>The JexlContext used for evaluation can implement this interface to alter behavior.</p>
@@ -168,17 +197,27 @@ public abstract class JexlEngine {
      * @return a Jexl Template engine
      */
     public JxltEngine createJxltEngine() {
-        return createJxltEngine(JXLT_CACHE_SIZE, '$', '#');
+        return createJxltEngine(true);
+    }
+
+    /**
+     * Creates a new {@link JxltEngine} instance using this engine.
+     * @param noScript  whether the JxltEngine only allows Jexl expressions or scripts
+     * @return a Jexl Template engine
+     */
+    public JxltEngine createJxltEngine(boolean noScript) {
+        return createJxltEngine(noScript, JXLT_CACHE_SIZE, '$', '#');
     }
 
     /**
      * Creates a new instance of {@link JxltEngine} using this engine.
+     * @param noScript  whether the JxltEngine only allows Jexl expressions or scripts
      * @param cacheSize the number of expressions in this cache, default is 256
      * @param immediate the immediate template expression character, default is '$'
      * @param deferred  the deferred template expression character, default is '#'
      * @return a Jexl Template engine
      */
-    public abstract JxltEngine createJxltEngine(int cacheSize, char immediate, char deferred);
+    public abstract JxltEngine createJxltEngine(boolean noScript, int cacheSize, char immediate, char deferred);
 
     /**
      * Clears the expression cache.
diff --git a/src/main/java/org/apache/commons/jexl3/JexlException.java b/src/main/java/org/apache/commons/jexl3/JexlException.java
index d8dad3f1..3faaa771 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlException.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlException.java
@@ -38,7 +38,7 @@ public class JexlException extends RuntimeException {
     /** The debug info. */
     private final transient JexlInfo info;
     /** Maximum number of characters around exception location. */
-    private static final int MAX_EXCHARLOC = 32;
+    private static final int MAX_EXCHARLOC = 42;
 
     /**
      * Creates a new JexlException.
@@ -83,6 +83,17 @@ public class JexlException extends RuntimeException {
      * @return the information
      */
     public JexlInfo getInfo() {
+        if (info != null && mark != null) {
+            final Debugger dbg = new Debugger();
+            if (dbg.debug(mark)) {
+                return new JexlInfo(info) {
+                    @Override
+                    public JexlInfo.Detail getDetail() {
+                        return dbg;
+                    }
+                };
+            }
+        }
         return info;
     }
 
@@ -343,7 +354,7 @@ public class JexlException extends RuntimeException {
 
         @Override
         protected String detailedMessage() {
-            return "inaccessible or unknown property " + getProperty();
+            return "unsolvable property '" + getProperty() + "'";
         }
     }
 
@@ -381,7 +392,7 @@ public class JexlException extends RuntimeException {
 
         @Override
         protected String detailedMessage() {
-            return "unknown, ambiguous or inaccessible method " + getMethod();
+            return "unsolvable function/method '" + getMethod() + "'";
         }
     }
 
@@ -441,19 +452,7 @@ public class JexlException extends RuntimeException {
         if (info != null) {
             msg.append(info.toString());
         } else {
-            msg.append('?');
-        }
-        if (mark != null) {
-            Debugger dbg = new Debugger();
-            if (dbg.debug(mark)) {
-                msg.append("![");
-                msg.append(dbg.start());
-                msg.append(",");
-                msg.append(dbg.end());
-                msg.append("]: '");
-                msg.append(dbg.toString());
-                msg.append("'");
-            }
+            msg.append("?:");
         }
         msg.append(' ');
         msg.append(detailedMessage());
diff --git a/src/main/java/org/apache/commons/jexl3/JexlExpression.java b/src/main/java/org/apache/commons/jexl3/JexlExpression.java
index 2f543eac..09567765 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlExpression.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlExpression.java
@@ -28,6 +28,7 @@ package org.apache.commons.jexl3;
  * <p>
  * An expression is different than a script - it is simply a reference to
  * a single expression, not to multiple statements.
+ * This implies 'if','for','while','var' and blocks '{'... '}'are NOT allowed in expressions.
  * </p>
  *
  * @since 1.0
diff --git a/src/main/java/org/apache/commons/jexl3/JexlInfo.java b/src/main/java/org/apache/commons/jexl3/JexlInfo.java
index 320ac45f..66c225d0 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlInfo.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlInfo.java
@@ -29,6 +29,26 @@ public class JexlInfo {
     /** name. */
     protected final String name;
 
+    /**
+     * @return the detailed information in case of an error
+     */
+    public Detail getDetail() {
+        return null;
+    }
+
+    /**
+     * Describes errors more precicely.
+     */
+    public static interface Detail {
+        /** The start column on the line that triggered the error. */
+        int start();
+        /** The end column on the line that triggered the error. */
+        int end();
+        /** The actual part of code that triggered the error. */
+        @Override
+        String toString();
+    }
+
     /**
      * Create info.
      * @param source source name
@@ -41,6 +61,12 @@ public class JexlInfo {
         column = c;
     }
 
+    protected JexlInfo(JexlInfo copy) {
+        name = copy.getName();
+        line = copy.getLine();
+        column = copy.getColumn();
+    }
+
     /**
      * Formats this info in the form 'name&#064line:column'.
      * @return the formatted info
@@ -56,6 +82,16 @@ public class JexlInfo {
                 sb.append(column);
             }
         }
+        JexlInfo.Detail dbg = getDetail();
+        if (dbg!= null) {
+            sb.append("![");
+            sb.append(dbg.start());
+            sb.append(",");
+            sb.append(dbg.end());
+            sb.append("]: '");
+            sb.append(dbg.toString());
+            sb.append("'");
+        }
         return sb.toString();
     }
 
diff --git a/src/main/java/org/apache/commons/jexl3/JexlScript.java b/src/main/java/org/apache/commons/jexl3/JexlScript.java
index e0fe26aa..7388855f 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlScript.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlScript.java
@@ -30,7 +30,19 @@ import java.util.concurrent.Callable;
  *
  * @since 1.1
  */
-public interface JexlScript extends JexlExpression {
+public interface JexlScript {
+     /**
+     * Returns the source text of this expression.
+     * @return the source text
+     */
+    String getSourceText();
+
+    /**
+     * Recreates the source text of this expression from the internal synactic tree.
+     * @return the source text
+     */
+    String getParsedText();
+    
     /**
      * Executes the script with the variables contained in the
      * supplied {@link JexlContext}.
diff --git a/src/main/java/org/apache/commons/jexl3/JxltEngine.java b/src/main/java/org/apache/commons/jexl3/JxltEngine.java
index 591c1fca..24fbfec4 100644
--- a/src/main/java/org/apache/commons/jexl3/JxltEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/JxltEngine.java
@@ -277,6 +277,15 @@ public abstract class JxltEngine {
          * @return the prepared version of the template
          */
         Template prepare(JexlContext context);
+
+        /**
+         * Gets the list of variables accessed by this expression.
+         * <p>This method will visit all nodes of the sub-expressions and extract all variables whether they
+         * are written in 'dot' or 'bracketed' notation. (a.b is equivalent to a['b']).</p>
+         * @return the set of variables, each as a list of strings (ant-ish variables use more than 1 string)
+         * or the empty set if no variables are used
+         */
+        Set<List<String>> getVariables();
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java b/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java
index 580e861c..5375b5d7 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java
@@ -17,17 +17,41 @@
 package org.apache.commons.jexl3.internal;
 
 import java.lang.reflect.Array;
-import java.lang.reflect.Field;
 import org.apache.commons.jexl3.JexlArithmetic;
+import org.apache.commons.jexl3.internal.introspection.MethodKey;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Helper class to create typed arrays.
  */
 public class ArrayBuilder implements JexlArithmetic.ArrayBuilder {
+    /** The boxing types to primitive conversion map. */
+    private static final int PRIMITIVE_SIZE = 8;
+    private static final Map<Class<?>, Class<?>> BOXING_CLASSES;
+    static {
+        BOXING_CLASSES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);
+        BOXING_CLASSES.put(Boolean.class, Boolean.TYPE);
+        BOXING_CLASSES.put(Byte.class, Byte.TYPE);
+        BOXING_CLASSES.put(Character.class, Character.TYPE);
+        BOXING_CLASSES.put(Double.class, Double.TYPE);
+        BOXING_CLASSES.put(Float.class, Float.TYPE);
+        BOXING_CLASSES.put(Integer.class, Integer.TYPE);
+        BOXING_CLASSES.put(Long.class, Long.TYPE);
+        BOXING_CLASSES.put(Short.class, Short.TYPE);
+    }
+
+    private static Class<?> unboxingClass(Class<?> parm) {
+        Class<?> prim = BOXING_CLASSES.get(parm);
+        return prim == null ? parm : prim;
+    }
+
     /** The intended class array. */
     private Class<?> commonClass = null;
     /** Whether the array stores numbers. */
     private boolean isNumber = true;
+    /** Whether we can try unboxing. */
+    private boolean unboxing = true;
     /** The untyped list of items being added. */
     private final Object[] untyped;
     /** Number of added items. */
@@ -47,6 +71,7 @@ public class ArrayBuilder implements JexlArithmetic.ArrayBuilder {
         if (!Object.class.equals(commonClass)) {
             if (value == null) {
                 isNumber = false;
+                unboxing = false;
             } else {
                 Class<?> eclass = value.getClass();
                 // base common class on first non-null entry
@@ -83,13 +108,8 @@ public class ArrayBuilder implements JexlArithmetic.ArrayBuilder {
             // convert untyped array to the common class if not Object.class
             if (commonClass != null && !Object.class.equals(commonClass)) {
                 // if the commonClass is a number, it has an equivalent primitive type, get it
-                if (isNumber) {
-                    try {
-                        final Field type = commonClass.getField("TYPE");
-                        commonClass = (Class<?>) type.get(null);
-                    } catch (Exception xany) {
-                        // ignore
-                    }
+                if (unboxing) {
+                    commonClass = unboxingClass(commonClass);
                 }
                 // allocate and fill up the typed array
                 Object typed = Array.newInstance(commonClass, size);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Closure.java b/src/main/java/org/apache/commons/jexl3/internal/Closure.java
index c05ad19e..6cbf51a2 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Closure.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Closure.java
@@ -62,10 +62,11 @@ public class Closure extends Script {
 
     @Override
     public Object execute(JexlContext context, Object... args) {
+        Scope.Frame callFrame = null;
         if (frame != null) {
-            frame.assign(args);
+            callFrame = frame.assign(args);
         }
-        Interpreter interpreter = jexl.createInterpreter(context, frame);
+        Interpreter interpreter = jexl.createInterpreter(context, callFrame);
         interpreter.functors = functors;
         JexlNode block = script.jjtGetChild(script.jjtGetNumChildren() - 1);
         return interpreter.interpret(block);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Debugger.java b/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
index ce023af8..da1dbcfe 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
@@ -16,7 +16,9 @@
  */
 package org.apache.commons.jexl3.internal;
 
+
 import org.apache.commons.jexl3.JexlExpression;
+import org.apache.commons.jexl3.JexlInfo;
 import org.apache.commons.jexl3.JexlScript;
 import org.apache.commons.jexl3.parser.ASTAddNode;
 import org.apache.commons.jexl3.parser.ASTAndNode;
@@ -33,6 +35,7 @@ import org.apache.commons.jexl3.parser.ASTConstructorNode;
 import org.apache.commons.jexl3.parser.ASTDivNode;
 import org.apache.commons.jexl3.parser.ASTEQNode;
 import org.apache.commons.jexl3.parser.ASTERNode;
+import org.apache.commons.jexl3.parser.ASTEWNode;
 import org.apache.commons.jexl3.parser.ASTEmptyFunction;
 import org.apache.commons.jexl3.parser.ASTEmptyMethod;
 import org.apache.commons.jexl3.parser.ASTFalseNode;
@@ -53,9 +56,9 @@ import org.apache.commons.jexl3.parser.ASTMethodNode;
 import org.apache.commons.jexl3.parser.ASTModNode;
 import org.apache.commons.jexl3.parser.ASTMulNode;
 import org.apache.commons.jexl3.parser.ASTNENode;
+import org.apache.commons.jexl3.parser.ASTNEWNode;
 import org.apache.commons.jexl3.parser.ASTNRNode;
-import org.apache.commons.jexl3.parser.ASTEWNode;
-import org.apache.commons.jexl3.parser.ASTSWNode;
+import org.apache.commons.jexl3.parser.ASTNSWNode;
 import org.apache.commons.jexl3.parser.ASTNotNode;
 import org.apache.commons.jexl3.parser.ASTNullLiteral;
 import org.apache.commons.jexl3.parser.ASTNumberLiteral;
@@ -64,6 +67,7 @@ import org.apache.commons.jexl3.parser.ASTRangeNode;
 import org.apache.commons.jexl3.parser.ASTReference;
 import org.apache.commons.jexl3.parser.ASTReferenceExpression;
 import org.apache.commons.jexl3.parser.ASTReturnStatement;
+import org.apache.commons.jexl3.parser.ASTSWNode;
 import org.apache.commons.jexl3.parser.ASTSizeFunction;
 import org.apache.commons.jexl3.parser.ASTSizeMethod;
 import org.apache.commons.jexl3.parser.ASTStringLiteral;
@@ -77,8 +81,6 @@ import org.apache.commons.jexl3.parser.JexlNode;
 import org.apache.commons.jexl3.parser.ParserVisitor;
 
 import java.util.regex.Pattern;
-import org.apache.commons.jexl3.parser.ASTNEWNode;
-import org.apache.commons.jexl3.parser.ASTNSWNode;
 
 /**
  * Helps pinpoint the cause of problems in expressions that fail during evaluation.
@@ -88,7 +90,7 @@ import org.apache.commons.jexl3.parser.ASTNSWNode;
  * </p>
  * @since 2.0
  */
-public final class Debugger extends ParserVisitor {
+public final class Debugger extends ParserVisitor implements JexlInfo.Detail {
     /** The builder to compose messages. */
     private final StringBuilder builder = new StringBuilder();
     /** The cause of the issue to debug. */
@@ -187,6 +189,7 @@ public final class Debugger extends ParserVisitor {
     /**
      * @return The starting offset location of the cause in the expression
      */
+    @Override
     public int start() {
         return start;
     }
@@ -194,6 +197,7 @@ public final class Debugger extends ParserVisitor {
     /**
      * @return The end offset location of the cause in the expression
      */
+    @Override
     public int end() {
         return end;
     }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Engine.java b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
index cc6df7ee..8dbb08c9 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Engine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
@@ -37,8 +37,8 @@ import org.apache.commons.jexl3.parser.ASTMethodNode;
 import org.apache.commons.jexl3.parser.JexlNode;
 import org.apache.commons.jexl3.parser.Parser;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
 
 import java.io.StringReader;
 import java.util.ArrayList;
@@ -68,7 +68,7 @@ public class Engine extends JexlEngine {
     private static final class UberspectHolder {
         /** The default uberspector that handles all introspection patterns. */
         private static final Uberspect UBERSPECT =
-                new Uberspect(LogFactory.getLog(JexlEngine.class));
+                new Uberspect(LogManager.getLogger(JexlEngine.class));
 
         /** Non-instantiable. */
         private UberspectHolder() {
@@ -85,7 +85,7 @@ public class Engine extends JexlEngine {
     /**
      * The Log to which all JexlEngine messages will be logged.
      */
-    protected final Log logger;
+    protected final Logger logger;
     /**
      * The {@link Parser}; when parsing expressions, this engine synchronizes on the parser.
      */
@@ -147,7 +147,7 @@ public class Engine extends JexlEngine {
         } else {
             this.uberspect = new SandboxUberspect(uber, sandbox);
         }
-        this.logger = conf.logger() == null ? LogFactory.getLog(JexlEngine.class) : conf.logger();
+        this.logger = conf.logger() == null ? LogManager.getLogger(JexlEngine.class) : conf.logger();
         this.functions = conf.namespaces() == null ? Collections.<String, Object>emptyMap() : conf.namespaces();
         this.silent = conf.silent() == null ? false : conf.silent().booleanValue();
         this.debug = conf.debug() == null ? true : conf.debug().booleanValue();
@@ -167,8 +167,8 @@ public class Engine extends JexlEngine {
      * @param logger the logger to use for the underlying Uberspect
      * @return Uberspect the default uberspector instance.
      */
-    public static Uberspect getUberspect(Log logger) {
-        if (logger == null || logger.equals(LogFactory.getLog(JexlEngine.class))) {
+    public static Uberspect getUberspect(Logger logger) {
+        if (logger == null || logger.equals(LogManager.getLogger(JexlEngine.class))) {
             return UberspectHolder.UBERSPECT;
         }
         return new Uberspect(logger);
@@ -210,8 +210,19 @@ public class Engine extends JexlEngine {
     }
 
     @Override
-    public TemplateEngine createJxltEngine(int cacheSize, char immediate, char deferred) {
-        return new TemplateEngine(this, cacheSize, immediate, deferred);
+    public TemplateEngine createJxltEngine(boolean noScript, int cacheSize, char immediate, char deferred) {
+        return new TemplateEngine(this, noScript, cacheSize, immediate, deferred);
+    }
+
+    /**
+     * Swaps the current thread local context.
+     * @param tls the context or null
+     * @return the previous thread local context
+     */
+    protected JexlContext.ThreadLocal putThreadLocal(JexlContext.ThreadLocal tls) {
+        JexlContext.ThreadLocal local = CONTEXT.get();
+        CONTEXT.set(tls);
+        return local;
     }
 
     /**
@@ -336,7 +347,7 @@ public class Engine extends JexlEngine {
         }
         String source = trimSource(scriptText);
         Scope scope = names == null ? null : new Scope(null, names);
-        ASTJexlScript tree = parse(info, source, scope, false);
+        ASTJexlScript tree = parse(info, source, scope, false, false);
         return new Script(this, source, tree);
     }
 
@@ -349,11 +360,7 @@ public class Engine extends JexlEngine {
             info = createInfo();
         }
         String source = trimSource(expression);
-        ASTJexlScript tree = parse(info, source, null, false);
-        if (tree.toExpression()) {
-            logger.warn("The JEXL Expression created will be a reference"
-                    + " to the first expression from the supplied script: \"" + expression + "\" ");
-        }
+        ASTJexlScript tree = parse(info, source, null, false, true);
         return new Script(this, source, tree);
     }
 
@@ -369,11 +376,11 @@ public class Engine extends JexlEngine {
         }
         // synthetize expr using register
         String src = trimSource(expr);
-        src = "#0" + (src.charAt(0) == '[' ? "" : ".") + src + ";";
+        src = "#0" + (src.charAt(0) == '[' ? "" : ".") + src;
         try {
             final JexlInfo info = debug ? createInfo() : null;
             final Scope scope = new Scope(null, "#0");
-            final ASTJexlScript script = parse(info, src, scope, true);
+            final ASTJexlScript script = parse(info, src, scope, true, true);
             final JexlNode node = script.jjtGetChild(0);
             final Scope.Frame frame = script.createFrame(bean);
             final Interpreter interpreter = createInterpreter(context, frame);
@@ -399,11 +406,11 @@ public class Engine extends JexlEngine {
         }
         // synthetize expr using registers
         String src = trimSource(expr);
-        src = "#0" + (src.charAt(0) == '[' ? "" : ".") + src + "=" + "#1" + ";";
+        src = "#0" + (src.charAt(0) == '[' ? "" : ".") + src + "=" + "#1";
         try {
             final JexlInfo info = debug ? createInfo() : null;
             final Scope scope = new Scope(null, "#0", "#1");
-            final ASTJexlScript script = parse(info, src, scope, true);
+            final ASTJexlScript script = parse(info, src, scope, true, true);
             final JexlNode node = script.jjtGetChild(0);
             final Scope.Frame frame = script.createFrame(bean, value);
             final Interpreter interpreter = createInterpreter(context, frame);
@@ -583,6 +590,12 @@ public class Engine extends JexlEngine {
                 collector.collect(null);
             }
         } else if (node instanceof ASTIdentifierAccess) {
+            JexlNode parent = node.jjtGetParent();
+            if (parent instanceof ASTMethodNode || parent instanceof ASTFunctionNode) {
+                // skip identifiers for methods and functions
+                collector.collect(null);
+                return;
+            }
             // belt and suspender since an identifier should have been seen first
             if (collector.isCollecting()) {
                 collector.add(((ASTIdentifierAccess) node).getName());
@@ -638,18 +651,19 @@ public class Engine extends JexlEngine {
      * Parses an expression.
      *
      * @param info      information structure
-     * @param expr      the expression to parse
+     * @param src      the expression to parse
      * @param scope     the script frame
      * @param registers whether the parser should allow the unnamed '#number' syntax for 'registers'
+     * @param expression whether the parser allows scripts or only expressions
      * @return the parsed tree
      * @throws JexlException if any error occured during parsing
      */
-    protected ASTJexlScript parse(JexlInfo info, String expr, Scope scope, boolean registers) {
-        final boolean cached = expr.length() < cacheThreshold && cache != null;
+    protected ASTJexlScript parse(JexlInfo info, String src, Scope scope, boolean registers, boolean expression) {
+        final boolean cached = src.length() < cacheThreshold && cache != null;
         ASTJexlScript script;
         synchronized (parser) {
             if (cached) {
-                script = cache.get(expr);
+                script = cache.get(src);
                 if (script != null) {
                     Scope f = script.getScope();
                     if ((f == null && scope == null) || (f != null && f.equals(scope))) {
@@ -657,9 +671,9 @@ public class Engine extends JexlEngine {
                     }
                 }
             }
-            script = parser.parse(info, expr, scope, registers);
+            script = parser.parse(info, src, scope, registers, expression);
             if (cached) {
-                cache.put(expr, script);
+                cache.put(src, script);
             }
         }
         return script;
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index f312843b..ed62f6ce 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -16,7 +16,6 @@
  */
 package org.apache.commons.jexl3.internal;
 
-
 import org.apache.commons.jexl3.JexlArithmetic;
 import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlEngine;
@@ -87,7 +86,7 @@ import org.apache.commons.jexl3.parser.JexlNode;
 import org.apache.commons.jexl3.parser.Node;
 import org.apache.commons.jexl3.parser.ParserVisitor;
 
-import org.apache.commons.logging.Log;
+import org.apache.log4j.Logger;
 
 import java.lang.reflect.Array;
 import java.lang.reflect.InvocationTargetException;
@@ -96,7 +95,6 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.Set;
 
 /**
  * An interpreter of JEXL syntax.
@@ -107,7 +105,7 @@ public class Interpreter extends ParserVisitor {
     /** The JEXL engine. */
     protected final Engine jexl;
     /** The logger. */
-    protected final Log logger;
+    protected final Logger logger;
     /** The uberspect. */
     protected final JexlUberspect uberspect;
     /** The arithmetic handler. */
@@ -171,14 +169,19 @@ public class Interpreter extends ParserVisitor {
     }
 
     /**
-     * Interpret the given script/expression. <p> If the underlying JEXL engine is silent, errors will be logged through
-     * its logger as info. </p>
+     * Interpret the given script/expression.
+     * <p> If the underlying JEXL engine is silent, errors will be logged through
+     * its logger as warning.
      * @param node the script or expression to interpret.
      * @return the result of the interpretation.
      * @throws JexlException if any error occurs during interpretation.
      */
     public Object interpret(JexlNode node) {
+        JexlContext.ThreadLocal local = null;
         try {
+            if (context instanceof JexlContext.ThreadLocal) {
+                local = jexl.putThreadLocal((JexlContext.ThreadLocal) context);
+            }
             return node.jjtAccept(this, null);
         } catch (JexlException.Return xreturn) {
             Object value = xreturn.getValue();
@@ -190,10 +193,36 @@ public class Interpreter extends ParserVisitor {
             }
             throw xjexl.clean();
         } finally {
+            if (functors != null && AUTOCLOSEABLE != null ) {
+                for(Object functor : functors.values()) {
+                   if (functor != null && AUTOCLOSEABLE.isAssignableFrom(functor.getClass())) {
+                       try {
+                            jexl.invokeMethod(functor, "close", EMPTY_PARAMS);
+                       } catch(Exception xclose) {
+                            logger.warn(xclose.getMessage(), xclose.getCause());
+                       }
+                   }
+                }
+            }
             functors = null;
+            if (context instanceof JexlContext.ThreadLocal) {
+                jexl.putThreadLocal(local);
+            }
         }
     }
 
+    /** Java7 AutoCloseable interface defined?. */
+    private static final Class<?> AUTOCLOSEABLE;
+    static {
+        Class<?> c;
+        try {
+          c = Class.forName("java.lang.AutoCloseable");
+        } catch(ClassNotFoundException xclass) {
+          c = null;
+        }
+        AUTOCLOSEABLE = c;
+    }
+
     /**
      * Finds the node causing a NPE for diadic operators.
      * @param xrt   the RuntimeException
@@ -271,7 +300,7 @@ public class Interpreter extends ParserVisitor {
                 return namespace;
             }
         }
-        // check if namespace if a resolver
+        // check if namespace is a resolver
         namespace = ns.resolveNamespace(prefix);
         if (namespace == null) {
             namespace = functions.get(prefix);
@@ -279,23 +308,31 @@ public class Interpreter extends ParserVisitor {
                 throw new JexlException(node, "no such function namespace " + prefix, null);
             }
         }
-        // allow namespace to be instantiated as functor with context if possible, not an error otherwise
-        if (namespace instanceof Class<?>) {
+        // allow namespace to instantiate a functor with context if possible, not an error otherwise
+        Object functor = null;
+        if (namespace instanceof JexlContext.NamespaceFunctor) {
+            functor = ((JexlContext.NamespaceFunctor) namespace).createFunctor(context);
+        } else if (namespace instanceof Class<?>) {
             Object[] args = new Object[]{context};
             JexlMethod ctor = uberspect.getConstructor(namespace, args);
             if (ctor != null) {
                 try {
-                    namespace = ctor.invoke(namespace, args);
-                    if (functors == null) {
-                        functors = new HashMap<String, Object>();
-                    }
-                    functors.put(prefix, namespace);
+                    functor = ctor.invoke(namespace, args);
                 } catch (Exception xinst) {
                     throw new JexlException(node, "unable to instantiate namespace " + prefix, xinst);
                 }
             }
         }
-        return namespace;
+        // got a functor, store it and return it
+        if (functor != null) {
+            if (functors == null) {
+                functors = new HashMap<String, Object>();
+            }
+            functors.put(prefix, functor);
+            return functor;
+        } else {
+            return namespace;
+        }
     }
 
     @Override
@@ -507,10 +544,10 @@ public class Interpreter extends ParserVisitor {
 
     /**
      * The 'startsWith' operator implementation.
-     * @param node  the node
-     * @param operator    the calling operator, $= or $!
-     * @param left  the left operand
-     * @param right the right operand
+     * @param node     the node
+     * @param operator the calling operator, $= or $!
+     * @param left     the left operand
+     * @param right    the right operand
      * @return true if left starts with right, false otherwise
      */
     protected boolean startsWith(JexlNode node, String operator, Object left, Object right) {
@@ -550,23 +587,23 @@ public class Interpreter extends ParserVisitor {
     protected Object visit(ASTSWNode node, Object data) {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
-        return startsWith(node, "^=", left, right)? Boolean.TRUE : Boolean.FALSE;
+        return startsWith(node, "^=", left, right) ? Boolean.TRUE : Boolean.FALSE;
     }
 
     @Override
     protected Object visit(ASTNSWNode node, Object data) {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
-        return startsWith(node, "^!", left, right)? Boolean.FALSE : Boolean.TRUE;
+        return startsWith(node, "^!", left, right) ? Boolean.FALSE : Boolean.TRUE;
     }
 
     /**
      * The 'endsWith' operator implementation.
-     * @param node      the node
-     * @param operator  the calling operator, ^= or ^!
-     * @param left      the left operand
-     * @param right     the right operand
-     * @return true     if left ends with right, false otherwise
+     * @param node     the node
+     * @param operator the calling operator, ^= or ^!
+     * @param left     the left operand
+     * @param right    the right operand
+     * @return true if left ends with right, false otherwise
      */
     protected boolean endsWith(JexlNode node, String operator, Object left, Object right) {
         try {
@@ -630,10 +667,6 @@ public class Interpreter extends ParserVisitor {
                 return arithmetic.matches(left, right);
             }
             // left in right ? <=> right.contains(left) ?
-            // try contains on collection
-            if (right instanceof Set<?>) {
-                return ((Set<?>) right).contains(left);
-            }
             // try contains on map key
             if (right instanceof Map<?, ?>) {
                 return ((Map<?, ?>) right).containsKey(left);
@@ -665,7 +698,7 @@ public class Interpreter extends ParserVisitor {
                 while (it.hasNext()) {
                     Object next = it.next();
                     if (next == left || (next != null && next.equals(left))) {
-                        return Boolean.TRUE;
+                        return true;
                     }
                 }
                 return false;
@@ -972,7 +1005,7 @@ public class Interpreter extends ParserVisitor {
             return "".equals(object) ? Boolean.TRUE : Boolean.FALSE;
         }
         if (object.getClass().isArray()) {
-            return Array.getLength(object) == 0? Boolean.TRUE : Boolean.FALSE;
+            return Array.getLength(object) == 0 ? Boolean.TRUE : Boolean.FALSE;
         }
         if (object instanceof Collection<?>) {
             return ((Collection<?>) object).isEmpty() ? Boolean.TRUE : Boolean.FALSE;
@@ -1035,7 +1068,7 @@ public class Interpreter extends ParserVisitor {
 
     @Override
     protected Object visit(ASTJexlScript node, Object data) {
-        if (node instanceof ASTJexlLambda) {
+        if (node instanceof ASTJexlLambda && !((ASTJexlLambda) node).isTopLevel()) {
             return new Closure(this, (ASTJexlLambda) node);
         } else {
             final int numChildren = node.jjtGetNumChildren();
@@ -1379,9 +1412,7 @@ public class Interpreter extends ParserVisitor {
         if (functor instanceof ASTIdentifier) {
             ASTIdentifier methodIdentifier = (ASTIdentifier) functor;
             symbol = methodIdentifier.getSymbol();
-            if (symbol < 0) {
-                methodName = methodIdentifier.getName();
-            }
+            methodName = methodIdentifier.getName();
             functor = null;
         } else if (functor instanceof ASTIdentifierAccess) {
             methodName = ((ASTIdentifierAccess) functor).getName();
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Scope.java b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
index 690fc0a0..27ffba10 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Scope.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
@@ -288,7 +288,9 @@ public final class Scope {
          */
         public Frame assign(Object... values) {
             if (stack != null && values != null && values.length > 0) {
-                System.arraycopy(values, 0, stack, 0, Math.min(stack.length, values.length));
+                Object[] copy = stack.clone();
+                System.arraycopy(values, 0, copy, 0, Math.min(copy.length, values.length));
+                return new Frame(copy);
             }
             return this;
         }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Script.java b/src/main/java/org/apache/commons/jexl3/internal/Script.java
index ea3366e0..d7738ee8 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Script.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Script.java
@@ -18,6 +18,7 @@ package org.apache.commons.jexl3.internal;
 
 import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlScript;
+import org.apache.commons.jexl3.JexlExpression;
 import org.apache.commons.jexl3.parser.ASTJexlScript;
 
 import java.util.List;
@@ -28,7 +29,7 @@ import java.util.concurrent.Callable;
  * <p>A JexlScript implementation.</p>
  * @since 1.1
  */
-public class Script implements JexlScript {
+public class Script implements JexlScript, JexlExpression {
     /**
      * The engine for this expression.
      */
diff --git a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
index 81194396..7a05bb39 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
@@ -20,6 +20,7 @@ import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.JexlException;
 import org.apache.commons.jexl3.JxltEngine;
+import org.apache.commons.jexl3.internal.Engine.VarCollector;
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.introspection.JexlUberspect;
 import org.apache.commons.jexl3.parser.ASTJexlScript;
@@ -34,6 +35,7 @@ import java.io.Writer;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
@@ -50,19 +52,23 @@ public final class TemplateEngine extends JxltEngine {
     private final char immediateChar;
     /** The first character for deferred expressions. */
     private final char deferredChar;
+    /** Whether expressions can use Jexl script or only expressions (ie, no for, var, etc). */
+    private boolean noscript = true;
 
     /**
      * Creates a new instance of {@link JxltEngine} creating a local cache.
      * @param aJexl     the JexlEngine to use.
+     * @param noScript  whether this engine only allows Jexl expressions or scripts
      * @param cacheSize the number of expressions in this cache, default is 256
      * @param immediate the immediate template expression character, default is '$'
      * @param deferred  the deferred template expression character, default is '#'
      */
-    public TemplateEngine(Engine aJexl, int cacheSize, char immediate, char deferred) {
+    public TemplateEngine(Engine aJexl, boolean noScript, int cacheSize, char immediate, char deferred) {
         this.jexl = aJexl;
         this.cache = aJexl.new SoftCache<String, TemplateExpression>(cacheSize);
         immediateChar = immediate;
         deferredChar = deferred;
+        noscript = noScript;
     }
 
     /**
@@ -481,7 +487,7 @@ public final class TemplateEngine extends JxltEngine {
         @Override
         protected TemplateExpression prepare(Interpreter interpreter) {
             String value = interpreter.interpret(node).toString();
-            JexlNode dnode = jexl.parse(jexl.isDebug() ? node.jexlInfo() : null, value, null, false);
+            JexlNode dnode = jexl.parse(jexl.isDebug() ? node.jexlInfo() : null, value, null, false, noscript);
             return new ImmediateExpression(value, dnode, this);
         }
 
@@ -539,6 +545,17 @@ public final class TemplateEngine extends JxltEngine {
             return collector.collected();
         }
 
+        /**
+         * Fills up the list of variables accessed by this unified expression.
+         * @param collector the variable collector
+         */
+        @Override
+        protected void getVariables(Engine.VarCollector collector) {
+            for (TemplateExpression expr : exprs) {
+                expr.getVariables(collector);
+            }
+        }
+
         @Override
         protected TemplateExpression prepare(Interpreter interpreter) {
             // if this composite is not its own source, it is already prepared
@@ -667,7 +684,7 @@ public final class TemplateEngine extends JxltEngine {
         ExpressionBuilder builder = new ExpressionBuilder(0);
         StringBuilder strb = new StringBuilder(size);
         ParseState state = ParseState.CONST;
-        int inner = 0;
+        int inner1 = 0;
         boolean nested = false;
         int inested = -1;
         for (int i = 0; i < size; ++i) {
@@ -726,7 +743,7 @@ public final class TemplateEngine extends JxltEngine {
                         String src = strb.toString();
                         TemplateExpression iexpr = new ImmediateExpression(
                                 src,
-                                jexl.parse(null, src, scope, false),
+                                jexl.parse(null, src, scope, false, noscript),
                                 null);
                         builder.add(iexpr);
                         strb.delete(0, Integer.MAX_VALUE);
@@ -746,7 +763,7 @@ public final class TemplateEngine extends JxltEngine {
                     // nested immediate in deferred; need to balance count of '{' & '}'
                     if (c == '{') {
                         if (expr.charAt(i - 1) == immediateChar) {
-                            inner += 1;
+                            inner1 += 1;
                             strb.deleteCharAt(strb.length() - 1);
                             nested = true;
                         }
@@ -755,8 +772,8 @@ public final class TemplateEngine extends JxltEngine {
                     // closing '}'
                     if (c == '}') {
                         // balance nested immediate
-                        if (inner > 0) {
-                            inner -= 1;
+                        if (inner1 > 0) {
+                            inner1 -= 1;
                         } else {
                             // materialize the nested/deferred expr
                             String src = strb.toString();
@@ -764,12 +781,12 @@ public final class TemplateEngine extends JxltEngine {
                             if (nested) {
                                 dexpr = new NestedExpression(
                                         expr.substring(inested, i + 1),
-                                        jexl.parse(null, src, scope, false),
+                                        jexl.parse(null, src, scope, false, noscript),
                                         null);
                             } else {
                                 dexpr = new DeferredExpression(
                                         strb.toString(),
-                                        jexl.parse(null, src, scope, false),
+                                        jexl.parse(null, src, scope, false, noscript),
                                         null);
                             }
                             builder.add(dexpr);
@@ -822,7 +839,7 @@ public final class TemplateEngine extends JxltEngine {
     private static final class Block {
         /** The type of block, verbatim or directive. */
         private final BlockType type;
-        /** The actual contexnt. */
+        /** The actual content. */
         private final String body;
 
         /**
@@ -837,7 +854,25 @@ public final class TemplateEngine extends JxltEngine {
 
         @Override
         public String toString() {
-            return body;
+            if (BlockType.VERBATIM.equals(type)) {
+                return body;
+            } else {
+                StringBuilder strb = new StringBuilder(64);
+                toString(strb, "$$");
+                return strb.toString();
+            }
+        }
+
+        protected void toString(StringBuilder strb, String prefix) {
+            if (BlockType.VERBATIM.equals(type)) {
+                strb.append(body);
+            } else {
+                Iterator<CharSequence> lines = readLines(new StringReader(body));
+                while (lines.hasNext()) {
+                    strb.append(prefix);
+                    strb.append(lines.next());
+                }
+            }
         }
     }
 
@@ -897,8 +932,8 @@ public final class TemplateEngine extends JxltEngine {
                     strb.append(block.body);
                 }
             }
-            // createExpression the script
-            script = jexl.parse(null, strb.toString(), scope, false);
+            // create the script
+            script = jexl.parse(null, strb.toString(), scope, false, false);
             scope = script.getScope();
             // createExpression the exprs using the code frame for those appearing after the first block of code
             for (int b = 0; b < blocks.size(); ++b) {
@@ -930,11 +965,7 @@ public final class TemplateEngine extends JxltEngine {
         public String toString() {
             StringBuilder strb = new StringBuilder();
             for (Block block : source) {
-                if (block.type == BlockType.DIRECTIVE) {
-                    strb.append(prefix);
-                }
-                strb.append(block.toString());
-                strb.append('\n');
+                block.toString(strb, prefix);
             }
             return strb.toString();
         }
@@ -977,6 +1008,22 @@ public final class TemplateEngine extends JxltEngine {
             Interpreter interpreter = jexl.createInterpreter(tcontext, frame);
             interpreter.interpret(script);
         }
+
+        /**
+         * Gets the list of variables accessed by this template.
+         * <p>This method will visit all nodes of the sub-expressions and extract all variables whether they
+         * are written in 'dot' or 'bracketed' notation. (a.b is equivalent to a['b']).</p>
+         * @return the set of variables, each as a list of strings (ant-ish variables use more than 1 string)
+         *         or the empty set if no variables are used
+         */
+        @Override
+        public Set<List<String>> getVariables() {
+            VarCollector collector = new VarCollector();
+            for (TemplateExpression expr : exprs) {
+                expr.getVariables(collector);
+            }
+            return collector.collected();
+        }
     }
 
     /**
@@ -1141,6 +1188,61 @@ public final class TemplateEngine extends JxltEngine {
         return -1;
     }
 
+    /**
+     * Read lines from a (buffered / mark-able) reader keeping all new-lines and line-feeds.
+     * @param reader the reader
+     * @return the line iterator
+     */
+    protected static Iterator<CharSequence> readLines(final Reader reader) {
+        if (!reader.markSupported()) {
+            throw new IllegalArgumentException("mark support in reader required");
+        }
+        return new Iterator<CharSequence>() {
+            CharSequence next = doNext();
+
+            private CharSequence doNext() {
+                StringBuffer strb = new StringBuffer(64);
+                int c;
+                boolean eol = false;
+                try {
+                    while ((c = reader.read()) >= 0) {
+                        if (eol && (c != '\n' && c != '\r')) {
+                            reader.reset();
+                            break;
+                        }
+                        if (c == '\n') {
+                            eol = true;
+                        }
+                        strb.append((char) c);
+                        reader.mark(1);
+                    }
+                } catch (IOException xio) {
+                    return null;
+                }
+                return strb.length() > 0 ? strb : null;
+            }
+
+            @Override
+            public boolean hasNext() {
+                return next != null;
+            }
+
+            @Override
+            public CharSequence next() {
+                CharSequence current = next;
+                if (current != null) {
+                    next = doNext();
+                }
+                return current;
+            }
+
+            @Override
+            public void remove() {
+                throw new UnsupportedOperationException("Not supported.");
+            }
+        };
+    }
+
     /**
      * Reads lines of a template grouping them by typed blocks.
      * @param prefix the directive prefix
@@ -1148,66 +1250,65 @@ public final class TemplateEngine extends JxltEngine {
      * @return the list of blocks
      */
     protected List<Block> readTemplate(final String prefix, Reader source) {
-        try {
-            int prefixLen;
-            List<Block> blocks = new ArrayList<Block>();
-            BufferedReader reader;
-            if (source instanceof BufferedReader) {
-                reader = (BufferedReader) source;
-            } else {
-                reader = new BufferedReader(source);
-            }
-            StringBuilder strb = new StringBuilder();
-            BlockType type = null;
-            while (true) {
-                CharSequence line = reader.readLine();
-                if (line == null) {
-                    // at end
-                    Block block = new Block(type, strb.toString());
-                    blocks.add(block);
-                    break;
-                } else if (type == null) {
-                    // determine starting type if not known yet
-                    prefixLen = startsWith(line, prefix);
-                    if (prefixLen >= 0) {
-                        type = BlockType.DIRECTIVE;
-                        strb.append(line.subSequence(prefixLen, line.length()));
-                    } else {
-                        type = BlockType.VERBATIM;
-                        strb.append(line.subSequence(0, line.length()));
-                        strb.append('\n');
-                    }
-                } else if (type == BlockType.DIRECTIVE) {
-                    // switch to verbatim if necessary
-                    prefixLen = startsWith(line, prefix);
-                    if (prefixLen < 0) {
-                        Block code = new Block(BlockType.DIRECTIVE, strb.toString());
-                        strb.delete(0, Integer.MAX_VALUE);
-                        blocks.add(code);
-                        type = BlockType.VERBATIM;
-                        strb.append(line.subSequence(0, line.length()));
-                    } else {
-                        strb.append(line.subSequence(prefixLen, line.length()));
-                    }
-                } else if (type == BlockType.VERBATIM) {
-                    // switch to code if necessary(
-                    prefixLen = startsWith(line, prefix);
-                    if (prefixLen >= 0) {
-                        strb.append('\n');
-                        Block verbatim = new Block(BlockType.VERBATIM, strb.toString());
-                        strb.delete(0, Integer.MAX_VALUE);
-                        blocks.add(verbatim);
-                        type = BlockType.DIRECTIVE;
-                        strb.append(line.subSequence(prefixLen, line.length()));
-                    } else {
-                        strb.append(line.subSequence(0, line.length()));
-                    }
+        final ArrayList<Block> blocks = new ArrayList<Block>();
+        final BufferedReader reader;
+        if (source instanceof BufferedReader) {
+            reader = (BufferedReader) source;
+        } else {
+            reader = new BufferedReader(source);
+        }
+        final StringBuilder strb = new StringBuilder();
+        BlockType type = null;
+        int prefixLen;
+        Iterator<CharSequence> lines = readLines(reader);
+        while (lines.hasNext()) {
+            CharSequence line = lines.next();
+            if (line == null) {
+                break;
+            } else if (type == null) {
+                // determine starting type if not known yet
+                prefixLen = startsWith(line, prefix);
+                if (prefixLen >= 0) {
+                    type = BlockType.DIRECTIVE;
+                    strb.append(line.subSequence(prefixLen, line.length()));
+                } else {
+                    type = BlockType.VERBATIM;
+                    strb.append(line.subSequence(0, line.length()));
+                }
+            } else if (type == BlockType.DIRECTIVE) {
+                // switch to verbatim if necessary
+                prefixLen = startsWith(line, prefix);
+                if (prefixLen < 0) {
+                    Block directive = new Block(BlockType.DIRECTIVE, strb.toString());
+                    strb.delete(0, Integer.MAX_VALUE);
+                    blocks.add(directive);
+                    type = BlockType.VERBATIM;
+                    strb.append(line.subSequence(0, line.length()));
+                } else {
+                    // still a directive
+                    strb.append(line.subSequence(prefixLen, line.length()));
+                }
+            } else if (type == BlockType.VERBATIM) {
+                // switch to directive if necessary
+                prefixLen = startsWith(line, prefix);
+                if (prefixLen >= 0) {
+                    Block verbatim = new Block(BlockType.VERBATIM, strb.toString());
+                    strb.delete(0, Integer.MAX_VALUE);
+                    blocks.add(verbatim);
+                    type = BlockType.DIRECTIVE;
+                    strb.append(line.subSequence(prefixLen, line.length()));
+                } else {
+                    strb.append(line.subSequence(0, line.length()));
                 }
             }
-            return blocks;
-        } catch (IOException xio) {
-            return null;
         }
+        // input may be null
+        if (type != null && strb.length() > 0) {
+            Block block = new Block(type, strb.toString());
+            blocks.add(block);
+        }
+        blocks.trimToSize();
+        return blocks;
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
index a345bcc9..0b1e1721 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
@@ -52,22 +52,12 @@ abstract class AbstractExecutor {
     }
 
     /**
-     * Coerce an Object  to an Integer.
+     * Coerce an Object which must be a number to an Integer.
      * @param arg the Object to coerce
      * @return an Integer if it can be converted, null otherwise
      */
-    static Integer toInteger(Object arg) {
-        if (arg == null) {
-            return null;
-        } else if (arg instanceof Number) {
-            return Integer.valueOf(((Number) arg).intValue());
-        } else {
-            try {
-                return Integer.valueOf(arg.toString());
-            } catch (NumberFormatException xnumber) {
-                return null;
-            }
-        }
+    static Integer castInteger(Object arg) {
+        return arg instanceof Number? Integer.valueOf(((Number) arg).intValue()) : null;
     }
 
     /**
@@ -75,8 +65,8 @@ abstract class AbstractExecutor {
      * @param arg the Object to coerce
      * @return a String if it can be converted, null otherwise
      */
-    static String toString(Object arg) {
-        return arg == null ? null : arg.toString();
+    static String castString(Object arg) {
+        return arg instanceof CharSequence || arg instanceof Integer ? arg.toString() : null;
     }
 
     /**
@@ -87,7 +77,7 @@ abstract class AbstractExecutor {
     static Object[] makeArgs(Object... args) {
         return args;
     }
-    
+
     /** The class this executor applies to. */
     protected final Class<?> objectClass;
     /** Method to be executed. */
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ArrayIterator.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ArrayIterator.java
index fb68cfad..e5a461d9 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ArrayIterator.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ArrayIterator.java
@@ -71,12 +71,12 @@ public class ArrayIterator implements Iterator<Object> {
     public Object next() {
         if (pos < size) {
             return Array.get(array, pos++);
-        }    
+        }
         // we screwed up...
         throw new NoSuchElementException("No more elements: " + pos
                                          + " / " + size);
     }
-    
+
     /**
      * Check to see if there is another element in the array.
      *
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/BooleanGetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/BooleanGetExecutor.java
index cd00e842..370097b2 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/BooleanGetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/BooleanGetExecutor.java
@@ -24,11 +24,11 @@ import java.lang.reflect.InvocationTargetException;
 public final class BooleanGetExecutor extends AbstractExecutor.Get {
     /** The property. */
     private final String property;
-    
+
     /**
      * Discovers a BooleanGetExecutor.
      * <p>The method to be found should be named "is{P,p}property and return a boolean.</p>
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
      * @param property the the property name
@@ -42,7 +42,7 @@ public final class BooleanGetExecutor extends AbstractExecutor.Get {
             return null;
         }
     }
-    
+
     /**
      * Creates an instance by attempting discovery of the get method.
      * @param clazz the class to introspect
@@ -63,7 +63,7 @@ public final class BooleanGetExecutor extends AbstractExecutor.Get {
     public Object invoke(Object obj) throws IllegalAccessException, InvocationTargetException {
         return method == null ? null : method.invoke(obj, (Object[]) null);
     }
-    
+
     @Override
     public Object tryInvoke(Object obj, Object key) {
         if (obj != null && method !=  null
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java
index f35fe3f3..744704a3 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java
@@ -16,7 +16,7 @@
  */
 package org.apache.commons.jexl3.internal.introspection;
 
-import org.apache.commons.logging.Log;
+import org.apache.log4j.Logger;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -56,7 +56,7 @@ final class ClassMap {
             return null;
         }
     }
-    
+
     /** The cache miss marker method. */
     private static final Method CACHE_MISS = cacheMiss();
     /**
@@ -78,7 +78,7 @@ final class ClassMap {
      * Keep track of all methods with the same name; this is not modified after creation.
      */
     private final Map<String, Method[]> byName = new HashMap<String, Method[]>();
-    /** 
+    /**
      * Cache of fields.
      */
     private final Map<String, Field> fieldCache;
@@ -90,7 +90,7 @@ final class ClassMap {
      * @param log the logger.
      */
     @SuppressWarnings("LeakingThisInConstructor")
-    ClassMap(Class<?> aClass, Log log) {
+    ClassMap(Class<?> aClass, Logger log) {
         // eagerly cache methods
         create(this, aClass, log);
         // eagerly cache public fields
@@ -199,7 +199,7 @@ final class ClassMap {
      * @param classToReflect the class to cache
      * @param log the Log
      */
-    private static void create(ClassMap cache, Class<?> classToReflect, Log log) {
+    private static void create(ClassMap cache, Class<?> classToReflect, Logger log) {
         //
         // Build a list of all elements in the class hierarchy. This one is bottom-first (i.e. we start
         // with the actual declaring class and its interfaces and then move up (superclass etc.) until we
@@ -256,7 +256,7 @@ final class ClassMap {
      * @param iface the interface to populate the cache from
      * @param log the Log
      */
-    private static void populateWithInterface(ClassMap cache, Class<?> iface, Log log) {
+    private static void populateWithInterface(ClassMap cache, Class<?> iface, Logger log) {
         if (Modifier.isPublic(iface.getModifiers())) {
             populateWithClass(cache, iface, log);
         }
@@ -272,7 +272,7 @@ final class ClassMap {
      * @param clazz the class to populate the cache from
      * @param log the Log
      */
-    private static void populateWithClass(ClassMap cache, Class<?> clazz, Log log) {
+    private static void populateWithClass(ClassMap cache, Class<?> clazz, Logger log) {
         try {
             Method[] methods = clazz.getDeclaredMethods();
             for (int i = 0; i < methods.length; i++) {
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java
index da3d9112..6f121d04 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java
@@ -120,5 +120,5 @@ public final class ConstructorMethod implements JexlMethod {
     public Class<?> getReturnType() {
         return ctor.getDeclaringClass();
     }
-    
+
 }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java
index e1863fb0..ebd1b9d8 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java
@@ -32,10 +32,10 @@ import java.lang.reflect.InvocationTargetException;
 public final class DuckSetExecutor extends AbstractExecutor.Set {
     /** The property. */
     private final Object property;
-    
+
     /**
      * Discovers a DuckSetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the set method from
      * @param key the key to use as 1st argument to the set method
@@ -46,7 +46,7 @@ public final class DuckSetExecutor extends AbstractExecutor.Set {
         java.lang.reflect.Method method = is.getMethod(clazz, "set", makeArgs(key, value));
         return method == null? null : new DuckSetExecutor(clazz, method, key);
     }
-    
+
     /**
      * Creates an instance.
      * @param clazz the class the set method applies to
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/EnumerationIterator.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/EnumerationIterator.java
index d7e629f0..88e03cc0 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/EnumerationIterator.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/EnumerationIterator.java
@@ -33,7 +33,7 @@ public class EnumerationIterator<T> implements Iterator<T> {
     private final Enumeration<T> enumeration;
 
     /**
-     * Creates a new iteratorwrapper instance for the specified 
+     * Creates a new iteratorwrapper instance for the specified
      * Enumeration.
      *
      * @param enumer  The Enumeration to wrap.
@@ -46,7 +46,7 @@ public class EnumerationIterator<T> implements Iterator<T> {
     public T next() {
         return enumeration.nextElement();
     }
-    
+
     @Override
     public boolean hasNext() {
         return enumeration.hasMoreElements();
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldGetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldGetExecutor.java
index 723007f6..48871ba9 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldGetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldGetExecutor.java
@@ -31,7 +31,7 @@ public final class FieldGetExecutor implements JexlPropertyGet {
 
     /**
      * Attempts to discover a FieldGetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
      * @param identifier the key to use as an argument to the get method
@@ -80,5 +80,5 @@ public final class FieldGetExecutor implements JexlPropertyGet {
     public boolean isCacheable() {
         return true;
     }
-    
+
 }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldSetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldSetExecutor.java
index c75474b6..001f4b80 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldSetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/FieldSetExecutor.java
@@ -32,7 +32,7 @@ public final class FieldSetExecutor implements JexlPropertySet {
 
     /**
      * Attempts to discover a FieldSetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
      * @param identifier the key to use as an argument to the get method
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/IndexedType.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/IndexedType.java
index ad5b14f1..a5a0fe5d 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/IndexedType.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/IndexedType.java
@@ -42,7 +42,7 @@ public final class IndexedType implements JexlPropertyGet {
      * The code attempts to find the list of methods getXXX() and setXXX().
      * Note that this is not equivalent to the strict bean definition of indexed properties; the type of the key
      * is not necessarily an int and the set/get arrays are not resolved.
-     * 
+     *
      * @param is the introspector
      * @param object the object
      * @param name the container name
@@ -61,7 +61,7 @@ public final class IndexedType implements JexlPropertyGet {
         }
         return null;
     }
-    
+
     /**
      * A generic indexed property container, exposes get(key) and set(key, value) and solves method call dynamically
      * based on arguments.
@@ -104,7 +104,7 @@ public final class IndexedType implements JexlPropertyGet {
             return type.invokeSet(object, key, value);
         }
     }
-    
+
     /**
      * Creates a new indexed type.
      * @param name the container name
@@ -193,5 +193,5 @@ public final class IndexedType implements JexlPropertyGet {
         }
         throw new IntrospectionException("property set error: " + object.getClass().toString() + "@" + key.toString());
     }
-    
+
 }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/Introspector.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/Introspector.java
index 63e87df1..f9984923 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/Introspector.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/Introspector.java
@@ -16,7 +16,7 @@
  */
 package org.apache.commons.jexl3.internal.introspection;
 
-import org.apache.commons.logging.Log;
+import org.apache.log4j.Logger;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
@@ -38,19 +38,10 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
  * in the form of an Object[]
  * <p/>
  * The first time the Introspector sees a class it creates a class method map
- * for the class in question. Basically the class method map is a Hastable where
- * Method objects are keyed by a concatenation of the method name and the names
- * of classes that make up the parameters.
- *
- * For example, a method with the following signature:
- *
- * public void method(String a, StringBuffer b)
- *
- * would be mapped by the key:
- *
- * "method" + "java.lang.String" + "java.lang.StringBuffer"
- *
- * This mapping is performed for all the methods in a class and stored.
+ * for the class in question.
+ * Basically the class method map is a Hashtable where Method objects are keyed by the aggregation of
+ * the method name and the array of parameters classes.
+ * This mapping is performed for all the public methods of a class and stored.
  * @since 1.0
  */
 public final class Introspector {
@@ -70,7 +61,7 @@ public final class Introspector {
     /**
      * the logger.
      */
-    protected final Log rlog;
+    protected final Logger rlog;
     /**
      * The class loader used to solve constructors if needed.
      */
@@ -97,7 +88,7 @@ public final class Introspector {
      * @param log     the logger to use
      * @param cloader the class loader
      */
-    public Introspector(Log log, ClassLoader cloader) {
+    public Introspector(Logger log, ClassLoader cloader) {
         this.rlog = log;
         loader = cloader;
     }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ListGetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ListGetExecutor.java
index 31020dfc..fd2c558c 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ListGetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ListGetExecutor.java
@@ -35,34 +35,33 @@ public final class ListGetExecutor extends AbstractExecutor.Get {
 
     /**
      * Attempts to discover a ListGetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
-     * @param identifier the key to use as an argument to the get method
+     * @param index the index to use as an argument to the get method
      * @return the executor if found, null otherwise
      */
-    public static ListGetExecutor discover(Introspector is, Class<?> clazz, Object identifier) {
-        java.lang.reflect.Method method = null;
-        Integer index = toInteger(identifier);
+    public static ListGetExecutor discover(Introspector is, Class<?> clazz, Integer index) {
         if (index != null) {
             if (clazz.isArray()) {
-                method = ARRAY_GET;
-            } else if (List.class.isAssignableFrom(clazz)) {
-                method = LIST_GET;
+                return new ListGetExecutor(clazz, ARRAY_GET, index);
+            }
+            if (List.class.isAssignableFrom(clazz)) {
+                return new ListGetExecutor(clazz, LIST_GET, index);
             }
         }
-        return method == null ? null : new ListGetExecutor(clazz, method, index);
+        return null;
     }
 
     /**
      * Creates an instance.
      * @param clazz he class the get method applies to
      * @param method the method held by this executor
-     * @param identifier the property to get
+     * @param index the index to use as an argument to the get method
      */
-    private ListGetExecutor(Class<?> clazz, java.lang.reflect.Method method, Integer identifier) {
+    private ListGetExecutor(Class<?> clazz, java.lang.reflect.Method method, Integer index) {
         super(clazz, method);
-        property = identifier;
+        property = index;
     }
 
     @Override
@@ -80,8 +79,8 @@ public final class ListGetExecutor extends AbstractExecutor.Get {
     }
 
     @Override
-    public Object tryInvoke(final Object obj, Object key) {
-        Integer index = toInteger(key);
+    public Object tryInvoke(final Object obj, Object identifier) {
+        Integer index = castInteger(identifier);
         if (obj != null && method != null
             && objectClass.equals(obj.getClass())
             && index != null) {
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ListSetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ListSetExecutor.java
index 1caba707..18b1b837 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ListSetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ListSetExecutor.java
@@ -35,7 +35,7 @@ public final class ListSetExecutor extends AbstractExecutor.Set {
 
     /**
      * Attempts to discover a ListSetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
      * @param identifier the key to use as an argument to the get method
@@ -43,8 +43,7 @@ public final class ListSetExecutor extends AbstractExecutor.Set {
      * @return the executor if found, null otherwise
      */
     public static ListSetExecutor discover(Introspector is, Class<?> clazz, Object identifier, Object value) {
-        Integer index = toInteger(identifier);
-        java.lang.reflect.Method method = null;
+        Integer index = castInteger(identifier);
         if (index != null) {
             if (clazz.isArray()) {
                 // we could verify if the call can be performed but it does not change
@@ -52,18 +51,19 @@ public final class ListSetExecutor extends AbstractExecutor.Set {
                 // Class<?> formal = clazz.getComponentType();
                 // Class<?> actual = value == null? Object.class : value.getClass();
                 // if (IntrospectionUtils.isMethodInvocationConvertible(formal, actual, false)) {
-                method = ARRAY_SET;
+                return new ListSetExecutor(clazz, ARRAY_SET, index);
                 // }
-            } else if (List.class.isAssignableFrom(clazz)) {
-                method = LIST_SET;
+            }
+            if (List.class.isAssignableFrom(clazz)) {
+                return new ListSetExecutor(clazz, LIST_SET, index);
             }
         }
-        return method == null ? null : new ListSetExecutor(clazz, method, index);
+        return null;
     }
 
     /**
      * Creates an instance.
-     * 
+     *
      * @param clazz the class the set method applies to
      * @param method the method called through this executor
      * @param key the key to use as 1st argument to the set method
@@ -92,7 +92,7 @@ public final class ListSetExecutor extends AbstractExecutor.Set {
 
     @Override
     public Object tryInvoke(final Object obj, Object key, Object value) {
-        Integer index = toInteger(key);
+        Integer index = castInteger(key);
         if (obj != null && method != null
                 && objectClass.equals(obj.getClass())
                 && index != null) {
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MapGetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MapGetExecutor.java
index 31a55f22..4cd95553 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MapGetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MapGetExecutor.java
@@ -32,7 +32,7 @@ public final class MapGetExecutor extends AbstractExecutor.Get {
 
     /**
      * Attempts to discover a MapGetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
      * @param identifier the key to use as an argument to the get method
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java
index 53a05946..d1d25648 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java
@@ -31,7 +31,7 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
 
     /**
      * Attempts to discover a MapSetExecutor.
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the set method from
      * @param identifier the key to use as an argument to the get method
@@ -45,7 +45,7 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
             return null;
         }
     }
-    
+
     /**
      * Creates an instance.
      * @param clazz the class the set method applies to
@@ -61,7 +61,7 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
     public Object getTargetProperty() {
         return property;
     }
-    
+
     @Override
     public Object invoke(final Object obj, Object value) throws IllegalAccessException, InvocationTargetException {
         @SuppressWarnings("unchecked") // ctor only allows Map instances - see discover() method
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java
index 32077336..5daf3b49 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java
@@ -24,9 +24,10 @@ import java.lang.reflect.InvocationTargetException;
  * @since 2.0
  */
 public final class MethodExecutor extends AbstractExecutor.Method {
-    /** Whether this method handles varargs. */
-    private final boolean isVarArgs;
-
+    /** If this method is a vararg method, vaStart is the last argument index. */
+    private final int vaStart;
+    /** If this method is a vararg method, vaClass is the component type of the vararg array. */
+    private final Class<?> vaClass;
 
     /**
      * Discovers a {@link MethodExecutor}.
@@ -66,18 +67,24 @@ public final class MethodExecutor extends AbstractExecutor.Method {
      */
     private MethodExecutor(Class<?> c, java.lang.reflect.Method m, MethodKey k) {
         super(c, m, k);
-        isVarArgs = method != null && isVarArgMethod(method);
+        int vastart = -1;
+        Class<?> vaclass = null;
+        if (method != null) {
+            Class<?>[] formal = method.getParameterTypes();
+            // if the last parameter is an array, the method is considered as vararg
+            if (formal != null && method.isVarArgs()) {
+                vastart = formal.length - 1;
+                vaclass = formal[vastart].getComponentType();
+            }
+        }
+        vaStart = vastart;
+        vaClass = vaclass;
     }
 
     @Override
     public Object invoke(Object o, Object[] args) throws IllegalAccessException, InvocationTargetException  {
-        if (isVarArgs) {
-            Class<?>[] formal = method.getParameterTypes();
-            int index = formal.length - 1;
-            Class<?> type = formal[index].getComponentType();
-            if (args.length >= index) {
-                args = handleVarArg(type, index, args);
-            }
+        if (vaClass != null) {
+            args = handleVarArg(args);
         }
         if (method.getDeclaringClass() == ArrayListWrapper.class && o.getClass().isArray()) {
             return method.invoke(new ArrayListWrapper(o), args);
@@ -111,62 +118,45 @@ public final class MethodExecutor extends AbstractExecutor.Method {
      * @param index  The index of the vararg in the method declaration
      *               (This will always be one less than the number of
      *               expected arguments.)
-     * @param actual The actual parameters being passed to this method
+     * @param actual The actual arguments being passed to this method
      * @return The actual parameters adjusted for the varargs in order
      * to fit the method declaration.
      */
-    private Object[] handleVarArg(Class<?> type, int index, Object[] actual) {
-        final int size = actual.length - index;
+    @SuppressWarnings("SuspiciousSystemArraycopy")
+    private Object[] handleVarArg(Object[] actual) {
+        final Class<?> vaclass = vaClass;
+        final int vastart = vaStart;
+        // variable arguments count
+        final int varargc = actual.length - vastart;
         // if no values are being passed into the vararg, size == 0
-        if (size == 1) {
+        if (varargc == 1) {
             // if one non-null value is being passed into the vararg,
             // and that arg is not the sole argument and not an array of the expected type,
             // make the last arg an array of the expected type
-            if (actual[index] != null) {
-                Class<?> aclazz = actual[index].getClass();
-                if (!aclazz.isArray() || !type.isAssignableFrom(aclazz.getComponentType())) {
+            if (actual[vastart] != null) {
+                Class<?> aclazz = actual[vastart].getClass();
+                if (!aclazz.isArray() || !vaclass.isAssignableFrom(aclazz.getComponentType())) {
                     // create a 1-length array to hold and replace the last argument
-                    Object lastActual = Array.newInstance(type, 1);
-                    Array.set(lastActual, 0, actual[index]);
-                    actual[index] = lastActual;
+                    Object lastActual = Array.newInstance(vaclass, 1);
+                    Array.set(lastActual, 0, actual[vastart]);
+                    actual[vastart] = lastActual;
                 }
             }
             // else, the vararg is null and used as is, considered as T[]
         } else {
             // if no or multiple values are being passed into the vararg,
             // put them in an array of the expected type
-            Object lastActual = Array.newInstance(type, size);
-            for (int i = 0; i < size; i++) {
-                Array.set(lastActual, i, actual[index + i]);
-            }
-
+            Object varargs = Array.newInstance(vaclass, varargc);
+            System.arraycopy(actual, vastart, varargs, 0, varargc);
             // put all arguments into a new actual array of the appropriate size
-            Object[] newActual = new Object[index + 1];
-            System.arraycopy(actual, 0, newActual, 0, index);
-            newActual[index] = lastActual;
-
+            Object[] newActual = new Object[vastart + 1];
+            System.arraycopy(actual, 0, newActual, 0, vastart);
+            newActual[vastart] = varargs;
             // replace the old actual array
             actual = newActual;
         }
         return actual;
     }
-
-   /**
-     * Determines if a method can accept a variable number of arguments.
-     * @param m a the method to check
-     * @return true if method is vararg, false otherwise
-     */
-    private static boolean isVarArgMethod(java.lang.reflect.Method m) {
-        Class<?>[] formal = m.getParameterTypes();
-        if (formal == null || formal.length == 0) {
-            return false;
-        } else {
-            Class<?> last = formal[formal.length - 1];
-            // if the last arg is an array, then
-            // we consider this a varargs method
-            return last.isArray();
-        }
-    }
 }
 
 
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java
index ee0600f1..e87fd56e 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java
@@ -49,7 +49,6 @@ public final class MethodKey {
     private static final int PRIMITIVE_SIZE = 13;
     /** The primitive type to class conversion map. */
     private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES;
-
     static {
         PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);
         PRIMITIVE_TYPES.put(Boolean.TYPE, Boolean.class);
@@ -78,7 +77,6 @@ public final class MethodKey {
         Class<?> prim = PRIMITIVE_TYPES.get(parm);
         return prim == null ? parm : prim;
     }
-
     /** The hash code. */
     private final int hashCode;
     /** The method name. */
@@ -93,7 +91,7 @@ public final class MethodKey {
     /**
      * Creates a key from a method name and a set of arguments.
      * @param aMethod the method to generate the key from
-     * @param args the intended method arguments
+     * @param args    the intended method arguments
      */
     public MethodKey(String aMethod, Object[] args) {
         super();
@@ -136,7 +134,7 @@ public final class MethodKey {
     /**
      * Creates a key from a method name and a set of parameters.
      * @param aMethod the method to generate the key from
-     * @param args the intended method parameters
+     * @param args    the intended method parameters
      */
     MethodKey(String aMethod, Class<?>[] args) {
         super();
@@ -257,9 +255,7 @@ public final class MethodKey {
      *         type or an object type of a primitive type that can be converted to
      *         the formal type.
      */
-    public static boolean isInvocationConvertible(Class<?> formal,
-            Class<?> actual,
-            boolean possibleVarArg) {
+    public static boolean isInvocationConvertible(Class<?> formal, Class<?> actual, boolean possibleVarArg) {
         /* if it's a null, it means the arg was null */
         if (actual == null && !formal.isPrimitive()) {
             return true;
@@ -270,6 +266,11 @@ public final class MethodKey {
             return true;
         }
 
+        /** Catch all... */
+        if (formal == Object.class) {
+            return true;
+        }
+
         /* Check for boxing with widening primitive conversion. Note that
          * actual parameters are never primitives. */
         if (formal.isPrimitive()) {
@@ -315,8 +316,7 @@ public final class MethodKey {
             if (actual != null && actual.isArray()) {
                 actual = actual.getComponentType();
             }
-            return isInvocationConvertible(formal.getComponentType(),
-                    actual, false);
+            return isInvocationConvertible(formal.getComponentType(), actual, false);
         }
         return false;
     }
@@ -337,16 +337,14 @@ public final class MethodKey {
      *         or formal and actual are both primitive types and actual can be
      *         subject to widening conversion to formal.
      */
-    public static boolean isStrictInvocationConvertible(Class<?> formal,
-            Class<?> actual,
-            boolean possibleVarArg) {
+    public static boolean isStrictInvocationConvertible(Class<?> formal, Class<?> actual, boolean possibleVarArg) {
         /* we shouldn't get a null into, but if so */
         if (actual == null && !formal.isPrimitive()) {
             return true;
         }
 
         /* Check for identity or widening reference conversion */
-        if (formal.isAssignableFrom(actual)) {
+        if (formal.isAssignableFrom(actual) && (formal.isArray() == actual.isArray())) {
             return true;
         }
 
@@ -382,8 +380,7 @@ public final class MethodKey {
             if (actual != null && actual.isArray()) {
                 actual = actual.getComponentType();
             }
-            return isStrictInvocationConvertible(formal.getComponentType(),
-                    actual, false);
+            return isStrictInvocationConvertible(formal.getComponentType(), actual, false);
         }
         return false;
     }
@@ -402,7 +399,7 @@ public final class MethodKey {
 
     /**
      * Simple distinguishable exception, used when
-     * we run across ambiguous overloading.  Caught
+     * we run across ambiguous overloading. Caught
      * by the introspector.
      */
     public static class AmbiguousException extends RuntimeException {
@@ -424,6 +421,8 @@ public final class MethodKey {
          */
         protected abstract Class<?>[] getParameterTypes(T app);
 
+        protected abstract boolean isVarArgs(T app);
+
         // CSOFF: RedundantThrows
         /**
          * Gets the most specific method that is applicable to actual argument types.<p>
@@ -580,7 +579,7 @@ public final class MethodKey {
         /**
          * Checks whether a parameter class is a primitive.
          * @param c the parameter class
-         * @param possibleVararg true if this is the last parameter which can tbe be a primitive array (vararg call)
+         * @param possibleVararg true if this is the last parameter which can be a primitive array (vararg call)
          * @return true if primitive, false otherwise
          */
         private boolean isPrimitive(Class<?> c,  boolean possibleVarArg) {
@@ -610,7 +609,6 @@ public final class MethodKey {
                 if (isApplicable(method, classes)) {
                     list.add(method);
                 }
-
             }
             return list;
         }
@@ -623,48 +621,62 @@ public final class MethodKey {
          * @param classes arguments to method
          * @return true if method is applicable to arguments
          */
-        private boolean isApplicable(T method, Class<?>[] classes) {
-            Class<?>[] methodArgs = getParameterTypes(method);
-            // if samee number or args or
+        private boolean isApplicable(T method, Class<?>[] actuals) {
+            Class<?>[] formals = getParameterTypes(method);
+            // if same number or args or
             // there's just one more methodArg than class arg
             // and the last methodArg is an array, then treat it as a vararg
-            if (methodArgs.length == classes.length
-                || ((methodArgs.length == classes.length + 1) && methodArgs[methodArgs.length - 1].isArray())) {
+            if (formals.length == actuals.length) {
                 // this will properly match when the last methodArg
                 // is an array/varargs and the last class is the type of array
                 // (e.g. String when the method is expecting String...)
-                for (int i = 0; i < classes.length; ++i) {
-                    if (!isConvertible(methodArgs[i], classes[i], false)) {
+                for (int i = 0; i < actuals.length; ++i) {
+                    if (!isConvertible(formals[i], actuals[i], false)) {
                         // if we're on the last arg and the method expects an array
-                        if (i == classes.length - 1 && methodArgs[i].isArray()) {
+                        if (i == actuals.length - 1 && formals[i].isArray()) {
                             // check to see if the last arg is convertible
                             // to the array's component type
-                            return isConvertible(methodArgs[i], classes[i], true);
+                            return isConvertible(formals[i], actuals[i], true);
                         }
                         return false;
                     }
                 }
                 return true;
             }
-            // more arguments given than the method accepts; check for varargs
-            if (methodArgs.length > 0 && classes.length > 0) {
-                // check that the last methodArg is an array
-                Class<?> lastarg = methodArgs[methodArgs.length - 1];
-                if (!lastarg.isArray()) {
+
+            // number of formal and actual differ, method must be vararg
+            if (!isVarArgs(method)) {
+                return false;
+            }
+
+            // less arguments than method parameters: vararg is null
+            if (formals.length > actuals.length) {
+                // only one parameter, the last (ie vararg) can be missing
+                if (formals.length - actuals.length > 1) {
                     return false;
                 }
+                // check that all present args match up to the method parms
+                for (int i = 0; i < actuals.length; ++i) {
+                    if (!isConvertible(formals[i], actuals[i], false)) {
+                        return false;
+                    }
+                }
+                return true;
+            }
 
+            // more arguments given than the method accepts; check for varargs
+            if (formals.length > 0 && actuals.length > 0) {
                 // check that they all match up to the last method arg
-                for (int i = 0; i < methodArgs.length - 1; ++i) {
-                    if (!isConvertible(methodArgs[i], classes[i], false)) {
+                for (int i = 0; i < formals.length - 1; ++i) {
+                    if (!isConvertible(formals[i], actuals[i], false)) {
                         return false;
                     }
                 }
-
                 // check that all remaining arguments are convertible to the vararg type
-                Class<?> vararg = lastarg.getComponentType();
-                for (int i = methodArgs.length - 1; i < classes.length; ++i) {
-                    if (!isConvertible(vararg, classes[i], false)) {
+                // (last parm is an array since method is vararg)
+                Class<?> vararg = formals[formals.length - 1].getComponentType();
+                for (int i = formals.length - 1; i < actuals.length; ++i) {
+                    if (!isConvertible(vararg, actuals[i], false)) {
                         return false;
                     }
                 }
@@ -697,7 +709,8 @@ public final class MethodKey {
          *                       in the method declaration
          * @return see isStrictMethodInvocationConvertible.
          */
-        private boolean isStrictConvertible(Class<?> formal, Class<?> actual, boolean possibleVarArg) {
+        private boolean isStrictConvertible(Class<?> formal, Class<?> actual,
+                boolean possibleVarArg) {
             // if we see Void.class, the argument was null
             return isStrictInvocationConvertible(formal, actual.equals(Void.class) ? null : actual, possibleVarArg);
         }
@@ -710,6 +723,10 @@ public final class MethodKey {
         protected Class<?>[] getParameterTypes(Method app) {
             return app.getParameterTypes();
         }
+        @Override
+        public boolean isVarArgs(Method app) {
+            return app.isVarArgs();
+        }
     };
     /**
      * The parameter matching service for constructors.
@@ -719,5 +736,9 @@ public final class MethodKey {
         protected Class<?>[] getParameterTypes(Constructor<?> app) {
             return app.getParameterTypes();
         }
+        @Override
+        public boolean isVarArgs(Constructor<?> app) {
+            return app.isVarArgs();
+        }
     };
 }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertyGetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertyGetExecutor.java
index a7cd1e88..40c49c9f 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertyGetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertyGetExecutor.java
@@ -27,11 +27,11 @@ public final class PropertyGetExecutor extends AbstractExecutor.Get {
     private static final Object[] EMPTY_PARAMS = {};
     /** The property. */
     private final String property;
-    
+
     /**
      * Discovers a PropertyGetExecutor.
      * <p>The method to be found should be named "get{P,p}property.</p>
-     * 
+     *
      * @param is the introspector
      * @param clazz the class to find the get method from
      * @param property the property name to find
@@ -41,7 +41,7 @@ public final class PropertyGetExecutor extends AbstractExecutor.Get {
         java.lang.reflect.Method method = discoverGet(is, "get", clazz, property);
         return method == null? null : new PropertyGetExecutor(clazz, method, property);
     }
-    
+
     /**
      * Creates an instance.
      * @param clazz he class the get method applies to
@@ -57,7 +57,7 @@ public final class PropertyGetExecutor extends AbstractExecutor.Get {
     public Object getTargetProperty() {
         return property;
     }
-    
+
     @Override
     public Object invoke(Object o)
         throws IllegalAccessException, InvocationTargetException {
@@ -67,7 +67,7 @@ public final class PropertyGetExecutor extends AbstractExecutor.Get {
     @Override
     public Object tryInvoke(Object o, Object identifier) {
         if (o != null && method !=  null
-            && property.equals(toString(identifier))
+            && property.equals(castString(identifier))
             && objectClass.equals(o.getClass())) {
             try {
                 return method.invoke(o, (Object[]) null);
@@ -89,8 +89,11 @@ public final class PropertyGetExecutor extends AbstractExecutor.Get {
      * @return The {get,is}{p,P}roperty method if one exists, null otherwise.
      */
     static java.lang.reflect.Method discoverGet(Introspector is, String which, Class<?> clazz, String property) {
+        if (property == null || property.isEmpty()) {
+            return null;
+        }
         //  this is gross and linear, but it keeps it straightforward.
-        java.lang.reflect.Method method = null;
+        java.lang.reflect.Method method;
         final int start = which.length(); // "get" or "is" so 3 or 2 for char case switch
         // start with get<Property>
         StringBuilder sb = new StringBuilder(which);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java
index f16f3e7c..510ffba9 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java
@@ -14,45 +14,48 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.commons.jexl3.internal.introspection;
+
+import java.lang.reflect.Array;
 import java.lang.reflect.InvocationTargetException;
 
 /**
  * Specialized executor to set a property in an object.
  * @since 2.0
  */
-public final class PropertySetExecutor extends AbstractExecutor.Set {
+public class PropertySetExecutor extends AbstractExecutor.Set {
     /** Index of the first character of the set{p,P}roperty. */
     private static final int SET_START_INDEX = 3;
     /** The property. */
-    private final String property;
-    
+    protected final String property;
+
     /**
      * Discovers a PropertySetExecutor.
      * <p>The method to be found should be named "set{P,p}property.</p>
-     * 
-     * @param is the introspector
-     * @param clazz the class to find the get method from
+     *
+     * @param is       the introspector
+     * @param clazz    the class to find the get method from
      * @param property the property name to find
-     * @param arg the value to assign to the property
+     * @param arg      the value to assign to the property
      * @return the executor if found, null otherwise
      */
     public static PropertySetExecutor discover(Introspector is, Class<?> clazz, String property, Object arg) {
+        if (property == null || property.isEmpty()) {
+            return null;
+        }
         java.lang.reflect.Method method = discoverSet(is, clazz, property, arg);
-        return method == null? null : new PropertySetExecutor(clazz, method, property);
+        return method != null? new PropertySetExecutor(clazz, method, property) : null;
     }
-    
+
     /**
      * Creates an instance.
-     * @param clazz the class the set method applies to
+     * @param clazz  the class the set method applies to
      * @param method the method called through this executor
-     * @param key the key to use as 1st argument to the set method
+     * @param key    the key to use as 1st argument to the set method
      */
-    private PropertySetExecutor(Class<?> clazz, java.lang.reflect.Method method, String key) {
+    protected PropertySetExecutor(Class<?> clazz, java.lang.reflect.Method method, String key) {
         super(clazz, method);
         property = key;
-
     }
 
     @Override
@@ -62,9 +65,17 @@ public final class PropertySetExecutor extends AbstractExecutor.Set {
 
     @Override
     public Object invoke(Object o, Object arg) throws IllegalAccessException, InvocationTargetException {
-        Object[] pargs = {arg};
         if (method != null) {
-            method.invoke(o, pargs);
+            // handle the empty array case
+            if (isEmptyArray(arg)) {
+                // if array is empty but its component type is different from the method first parameter component type,
+                // replace argument with a new empty array instance (of the method first parameter component type)
+                Class<?> componentType = method.getParameterTypes()[0].getComponentType();
+                if (componentType != null && !componentType.equals(arg.getClass().getComponentType())) {
+                    arg = Array.newInstance(componentType, 0);
+                }
+            }
+            method.invoke(o, arg);
         }
         return arg;
     }
@@ -73,11 +84,9 @@ public final class PropertySetExecutor extends AbstractExecutor.Set {
     public Object tryInvoke(Object o, Object identifier, Object arg) {
         if (o != null && method != null
             // ensure method name matches the property name
-            && property.equals(toString(identifier))
+            && property.equals(castString(identifier))
             // object class should be same as executor's method declaring class
-            && objectClass.equals(o.getClass())
-            // we are guaranteed the method has one parameter since it is a set(x)
-            && (arg == null || method.getParameterTypes()[0].equals(arg.getClass()))) {
+            && objectClass.equals(o.getClass())) {
             try {
                 return invoke(o, arg);
             } catch (InvocationTargetException xinvoke) {
@@ -89,15 +98,24 @@ public final class PropertySetExecutor extends AbstractExecutor.Set {
         return TRY_FAILED;
     }
 
+    /**
+     * Checks wether an argument is an empty array.
+     * @param arg the argument
+     * @return true if <code>arg</code> is an empty array
+     */
+    private static boolean isEmptyArray(Object arg) {
+        return (arg != null && arg.getClass().isArray() && Array.getLength(arg) == 0);
+    }
 
     /**
      * Discovers the method for a {@link PropertySet}.
-     * <p>The method to be found should be named "set{P,p}property.</p>
-     * 
-     * @param is the introspector
-     * @param clazz the class to find the get method from
+     * <p>The method to be found should be named "set{P,p}property.
+     * As a special case, any empty array will try to find a valid array-setting non-ambiguous method.
+     *
+     * @param is       the introspector
+     * @param clazz    the class to find the get method from
      * @param property the name of the property to set
-     * @param arg the value to assign to the property
+     * @param arg      the value to assign to the property
      * @return the method if found, null otherwise
      */
     private static java.lang.reflect.Method discoverSet(Introspector is, Class<?> clazz, String property, Object arg) {
@@ -113,8 +131,44 @@ public final class PropertySetExecutor extends AbstractExecutor.Set {
         if (method == null) {
             sb.setCharAt(SET_START_INDEX, Character.toLowerCase(c));
             method = is.getMethod(clazz, sb.toString(), params);
+            // uppercase nth char, try array
+            if (method == null && isEmptyArray(arg)) {
+                sb.setCharAt(SET_START_INDEX, Character.toUpperCase(c));
+                method = lookupSetEmptyArray(is, clazz, sb.toString());
+                // lowercase nth char
+                if (method == null) {
+                    sb.setCharAt(SET_START_INDEX, Character.toLowerCase(c));
+                    method = lookupSetEmptyArray(is, clazz, sb.toString());
+                }
+            }
         }
         return method;
     }
-}
 
+    /**
+     * Finds an empty array property setter method by <code>methodName</code>.
+     * <p>This checks only one method with that name accepts an array as sole parameter.
+     * @param is       the introspector
+     * @param clazz    the class to find the get method from
+     * @param methodName the method name to find
+     * @return         the sole method that accepts an array as parameter
+     */
+    private static java.lang.reflect.Method lookupSetEmptyArray(Introspector is, final Class<?> clazz, String methodName) {
+        java.lang.reflect.Method candidate = null;
+        java.lang.reflect.Method[] methods = is.getMethods(clazz, methodName);
+        if (methods != null) {
+            for (java.lang.reflect.Method method : methods) {
+                Class<?>[] paramTypes = method.getParameterTypes();
+                if (paramTypes.length == 1 && paramTypes[0].isArray()) {
+                    if (candidate != null) {
+                        // because the setter method is overloaded for different parameter type,
+                        // return null here to report the ambiguity.
+                        return null;
+                    }
+                    candidate = method;
+                }
+            }
+        }
+        return candidate;
+    }
+}
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java
index ccf6a113..eaad80e0 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java
@@ -21,7 +21,7 @@ import org.apache.commons.jexl3.introspection.JexlPropertyGet;
 import org.apache.commons.jexl3.introspection.JexlPropertySet;
 import org.apache.commons.jexl3.introspection.JexlUberspect;
 
-import org.apache.commons.logging.Log;
+import org.apache.log4j.Logger;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
@@ -47,7 +47,7 @@ public class Uberspect implements JexlUberspect {
      */
     public static final Object TRY_FAILED = AbstractExecutor.TRY_FAILED;
     /** The logger to use for all warnings & errors. */
-    protected final Log rlog;
+    protected final Logger rlog;
     /** The introspector version. */
     private final AtomicInteger version;
     /** The soft reference to the introspector currently in use. */
@@ -59,7 +59,7 @@ public class Uberspect implements JexlUberspect {
      * Creates a new Uberspect.
      * @param runtimeLogger the logger used for all logging needs
      */
-    public Uberspect(Log runtimeLogger) {
+    public Uberspect(Logger runtimeLogger) {
         rlog = runtimeLogger;
         ref = new SoftReference<Introspector>(null);
         loader = new SoftReference<ClassLoader>(getClass().getClassLoader());
@@ -120,7 +120,9 @@ public class Uberspect implements JexlUberspect {
     }
 
     /**
-     * Gets the field named by <code>key</code> for the class <code>c</code>.
+     * Gets the field named by
+     * <code>key</code> for the class
+     * <code>c</code>.
      *
      * @param c   Class in which the field search is taking place
      * @param key Name of the field being searched for
@@ -140,29 +142,33 @@ public class Uberspect implements JexlUberspect {
     }
 
     /**
-     * Gets the method defined by <code>name</code> and
-     * <code>params</code> for the Class <code>c</code>.
+     * Gets the method defined by
+     * <code>name</code> and
+     * <code>params</code> for the Class
+     * <code>c</code>.
      *
      * @param c      Class in which the method search is taking place
      * @param name   Name of the method being searched for
      * @param params An array of Objects (not Classes) that describe the
-     * the parameters
+     *               the parameters
      *
      * @return a {@link java.lang.reflect.Method}
-     * or null if no unambiguous method could be found through introspection.
+     *         or null if no unambiguous method could be found through introspection.
      */
     public final Method getMethod(Class<?> c, String name, Object[] params) {
         return base().getMethod(c, new MethodKey(name, params));
     }
 
     /**
-     * Gets the method defined by <code>key</code> and for the Class <code>c</code>.
+     * Gets the method defined by
+     * <code>key</code> and for the Class
+     * <code>c</code>.
      *
      * @param c   Class in which the method search is taking place
      * @param key MethodKey of the method being searched for
      *
      * @return a {@link java.lang.reflect.Method}
-     * or null if no unambiguous method could be found through introspection.
+     *         or null if no unambiguous method could be found through introspection.
      */
     public final Method getMethod(Class<?> c, MethodKey key) {
         return base().getMethod(c, key);
@@ -195,7 +201,7 @@ public class Uberspect implements JexlUberspect {
     @Override
     public JexlPropertyGet getPropertyGet(Object obj, Object identifier) {
         final Class<?> claz = obj.getClass();
-        final String property = AbstractExecutor.toString(identifier);
+        final String property = AbstractExecutor.castString(identifier);
         final Introspector is = base();
         JexlPropertyGet executor;
         // first try for a getFoo() type of property (also getfoo() )
@@ -216,32 +222,38 @@ public class Uberspect implements JexlUberspect {
             return executor;
         }
         // let's see if this is a list or array
-        executor = ListGetExecutor.discover(is, claz, identifier);
-        if (executor != null) {
-            return executor;
-        }
-        // if that didn't work, look for get(foo)
-        executor = DuckGetExecutor.discover(is, claz, identifier);
-        if (executor != null) {
-            return executor;
-        }
-        // last, look for get("foo") if we did not try yet
-        if (property != null && !(identifier instanceof String)) {
-            // if that didn't work, look for get("foo")
-            executor = DuckGetExecutor.discover(is, claz, property);
+        Integer index = AbstractExecutor.castInteger(identifier);
+        if (index != null) {
+            executor = ListGetExecutor.discover(is, claz, index);
             if (executor != null) {
                 return executor;
             }
         }
-        // a field may be?
-        executor = FieldGetExecutor.discover(is, claz, property);
+        // if that didn't work, look for get(foo)
+        executor = DuckGetExecutor.discover(is, claz, identifier);
         if (executor != null) {
             return executor;
         }
-        // or an indexed property?
-        executor = IndexedType.discover(is, obj, property);
-        if (executor != null) {
-            return executor;
+        if (property != null) {
+            // look for get("foo") if we did not try yet (just above)
+            if (property != identifier) {
+                executor = DuckGetExecutor.discover(is, claz, property);
+                if (executor != null) {
+                    return executor;
+                }
+            }
+            if (index == null) {
+                // a field may be? (can not be a number)
+                executor = FieldGetExecutor.discover(is, claz, property);
+                if (executor != null) {
+                    return executor;
+                }
+                // or an indexed property?
+                executor = IndexedType.discover(is, obj, property);
+                if (executor != null) {
+                    return executor;
+                }
+            }
         }
         return null;
     }
@@ -249,7 +261,7 @@ public class Uberspect implements JexlUberspect {
     @Override
     public JexlPropertySet getPropertySet(final Object obj, final Object identifier, Object arg) {
         final Class<?> claz = obj.getClass();
-        final String property = AbstractExecutor.toString(identifier);
+        final String property = AbstractExecutor.castString(identifier);
         final Introspector is = base();
         JexlPropertySet executor;
         // first try for a setFoo() type of property (also setfoo() )
@@ -266,9 +278,12 @@ public class Uberspect implements JexlUberspect {
         }
         // let's see if we can convert the identifier to an int,
         // if obj is an array or a list, we can still do something
-        executor = ListSetExecutor.discover(is, claz, identifier, arg);
-        if (executor != null) {
-            return executor;
+        Integer index = AbstractExecutor.castInteger(identifier);
+        if (index != null) {
+            executor = ListSetExecutor.discover(is, claz, identifier, arg);
+            if (executor != null) {
+                return executor;
+            }
         }
         // if that didn't work, look for set(foo)
         executor = DuckSetExecutor.discover(is, claz, identifier, arg);
@@ -276,16 +291,20 @@ public class Uberspect implements JexlUberspect {
             return executor;
         }
         // last, look for set("foo") if we did not try yet
-        if (property != null && !(identifier instanceof String)) {
-            executor = DuckSetExecutor.discover(is, claz, property, arg);
-            if (executor != null) {
-                return executor;
+        if (property != null) {
+            if (property != identifier) {
+                executor = DuckSetExecutor.discover(is, claz, property, arg);
+                if (executor != null) {
+                    return executor;
+                }
+            }
+            if (index == null) {
+                // a field may be?
+                executor = FieldSetExecutor.discover(is, claz, property, arg);
+                if (executor != null) {
+                    return executor;
+                }
             }
-        }
-        // a field may be?
-        executor = FieldSetExecutor.discover(is, claz, property, arg);
-        if (executor != null) {
-            return executor;
         }
         return null;
     }
@@ -328,4 +347,63 @@ public class Uberspect implements JexlUberspect {
     public JexlMethod getConstructor(Object ctorHandle, Object[] args) {
         return ConstructorMethod.discover(base(), ctorHandle, args);
     }
+    /**
+     * May be a way to extend/improve sandboxing by choosing actual method for resolution.
+     **
+     * public static enum GetResolver {
+     * PROPERTY {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return PropertyGetExecutor.discover(uberspect.base(), obj.getClass(), AbstractExecutor.toString(identifier));
+     * }
+     * },
+     * BOOLEAN {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return BooleanGetExecutor.discover(uberspect.base(), obj.getClass(), AbstractExecutor.toString(identifier));
+     * }
+     * },
+     * MAP {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return MapGetExecutor.discover(uberspect.base(), obj.getClass(), identifier);
+     * }
+     * },
+     * LIST {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return ListGetExecutor.discover(uberspect.base(), obj.getClass(), identifier);
+     * }
+     * },
+     * DUCK {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * final Introspector is = uberspect.base();
+     * final Class<?> clazz = obj.getClass();
+     * JexlPropertyGet executor = DuckGetExecutor.discover(is, clazz, identifier);
+     * if (executor == null && identifier != null && !(identifier instanceof String)) {
+     * executor = DuckGetExecutor.discover(is, clazz, AbstractExecutor.toString(identifier));
+     * }
+     * return executor;
+     * }
+     * },
+     * FIELD {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return FieldGetExecutor.discover(uberspect.base(), obj.getClass(), AbstractExecutor.toString(identifier));
+     * }
+     * },
+     * INDEXED {
+     * @Override
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return IndexedType.discover(uberspect.base(), obj, AbstractExecutor.toString(identifier));
+     * }
+     * },
+     * ANY {};
+     * <p/>
+     * public JexlPropertyGet resolve(Uberspect uberspect, Object obj, Object identifier) {
+     * return uberspect.getPropertyGet(obj, identifier);
+     * }
+     * }
+     */
 }
diff --git a/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java b/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java
index 5db3a511..021f5b28 100644
--- a/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java
+++ b/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java
@@ -23,7 +23,7 @@ package org.apache.commons.jexl3.introspection;
  * <code>
  * ${foo.bar()}
  * </code>
- * 
+ *
  * @since 1.0
  */
 public interface JexlMethod {
@@ -51,7 +51,8 @@ public interface JexlMethod {
     Object tryInvoke(String name, Object obj, Object[] params);
 
     /**
-     * Checks whether a tryInvoke failed or not.
+     * Checks whether a tryInvoke return value indicates a failure or not.
+     * <p>Usage is : <code>Object r = tryInvoke(...); if (tryFailed(r) {...} else {...}</code>
      * @param rval the value returned by tryInvoke
      * @return true if tryInvoke failed, false otherwise
      */
@@ -60,7 +61,7 @@ public interface JexlMethod {
     /**
      * Specifies if this JexlMethod is cacheable and able to be reused for this
      * class of object it was returned for.
-     * 
+     *
      * @return true if can be reused for this class, false if not
      */
     boolean isCacheable();
diff --git a/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertyGet.java b/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertyGet.java
index 5268b9d0..5e690a7f 100644
--- a/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertyGet.java
+++ b/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertyGet.java
@@ -28,7 +28,7 @@ package org.apache.commons.jexl3.introspection;
 public interface JexlPropertyGet {
     /**
      * Method used to get the property value of an object.
-     * 
+     *
      * @param obj the object to get the property value from.
      * @return the property value.
      * @throws Exception on any error.
diff --git a/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertySet.java b/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertySet.java
index 7079834d..f25becb9 100644
--- a/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertySet.java
+++ b/src/main/java/org/apache/commons/jexl3/introspection/JexlPropertySet.java
@@ -28,7 +28,7 @@ package org.apache.commons.jexl3.introspection;
 public interface JexlPropertySet {
     /**
      * Method used to set the property value of an object.
-     * 
+     *
      * @param obj Object on which the property setter will be called with the value
      * @param arg value to be set
      * @return the value returned from the set operation (impl specific)
@@ -53,11 +53,11 @@ public interface JexlPropertySet {
      * @return true if tryInvoke failed, false otherwise
      */
     boolean tryFailed(Object rval);
-    
+
     /**
      * Specifies if this JexlPropertySet is cacheable and able to be reused for
      * this class of object it was returned for.
-     * 
+     *
      * @return true if can be reused for this class, false if not
      */
     boolean isCacheable();
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTArrayLiteral.java b/src/main/java/org/apache/commons/jexl3/parser/ASTArrayLiteral.java
index 9c72629a..0b78e77e 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTArrayLiteral.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTArrayLiteral.java
@@ -41,8 +41,7 @@ public final class ASTArrayLiteral extends JexlNode {
         return constant;
     }
 
-    /** {
-     * @inheritDoc} */
+    /** {@inheritDoc} */
     @Override
     public void jjtClose() {
         constant = true;
@@ -58,8 +57,7 @@ public final class ASTArrayLiteral extends JexlNode {
         }
     }
 
-    /** {
-     * @inheritDoc} */
+    /** {@inheritDoc} */
     @Override
     public Object jjtAccept(ParserVisitor visitor, Object data) {
         return visitor.visit(this, data);
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java
index da785234..051f8fd1 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java
@@ -19,7 +19,7 @@ package org.apache.commons.jexl3.parser;
 import org.apache.commons.jexl3.internal.Scope;
 
 /**
- * Enhanced script to allow parameters declaration.
+ * Lambda (function).
  */
 public final class ASTJexlLambda extends ASTJexlScript {
     ASTJexlLambda(int id) {
@@ -30,6 +30,10 @@ public final class ASTJexlLambda extends ASTJexlScript {
         super(p, id);
     }
 
+    public boolean isTopLevel() {
+        return parent == null;
+    }
+
     /**
      * Creates an array of arguments by copying values up to the number of parameters.
      * @param values the argument values
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
index f9de68bf..4bd8437b 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
@@ -33,6 +33,20 @@ public class ASTJexlScript extends JexlNode {
         super(p, id);
     }
 
+    /**
+     * Consider script with no parameters that return lambda as parametric-scripts.
+     * @return the script
+     */
+    public ASTJexlScript script() {
+        if (scope == null && children != null && children.length == 1 && children[0] instanceof ASTJexlLambda) {
+            ASTJexlLambda lambda = (ASTJexlLambda) children[0];
+            lambda.parent = null;
+            return lambda;
+        } else {
+            return this;
+        }
+    }
+
     @Override
     public Object jjtAccept(ParserVisitor visitor, Object data) {
         return visitor.visit(this, data);
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTNumberLiteral.java b/src/main/java/org/apache/commons/jexl3/parser/ASTNumberLiteral.java
index 5ce38fe2..df6f97ea 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTNumberLiteral.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTNumberLiteral.java
@@ -38,25 +38,27 @@ public final class ASTNumberLiteral extends JexlNode implements JexlNode.Constan
 
     @Override
     public String toString() {
+        if (literal == null || clazz == null || Double.isNaN(literal.doubleValue())) {
+            return "NaN";
+        }
         if (BigDecimal.class.equals(clazz)) {
               return BIGDF.format(literal);
-        } else {
-            StringBuilder strb = new StringBuilder(literal.toString());
-            if (clazz != null) {
-                if (Float.class.equals(clazz)) {
-                    strb.append('f');
-                } else if (Double.class.equals(clazz)) {
-                    strb.append('d');
-                } else if (BigDecimal.class.equals(clazz)) {
-                    strb.append('b');
-                } else if (BigInteger.class.equals(clazz)) {
-                    strb.append('h');
-                } else if (Long.class.equals(clazz)) {
-                    strb.append('l');
-                }
+        }
+        StringBuilder strb = new StringBuilder(literal.toString());
+        if (clazz != null) {
+            if (Float.class.equals(clazz)) {
+                strb.append('f');
+            } else if (Double.class.equals(clazz)) {
+                strb.append('d');
+            } else if (BigDecimal.class.equals(clazz)) {
+                strb.append('b');
+            } else if (BigInteger.class.equals(clazz)) {
+                strb.append('h');
+            } else if (Long.class.equals(clazz)) {
+                strb.append('l');
             }
-            return strb.toString();
         }
+        return strb.toString();
     }
 
     @Override
@@ -136,7 +138,7 @@ public final class ASTNumberLiteral extends JexlNode implements JexlNode.Constan
     void setReal(String s) {
         Number result;
         Class<?> rclass;
-        if ("#NaN".equals(s)) {
+        if ("#NaN".equals(s) || "NaN".equals(s)) {
             result = Double.NaN;
             rclass = Double.class;
         } else {
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTVar.java b/src/main/java/org/apache/commons/jexl3/parser/ASTVar.java
index 03697d3c..6fbcb2d1 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTVar.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTVar.java
@@ -27,7 +27,7 @@ public class ASTVar extends ASTIdentifier {
     public ASTVar(Parser p, int id) {
         super(p, id);
     }
-    
+
     @Override
     public Object jjtAccept(ParserVisitor visitor, Object data) {
         return visitor.visit(this, data);
diff --git a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
index 40b5a4f0..36e1a033 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
@@ -38,7 +38,7 @@ import org.apache.commons.jexl3.internal.Scope;
 
 public final class Parser extends JexlParser
 {
-    public ASTJexlScript parse(JexlInfo info, String jexlSrc, Scope scope, boolean registers) {
+    public ASTJexlScript parse(JexlInfo info, String jexlSrc, Scope scope, boolean registers, boolean expr) {
         try {
             // If registers are allowed, the default parser state has to be REGISTERS.
             if (registers || ALLOW_REGISTERS) {
@@ -48,7 +48,7 @@ public final class Parser extends JexlParser
             source = jexlSrc;
             ReInit(new java.io.StringReader(jexlSrc));
             frame = scope;
-            ASTJexlScript script = JexlScript(scope);
+            ASTJexlScript script = expr? JexlExpression(scope) : JexlScript(scope) ;
             script.value = info;
             return script;
         } catch (TokenMgrError xtme) {
@@ -159,6 +159,10 @@ PARSER_END(Parser)
 /***************************************
  *     Identifier & String tokens
  ***************************************/
+<*> TOKEN :  /* NaN */
+{
+    < NAN_LITERAL : "NaN" >
+}
 
 <*> TOKEN : /* IDENTIFIERS */
 {
@@ -205,7 +209,19 @@ ASTJexlScript JexlScript(Scope frame) : {
 }
 {
    ( Statement() )* <EOF>
-   { return jjtThis;}
+   {
+        return jjtThis.script();
+   }
+}
+
+ASTJexlScript JexlExpression(Scope frame) #JexlScript : {
+    jjtThis.setScope(frame);
+}
+{
+   ( Expression() )? <EOF>
+   {
+        return jjtThis.script();
+   }
 }
 
 void Statement() #void : {}
@@ -452,6 +468,14 @@ void Literal() #void :
   StringLiteral()
 |
   NullLiteral()
+|
+  NaNLiteral()
+}
+
+void NaNLiteral() #NumberLiteral :
+{}
+{
+    <NAN_LITERAL> { jjtThis.setReal("NaN"); }
 }
 
 void NullLiteral() : {}
@@ -535,6 +559,15 @@ void Arguments() #Arguments : {}
      <LPAREN> (Expression() (<COMMA> Expression())* )? <RPAREN>
 }
 
+void FunctionCallLookahead() #void : {}
+{
+    LOOKAHEAD(4) <IDENTIFIER> <COLON> <IDENTIFIER> <LPAREN>
+    |
+    LOOKAHEAD(2) <IDENTIFIER> <LPAREN>
+    |
+    LOOKAHEAD(2) <REGISTER> <LPAREN>
+}
+
 void FunctionCall() #void : {}
 {
       LOOKAHEAD(2) Identifier() <COLON> Identifier() Arguments() #FunctionNode(3)
@@ -627,7 +660,7 @@ void PrimaryExpression() #void : {}
     |
        LOOKAHEAD( <NEW> ) Constructor()
     |
-       LOOKAHEAD(2) FunctionCall()
+       LOOKAHEAD( FunctionCallLookahead() ) FunctionCall()
     |
        Identifier(true)
     |
diff --git a/src/main/java/org/apache/commons/jexl3/parser/StringParser.java b/src/main/java/org/apache/commons/jexl3/parser/StringParser.java
index bc3bfbd3..8cb4b9d6 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/StringParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/StringParser.java
@@ -205,5 +205,5 @@ public class StringParser {
         strb.append(delim);
         return strb.toString();
     }
-    
+
 }
\ No newline at end of file
diff --git a/src/main/java/org/apache/commons/jexl3/scripting/JexlScriptEngine.java b/src/main/java/org/apache/commons/jexl3/scripting/JexlScriptEngine.java
index 64384fc0..78c9fe47 100644
--- a/src/main/java/org/apache/commons/jexl3/scripting/JexlScriptEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/scripting/JexlScriptEngine.java
@@ -38,8 +38,8 @@ import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.JexlScript;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
 
 /**
  * Implements the Jexl ScriptEngine for JSF-223.
@@ -62,7 +62,7 @@ import org.apache.commons.logging.LogFactory;
  */
 public class JexlScriptEngine extends AbstractScriptEngine implements Compilable {
     /** The logger. */
-    private static final Log LOG = LogFactory.getLog(JexlScriptEngine.class);
+    private static final Logger LOG = LogManager.getLogger(JexlScriptEngine.class);
 
     /** The shared expression cache size. */
     private static final int CACHE_SIZE = 512;
@@ -169,7 +169,7 @@ public class JexlScriptEngine extends AbstractScriptEngine implements Compilable
          * Gives access to the engine logger.
          * @return the JexlScriptEngine logger
          */
-        public Log getLogger() {
+        public Logger getLogger() {
             return LOG;
         }
     }
diff --git a/src/main/java/org/apache/commons/jexl3/scripting/Main.java b/src/main/java/org/apache/commons/jexl3/scripting/Main.java
index 503e1b1f..4da15305 100644
--- a/src/main/java/org/apache/commons/jexl3/scripting/Main.java
+++ b/src/main/java/org/apache/commons/jexl3/scripting/Main.java
@@ -32,16 +32,16 @@ public class Main {
 
     /**
      * Test application for JexlScriptEngine (JSR-223 implementation).
-     * 
+     *
      * If a single argument is present, it is treated as a filename of a JEXL
      * script to be evaluated. Any exceptions terminate the application.
-     * 
+     *
      * Otherwise, lines are read from standard input and evaluated.
      * ScriptExceptions are logged, and do not cause the application to exit.
      * This is done so that interactive testing is easier.
-     * 
+     *
      * @param args (optional) filename to evaluate. Stored in the args variable.
-     * 
+     *
      * @throws Exception if parsing or IO fail
      */
     public static void main(String[] args) throws Exception {
diff --git a/src/site/xdoc/changes.xml b/src/site/xdoc/changes.xml
index 8e905bb4..43d7f8e8 100644
--- a/src/site/xdoc/changes.xml
+++ b/src/site/xdoc/changes.xml
@@ -25,7 +25,55 @@
         <author email="dev@commons.apache.org">Commons Developers</author>
     </properties>
     <body>
-        <release version="3.0" date="2012-09-30">
+        <release version="3.0.1" date="unreleased">
+            <action dev="henrib" type="fix" >
+                Fixed issue in edge case method resolution wrt overload and varargs
+            </action>
+            <action dev="henrib" type="add" >
+                Switch logging to log4j 1.2
+            </action>
+            <action dev="henrib" type="fix" issue="JEXL-144" due-to="Woonsang Ko">
+                Empty array property setting fails
+            </action>
+            <action dev="henrib" type="fix" issue="JEXL-142" due-to="Juozas Baliuks">
+                Map expression issue with empty key
+            </action>
+            <action dev="henrib" type="fix" issue="JEXL-141" due-to="Harpreet Singh">
+                Suffix for Big Decimal and Big Integer Literal is incorrectly mentioned in Java docs
+            </action>
+            <action dev="henrib" type="fix" issue="JEXL-137">
+                Invalid script variable list for nested array/map access
+            </action>
+            <action dev="henrib" type="fix">
+                Fixed Engine.getVariables that was erroneously considering method calls as variable usage
+            </action>
+            <action dev="henrib" type="fix">
+                Fixed issue in ternary expression
+                (grammar was not precise enough to differentiate namespace:function calls vs ternary right hand side)
+            </action>
+            <action dev="henrib" type="add">
+                NaN is now a keyword equivalent to #NaN (deprecated): POTENTIAL SCRIPT BREAK!
+            </action>
+            <action dev="henrib" type="add">
+                Syntactically enforce that expressions do not contain statements: POTENTIAL EXPRESSION BREAK!
+                (ie an expression is not a script and can NOT use 'if','for'... and blocks)
+            </action>
+           <action dev="henrib" type="add">
+                Added syntactic shortcut to create parametric scripts (script source creates an anonymous function)
+            </action>
+            <action dev="henrib" type="fix">
+                Segregated JexlScript and JexlExpression further to avoid calling JexlExpression.evaluate on JexlScript
+                (instead of JexlScript.execute) which had the unexpected property of only evaluating the first statement
+            </action>
+            <action dev="henrib" type="fix">
+                Fix an edge case of ambiguous method matching (see http://apache-commons.680414.n4.nabble.com/jexl-mathod-within-namespace-not-found-if-parameter-is-int-tt4637888.html)
+            </action>
+            <action dev="henrib" type="fix">
+                Fix issue wrt isEmpty and method varargs (assignable types vs equal types)
+                (see http://apache-commons.680414.n4.nabble.com/jexl-empty-function-crashes-if-called-with-int-tt4637895.html)
+            </action>
+        </release>
+        <release version="3.0" date="unreleased">
             <action dev="henrib" type="add" issue="JEXL-133" due-to="Alfred Reibenschuh">
                 String matching Operator short-hand inspired by CSS3
             </action>
diff --git a/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java b/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java
index fca06608..516f5788 100644
--- a/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java
@@ -352,9 +352,15 @@ public class ArithmeticTest extends JexlTestCase {
         script = jexl.createScript("#NaN");
         result = script.execute(null);
         assertTrue(Double.isNaN((Double) result));
+        script = jexl.createScript("NaN");
+        result = script.execute(null);
+        assertTrue(Double.isNaN((Double) result));
         script = jexl.createScript("double:isNaN(#NaN)");
         result = script.execute(null);
         assertTrue((Boolean) result);
+        script = jexl.createScript("double:isNaN(NaN)");
+        result = script.execute(null);
+        assertTrue((Boolean) result);
     }
 
     public static class EmptyTestContext extends MapContext implements JexlContext.NamespaceResolver {
@@ -405,4 +411,4 @@ public class ArithmeticTest extends JexlTestCase {
             assertEquals("failed on " + stext, expected, result);
         }
     }
-}
+}
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java b/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java
index d14f758e..39e4df09 100644
--- a/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java
@@ -27,7 +27,7 @@ public class ArrayLiteralTest extends JexlTestCase {
     public ArrayLiteralTest() {
         super("ArrayLiteralTest");
     }
-    
+
     public void testLiteralWithStrings() throws Exception {
         JexlExpression e = JEXL.createExpression( "[ 'foo' , 'bar' ]" );
         JexlContext jc = new MapContext();
@@ -63,7 +63,7 @@ public class ArrayLiteralTest extends JexlTestCase {
             "[ 10 , null , 10]",
             "[ '10' , null ]",
             "[ null, '10' , null ]"
-        }; 
+        };
         Object [][]checks = {
             {null, new Integer(10)},
             {new Integer(10), null},
diff --git a/src/test/java/org/apache/commons/jexl3/BitwiseOperatorTest.java b/src/test/java/org/apache/commons/jexl3/BitwiseOperatorTest.java
index f3e311fe..22585c60 100644
--- a/src/test/java/org/apache/commons/jexl3/BitwiseOperatorTest.java
+++ b/src/test/java/org/apache/commons/jexl3/BitwiseOperatorTest.java
@@ -38,7 +38,7 @@ public class BitwiseOperatorTest extends JexlTestCase {
     public BitwiseOperatorTest(String name) {
         super(name);
     }
-    
+
     public void testAndWithTwoNulls() throws Exception {
         asserter.assertExpression("null & null", new Long(0));
     }
@@ -70,7 +70,7 @@ public class BitwiseOperatorTest extends JexlTestCase {
     public void testComplementWithNull() throws Exception {
         asserter.assertExpression("~null", new Long(-1));
     }
-    
+
     public void testComplementSimple() throws Exception {
         asserter.assertExpression("~128", new Long(-129));
     }
diff --git a/src/test/java/org/apache/commons/jexl3/BlockTest.java b/src/test/java/org/apache/commons/jexl3/BlockTest.java
index a33d4506..1621611f 100644
--- a/src/test/java/org/apache/commons/jexl3/BlockTest.java
+++ b/src/test/java/org/apache/commons/jexl3/BlockTest.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -24,7 +24,7 @@ public class BlockTest extends JexlTestCase {
 
     /**
      * Create the test
-     * 
+     *
      * @param testName name of the test
      */
     public BlockTest(String testName) {
@@ -32,46 +32,46 @@ public class BlockTest extends JexlTestCase {
     }
 
     public void testBlockSimple() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) { 'hello'; }");
+        JexlScript e = JEXL.createScript("if (true) { 'hello'; }");
         JexlContext jc = new MapContext();
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is wrong", "hello", o);
     }
 
     public void testBlockExecutesAll() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) { x = 'Hello'; y = 'World';}");
+        JexlScript e = JEXL.createScript("if (true) { x = 'Hello'; y = 'World';}");
         JexlContext jc = new MapContext();
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("First result is wrong", "Hello", jc.get("x"));
         assertEquals("Second result is wrong", "World", jc.get("y"));
         assertEquals("Block result is wrong", "World", o);
     }
 
     public void testEmptyBlock() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) { }");
+        JexlScript e = JEXL.createScript("if (true) { }");
         JexlContext jc = new MapContext();
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertNull("Result is wrong", o);
     }
 
     public void testBlockLastExecuted01() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) { x = 1; } else { x = 2; }");
+        JexlScript e = JEXL.createScript("if (true) { x = 1; } else { x = 2; }");
         JexlContext jc = new MapContext();
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Block result is wrong", new Integer(1), o);
     }
 
     public void testBlockLastExecuted02() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (false) { x = 1; } else { x = 2; }");
+        JexlScript e = JEXL.createScript("if (false) { x = 1; } else { x = 2; }");
         JexlContext jc = new MapContext();
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Block result is wrong", new Integer(2), o);
     }
 
     public void testNestedBlock() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) { x = 'hello'; y = 'world';" + " if (true) { x; } y; }");
+        JexlScript e = JEXL.createScript("if (true) { x = 'hello'; y = 'world';" + " if (true) { x; } y; }");
         JexlContext jc = new MapContext();
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Block result is wrong", "world", o);
     }
 }
diff --git a/src/test/java/org/apache/commons/jexl3/ClassCreator.java b/src/test/java/org/apache/commons/jexl3/ClassCreator.java
index 70f655d2..49805ca6 100644
--- a/src/test/java/org/apache/commons/jexl3/ClassCreator.java
+++ b/src/test/java/org/apache/commons/jexl3/ClassCreator.java
@@ -37,6 +37,9 @@ public class ClassCreator {
     private String sourceName = null;
     private ClassLoader loader = null;
     public static final boolean canRun = comSunToolsJavacMain();
+
+    static final String GEN_PATH = "/org/apache/commons/jexl3/generated";
+    static final String GEN_CLASS = "org.apache.commons.jexl3.generated.";
     /**
      * Check if we can invoke Sun's java compiler.
      * @return true if it is possible, false otherwise
@@ -69,17 +72,17 @@ public class ClassCreator {
         seed = s;
         className = "foo" + s;
         sourceName = className + ".java";
-        packageDir = new File(base, seed + "/org/apache/commons/jexl3/generated");
+        packageDir = new File(base, seed + GEN_PATH);
         packageDir.mkdirs();
         loader = null;
     }
 
     public String getClassName() {
-        return "org.apache.commons.jexl3.generated." + className;
+        return GEN_CLASS + className;
     }
 
     public Class<?> getClassInstance() throws Exception {
-        return getClassLoader().loadClass("org.apache.commons.jexl3.generated." + className);
+        return getClassLoader().loadClass(getClassName());
     }
 
     public ClassLoader getClassLoader() throws Exception {
@@ -128,7 +131,16 @@ public class ClassCreator {
         if (javac == null) {
             return null;
         }
-        Integer r = (Integer) jexl.invokeMethod(javac, "compile", source);
+        Integer r;
+        try {
+            r = (Integer) jexl.invokeMethod(javac, "compile", source);
+            if (r.intValue() >= 0) {
+                return getClassLoader().loadClass("org.apache.commons.jexl3.generated." + className);
+            }
+        } catch (JexlException xignore) {
+            // ignore
+        }
+        r = (Integer) jexl.invokeMethod(javac, "compile", (Object) new String[]{source});
         if (r.intValue() >= 0) {
             return getClassLoader().loadClass("org.apache.commons.jexl3.generated." + className);
         }
diff --git a/src/test/java/org/apache/commons/jexl3/ClassCreatorTest.java b/src/test/java/org/apache/commons/jexl3/ClassCreatorTest.java
index 5945e711..d4a90d84 100644
--- a/src/test/java/org/apache/commons/jexl3/ClassCreatorTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ClassCreatorTest.java
@@ -24,14 +24,14 @@ import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
 
 /**
  * Basic check on automated class creation
  */
 public class ClassCreatorTest extends JexlTestCase {
-    static final Log logger = LogFactory.getLog(JexlTestCase.class);
+    static final Logger logger = LogManager.getLogger(JexlTestCase.class);
     static final int LOOPS = 8;
     private File base = null;
     private JexlEngine jexl = null;
diff --git a/src/test/java/org/apache/commons/jexl3/ContextNamespaceTest.java b/src/test/java/org/apache/commons/jexl3/ContextNamespaceTest.java
new file mode 100644
index 00000000..59e425dc
--- /dev/null
+++ b/src/test/java/org/apache/commons/jexl3/ContextNamespaceTest.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.jexl3;
+
+import org.apache.commons.jexl3.internal.Engine;
+/**
+ * Tests JexlContext (advanced) features.
+ */
+public class ContextNamespaceTest extends JexlTestCase {
+
+    public ContextNamespaceTest(String testName) {
+        super(testName);
+    }
+
+    /*
+     * Accesses the thread context and cast it.
+     */
+    public static class Taxes {
+        public double vat(double n) {
+            TaxesContext context = (TaxesContext) JexlEngine.getThreadContext();
+            return n * context.getVAT() / 100.;
+        }
+    }
+
+    /**
+     * A thread local context carrying a namespace and some inner constants.
+     */
+    public static class TaxesContext extends MapContext implements JexlContext.ThreadLocal, JexlContext.NamespaceResolver {
+        private final Taxes taxes = new Taxes();
+        private final double vat;
+        TaxesContext(double vat) {
+            this.vat = vat;
+        }
+        @Override
+        public Object resolveNamespace(String name) {
+           return "taxes".equals(name)? taxes : null;
+        }
+        public double getVAT() {
+            return vat;
+        }
+    }
+
+    public void testThreadedContext() throws Exception {
+        JexlEngine jexl = new Engine();
+        TaxesContext context = new TaxesContext(18.6);
+        String strs = "taxes:vat(1000)";
+        JexlScript staxes = jexl.createScript(strs);
+        Object result = staxes.execute(context);
+        assertEquals(186., result);
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/jexl3/Foo.java b/src/test/java/org/apache/commons/jexl3/Foo.java
index fe90ca0f..6b69b03e 100644
--- a/src/test/java/org/apache/commons/jexl3/Foo.java
+++ b/src/test/java/org/apache/commons/jexl3/Foo.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -22,11 +22,11 @@ import java.util.List;
 
 /**
  * A simple bean used for testing purposes
- * 
+ *
  * @since 1.0
  */
 public class Foo {
-    
+
     private boolean beenModified = false;
     private String property1 = "some value";
     public Foo() {}
@@ -35,7 +35,7 @@ public class Foo {
             return getCheeseList().iterator();
         }
     }
-    
+
     public String bar()
     {
         return JexlTest.METHOD_STRING;
@@ -115,7 +115,7 @@ public class Foo {
     {
         return 22;
     }
-    
+
     public String getProperty1() {
         return property1;
     }
diff --git a/src/test/java/org/apache/commons/jexl3/ForEachTest.java b/src/test/java/org/apache/commons/jexl3/ForEachTest.java
index 4b552e6d..8c9bac13 100644
--- a/src/test/java/org/apache/commons/jexl3/ForEachTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ForEachTest.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -36,102 +36,102 @@ public class ForEachTest extends JexlTestCase {
     }
 
     public void testForEachWithEmptyStatement() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) ;");
+        JexlScript e = JEXL.createScript("for(item : list) ;");
         JexlContext jc = new MapContext();
         jc.set("list", Collections.emptyList());
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertNull("Result is not null", o);
     }
 
     public void testForEachWithEmptyList() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) 1+1");
+        JexlScript e = JEXL.createScript("for(item : list) 1+1");
         JexlContext jc = new MapContext();
         jc.set("list", Collections.emptyList());
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertNull("Result is not null", o);
     }
 
     public void testForEachWithArray() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) item");
+        JexlScript e = JEXL.createScript("for(item : list) item");
         JexlContext jc = new MapContext();
         jc.set("list", new Object[] {"Hello", "World"});
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "World", o);
     }
 
     public void testForEachWithCollection() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) item");
+        JexlScript e = JEXL.createScript("for(item : list) item");
         JexlContext jc = new MapContext();
         jc.set("list", Arrays.asList(new Object[] {"Hello", "World"}));
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "World", o);
     }
 
     public void testForEachWithEnumeration() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) item");
+        JexlScript e = JEXL.createScript("for(item : list) item");
         JexlContext jc = new MapContext();
         jc.set("list", new StringTokenizer("Hello,World", ","));
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "World", o);
     }
 
     public void testForEachWithIterator() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) item");
+        JexlScript e = JEXL.createScript("for(item : list) item");
         JexlContext jc = new MapContext();
         jc.set("list", Arrays.asList(new Object[] {"Hello", "World"}).iterator());
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "World", o);
     }
 
     public void testForEachWithMap() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list) item");
+        JexlScript e = JEXL.createScript("for(item : list) item");
         JexlContext jc = new MapContext();
         Map<?, ?> map = System.getProperties();
         String lastProperty = (String) new ArrayList<Object>(map.values()).get(System.getProperties().size() - 1);
         jc.set("list", map);
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", lastProperty, o);
     }
 
     public void testForEachWithBlock() throws Exception {
-        JexlExpression exs0 = JEXL.createExpression("for(in : list) { x = x + in; }");
-        JexlExpression exs1 = JEXL.createExpression("foreach(item in list) { x = x + item; }");
-        JexlExpression []exs = { exs0, exs1 };
+        JexlScript exs0 = JEXL.createScript("for(in : list) { x = x + in; }");
+        JexlScript exs1 = JEXL.createScript("foreach(item in list) { x = x + item; }");
+        JexlScript []exs = { exs0, exs1 };
         JexlContext jc = new MapContext();
         jc.set("list", new Object[] {"2", "3"});
         for(int ex = 0; ex < exs.length; ++ex) {
             jc.set("x", new Integer(1));
-            Object o = exs[ex].evaluate(jc);
+            Object o = exs[ex].execute(jc);
             assertEquals("Result is wrong", new Integer(6), o);
             assertEquals("x is wrong", new Integer(6), jc.get("x"));
         }
     }
 
     public void testForEachWithListExpression() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list.keySet()) item");
+        JexlScript e = JEXL.createScript("for(item : list.keySet()) item");
         JexlContext jc = new MapContext();
         Map<?, ?> map = System.getProperties();
         String lastKey = (String) new ArrayList<Object>(map.keySet()).get(System.getProperties().size() - 1);
         jc.set("list", map);
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", lastKey, o);
     }
-    
+
     public void testForEachWithProperty() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list.cheeseList) item");
+        JexlScript e = JEXL.createScript("for(item : list.cheeseList) item");
         JexlContext jc = new MapContext();
         jc.set("list", new Foo());
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "brie", o);
     }
-    
+
     public void testForEachWithIteratorMethod() throws Exception {
-        JexlExpression e = JEXL.createExpression("for(item : list.cheezy) item");
+        JexlScript e = JEXL.createScript("for(item : list.cheezy) item");
         JexlContext jc = new MapContext();
         jc.set("list", new Foo());
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "brie", o);
     }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/jexl3/IfTest.java b/src/test/java/org/apache/commons/jexl3/IfTest.java
index 80019ab0..e4a42352 100644
--- a/src/test/java/org/apache/commons/jexl3/IfTest.java
+++ b/src/test/java/org/apache/commons/jexl3/IfTest.java
@@ -32,10 +32,10 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testSimpleIfTrue() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) 1");
+        JexlScript e = JEXL.createScript("if (true) 1");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not 1", new Integer(1), o);
     }
 
@@ -45,10 +45,10 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testSimpleIfFalse() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (false) 1");
+        JexlScript e = JEXL.createScript("if (false) 1");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertNull("Return value is not empty", o);
     }
 
@@ -58,10 +58,10 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testSimpleElse() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (false) 1 else 2;");
+        JexlScript e = JEXL.createScript("if (false) 1 else 2;");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not 2", new Integer(2), o);
     }
 
@@ -71,10 +71,10 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testBlockIfTrue() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (true) { 'hello'; }");
+        JexlScript e = JEXL.createScript("if (true) { 'hello'; }");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is wrong", "hello", o);
     }
 
@@ -84,10 +84,10 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testBlockElse() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (false) {1} else {2 ; 3}");
+        JexlScript e = JEXL.createScript("if (false) {1} else {2 ; 3}");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is wrong", new Integer(3), o);
     }
 
@@ -97,11 +97,11 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testIfWithSimpleExpression() throws Exception {
-        JexlExpression e = JEXL.createExpression("if (x == 1) true;");
+        JexlScript e = JEXL.createScript("if (x == 1) true;");
         JexlContext jc = new MapContext();
         jc.set("x", new Integer(1));
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not true", Boolean.TRUE, o);
     }
 
@@ -111,11 +111,11 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testIfWithArithmeticExpression() throws Exception {
-        JexlExpression e = JEXL.createExpression("if ((x * 2) + 1 == 5) true;");
+        JexlScript e = JEXL.createScript("if ((x * 2) + 1 == 5) true;");
         JexlContext jc = new MapContext();
         jc.set("x", new Integer(2));
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not true", Boolean.TRUE, o);
     }
 
@@ -125,11 +125,11 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testIfWithDecimalArithmeticExpression() throws Exception {
-        JexlExpression e = JEXL.createExpression("if ((x * 2) == 5) true");
+        JexlScript e = JEXL.createScript("if ((x * 2) == 5) true");
         JexlContext jc = new MapContext();
         jc.set("x", new Float(2.5f));
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is not true", Boolean.TRUE, o);
     }
 
@@ -139,11 +139,11 @@ public class IfTest extends JexlTestCase {
      * @throws Exception on any error
      */
     public void testIfWithAssignment() throws Exception {
-        JexlExpression e = JEXL.createExpression("if ((x * 2) == 5) {y = 1} else {y = 2;}");
+        JexlScript e = JEXL.createScript("if ((x * 2) == 5) {y = 1} else {y = 2;}");
         JexlContext jc = new MapContext();
         jc.set("x", new Float(2.5f));
 
-        e.evaluate(jc);
+        e.execute(jc);
         Object result = jc.get("y");
         assertEquals("y has the wrong value", new Integer(1), result);
     }
diff --git a/src/test/java/org/apache/commons/jexl3/IssuesTest.java b/src/test/java/org/apache/commons/jexl3/IssuesTest.java
index c3727c53..52803720 100644
--- a/src/test/java/org/apache/commons/jexl3/IssuesTest.java
+++ b/src/test/java/org/apache/commons/jexl3/IssuesTest.java
@@ -23,10 +23,15 @@ import java.math.MathContext;
 import java.util.HashMap;
 import java.util.Map;
 import org.apache.commons.jexl3.internal.introspection.Uberspect;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import org.junit.Assert;
 import org.junit.Test;
 
 /**
- * Test cases for reported issues
+ * Test cases for reported issue .
  */
 @SuppressWarnings("boxing")
 public class IssuesTest extends JexlTestCase {
@@ -196,11 +201,11 @@ public class IssuesTest extends JexlTestCase {
         ctxt.set("a", null);
 
         String[] exprs = {
-            "10 + null",
-            "a - 10",
-            "b * 10",
-            "a % b",
-            "1000 / a"
+            //"10 + null",
+            //"a - 10",
+            //"b * 10",
+            "a % b"//,
+        //"1000 / a"
         };
         for (int e = 0; e < exprs.length; ++e) {
             try {
@@ -501,35 +506,35 @@ public class IssuesTest extends JexlTestCase {
     }
 
     public void test108() throws Exception {
-        JexlExpression expr;
+        JexlScript expr;
         Object value;
         JexlEngine jexl = new Engine();
-        expr = jexl.createExpression("size([])");
-        value = expr.evaluate(null);
+        expr = jexl.createScript("size([])");
+        value = expr.execute(null);
         assertEquals(0, value);
-        expr = jexl.createExpression(expr.getParsedText());
-        value = expr.evaluate(null);
+        expr = jexl.createScript(expr.getParsedText());
+        value = expr.execute(null);
         assertEquals(0, value);
 
-        expr = jexl.createExpression("if (true) { [] } else { {:} }");
-        value = expr.evaluate(null);
+        expr = jexl.createScript("if (true) { [] } else { {:} }");
+        value = expr.execute(null);
         assertTrue(value.getClass().isArray());
-        expr = jexl.createExpression(expr.getParsedText());
-        value = expr.evaluate(null);
+        expr = jexl.createScript(expr.getParsedText());
+        value = expr.execute(null);
         assertTrue(value.getClass().isArray());
 
-        expr = jexl.createExpression("size({:})");
-        value = expr.evaluate(null);
+        expr = jexl.createScript("size({:})");
+        value = expr.execute(null);
         assertEquals(0, value);
-        expr = jexl.createExpression(expr.getParsedText());
-        value = expr.evaluate(null);
+        expr = jexl.createScript(expr.getParsedText());
+        value = expr.execute(null);
         assertEquals(0, value);
 
-        expr = jexl.createExpression("if (false) { [] } else { {:} }");
-        value = expr.evaluate(null);
+        expr = jexl.createScript("if (false) { [] } else { {:} }");
+        value = expr.execute(null);
         assertTrue(value instanceof Map<?, ?>);
-        expr = jexl.createExpression(expr.getParsedText());
-        value = expr.evaluate(null);
+        expr = jexl.createScript(expr.getParsedText());
+        value = expr.execute(null);
         assertTrue(value instanceof Map<?, ?>);
     }
 
@@ -660,6 +665,10 @@ public class IssuesTest extends JexlTestCase {
         public String method() {
             return "OK";
         }
+
+        public String total(String tt) {
+            return "total " + tt;
+        }
     }
 
     public static class Foo125Context extends ObjectContext<Foo125> {
@@ -892,4 +901,172 @@ public class IssuesTest extends JexlTestCase {
         result = expr.evaluate(jc);
         assertEquals("EXPR01 result", 22, result);
     }
+
+    public void test137() throws Exception {
+        JexlEngine jexl = new Engine();
+        JexlContext jc = new MapContext();
+        JexlScript script;
+        JexlExpression expr;
+        Object result;
+
+        script = jexl.createScript("(x)->{ x }");
+        Assert.assertArrayEquals(new String[]{"x"}, script.getParameters());
+        result = script.execute(null, 42);
+        Assert.assertEquals(42, result);
+    }
+
+//    public void test138() throws Exception {
+//        MapContext ctxt = new MapContext();
+//        ctxt.set("tz", java.util.TimeZone.class);
+//        String source = ""
+//                + "var currentDate = new('java.util.Date');"
+//                +  "var gmt = tz.getTimeZone('GMT');"
+//                +  "var cet = tz.getTimeZone('CET');"
+//                +  "var calendarGMT = new('java.util.GregorianCalendar' , gmt);"
+//                +  "var calendarCET = new('java.util.GregorianCalendar', cet);"
+//                +  "var diff = calendarCET.getTime() - calendarGMT.getTime();"
+//                + "return diff";
+//
+//        JexlEngine jexl = new Engine();
+//        JexlScript script = jexl.createScript(source);
+//        Object result = script.execute(ctxt);
+//        Assert.assertNotNull(result);
+//    }
+    public void test142() throws Exception {
+        JexlEngine jexl = new Engine();
+        JexlContext jc = new MapContext();
+        JexlScript script;
+        Object result;
+
+        script = jexl.createScript("map['']", "map");
+        result = script.execute(jc, Collections.singletonMap("", 42));
+        Assert.assertEquals(42, result);
+    }
+
+    public void test143() throws Exception {
+        JexlEngine jexl = new Engine();
+        JexlContext jc = new MapContext();
+        JexlScript script;
+        Object result;
+
+        script = jexl.createScript("var total = 10; total = (total - ((x < 3)? y : z)) / (total / 10); total", "x", "y", "z");
+        result = script.execute(jc, 2, 2, 1);
+        Assert.assertEquals(8, result);
+        script = jexl.createScript("var total = 10; total = (total - ((x < 3)? y : 1)) / (total / 10); total", "x", "y", "z");
+        result = script.execute(jc, 2, 2, 1);
+        Assert.assertEquals(8, result);
+    }
+
+    public void test144() throws Exception {
+        JexlEngine jexl = new Engine();
+        JexlContext jc = new MapContext();//ObjectContext<Foo125>(jexl, new Foo125());
+        JexlScript script;
+        Object result;
+        script = jexl.createScript("var total = 10; total('tt')");
+        try {
+            result = script.execute(jc);
+            Assert.fail("total() is not solvable");
+        } catch (JexlException.Method ambiguous) {
+            Assert.assertEquals("total", ambiguous.getMethod());
+        }
+        jc = new ObjectContext<Foo125>(jexl, new Foo125());
+        try {
+            result = script.execute(jc);
+        } catch (JexlException.Method ambiguous) {
+            Assert.fail("total() is solvable");
+        }
+    }
+
+    public void test145() throws Exception {
+        JexlEngine jexl = new Engine();
+        JexlContext jc = new MapContext();
+        JexlScript script = jexl.createScript("sum(TOTAL) - partial.sum() + partial['sub'].avg() - sum(partial.sub)");
+        Set<List<String>> vars = script.getVariables();
+
+        Assert.assertTrue(vars.size() == 3);
+    }
+
+    public void test143apache() throws Exception {
+        JexlEngine jexl = new Engine();
+        JexlExpression e = jexl.createExpression("9223372036854775806.5B");
+        JexlContext context = new MapContext();
+        String res = String.valueOf(e.evaluate(context));
+        Assert.assertEquals("9223372036854775806.5", res);
+    }
+
+    /**
+     * Test cases for empty array assignment.
+     */
+    public static class Quux144 {
+        String[] arr;
+        String[] arr2;
+
+        public Quux144() {
+        }
+
+        public String[] getArr() {
+            return arr;
+        }
+
+        public String[] getArr2() {
+            return arr2;
+        }
+
+        public void setArr(String[] arr) {
+            this.arr = arr;
+        }
+
+        public void setArr2(String[] arr2) {
+            this.arr2 = arr2;
+        }
+
+        // Overloaded setter with different argument type.
+        public void setArr2(Integer[] arr2) {
+        }
+    }
+
+    public void test144apache() throws Exception {
+        JexlEngine JEXL = new Engine();
+        JexlContext jc = new MapContext();
+        jc.set("quuxClass", Quux144.class);
+        JexlExpression create = JEXL.createExpression("quux = new(quuxClass)");
+        JexlExpression assignArray = JEXL.createExpression("quux.arr = [ 'hello', 'world' ]");
+        JexlExpression checkArray = JEXL.createExpression("quux.arr");
+
+        // test with a string
+        Quux144 quux = (Quux144) create.evaluate(jc);
+        assertNotNull("quux is null", quux);
+
+        // test with a nonempty string array
+        Object o = assignArray.evaluate(jc);
+        assertEquals("Result is not a string array", String[].class, o.getClass());
+        o = checkArray.evaluate(jc);
+        assertEquals("The array elements are equal", Arrays.asList("hello", "world"), Arrays.asList((String[]) o));
+
+        // test with a null array
+        assignArray = JEXL.createExpression("quux.arr = null");
+        o = assignArray.evaluate(jc);
+        assertNull("Result is not null", o);
+        o = checkArray.evaluate(jc);
+        assertNull("Result is not null", o);
+
+        // test with an empty array
+        assignArray = JEXL.createExpression("quux.arr = [ ]");
+        o = assignArray.evaluate(jc);
+        assertNotNull("Result is null", o);
+        o = checkArray.evaluate(jc);
+        assertEquals("The array elements are not equal", Arrays.asList(new String[0]), Arrays.asList((String[]) o));
+        assertEquals("The array size is not zero", 0, ((String[]) o).length);
+
+        // test with an empty array on the overloaded setter for different types.
+        // so, the assignment should fail with logging 'The ambiguous property, arr2, should have failed.'
+        try {
+            assignArray = JEXL.createExpression("quux.arr2 = [ ]");
+            o = assignArray.evaluate(jc);
+            fail("The arr2 property shouldn't be set due to its ambiguity (overloaded setters with different types).");
+        } catch (JexlException.Property e) {
+            //System.out.println("Expected ambiguous property setting exception: " + e);
+        }
+        assertNull("The arr2 property value should remain as null, not an empty array.", quux.arr2);
+    }
 }
diff --git a/src/test/java/org/apache/commons/jexl3/JXLTTest.java b/src/test/java/org/apache/commons/jexl3/JXLTTest.java
index f84f51af..ec6ffe3b 100644
--- a/src/test/java/org/apache/commons/jexl3/JXLTTest.java
+++ b/src/test/java/org/apache/commons/jexl3/JXLTTest.java
@@ -16,8 +16,8 @@
  */
 package org.apache.commons.jexl3;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
 
 import java.io.PrintWriter;
 import java.io.StringReader;
@@ -34,7 +34,7 @@ import java.util.Set;
 public class JXLTTest extends JexlTestCase {
     private static final JexlEngine ENGINE = new JexlBuilder().silent(false).cache(128).strict(true).create();
     private static final JxltEngine JXLT = ENGINE.createJxltEngine();
-    private static final Log LOG = LogFactory.getLog(JxltEngine.class);
+    private static final Logger LOG = LogManager.getLogger(JxltEngine.class);
     private MapContext vars = new MapContext();
     private JexlEvalContext context = null;
 
@@ -94,12 +94,14 @@ public class JXLTTest extends JexlTestCase {
     }
 
     public void testStatement() throws Exception {
-        context.set("froboz", new Froboz(123));
-        JxltEngine.Expression check = JXLT.createExpression("${froboz.value = 32; froboz.plus10(); froboz.value}");
+        Froboz froboz = new Froboz(32);
+        context.set("froboz", froboz);
+        JxltEngine.Expression check = JXLT.createExpression("${ froboz.plus10() }");
         Object o = check.evaluate(context);
-        assertEquals("Result is not 42", new Integer(42), o);
+        assertEquals("Result is not 32", new Integer(32), o);
+        assertEquals("Result is not 42", 42, froboz.getValue());
         Set<List<String>> evars = check.getVariables();
-        assertEquals(2, evars.size());
+        assertEquals(1, evars.size());
     }
 
     public void testAssign() throws Exception {
@@ -269,6 +271,21 @@ public class JXLTTest extends JexlTestCase {
         }
     }
 
+    public void testMalformedNested2() throws Exception {
+        try {
+            JxltEngine.Expression expr = JXLT.createExpression("#{${hi} world}");
+            JexlContext ctxt = new MapContext();
+            ctxt.set("hi", "hello");
+            expr.evaluate(ctxt);
+            fail("should be malformed");
+        } catch (JxltEngine.Exception xjexl) {
+            // expected
+            String xmsg = xjexl.getMessage();
+            LOG.warn(xmsg);
+        }
+    }
+
+
     public void testBadContextNested() throws Exception {
         try {
             JxltEngine.Expression expr = JXLT.createExpression("#{${hi}+'.world'}");
@@ -353,6 +370,8 @@ public class JXLTTest extends JexlTestCase {
         JxltEngine.Template tl10n = JXLT.createTemplate(source, "list");
         String dstr = tl10n.asString();
         assertNotNull(dstr);
+        Set<List<String>> vars = tl10n.getVariables();
+        assertFalse(vars.isEmpty());
         context.set("l10n", "valeur");
         JxltEngine.Template tpFR = tl10n.prepare(context);
         context.set("l10n", "value");
@@ -439,7 +458,44 @@ public class JXLTTest extends JexlTestCase {
         StringWriter strw = new StringWriter();
         t.evaluate(context, strw);
         String output = strw.toString();
-        String ctl = "<report>\n\n\n        11</report>";
+        String ctl = "<report>\n\n\n        11\n</report>\n";
         assertEquals(ctl, output);
     }
+
+
+    public void testOneLiner() throws Exception {
+        JxltEngine.Template t = JXLT.createTemplate("$$", new StringReader("fourty-two"));
+        StringWriter strw = new StringWriter();
+        t.evaluate(context, strw);
+        String output = strw.toString();
+        assertEquals("fourty-two", output);
+    }
+
+    public void testOneLinerVar() throws Exception {
+        JxltEngine.Template t = JXLT.createTemplate("$$", new StringReader("fourty-${x}"));
+        StringWriter strw = new StringWriter();
+        context.set("x", "two");
+        t.evaluate(context, strw);
+        String output = strw.toString();
+        assertEquals("fourty-two", output);
+    }
+//
+//    public void testDeferredTemplate() throws Exception {
+//        JxltEngine.Template t = JXLT.createTemplate("$$", new StringReader(
+//             "select * from \n"+
+//             "##for(var c : tables) {\n"+
+//             "#{c} \n"+
+//             "##}\n"+
+//             "where $(w}\n"
+//                ));
+//        StringWriter strw = new StringWriter();
+//        context.set("tables", new String[]{"table1", "table2"});
+//        t = t.prepare(context);
+//        vars.clear();
+//        context.set("w" ,"x=1");
+//        t.evaluate(context, strw);
+//        String output = strw.toString();
+//        assertEquals("fourty-two", output);
+//
+//    }
 }
diff --git a/src/test/java/org/apache/commons/jexl3/Jexl.java b/src/test/java/org/apache/commons/jexl3/Jexl.java
index 64e868f0..8116bec8 100644
--- a/src/test/java/org/apache/commons/jexl3/Jexl.java
+++ b/src/test/java/org/apache/commons/jexl3/Jexl.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
diff --git a/src/test/java/org/apache/commons/jexl3/JexlTest.java b/src/test/java/org/apache/commons/jexl3/JexlTest.java
index 80cdb2eb..2dc97bb9 100644
--- a/src/test/java/org/apache/commons/jexl3/JexlTest.java
+++ b/src/test/java/org/apache/commons/jexl3/JexlTest.java
@@ -649,7 +649,7 @@ public class JexlTest extends JexlTestCase {
         Foo foo = new Foo();
         jc.set("foo", foo);
         Parser parser = new Parser(new StringReader(";"));
-        parser.parse(null, "aString = 'World';", null, false);
+        parser.parse(null, "aString = 'World';", null, false, false);
 
         assertExpression(jc, "hello = 'world'", "world");
         assertEquals("hello variable not changed", "world", jc.get("hello"));
@@ -677,7 +677,7 @@ public class JexlTest extends JexlTestCase {
 
     public void testUnicodeSupport() throws Exception {
         JexlContext jc = new MapContext();
-        assertExpression(jc, "'x' == 'U?ytkownik'", Boolean.FALSE);
+        assertExpression(jc, "'x' == '\\u0032?ytkownik'", Boolean.FALSE);
         assertExpression(jc, "'c:\\some\\windows\\path'", "c:\\some\\windows\\path");
         assertExpression(jc, "'foo\\u0020bar'", "foo\u0020bar");
         assertExpression(jc, "'foo\\u0020\\u0020bar'", "foo\u0020\u0020bar");
diff --git a/src/test/java/org/apache/commons/jexl3/JexlTestCase.java b/src/test/java/org/apache/commons/jexl3/JexlTestCase.java
index 2809809a..fcbb24c6 100644
--- a/src/test/java/org/apache/commons/jexl3/JexlTestCase.java
+++ b/src/test/java/org/apache/commons/jexl3/JexlTestCase.java
@@ -41,7 +41,7 @@ public class JexlTestCase extends TestCase {
     public JexlTestCase(String name) {
         this(name, new JexlBuilder().strict(true).silent(false).cache(32).create());
     }
-    
+
     protected JexlTestCase(String name, JexlEngine jexl) {
         super(name);
         JEXL = jexl;
@@ -55,7 +55,7 @@ public class JexlTestCase extends TestCase {
     public static JexlEngine createEngine(boolean lenient) {
         return new JexlBuilder().arithmetic(new JexlArithmetic(!lenient)).cache(512).create();
     }
-    
+
     /**
      * Will force testing the debugger for each derived test class by
      * recreating each expression from the JexlNode in the JexlEngine cache &
diff --git a/src/test/java/org/apache/commons/jexl3/LambdaTest.java b/src/test/java/org/apache/commons/jexl3/LambdaTest.java
index 0f89f980..7d9b9f24 100644
--- a/src/test/java/org/apache/commons/jexl3/LambdaTest.java
+++ b/src/test/java/org/apache/commons/jexl3/LambdaTest.java
@@ -38,16 +38,15 @@ public class LambdaTest extends JexlTestCase {
     public void testScriptContext() throws Exception {
         JexlEngine jexl = new Engine();
         JexlScript s = jexl.createScript("function(x) { x + x }");
-        JexlScript fs = (JexlScript) s.execute(null);
-        String fsstr = fs.toString();
+        String fsstr = s.getParsedText();
         assertEquals("(x)->{ x + x; }", fsstr);
-        assertEquals(42, fs.execute(null, 21));
+        assertEquals(42, s.execute(null, 21));
         JexlScript s42 = jexl.createScript("s(21)");
         JexlEvalContext ctxt = new JexlEvalContext();
-        ctxt.set("s", fs);
+        ctxt.set("s", s);
         Object result = s42.execute(ctxt);
         assertEquals(42, result);
-        result = s42.evaluate(ctxt);
+        result = s42.execute(ctxt);
         assertEquals(42, result);
     }
 
diff --git a/src/test/java/org/apache/commons/jexl3/MethodTest.java b/src/test/java/org/apache/commons/jexl3/MethodTest.java
index 8a06f77b..52a73db0 100644
--- a/src/test/java/org/apache/commons/jexl3/MethodTest.java
+++ b/src/test/java/org/apache/commons/jexl3/MethodTest.java
@@ -20,6 +20,7 @@ import java.util.HashMap;
 import java.util.Map;
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.junit.Asserter;
+import java.util.Arrays;
 
 /**
  * Tests for calling methods on objects
@@ -35,6 +36,11 @@ public class MethodTest extends JexlTestCase {
     }
 
     public static class VarArgs {
+        public String callInts() {
+            int result = -5000;
+            return "Varargs:" + result;
+        }
+
         public String callInts(Integer... args) {
             int result = 0;
             if (args != null) {
@@ -85,28 +91,6 @@ public class MethodTest extends JexlTestCase {
         }
     }
 
-    public static class Functor {
-        public int ten() {
-            return 10;
-        }
-
-        public int plus10(int num) {
-            return num + 10;
-        }
-
-        public static int TWENTY() {
-            return 20;
-        }
-
-        public static int PLUS20(int num) {
-            return num + 20;
-        }
-
-        public static Class<?> NPEIfNull(Object x) {
-            return x.getClass();
-        }
-    }
-
     public static class EnhancedContext extends JexlEvalContext {
         int factor = 6;
         final Map<String, Object> funcs;
@@ -143,11 +127,11 @@ public class MethodTest extends JexlTestCase {
     public void testCallVarArgMethod() throws Exception {
         VarArgs test = new VarArgs();
         asserter.setVariable("test", test);
-        asserter.assertExpression("test.callInts()", "Varargs:0");
-        asserter.assertExpression("test.callInts(1)", "Varargs:1");
-        asserter.assertExpression("test.callInts(1,2,3,4,5)", "Varargs:15");
-        asserter.assertExpression("test.concat(['1', '2', '3'])", "1, 2, 3");
-        asserter.assertExpression("test.concat('1', '2', '3')", "1, 2, 3");
+        asserter.assertExpression("test.callInts()", test.callInts());
+        asserter.assertExpression("test.callInts(1)", test.callInts(1));
+        asserter.assertExpression("test.callInts(1,2,3,4,5)", test.callInts(1,2,3,4,5));
+        asserter.assertExpression("test.concat(['1', '2', '3'])", test.concat(new String[]{"1", "2", "3"}));
+        asserter.assertExpression("test.concat('1', '2', '3')", test.concat("1", "2", "3"));
 
     }
 
@@ -155,14 +139,14 @@ public class MethodTest extends JexlTestCase {
         VarArgs test = new VarArgs();
         asserter.setVariable("test", test);
         assertEquals("Mixed:1", test.callMixed(Integer.valueOf(1)));
-        asserter.assertExpression("test.callMixed(1)", "Mixed:1");
+        asserter.assertExpression("test.callMixed(1)", test.callMixed(1));
         // Java and JEXL equivalent behavior: 'Mixed:-999' expected
         //{
         assertEquals("Mixed:-999", test.callMixed(Integer.valueOf(1), (Integer[]) null));
         asserter.assertExpression("test.callMixed(1, null)", "Mixed:-999");
         //}
-        asserter.assertExpression("test.callMixed(1,2)", "Mixed:3");
-        asserter.assertExpression("test.callMixed(1,2,3,4,5)", "Mixed:15");
+        asserter.assertExpression("test.callMixed(1,2)", test.callMixed(1,2));
+        asserter.assertExpression("test.callMixed(1,2,3,4,5)", test.callMixed(1,2,3,4,5));
     }
 
     public void testCallJexlVarArgMethod() throws Exception {
@@ -175,8 +159,30 @@ public class MethodTest extends JexlTestCase {
         assertEquals("jexl:-1000", test.callMixed("jexl", (Integer[]) null));
         asserter.assertExpression("test.callMixed('jexl', null)", "jexl:-1000");
         //}
-        asserter.assertExpression("test.callMixed('jexl', 2)", "jexl:2");
-        asserter.assertExpression("test.callMixed('jexl',2,3,4,5)", "jexl:14");
+        asserter.assertExpression("test.callMixed('jexl', 2)", test.callMixed("jexl", 2));
+        asserter.assertExpression("test.callMixed('jexl',2,3,4,5)", test.callMixed("jexl",2,3,4,5));
+    }
+
+    public static class Functor {
+        public int ten() {
+            return 10;
+        }
+
+        public int plus10(int num) {
+            return num + 10;
+        }
+
+        public static int TWENTY() {
+            return 20;
+        }
+
+        public static int PLUS20(int num) {
+            return num + 20;
+        }
+
+        public static Class<?> NPEIfNull(Object x) {
+            return x.getClass();
+        }
     }
 
     public void testInvoke() throws Exception {
@@ -300,6 +306,139 @@ public class MethodTest extends JexlTestCase {
         assertEquals("Result is not 40", new Integer(40), o);
     }
 
+    public static class Edge {
+        private Edge() {}
+
+        public int exec(int arg) {
+            return 1;
+        }
+
+        public int exec(int[] arg) {
+            return 20;
+        }
+
+        public int exec(String arg) {
+            return 2;
+        }
+
+        public int exec(String... arg) {
+            return 200;
+        }
+
+        public int exec(Object args) {
+            return 3;
+        }
+
+        public int exec(Object... args) {
+            return 4;
+        }
+
+        public int exec(Boolean x, int arg) {
+            return 1;
+        }
+
+        public int exec(Boolean x, int[] arg) {
+            return 20;
+        }
+
+        public int exec(Boolean x, String arg) {
+            return 2;
+        }
+
+        public int exec(Boolean x, Object args) {
+            return 3;
+        }
+
+        public int exec(Boolean x, Object... args) {
+            return 4;
+        }
+
+        public Class<?>[] execute(Object... args) {
+            Class<?>[] clazz = new Class<?>[args.length];
+            for(int a = 0; a < args.length; ++a) {
+                clazz[a] = args[a] != null? args[a].getClass() : Void.class;
+            }
+            return clazz;
+        }
+    }
+
+    private boolean eqExecute(Object lhs, Object rhs) {
+        if (lhs instanceof Class<?>[] && rhs instanceof Class<?>[]) {
+            Class<?>[] lhsa = (Class<?>[]) lhs;
+            Class<?>[] rhsa = (Class<?>[]) rhs;
+            return Arrays.deepEquals(lhsa, rhsa);
+        }
+        return false;
+    }
+
+
+    public void testNamespaceCallEdge() throws Exception {
+        java.util.Map<String, Object> funcs = new java.util.HashMap<String, Object>();
+        Edge func = new Edge();
+        funcs.put("func", func);
+
+        Object o;
+        Object c;
+        JexlExpression e;
+        JexlEvalContext jc = new EnhancedContext(funcs);
+        try {
+            for (int i = 0; i < 2; ++i) {
+                e = JEXL.createExpression("func:exec([1, 2])");
+                o = e.evaluate(jc);
+                assertEquals("exec(int[] arg): " + i, 20, o);
+
+                e = JEXL.createExpression("func:exec(1, 2)");
+                o = e.evaluate(jc);
+                assertEquals("exec(Object... args): " + i, 4, o);
+
+                e = JEXL.createExpression("func:exec([10.0, 20.0])");
+                o = e.evaluate(jc);
+                assertEquals("exec(Object args): " + i, 3, o);
+
+                e = JEXL.createExpression("func:exec('1', 2)");
+                o = e.evaluate(jc);
+                assertEquals("exec(Object... args): " + i, 4, o);
+
+                // no way to differentiate between a single arg call with an array and a vararg call with same args
+                assertEquals("exec(String... args): " + i, func.exec("1", "2"), func.exec(new String[]{"1", "2"}));
+                e = JEXL.createExpression("func:exec(['1', '2'])");
+                o = e.evaluate(jc);
+                assertEquals("exec(String... args): " + i, func.exec(new String[]{"1", "2"}), o);
+                e = JEXL.createExpression("func:exec('1', '2')");
+                o = e.evaluate(jc);
+                assertEquals("exec(String... args): " + i, func.exec("1", "2"), o);
+
+                e = JEXL.createExpression("func:exec(true, [1, 2])");
+                o = e.evaluate(jc);
+                assertEquals("exec(int[] arg): " + i, 20, o);
+
+                e = JEXL.createExpression("func:exec(true, 1, 2)");
+                o = e.evaluate(jc);
+                assertEquals("exec(Object... args): " + i, 4, o);
+
+                e = JEXL.createExpression("func:exec(true, ['1', '2'])");
+                o = e.evaluate(jc);
+                assertEquals("exec(Object args): " + i, 3, o);
+
+                e = JEXL.createExpression("func:exec(true, '1', '2')");
+                o = e.evaluate(jc);
+                assertEquals("exec(Object... args): " + i, 4, o);
+
+                e = JEXL.createExpression("func:execute(true, '1', '2')");
+                o = e.evaluate(jc);
+                c = func.execute(Boolean.TRUE, "1", "2");
+                assertTrue("execute(Object... args): " + i, eqExecute(o, c));
+
+                e = JEXL.createExpression("func:execute([true])");
+                o = e.evaluate(jc);
+                c = func.execute(new boolean[]{true});
+                assertTrue("execute(Object... args): " + i, eqExecute(o, c));
+            }
+        } catch (JexlException xjexl) {
+            fail(xjexl.toString());
+        }
+    }
+
     public static class ScriptContext extends MapContext implements JexlContext.NamespaceResolver {
         Map<String, Object> nsScript;
 
@@ -315,6 +454,20 @@ public class MethodTest extends JexlTestCase {
             if ("script".equals(name)) {
                 return nsScript;
             }
+            if ("functor".equals(name)) {
+                return new JexlContext.NamespaceFunctor() {
+                    @Override
+                    public Object createFunctor(JexlContext context) {
+                        Map<String, Object> values = new HashMap<String, Object>();
+                        if ("gin".equals(context.get("base"))) {
+                            values.put("drink", "gin fizz");
+                        } else {
+                            values.put("drink", "champaign");
+                        }
+                        return values;
+                    }
+                };
+            }
             return null;
         }
     }
@@ -389,4 +542,23 @@ public class MethodTest extends JexlTestCase {
         o = forty2.execute(context);
         assertEquals("Result is not 42", new Integer(42), o);
     }
+
+
+    public void testFizzCall() throws Exception {
+        ScriptContext context = new ScriptContext(new HashMap<String, Object>());
+
+        JexlScript bar = JEXL.createScript("functor:get('drink')");
+        Object o;
+        o = bar.execute(context);
+        assertEquals("Wrong choice", "champaign", o);
+        context.set("base", "gin");
+        o = bar.execute(context);
+        assertEquals("Wrong choice", "gin fizz", o);
+
+        // despite being called twice, the functor is created only once.
+        context.set("base", "wine");
+        bar = JEXL.createScript("var glass = functor:get('drink'); base = 'gin'; functor:get('drink')");
+        o = bar.execute(context);
+        assertEquals("Wrong choice", "champaign", o);
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/jexl3/ParseFailuresTest.java b/src/test/java/org/apache/commons/jexl3/ParseFailuresTest.java
index 19d5aa9d..f0d875d5 100644
--- a/src/test/java/org/apache/commons/jexl3/ParseFailuresTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ParseFailuresTest.java
@@ -16,8 +16,8 @@
  */
 package org.apache.commons.jexl3;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
 
 /**
  * Tests for malformed expressions and scripts.
@@ -29,7 +29,7 @@ import org.apache.commons.logging.LogFactory;
  */
 public class ParseFailuresTest extends JexlTestCase {
 
-    static final Log LOGGER = LogFactory.getLog(ParseFailuresTest.class.getName());
+    static final Logger LOGGER = LogManager.getLogger(ParseFailuresTest.class.getName());
     /**
      * Create the test.
      *
diff --git a/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java b/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java
index 06fad06e..e1f3e8e6 100644
--- a/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java
+++ b/src/test/java/org/apache/commons/jexl3/ReadonlyContext.java
@@ -18,8 +18,6 @@ package org.apache.commons.jexl3;
 
 import java.math.MathContext;
 import java.nio.charset.Charset;
-import org.apache.commons.jexl3.JexlContext;
-import org.apache.commons.jexl3.JexlEngine;
 
 /**
  * A readonly context wrapper.
diff --git a/src/test/java/org/apache/commons/jexl3/SandboxTest.java b/src/test/java/org/apache/commons/jexl3/SandboxTest.java
index b0a97e42..17507323 100644
--- a/src/test/java/org/apache/commons/jexl3/SandboxTest.java
+++ b/src/test/java/org/apache/commons/jexl3/SandboxTest.java
@@ -18,15 +18,15 @@ package org.apache.commons.jexl3;
 
 import org.apache.commons.jexl3.annotations.NoJexl;
 import org.apache.commons.jexl3.introspection.JexlSandbox;
+import org.apache.log4j.LogManager;
+import org.apache.log4j.Logger;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 
 /**
  * Tests sandbox features.
  */
 public class SandboxTest extends JexlTestCase {
-    static final Log LOGGER = LogFactory.getLog(SandboxTest.class.getName());
+    static final Logger LOGGER = LogManager.getLogger(SandboxTest.class.getName());
 
     public SandboxTest() {
         super("SandboxTest");
diff --git a/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java b/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java
index 618c3ae1..64cd076e 100644
--- a/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ScriptCallableTest.java
@@ -69,7 +69,6 @@ public class ScriptCallableTest extends JexlTestCase {
 
     public void testCallableClosure() throws Exception {
         JexlScript e = JEXL.createScript("function(t) {while(t);}");
-        e = (JexlScript) e.execute(null);
         Callable<Object> c = e.callable(null, Boolean.TRUE);
 
         ExecutorService executor = Executors.newFixedThreadPool(1);
diff --git a/src/test/java/org/apache/commons/jexl3/VarTest.java b/src/test/java/org/apache/commons/jexl3/VarTest.java
index 78ffde25..d49f95d2 100644
--- a/src/test/java/org/apache/commons/jexl3/VarTest.java
+++ b/src/test/java/org/apache/commons/jexl3/VarTest.java
@@ -22,14 +22,14 @@ import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
 
 /**
  * Tests local variables.
  */
 public class VarTest extends JexlTestCase {
-    static final Log LOGGER = LogFactory.getLog(VarTest.class.getName());
+    static final Logger LOGGER = LogManager.getLogger(VarTest.class.getName());
 
     public VarTest(String testName) {
         super(testName);
diff --git a/src/test/java/org/apache/commons/jexl3/WhileTest.java b/src/test/java/org/apache/commons/jexl3/WhileTest.java
index 29fdc001..18ff8d38 100644
--- a/src/test/java/org/apache/commons/jexl3/WhileTest.java
+++ b/src/test/java/org/apache/commons/jexl3/WhileTest.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -28,29 +28,29 @@ public class WhileTest extends JexlTestCase {
     }
 
     public void testSimpleWhileFalse() throws Exception {
-        JexlExpression e = JEXL.createExpression("while (false) ;");
+        JexlScript e = JEXL.createScript("while (false) ;");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertNull("Result is not null", o);
     }
-    
+
     public void testWhileExecutesExpressionWhenLooping() throws Exception {
-        JexlExpression e = JEXL.createExpression("while (x < 10) x = x + 1;");
+        JexlScript e = JEXL.createScript("while (x < 10) x = x + 1;");
         JexlContext jc = new MapContext();
         jc.set("x", new Integer(1));
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is wrong", new Integer(10), o);
     }
 
     public void testWhileWithBlock() throws Exception {
-        JexlExpression e = JEXL.createExpression("while (x < 10) { x = x + 1; y = y * 2; }");
+        JexlScript e = JEXL.createScript("while (x < 10) { x = x + 1; y = y * 2; }");
         JexlContext jc = new MapContext();
         jc.set("x", new Integer(1));
         jc.set("y", new Integer(1));
 
-        Object o = e.evaluate(jc);
+        Object o = e.execute(jc);
         assertEquals("Result is wrong", new Integer(512), o);
         assertEquals("x is wrong", new Integer(10), jc.get("x"));
         assertEquals("y is wrong", new Integer(512), jc.get("y"));
diff --git a/src/test/java/org/apache/commons/jexl3/examples/ArrayTest.java b/src/test/java/org/apache/commons/jexl3/examples/ArrayTest.java
index 834e9c5f..22c27092 100644
--- a/src/test/java/org/apache/commons/jexl3/examples/ArrayTest.java
+++ b/src/test/java/org/apache/commons/jexl3/examples/ArrayTest.java
@@ -71,10 +71,10 @@ public class ArrayTest extends TestCase {
         example(Output.JUNIT);
     }
 
-    /** 
+    /**
      * Command line entry point.
      * @param args command line arguments
-     * @throws Exception cos jexl does. 
+     * @throws Exception cos jexl does.
      */
     public static void main(String[] args) throws Exception {
         example(Output.SYSTEM);
diff --git a/src/test/java/org/apache/commons/jexl3/examples/Output.java b/src/test/java/org/apache/commons/jexl3/examples/Output.java
index 06b79d30..ea67e9c4 100644
--- a/src/test/java/org/apache/commons/jexl3/examples/Output.java
+++ b/src/test/java/org/apache/commons/jexl3/examples/Output.java
@@ -47,7 +47,7 @@ public abstract class Output {
         }
     };
 
-        
+
     /**
      * The output instance for the general outputing to System.out.
      */
diff --git a/src/test/java/org/apache/commons/jexl3/internal/introspection/DiscoveryTest.java b/src/test/java/org/apache/commons/jexl3/internal/introspection/DiscoveryTest.java
index ca875622..861e6c29 100644
--- a/src/test/java/org/apache/commons/jexl3/internal/introspection/DiscoveryTest.java
+++ b/src/test/java/org/apache/commons/jexl3/internal/introspection/DiscoveryTest.java
@@ -29,7 +29,7 @@ import java.util.Map;
 
 /**
  * Tests for checking introspection discovery.
- * 
+ *
  * @since 2.0
  */
 public class DiscoveryTest extends JexlTestCase {
diff --git a/src/test/java/org/apache/commons/jexl3/introspection/SandboxTest.java b/src/test/java/org/apache/commons/jexl3/introspection/SandboxTest.java
new file mode 100644
index 00000000..37c76d57
--- /dev/null
+++ b/src/test/java/org/apache/commons/jexl3/introspection/SandboxTest.java
@@ -0,0 +1,320 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.jexl3.introspection;
+
+import org.apache.commons.jexl3.JexlBuilder;
+import org.apache.commons.jexl3.JexlContext;
+import org.apache.commons.jexl3.JexlEngine;
+import org.apache.commons.jexl3.JexlException;
+import org.apache.commons.jexl3.JexlScript;
+import org.apache.commons.jexl3.JexlTestCase;
+import org.apache.commons.jexl3.MapContext;
+import org.apache.commons.jexl3.annotations.NoJexl;
+
+import org.apache.log4j.Logger;
+import org.apache.log4j.LogManager;
+
+/**
+ * Tests sandbox features.
+ */
+public class SandboxTest extends JexlTestCase {
+    static final Logger LOGGER = LogManager.getLogger(SandboxTest.class.getName());
+
+    public SandboxTest() {
+        super("SandboxTest");
+        JEXL.setClassLoader(getClass().getClassLoader());
+    }
+
+    @NoJexl
+    public interface CantCallMe {
+        void tryMe();
+    }
+
+    public interface TryCallMe {
+        @NoJexl
+        void tryMeARiver();
+    }
+
+    public static abstract class CallMeNot {
+        public @NoJexl
+        String NONO = "should not be accessible!";
+
+        @NoJexl
+        public void callMeNot() {
+            throw new RuntimeException("should not be callable!");
+        }
+    }
+
+    public static class Foo extends CallMeNot implements CantCallMe, TryCallMe {
+        String name;
+        public String alias;
+
+        public @NoJexl Foo(String name, String notcallable) {
+            throw new RuntimeException("should not be callable!");
+        }
+
+        public Foo(String name) {
+            this.name = name;
+            this.alias = name + "-alias";
+        }
+
+        public String getName() {
+            return name;
+        }
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+        public String Quux() {
+            return name + "-quux";
+        }
+
+        @NoJexl
+        public String cantCallMe() {
+            throw new RuntimeException("should not be callable!");
+        }
+
+        @Override
+        public void tryMe() {
+            throw new RuntimeException("should not be callable!");
+        }
+
+        @Override
+        public void tryMeARiver() {
+            throw new RuntimeException("should not be callable!");
+        }
+    }
+
+    public void testCtorBlack() throws Exception {
+        String expr = "new('" + Foo.class.getName() + "', '42')";
+        JexlScript script = JEXL.createScript(expr);
+        Object result;
+        result = script.execute(null);
+        assertEquals("42", ((Foo) result).getName());
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.black(Foo.class.getName()).execute("");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr);
+        try {
+            result = script.execute(null);
+            fail("ctor should not be accessible");
+        } catch (JexlException.Method xmethod) {
+            // ok, ctor should not have been accessible
+            LOGGER.info(xmethod.toString());
+        }
+    }
+
+    public void testMethodBlack() throws Exception {
+        String expr = "foo.Quux()";
+        JexlScript script = JEXL.createScript(expr, "foo");
+        Foo foo = new Foo("42");
+        Object result;
+        result = script.execute(null, foo);
+        assertEquals(foo.Quux(), result);
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.black(Foo.class.getName()).execute("Quux");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr, "foo");
+        try {
+            result = script.execute(null, foo);
+            fail("Quux should not be accessible");
+        } catch (JexlException.Method xmethod) {
+            // ok, Quux should not have been accessible
+            LOGGER.info(xmethod.toString());
+        }
+    }
+
+    public void testGetBlack() throws Exception {
+        String expr = "foo.alias";
+        JexlScript script = JEXL.createScript(expr, "foo");
+        Foo foo = new Foo("42");
+        Object result;
+        result = script.execute(null, foo);
+        assertEquals(foo.alias, result);
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.black(Foo.class.getName()).read("alias");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr, "foo");
+        try {
+            result = script.execute(null, foo);
+            fail("alias should not be accessible");
+        } catch (JexlException.Property xvar) {
+            // ok, alias should not have been accessible
+            LOGGER.info(xvar.toString());
+        }
+    }
+
+    public void testSetBlack() throws Exception {
+        String expr = "foo.alias = $0";
+        JexlScript script = JEXL.createScript(expr, "foo", "$0");
+        Foo foo = new Foo("42");
+        Object result;
+        result = script.execute(null, foo, "43");
+        assertEquals("43", result);
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.black(Foo.class.getName()).write("alias");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr, "foo", "$0");
+        try {
+            result = script.execute(null, foo, "43");
+            fail("alias should not be accessible");
+        } catch (JexlException.Property xvar) {
+            // ok, alias should not have been accessible
+            LOGGER.info(xvar.toString());
+        }
+    }
+
+    public void testCtorWhite() throws Exception {
+        String expr = "new('" + Foo.class.getName() + "', '42')";
+        JexlScript script;
+        Object result;
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.white(Foo.class.getName()).execute("");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr);
+        result = script.execute(null);
+        assertEquals("42", ((Foo) result).getName());
+    }
+
+    public void testMethodWhite() throws Exception {
+        Foo foo = new Foo("42");
+        String expr = "foo.Quux()";
+        JexlScript script;
+        Object result;
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.white(Foo.class.getName()).execute("Quux");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr, "foo");
+        result = script.execute(null, foo);
+        assertEquals(foo.Quux(), result);
+    }
+
+    public void testMethodNoJexl() throws Exception {
+        Foo foo = new Foo("42");
+        String[] exprs = {
+            "foo.cantCallMe()",
+            "foo.tryMe()",
+            "foo.tryMeARiver()",
+            "foo.callMeNot()",
+            "foo.NONO",
+            "new('org.apache.commons.jexl3.SandboxTest$Foo', 'one', 'two')"
+        };
+        JexlScript script;
+        Object result;
+
+        JexlEngine sjexl = new JexlBuilder().strict(true).create();
+        for (String expr : exprs) {
+            script = sjexl.createScript(expr, "foo");
+            try {
+                result = script.execute(null, foo);
+                fail("should have not been possible");
+            } catch (JexlException.Method xjm) {
+                // ok
+                LOGGER.info(xjm.toString());
+            } catch (JexlException.Property xjm) {
+                // ok
+                LOGGER.info(xjm.toString());
+            }
+        }
+    }
+
+    public void testGetWhite() throws Exception {
+        Foo foo = new Foo("42");
+        String expr = "foo.alias";
+        JexlScript script;
+        Object result;
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.white(Foo.class.getName()).read("alias");
+        sandbox.get(Foo.class.getName()).read().alias("alias", "ALIAS");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr, "foo");
+        result = script.execute(null, foo);
+        assertEquals(foo.alias, result);
+
+        script = sjexl.createScript("foo.ALIAS", "foo");
+        result = script.execute(null, foo);
+        assertEquals(foo.alias, result);
+    }
+
+    public void testSetWhite() throws Exception {
+        Foo foo = new Foo("42");
+        String expr = "foo.alias = $0";
+        JexlScript script;
+        Object result;
+
+        JexlSandbox sandbox = new JexlSandbox();
+        sandbox.white(Foo.class.getName()).write("alias");
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        script = sjexl.createScript(expr, "foo", "$0");
+        result = script.execute(null, foo, "43");
+        assertEquals("43", result);
+        assertEquals("43", foo.alias);
+    }
+
+    public void testRestrict() throws Exception {
+        JexlContext context = new MapContext();
+        context.set("System", System.class);
+        JexlSandbox sandbox = new JexlSandbox();
+        // only allow call to currentTimeMillis (avoid exit, gc, loadLibrary, etc)
+        sandbox.white(System.class.getName()).execute("currentTimeMillis");
+        // can not create a new file
+        sandbox.black(java.io.File.class.getName()).execute("");
+
+        JexlEngine sjexl = new JexlBuilder().sandbox(sandbox).strict(true).create();
+
+        String expr;
+        JexlScript script;
+        Object result;
+
+        script = sjexl.createScript("System.exit()");
+        try {
+            result = script.execute(context);
+            fail("should not allow calling exit!");
+        } catch (JexlException xjexl) {
+            LOGGER.info(xjexl.toString());
+        }
+
+        script = sjexl.createScript("new('java.io.File', '/tmp/should-not-be-created')");
+        try {
+            result = script.execute(context);
+            fail("should not allow creating a file");
+        } catch (JexlException xjexl) {
+            LOGGER.info(xjexl.toString());
+        }
+
+        expr = "System.currentTimeMillis()";
+        script = sjexl.createScript("System.currentTimeMillis()");
+        result = script.execute(context);
+        assertNotNull(result);
+    }
+}
diff --git a/src/test/java/org/apache/commons/jexl3/junit/Asserter.java b/src/test/java/org/apache/commons/jexl3/junit/Asserter.java
index b0ecba6e..9e397e12 100644
--- a/src/test/java/org/apache/commons/jexl3/junit/Asserter.java
+++ b/src/test/java/org/apache/commons/jexl3/junit/Asserter.java
@@ -23,11 +23,11 @@ import java.util.Map;
 import junit.framework.Assert;
 
 import org.apache.commons.jexl3.JexlEvalContext;
-import org.apache.commons.jexl3.JexlExpression;
 import org.apache.commons.jexl3.JexlArithmetic;
 import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.JexlException;
+import org.apache.commons.jexl3.JexlScript;
 
 /**
  * A utility class for performing JUnit based assertions using Jexl
@@ -95,8 +95,8 @@ public class Asserter extends Assert {
      * fails
      */
     public void assertExpression(String expression, Object expected) throws Exception {
-        JexlExpression exp = engine.createScript(expression);
-        Object value = exp.evaluate(context);
+        JexlScript exp = engine.createScript(expression);
+        Object value = exp.execute(context);
         if (expected instanceof BigDecimal) {
             JexlArithmetic jexla = engine.getArithmetic();
             assertTrue("expression: " + expression, ((BigDecimal) expected).compareTo(jexla.toBigDecimal(value)) == 0);
@@ -122,8 +122,8 @@ public class Asserter extends Assert {
      */
     public void failExpression(String expression, String matchException) throws Exception {
         try {
-            JexlExpression exp = engine.createScript(expression);
-            exp.evaluate(context);
+            JexlScript exp = engine.createScript(expression);
+            exp.execute(context);
             fail("expression: " + expression);
         } catch (JexlException xjexl) {
             if (matchException != null && !xjexl.getMessage().matches(matchException)) {
diff --git a/src/test/java/org/apache/commons/jexl3/junit/AsserterTest.java b/src/test/java/org/apache/commons/jexl3/junit/AsserterTest.java
index 9cffe7df..ad9fedcc 100644
--- a/src/test/java/org/apache/commons/jexl3/junit/AsserterTest.java
+++ b/src/test/java/org/apache/commons/jexl3/junit/AsserterTest.java
@@ -5,9 +5,9 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -35,9 +35,9 @@ public class AsserterTest extends JexlTestCase {
     public void testThis() throws Exception {
         Asserter asserter = new Asserter(JEXL);
         asserter.setVariable("this", new Foo());
-        
+
         asserter.assertExpression("this.get('abc')", "Repeat : abc");
-        
+
         try {
             asserter.assertExpression("this.count", "Wrong Value");
             fail("This method should have thrown an assertion exception");
@@ -55,10 +55,10 @@ public class AsserterTest extends JexlTestCase {
 
         asserter.assertExpression("person", "James");
         asserter.assertExpression("size(person)", new Integer(5));
-        
+
         asserter.assertExpression("foo.getCount()", new Integer(5));
         asserter.assertExpression("foo.count", new Integer(5));
-        
+
         try {
             asserter.assertExpression("bar.count", new Integer(5));
             fail("This method should have thrown an assertion exception");
diff --git a/src/test/java/org/apache/commons/jexl3/parser/ParserTest.java b/src/test/java/org/apache/commons/jexl3/parser/ParserTest.java
index 7f3a2647..c128acb0 100644
--- a/src/test/java/org/apache/commons/jexl3/parser/ParserTest.java
+++ b/src/test/java/org/apache/commons/jexl3/parser/ParserTest.java
@@ -37,20 +37,20 @@ public class ParserTest extends TestCase {
         Parser parser = new Parser(new StringReader(";"));
 
         JexlNode sn;
-        sn = parser.parse(null, "foo = 1;", null, false);
+        sn = parser.parse(null, "foo = 1;", null, false, false);
         assertNotNull("parsed node is null", sn);
 
-        sn = parser.parse(null, "foo = \"bar\";", null, false);
+        sn = parser.parse(null, "foo = \"bar\";", null, false, false);
         assertNotNull("parsed node is null", sn);
 
-        sn = parser.parse(null, "foo = 'bar';", null, false);
+        sn = parser.parse(null, "foo = 'bar';", null, false, false);
         assertNotNull("parsed node is null", sn);
     }
 
     public void testErrorAssign() throws Exception {
         Parser parser = new Parser(new StringReader(";"));
         try {
-            JexlNode sn = parser.parse(null, "foo() = 1;", null, false);
+            JexlNode sn = parser.parse(null, "foo() = 1;", null, false, false);
             fail("should have failed on invalid assignment");
         } catch (JexlException.Parsing xparse) {
             // ok
@@ -60,7 +60,7 @@ public class ParserTest extends TestCase {
     public void testErrorAmbiguous() throws Exception {
         Parser parser = new Parser(new StringReader(";"));
         try {
-            JexlNode sn = parser.parse(null, "x = 1 y = 5", null, false);
+            JexlNode sn = parser.parse(null, "x = 1 y = 5", null, false, false);
             fail("should have failed on ambiguous statement");
         } catch (JexlException.Ambiguous xambiguous) {
             // ok
diff --git a/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineOptionalTest.java b/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineOptionalTest.java
index 92592e58..c2c89c5a 100644
--- a/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineOptionalTest.java
+++ b/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineOptionalTest.java
@@ -13,7 +13,7 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- * 
+ *
  */
 
 package org.apache.commons.jexl3.scripting;
diff --git a/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineTest.java b/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineTest.java
index cf741f7f..e9e46b40 100644
--- a/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineTest.java
+++ b/src/test/java/org/apache/commons/jexl3/scripting/JexlScriptEngineTest.java
@@ -13,7 +13,7 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- * 
+ *
  */
 
 package org.apache.commons.jexl3.scripting;
@@ -94,7 +94,7 @@ public class JexlScriptEngineTest extends TestCase {
         assertEquals(engine.getContext().getErrorWriter(),engine.eval("JEXL.err"));
         assertEquals(System.class,engine.eval("JEXL.System"));
     }
-    
+
     public void testNulls() throws Exception {
         ScriptEngineManager manager = new ScriptEngineManager();
         assertNotNull("Manager should not be null", manager);
diff --git a/src/test/resources/log4j.xml b/src/test/resources/log4j.xml
new file mode 100644
index 00000000..e974b484
--- /dev/null
+++ b/src/test/resources/log4j.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE log4j:configuration SYSTEM "log4j.dtd" >
+<log4j:configuration>
+    <appender name="Console" class="org.apache.log4j.ConsoleAppender">
+        <layout class="org.apache.log4j.PatternLayout">
+            <param name="ConversionPattern" value="%d{ABSOLUTE} %5p %c{1}:%L - %m%n"/>
+        </layout>
+    </appender>
+    
+    <logger name="org.apache.commons.jexl3" additivity="false">
+        <level value="error"/>
+        <appender-ref ref="Console"/>
+    </logger>
+
+    <root>
+        <priority value="error"></priority>
+        <appender-ref ref="Console"/>
+    </root>
+</log4j:configuration>
\ No newline at end of file
