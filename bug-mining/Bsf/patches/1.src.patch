diff --git a/src/org/apache/bsf/BSFManager.java b/src/org/apache/bsf/BSFManager.java
index ccc2818..7cf8726 100644
--- a/src/org/apache/bsf/BSFManager.java
+++ b/src/org/apache/bsf/BSFManager.java
@@ -59,15 +59,23 @@ import org.apache.bsf.util.ObjectRegistry;
  * @author   Rony G. Flatscher (added BSF_Log[Factory] to allow BSF to run without org.apache.commons.logging present)
  */
 
-// changed 2007-01-28: fixed Class.forName() to use the context class loader instead; oversaw this the last time
+// changed 2007-01-28: ---rgf, fixed Class.forName() to use the context class loader instead; oversaw this the last time
+/* changed 2007-09-17: ---rgf, some Java hosts do not set the Thread's context class loader and
+                               load BSF with a customized ClassLoader!
+                               Resolution:
+                               - use Thread context ClassLoader, if resource or class to
+                                 load not found, then
+                               - use the BSFManager's defining ClassLoader instead, if it is
+                                 different to the context ClassLoader
+*/
 
 public class BSFManager {
     // version string is in the form "abc.yyyymmdd" where
     // "abc" represents a dewey decimal number (three levels, each between 0 and 9),
     // and "yyyy" a four digit year, "mm" a two digit month, "dd" a two digit day.
     //
-    // Example: "242.20070128" stands for: BSF version "2.4.2" as of "2007-01-28"
-    protected static String version="242.20070128";
+    // Example: "242.20070921" stands for: BSF version "2.4.3" as of "2007-09-21"
+    protected static String version="243.20070921";
 
     // table of registered scripting engines
     protected static Hashtable registeredEngines = new Hashtable();
@@ -75,6 +83,23 @@ public class BSFManager {
     // mapping of file extensions to languages
     protected static Hashtable extn2Lang = new Hashtable();
 
+    // get the defined CL (ClassLoader which got used to define this class object) // rgf, 20070917
+    protected static ClassLoader definedClassLoader;
+/*
+    protected static ClassLoader appClassLoader;        // application/system class loader
+    protected static ClassLoader extClassLoader;        // extension (option) class loader
+*/
+
+    /** Returns the defined ClassLoader (the ClassLoader that got used to define the
+     *  org.apache.bsf.BSFManager class object).
+     *  @return the defined ClassLoader instance
+     */
+    public static ClassLoader getDefinedClassLoader()  // rgf, 20070917
+    {
+        return definedClassLoader;
+    }
+
+
     // table of scripting engine instances created by this manager.
     // only one instance of a given language engine is created by a single
     // manager instance.
@@ -87,10 +112,15 @@ public class BSFManager {
     // of my interesting properties change
     protected PropertyChangeSupport pcs;
 
+/* rgf (20070917): wrong assumption; context ClassLoader needs to be explicitly
+                   requested before usage as BSF could be deployed with different
+                   context ClassLoaders on different threads!
+*/
+
     // the class loader to use if a class loader is needed. Default is
     // he who loaded me (which may be null in which case its Class.forName).
-    // protected ClassLoader classLoader = getClass().getClassLoader();
-    protected ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // rgf, 2006-01-05
+    protected ClassLoader classLoader = getClass().getClassLoader();
+    // rgf, 20070917, reset to original// protected ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); // rgf, 2006-01-05
 
     // temporary directory to use to dump temporary files into. Note that
     // if class files are dropped here then unless this dir is in the
@@ -115,10 +145,27 @@ public class BSFManager {
     //////////////////////////////////////////////////////////////////////
 
     static {
+        String strInfo="org.apache.bsf.BSFManager.dumpEnvironment() [from static{}]";
         try {
+            definedClassLoader=BSFManager.class.getClassLoader();   // get defining ClassLoader
+
+/*
+            RGFInfo.newSection(strInfo);
+            RGFInfo.dumpClassLoaderInfos(BSFManager.class, "org.apache.bsf.BSFManager");
+            RGFInfo.append("BSFManager.staticBlock, registering BSF scripting engines:\n");
+*/
+
             // Enumeration e = BSFManager.class.getClassLoader().getResources("org/apache/bsf/Languages.properties");
             // use the Thread's context class loader to locate the resources
-            Enumeration e = Thread.currentThread().getContextClassLoader().getResources("org/apache/bsf/Languages.properties");
+            String resourceName="org/apache/bsf/Languages.properties";
+            Enumeration e = Thread.currentThread().getContextClassLoader().getResources(resourceName);
+
+            if (!e.hasMoreElements()) // 20070917: if no resources (BSF engines!), then use defCL
+            {
+//                RGFInfo.append("==> no BSF engines found from context ClassLoader, now using defCL !\n");
+                e=definedClassLoader.getResources(resourceName);
+            }
+
             while (e.hasMoreElements()) {
                 URL url = (URL)e.nextElement();
                 InputStream is = url.openStream();
@@ -133,14 +180,15 @@ public class BSFManager {
                     String className = value.substring(0, value.indexOf(","));
 
 
-
-
                     // get the extensions for this language
                     String exts = value.substring(value.indexOf(",")+1, value.length());
                     StringTokenizer st = new StringTokenizer(exts, "|");
                     String[] extensions = new String[st.countTokens()];
+
+//                    RGFInfo.append("\tregistering BSF engine: key=["+key+"]\tclassName=["+className+"] nr. of extensions=["+extensions.length+"\n");
                     for (int i = 0; st.hasMoreTokens(); i++) {
                         extensions[i] = ((String) st.nextToken()).trim();
+//                        RGFInfo.append("\t\t--->extension=["+extensions[i]+"]\n");
                     }
 
                     registerScriptingEngine(key, className, extensions);
@@ -150,14 +198,22 @@ public class BSFManager {
 
             ex.printStackTrace();
             System.err.println("Error reading Languages file " + ex);
+//            RGFInfo.append("\t*ERROR* reading Language file ["+ex+"]\n");
         } catch (NoSuchElementException nsee) {
 
             nsee.printStackTrace();
             System.err.println("Syntax error in Languages resource bundle");
+//            RGFInfo.append("\t*ERROR* Syntax error in Languages resourcebundle ["+nsee+"]\n");
         } catch (MissingResourceException mre) {
 
             mre.printStackTrace();
             System.err.println("Initialization error: " + mre.toString());
+//            RGFInfo.append("\t*ERROR* initializing ["+mre+"]\n");
+        }
+        finally
+        {
+//            RGFInfo.dumpEnvironment();
+//            RGFInfo.endSection(strInfo);
         }
     }
 
@@ -231,7 +287,7 @@ public class BSFManager {
             result = resultf;
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception: ", prive);
+        	logger.error("[BSFManager] Exception: ", prive);
             throw (BSFException) prive.getException();
         }
 
@@ -284,7 +340,7 @@ public class BSFManager {
                 });
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception :", prive);
+        	logger.error("[BSFManager] Exception :", prive);
             throw (BSFException) prive.getException();
         }
     }
@@ -327,7 +383,7 @@ public class BSFManager {
                 });
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception :", prive);
+        	logger.error("[BSFManager] Exception :", prive);
             throw (BSFException) prive.getException();
         }
     }
@@ -371,7 +427,7 @@ public class BSFManager {
                 });
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception :", prive);
+        	logger.error("[BSFManager] Exception :", prive);
             throw (BSFException) prive.getException();
         }
     }
@@ -460,7 +516,7 @@ public class BSFManager {
             result = resultf;
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception: ", prive);
+        	logger.error("[BSFManager] Exception: ", prive);
             throw (BSFException) prive.getException();
         }
 
@@ -508,7 +564,7 @@ public class BSFManager {
                 });
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception :", prive);
+        	logger.error("[BSFManager] Exception :", prive);
             throw (BSFException) prive.getException();
         }
     }
@@ -548,7 +604,7 @@ public class BSFManager {
                 });
         } catch (PrivilegedActionException prive) {
 
-        	logger.error("Exception :", prive);
+        	logger.error("[BSFManager] Exception :", prive);
             throw (BSFException) prive.getException();
         }
     }
@@ -571,7 +627,7 @@ public class BSFManager {
                 classPath = System.getProperty("java.class.path");
             } catch (Throwable t) {
 
-            	logger.debug("Exception :", t);
+            	logger.debug("[BSFManager] Exception :", t);
                 // prolly a security exception .. so no can do
             }
         }
@@ -610,16 +666,22 @@ public class BSFManager {
                     loops++;
 
                     // Test to see if in classpath
+                    String engineName=null;
                     try {
-                        String engineName =
+                        engineName =
                             (String) registeredEngines.get(lang);
                         // Class.forName(engineName);
                         Thread.currentThread().getContextClassLoader().loadClass (engineName); // rgf, 2007-01-28
-                    } catch (ClassNotFoundException cnfe) {
+                    } catch (ClassNotFoundException cnfe) { // 20070917: hmm, maybe defCL can load it ?
+                        try {
+                            definedClassLoader.loadClass(engineName);
+                        }
+                        catch (ClassNotFoundException cnfe2) {
+                            // Bummer.
+                            lang = langval;
+                            continue;
+                        }
 
-                        // Bummer.
-                        lang = langval;
-                        continue;
                     }
 
                     // Got past that? Good.
@@ -633,7 +695,7 @@ public class BSFManager {
             }
         }
         throw new BSFException(BSFException.REASON_OTHER_ERROR,
-                               "file extension missing or unknown: "
+                               "[BSFManager.getLangFromFilename] file extension missing or unknown: "
                                + "unable to determine language for '"
                                + fileName
                                + "'");
@@ -695,15 +757,23 @@ public class BSFManager {
         // is it a registered language?
         String engineClassName = (String) registeredEngines.get(lang);
         if (engineClassName == null) {
-        	logger.error("unsupported language: " + lang);
+        	logger.error("[BSFManager] unsupported language: " + lang);
             throw new BSFException(BSFException.REASON_UNKNOWN_LANGUAGE,
-                                   "unsupported language: " + lang);
+                                   "[BSFManager.loadScriptingEngine()] unsupported language: " + lang);
         }
 
         // create the engine and initialize it. if anything goes wrong
         // except.
         try {
-            Class engineClass = Thread.currentThread().getContextClassLoader().loadClass (engineClassName);
+
+            Class engineClass;
+            try {  // 20070917
+                engineClass = Thread.currentThread().getContextClassLoader().loadClass (engineClassName);
+            }
+            catch (ClassNotFoundException cnfe) {
+                engineClass = definedClassLoader.loadClass (engineClassName);
+            }
+
                // (classLoader == null)
                //  ? // Class.forName(engineClassName)
                //    Thread.currentThread().getContextClassLoader().loadClass (engineClassName) // rgf, 2007-01-28
@@ -725,13 +795,13 @@ public class BSFManager {
             return eng;
         } catch (PrivilegedActionException prive) {
 
-        	    logger.error("Exception :", prive);
+        	    logger.error("[BSFManager] Exception :", prive);
                 throw (BSFException) prive.getException();
         } catch (Throwable t) {
 
-        	logger.error("Exception :", t);
+        	logger.error("[BSFManager] Exception :", t);
             throw new BSFException(BSFException.REASON_OTHER_ERROR,
-                                   "unable to load language: " + lang,
+                                   "[BSFManager.loadScriptingEngine()] unable to load language: " + lang,
                                    t);
         }
     }
@@ -751,7 +821,7 @@ public class BSFManager {
             return ((BSFDeclaredBean)objectRegistry.lookup(beanName)).bean;
         } catch (IllegalArgumentException e) {
 
-        	logger.debug("Exception :", e);
+        	logger.debug("[BSFManager] Exception :", e);
             return null;
         }
     }
@@ -800,6 +870,7 @@ public class BSFManager {
         }
     }
 
+
     /**
      * Set the class loader for those that need to use it. Default is he
      * who loaded me or null (i.e., its Class.forName).
@@ -923,4 +994,6 @@ public class BSFManager {
 
         objectRegistry.unregister(beanName);
     }
+
+
 }
\ No newline at end of file
diff --git a/src/org/apache/bsf/BSF_Log.java b/src/org/apache/bsf/BSF_Log.java
index 5b398e2..dd5ad0c 100755
--- a/src/org/apache/bsf/BSF_Log.java
+++ b/src/org/apache/bsf/BSF_Log.java
@@ -34,6 +34,7 @@ import  java.lang.reflect.*;
 */
 
 /* ---rgf, 2007-01-29, loading and invoking all methods via reflection
+   ---rgf, 2007-09-17, adjusted for using default class loader, if system class loader fails
 */
 
 public class BSF_Log // implements org.apache.commons.logging.Log
@@ -66,11 +67,21 @@ public class BSF_Log // implements org.apache.commons.logging.Log
     final private static int isWarnEnabled  = 17 ;
 
     {           // try to demand load the apache commons logging LogFactory
-        try
+        try     // rgf, 20070917: o.k., if not found, try definedClassLoader instead
         {
             ClassLoader cl= Thread.currentThread().getContextClassLoader();
 
-            oac_Log        = cl.loadClass("org.apache.commons.logging.Log"       );
+            String str4Log="org.apache.commons.logging.Log";
+
+            try {
+                oac_Log        = cl.loadClass(str4Log);
+            }
+            catch (ClassNotFoundException e1) // not found by contextClassLoader
+            {                                 // try defined class loader instead
+                ClassLoader defCL=BSFManager.getDefinedClassLoader();
+                oac_Log = defCL.loadClass(str4Log);
+                cl=defCL;       // class found, hence we use the definedClassLoader here
+            }
 
             oac_LogFactory = cl.loadClass("org.apache.commons.logging.LogFactory");
 
diff --git a/src/org/apache/bsf/util/EngineUtils.java b/src/org/apache/bsf/util/EngineUtils.java
index 65eb9b2..2cf8601 100644
--- a/src/org/apache/bsf/util/EngineUtils.java
+++ b/src/org/apache/bsf/util/EngineUtils.java
@@ -1,12 +1,12 @@
 /*
- * Copyright 2004,2004 The Apache Software Foundation.
- * 
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -32,11 +32,22 @@ import org.apache.bsf.BSFManager;
  * @author   Sam Ruby
  * @author   Rony G. Flatscher (added addEventListenerReturningEventInfos)
  */
+
+ /*  2007-09-21: Rony G. Flatscher, new class loading sequence:
+
+        - Thread's context class loader
+        - settable class loader stored with BSF manager
+        - BSFManager's defining class loader
+        - BSF-custom class loader (loads from temp dir)
+ */
 public class EngineUtils {
     // the BSF class loader that knows how to load from the a specific
     // temp directory
     static BSFClassLoader bsfCL;
 
+    // rgf, 20070917: class loaders that we might need to load classes
+    static ClassLoader bsfManagerDefinedCL=BSFManager.getDefinedClassLoader();
+
     // ---rgf, 2003-02-13, determine whether changing accessibility of Methods is possible
     static boolean bMethodHasSetAccessible=false;
     static {
@@ -86,7 +97,7 @@ public class EngineUtils {
         } catch (Exception e) {
             e.printStackTrace ();
             throw new BSFException (BSFException.REASON_OTHER_ERROR,
-                                    "ouch while adding event listener: "
+                                    "[EngineUtils.addEventListener()] ouch while adding event listener: "
                                     + e, e);
         }
     }
@@ -144,7 +155,7 @@ public class EngineUtils {
         } catch (Exception e) {
             e.printStackTrace ();
             throw new BSFException (BSFException.REASON_OTHER_ERROR,
-                                    "ouch while adding event listener: "
+                                    "[EngineUtils.addEventListenerReturningEventInfos()] ouch while adding event listener: "
                                     + e, e);
         }
     }
@@ -240,7 +251,7 @@ public class EngineUtils {
                           ((InvocationTargetException)e).getTargetException () :
                           null;
             throw new BSFException (BSFException.REASON_OTHER_ERROR,
-                                    "method invocation failed: " + e +
+                                    "[EngineUtils.callBeanMethod()] method invocation failed: " + e +
                                     ((t==null) ? "" :
                                      (" target exception: " + t)), t);
         }
@@ -302,7 +313,7 @@ public class EngineUtils {
             }
         } catch (Exception e) {
             throw new BSFException (BSFException.REASON_OTHER_ERROR,
-                                    e.getMessage (), e);
+                                    "[EngineUtils.createBean()]" + e.getMessage (), e);
         }
     }
 
@@ -343,8 +354,10 @@ public class EngineUtils {
     }
 
     /**
-     * Load a class using the class loader of given manager. If that fails
-     * try using a class loader that loads from the tempdir of the manager.
+     * Loads a class using the following sequence of class loaders:
+     * Thread's context class loader, settable class loader stored with BSFManager,
+     * BSFManager's defining class loader, BSF customized class loader (from the
+     * BSFManager's temporary directory).
      *
      * @param mgr  BSFManager who's classLoader and tempDir props are
      *        consulted
@@ -356,13 +369,45 @@ public class EngineUtils {
      */
     public static Class loadClass (BSFManager mgr, String name)
         throws BSFException {
-        ClassLoader classLoader = mgr.getClassLoader ();
+
+        ClassLoader mgrCL = null;
 
         try {
+            // -------------------
+            // TODO: final decision about the sequence of class loaders !
+            //
+            // rgf, 20070917: class loader sequence:
+            //                - Thread's context class loader
+            //                - settable class loader stored with BSF manager
+            //                - BSFManager's defining class loader
+            //                - BSF-custom class loader (loads from temp dir)
+            try {   // try the Thread's context loader first
+                    return Thread.currentThread().getContextClassLoader().loadClass(name);
+            }
+            catch (ClassNotFoundException e01) {
+            }
+
+            try {   // try the class loader of the supplied BSFManager ("mgr")
+                mgrCL = mgr.getClassLoader ();
+                if (mgrCL != null) {
+                    return mgrCL.loadClass(name);
+                }
+            }
+            catch (ClassNotFoundException e02) {
+                    // o.k., now try the defined class loader
+            }
+
+                // try the class loader stored with the BSF manager
+            if (mgrCL != bsfManagerDefinedCL) {
+                return bsfManagerDefinedCL.loadClass(name);
+            }
+
+/*
             return (classLoader == null) ?
                        // Class.forName (name)
                        Thread.currentThread().getContextClassLoader().loadClass (name)
                 : classLoader.loadClass (name);
+*/
         } catch (ClassNotFoundException e) {
             // try to load it from the temp dir using my own class loader
             try {
@@ -372,8 +417,9 @@ public class EngineUtils {
                 return bsfCL.loadClass (name);
             } catch (ClassNotFoundException e2) {
                 throw new BSFException (BSFException.REASON_OTHER_ERROR,
-                        "unable to load class '" + name + "':" + e, e);
+                        "[EngineUtils.loadClass()] unable to load class '" + name + "':" + e, e);
             }
         }
+        return null;
     }
 }
diff --git a/src/org/apache/bsf/util/ReflectionUtils.java b/src/org/apache/bsf/util/ReflectionUtils.java
index 9dcf085..e7112b9 100644
--- a/src/org/apache/bsf/util/ReflectionUtils.java
+++ b/src/org/apache/bsf/util/ReflectionUtils.java
@@ -1,12 +1,12 @@
 /*
- * Copyright 2004,2004 The Apache Software Foundation.
- * 
+ * Copyright 2004,2007 The Apache Software Foundation.
+ *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -16,6 +16,8 @@
 
 package org.apache.bsf.util;
 
+import org.apache.bsf.BSFManager;   // rgf, 20070917
+
 import java.beans.BeanInfo;
 import java.beans.Beans;
 import java.beans.EventSetDescriptor;
@@ -44,7 +46,16 @@ import org.apache.bsf.util.type.TypeConvertorRegistry;
  * @author   Sanjiva Weerawarana
  * @author   Joseph Kesselman
  */
+ /*  2007-09-21: Rony G. Flatscher, new class loading sequence:
+
+        - supplied class loader (given as an argument)
+        - Thread's context class loader
+        - BSFManager's defining class loader
+ */
 public class ReflectionUtils {
+    // rgf, 20070921: class loaders that we might need to load classes
+    static ClassLoader bsfManagerDefinedCL=BSFManager.getDefinedClassLoader();
+
 
   //////////////////////////////////////////////////////////////////////////
 
@@ -67,7 +78,7 @@ public class ReflectionUtils {
    *            running add event listener method
    */
   public static void addEventListener (Object source, String eventSetName,
-									   EventProcessor processor)
+				       EventProcessor processor)
 	   throws IntrospectionException, IllegalArgumentException,
 			  IllegalAccessException, InstantiationException,
 			  InvocationTargetException {
@@ -142,16 +153,77 @@ public class ReflectionUtils {
    * @exception IOException               if I/O error in beans.instantiate
    */
   public static Bean createBean (ClassLoader cld, String className,
-								 Class[] argTypes, Object[] args)
+				 Class[] argTypes, Object[] args)
 	   throws ClassNotFoundException, NoSuchMethodException,
 			  InstantiationException, IllegalAccessException,
 			  IllegalArgumentException, InvocationTargetException,
 			  IOException {
 	if (argTypes != null) {
+
+/* original (remarked 20070917, rgf)
 	  // find the right constructor and use that to create bean
 	  Class cl = (cld != null) ? cld.loadClass (className)
 				   : Thread.currentThread().getContextClassLoader().loadClass (className); // rgf, 2006-01-05
                                    // : Class.forName (className);
+*/
+            // TODO: final decision about class loading strategy
+            // rgf, 20070917: if class loader given, use that one, else try
+            //                the Thread's context class loader and then
+            //                the BSFMananger defining class loader
+          Class cl=null;
+          ClassNotFoundException exCTX=null;
+
+// -----------------------------
+          if (cld != null) {    // class loader supplied as argument
+              try {     // CL passed as argument
+                  cl=cld.loadClass(className);
+              }
+              catch (ClassNotFoundException e02) {
+                  exCTX=e02;
+              }
+          }
+
+          if (cl==null) {
+              try {         // CTXCL
+                  cl=Thread.currentThread().getContextClassLoader().loadClass(className);
+              }
+              catch (ClassNotFoundException e01)  {
+              }
+          }
+
+
+          if (cl==null) {   // class not loaded yet
+                    // defined CL
+              if (cld != bsfManagerDefinedCL) {   // if not used already, attempt to load
+                  cl=bsfManagerDefinedCL.loadClass(className);
+              }
+              else {    // already , throw exception
+                  throw exCTX;        // re-throw very first exception
+              }
+          }
+// -----------------------------
+
+/*
+          try {     // try supplied class loader
+              if (cld !=null)
+                  cl=cld.loadClass(className);
+          }
+          catch (ClassNotFoundException e01) {
+              try {
+                  cl=Thread.currentThread().getContextClassLoader().loadClass(className);
+              }
+              catch (ClassNotFoundException e02)  {
+                  ClassLoader defCL=BSFManager.getDefinedClassLoader();
+                  if (cld != defCL) {
+                      cl=defCL.loadClass(className);
+                  }
+                  else
+                  {
+                      throw e01;        // re-throw original class not found exception
+                  }
+              }
+          }
+*/
 
 	  Constructor c = MethodUtils.getConstructor (cl, argTypes);
 	  return new Bean (cl, c.newInstance (args));
@@ -182,8 +254,7 @@ public class ReflectionUtils {
    * @exception InvocationTargetException if constructor excepted
    * @exception IOException               if I/O error in beans.instantiate
    */
-  public static Bean createBean (ClassLoader cld, String className,
-								 Object[] args)
+  public static Bean createBean (ClassLoader cld, String className, Object[] args)
 	   throws ClassNotFoundException, NoSuchMethodException,
 			  InstantiationException, IllegalAccessException,
 			  IllegalArgumentException, InvocationTargetException,
@@ -205,7 +276,7 @@ public class ReflectionUtils {
    */
   private static
   FeatureDescriptor findFeatureByName (String featureType, String name,
-									   FeatureDescriptor[] fds) {
+				       FeatureDescriptor[] fds) {
 	for (int i = 0; i < fds.length; i++) {
 	  if (name.equals (fds[i].getName())) {
 		return fds[i];
@@ -229,7 +300,7 @@ public class ReflectionUtils {
 	  return new Bean (fieldType, value);
 	} catch (NoSuchFieldException e) {
 	  throw new IllegalArgumentException ("field '" + fieldName + "' is " +
-										  "unknown for '" + target + "'");
+					      "unknown for '" + target + "'");
 	}
   }
   //////////////////////////////////////////////////////////////////////////
@@ -250,7 +321,7 @@ public class ReflectionUtils {
    * @exception InvocationTargetException if read method excepts
    */
   public static Bean getProperty (Object target, String propName,
-								  Integer index)
+				  Integer index)
 	   throws IntrospectionException, IllegalArgumentException,
 			  IllegalAccessException, InvocationTargetException {
 	// find the property descriptor
@@ -259,7 +330,7 @@ public class ReflectionUtils {
 	  findFeatureByName ("property", propName, bi.getPropertyDescriptors ());
 	if (pd == null) {
 	  throw new IllegalArgumentException ("property '" + propName + "' is " +
-										  "unknown for '" + target + "'");
+					      "unknown for '" + target + "'");
 	}
 
 	// get read method and type of property
@@ -269,8 +340,8 @@ public class ReflectionUtils {
 	  // if index != null, then property is indexed - pd better be so too
 	  if (!(pd instanceof IndexedPropertyDescriptor)) {
 		throw new IllegalArgumentException ("attempt to get non-indexed " +
-											"property '" + propName +
-											"' as being indexed");
+						    "property '" + propName +
+						    "' as being indexed");
 	  }
 	  IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) pd;
 	  rm = ipd.getIndexedReadMethod ();
@@ -282,7 +353,7 @@ public class ReflectionUtils {
 
 	if (rm == null) {
 	  throw new IllegalArgumentException ("property '" + propName +
-										  "' is not readable");
+					      "' is not readable");
 	}
 
 	// now get the value
@@ -295,7 +366,7 @@ public class ReflectionUtils {
 	return new Bean (propType, propVal);
   }
   public static void setField (Object target, String fieldName, Bean value,
-							   TypeConvertorRegistry tcr)
+			       TypeConvertorRegistry tcr)
 	  throws IllegalArgumentException, IllegalAccessException {
 	// This is to handle how we do static fields.
 	Class targetClass = (target instanceof Class)
@@ -323,14 +394,14 @@ public class ReflectionUtils {
 	  }
 	  if (!okeydokey) {
 		throw new IllegalArgumentException ("unable to assign '" + value.value +
-											"' to field '" + fieldName + "'");
+						    "' to field '" + fieldName + "'");
 	  }
 
 	  // now set the value
 	  f.set (target, fieldVal);
 	} catch (NoSuchFieldException e) {
 	  throw new IllegalArgumentException ("field '" + fieldName + "' is " +
-										  "unknown for '" + target + "'");
+					      "unknown for '" + target + "'");
 	}
   }
   //////////////////////////////////////////////////////////////////////////
@@ -355,8 +426,8 @@ public class ReflectionUtils {
    * @exception InvocationTargetException if write method excepts
    */
   public static void setProperty (Object target, String propName,
-								  Integer index, Object value,
-								  Class valueType, TypeConvertorRegistry tcr)
+				  Integer index, Object value,
+				  Class valueType, TypeConvertorRegistry tcr)
 	   throws IntrospectionException, IllegalArgumentException,
 			  IllegalAccessException, InvocationTargetException {
 	// find the property descriptor
@@ -365,7 +436,7 @@ public class ReflectionUtils {
 	  findFeatureByName ("property", propName, bi.getPropertyDescriptors ());
 	if (pd == null) {
 	  throw new IllegalArgumentException ("property '" + propName + "' is " +
-										  "unknown for '" + target + "'");
+					      "unknown for '" + target + "'");
 	}
 
 	// get write method and type of property
@@ -375,7 +446,7 @@ public class ReflectionUtils {
 	  // if index != null, then property is indexed - pd better be so too
 	  if (!(pd instanceof IndexedPropertyDescriptor)) {
 		throw new IllegalArgumentException ("attempt to set non-indexed " +
-											"property '" + propName +
+						    "property '" + propName +
 											"' as being indexed");
 	  }
 	  IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) pd;
@@ -388,7 +459,7 @@ public class ReflectionUtils {
 
 	if (wm == null) {
 	  throw new IllegalArgumentException ("property '" + propName +
-										  "' is not writeable");
+					      "' is not writeable");
 	}
 
 	// type convert the value if necessary
@@ -408,7 +479,7 @@ public class ReflectionUtils {
 	}
 	if (!okeydokey) {
 	  throw new IllegalArgumentException ("unable to assign '" + value +
-										  "' to property '" + propName + "'");
+					      "' to property '" + propName + "'");
 	}
 
 	// now set the value
diff --git a/src/org/apache/bsf/util/event/generator/EventAdapterGenerator.java b/src/org/apache/bsf/util/event/generator/EventAdapterGenerator.java
index 34fcdf5..41a7c51 100644
--- a/src/org/apache/bsf/util/event/generator/EventAdapterGenerator.java
+++ b/src/org/apache/bsf/util/event/generator/EventAdapterGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004,2004 The Apache Software Foundation.
+ * Copyright 2004,2007 The Apache Software Foundation.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,11 +14,23 @@
  * limitations under the License.
  */
 
+
+ /*
+ 2007-01-29: Rony G. Flatscher: added BSF_Log[Factory] to allow BSF to run without org.apache.commons.logging present
+
+ 2007-09-21: Rony G. Flatscher, new class loading sequence:
+
+        - Thread's context class loader
+        - BSFManager's defining class loader
+ */
+
 package org.apache.bsf.util.event.generator;
 
 import org.apache.bsf.BSF_Log;
 import org.apache.bsf.BSF_LogFactory;
 
+import org.apache.bsf.BSFManager;
+
 import java.io.FileOutputStream;
 import java.io.IOException;
 
@@ -27,7 +39,6 @@ import java.io.IOException;
   *
   * Generate an "Event Adapter" dynamically during program execution
   *
- * @author   Rony G. Flatscher (added BSF_Log[Factory] to allow BSF to run without org.apache.commons.logging present)
   **/
 public class EventAdapterGenerator
 {
@@ -77,7 +88,19 @@ public class EventAdapterGenerator
 	}
 	try
 	// { EVENTLISTENER = Class.forName("java.util.EventListener"); }
-	{ EVENTLISTENER = Thread.currentThread().getContextClassLoader().loadClass ("java.util.EventListener"); } // rgf, 2006-01-05
+	{
+            // EVENTLISTENER = Thread.currentThread().getContextClassLoader().loadClass ("java.util.EventListener"); // rgf, 2006-01-05
+
+            // rgf, 20070917: first try context class loader, then BSFManager's defining class loader
+            try {
+                 EVENTLISTENER = Thread.currentThread().getContextClassLoader().loadClass ("java.util.EventListener");
+            }
+            catch(ClassNotFoundException ex01)
+            {
+                EVENTLISTENER = BSFManager.getDefinedClassLoader().loadClass ("java.util.EventListener");
+            }
+
+        }
 	catch(ClassNotFoundException ex)
 	{
             System.err.println(ex.getMessage());
@@ -176,7 +199,7 @@ public class EventAdapterGenerator
   /* methods that take an EventListener Class Type to create an EventAdapterClass */
   public static Class makeEventAdapterClass(Class listenerType,boolean writeClassFile)
   {
-      logger.info("EventAdapterGenerator");
+      logger.debug("EventAdapterGenerator");
 
         if( EVENTLISTENER.isAssignableFrom(listenerType) )
 	{
@@ -191,7 +214,7 @@ public class EventAdapterGenerator
 
 	  /* Derive Names */
 	  String listenerTypeName      = listenerType.getName();
-          logger.info("ListenerTypeName: "+listenerTypeName);
+          logger.debug("ListenerTypeName: "+listenerTypeName);
 	  String adapterClassName      =
 		CLASSPACKAGE+
 		(listenerTypeName.endsWith("Listener")
@@ -206,7 +229,7 @@ public class EventAdapterGenerator
 	  {
 		if (null != (cached = ldr.getLoadedClass(finalAdapterClassName)))
 		{
-                    logger.info("cached:  "+cached);
+                    logger.debug("cached:  "+cached);
 		  try
 		  {
 			if (!listenerType.isAssignableFrom(cached))
