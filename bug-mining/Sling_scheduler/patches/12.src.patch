diff --git a/pom.xml b/pom.xml
index 9ce8071..44bb11d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -85,10 +85,12 @@
                             !weblogic.jdbc.jts,
                             !weblogic.jdbc.vendor.oracle,
                             org.apache.sling.discovery;resolution:=optional,
+                            !org.apache.sling.settings;resolution:=optional,
                             *                        
                         </Import-Package>
                         <DynamicImport-Package>
                             org.apache.sling.discovery;version="[1.0,2)",
+                            org.apache.sling.settings;version="[1.0,2)",
                             commonj.work,
                             com.mchange.v2.c3p0,
                             javax.ejb,
@@ -166,6 +168,12 @@
             <version>1.0.0</version>
             <scope>provided</scope>
         </dependency>
+        <dependency>
+            <groupId>org.apache.sling</groupId>
+            <artifactId>org.apache.sling.settings</artifactId>
+            <version>1.0.0</version>
+            <scope>provided</scope>
+        </dependency>
         <dependency>
             <groupId>org.quartz-scheduler</groupId>
             <artifactId>quartz</artifactId>
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzJobExecutor.java b/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzJobExecutor.java
index 57fd4a6..6dae910 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzJobExecutor.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzJobExecutor.java
@@ -36,11 +36,14 @@ import org.slf4j.Logger;
  */
 public class QuartzJobExecutor implements Job {
 
-    /** Is discovery information available? */
+    /** Is discovery available? */
+    public static final AtomicBoolean DISCOVERY_AVAILABLE = new AtomicBoolean(false);
+
+    /** Is stable discovery information available? */
     public static final AtomicBoolean DISCOVERY_INFO_AVAILABLE = new AtomicBoolean(false);
 
-    /** The id of the current instance. */
-    public static String SLING_ID;
+    /** The id of the current instance (if settings service is available. */
+    public static volatile String SLING_ID;
 
     /** Is this instance the leader? */
     public static final AtomicBoolean IS_LEADER = new AtomicBoolean(true);
@@ -57,37 +60,44 @@ public class QuartzJobExecutor implements Job {
         // check run on information
         final String[] runOn = (String[])data.get(QuartzScheduler.DATA_MAP_RUN_ON);
         if ( runOn != null ) {
-            if ( runOn.length == 1 && Scheduler.VALUE_RUN_ON_LEADER.equals(runOn[0])
-                 || runOn.length == 1 && Scheduler.VALUE_RUN_ON_SINGLE.equals(runOn[0]) ) {
-                if ( DISCOVERY_INFO_AVAILABLE.get() ) {
-                    if ( !IS_LEADER.get() ) {
-                        logger.debug("Excluding job {} with name {} and config {}.",
+            if ( runOn.length == 1 &&
+                 (Scheduler.VALUE_RUN_ON_LEADER.equals(runOn[0]) || Scheduler.VALUE_RUN_ON_SINGLE.equals(runOn[0])) ) {
+                if ( DISCOVERY_AVAILABLE.get() ) {
+                    if ( DISCOVERY_INFO_AVAILABLE.get() ) {
+                        if ( !IS_LEADER.get() ) {
+                            logger.debug("Excluding job {} with name {} and config {} - instance is not leader",
+                                    new Object[] {job, data.get(QuartzScheduler.DATA_MAP_NAME), runOn[0]});
+                            return;
+                        }
+                    } else {
+                        logger.debug("No discovery info available. Excluding job {} with name {} and config {}.",
                                 new Object[] {job, data.get(QuartzScheduler.DATA_MAP_NAME), runOn[0]});
                         return;
                     }
                 } else {
-                    logger.warn("No discovery info available. Executing job {} with name {} and config {} anyway.",
+                    logger.error("No discovery available, therefore not executing job {} with name {} and config {}.",
                             new Object[] {job, data.get(QuartzScheduler.DATA_MAP_NAME), runOn[0]});
+                    return;
                 }
             } else { // sling IDs
                 final String myId = SLING_ID;
-                boolean schedule = false;
                 if ( myId == null ) {
-                    logger.warn("No Sling ID available. Executing job {} with name {} and config {} anyway.",
+                    logger.error("No Sling ID available, therefore not executing job {} with name {} and config {}.",
                             new Object[] {job, data.get(QuartzScheduler.DATA_MAP_NAME), Arrays.toString(runOn)});
-                    schedule = true;
+                    return;
                 } else {
+                    boolean schedule = false;
                     for(final String id : runOn ) {
                         if ( myId.equals(id) ) {
                             schedule = true;
                             break;
                         }
                     }
-                }
-                if ( !schedule ) {
-                    logger.debug("Excluding job {} with name {} and config {}.",
-                            new Object[] {job, data.get(QuartzScheduler.DATA_MAP_NAME), Arrays.toString(runOn)});
-                    return;
+                    if ( !schedule ) {
+                        logger.debug("Excluding job {} with name {} and config {} - different Sling ID",
+                                new Object[] {job, data.get(QuartzScheduler.DATA_MAP_NAME), Arrays.toString(runOn)});
+                        return;
+                    }
                 }
             }
         }
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzScheduler.java b/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzScheduler.java
index 366c29b..8e23fc9 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzScheduler.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzScheduler.java
@@ -91,6 +91,9 @@ public class QuartzScheduler implements BundleListener {
     /** Map key for the bundle information (Long). */
     static final String DATA_MAP_BUNDLE_ID = "QuartzJobScheduler.bundleId";
 
+    /** Map key for the bundle information (Long). */
+    static final String DATA_MAP_SERVICE_ID = "QuartzJobScheduler.serviceId";
+
     /** The quartz scheduler. */
     private volatile org.quartz.Scheduler scheduler;
 
@@ -252,6 +255,7 @@ public class QuartzScheduler implements BundleListener {
      * @return
      */
     private JobDataMap initDataMap(final Long    bundleId,
+                                   final Long    serviceId,
                                    final String  jobName,
                                    final Object  job,
                                    final InternalScheduleOptions options) {
@@ -264,6 +268,9 @@ public class QuartzScheduler implements BundleListener {
         if ( bundleId != null ) {
             jobDataMap.put(DATA_MAP_BUNDLE_ID, bundleId);
         }
+        if ( serviceId != null ) {
+            jobDataMap.put(DATA_MAP_SERVICE_ID, serviceId);
+        }
         if ( options.configuration != null ) {
             jobDataMap.put(DATA_MAP_CONFIGURATION, options.configuration);
         }
@@ -304,13 +311,14 @@ public class QuartzScheduler implements BundleListener {
      * @see org.apache.sling.commons.scheduler.Scheduler#addJob(java.lang.String, java.lang.Object, java.util.Map, java.lang.String, boolean)
      */
     public void addJob(final Long bundleId,
+                       final Long serviceId,
                        final String name,
                        final Object job,
                        final Map<String, Serializable>    config,
                        final String schedulingExpression,
                        final boolean canRunConcurrently)
     throws SchedulerException {
-        this.scheduleJob(bundleId, job,
+        this.scheduleJob(bundleId, serviceId, job,
                 EXPR(schedulingExpression).name(name).config(config).canRunConcurrently(canRunConcurrently));
     }
 
@@ -318,19 +326,21 @@ public class QuartzScheduler implements BundleListener {
      * @see org.apache.sling.commons.scheduler.Scheduler#addPeriodicJob(java.lang.String, java.lang.Object, java.util.Map, long, boolean)
      */
     public void addPeriodicJob(final Long bundleId,
+                               final Long serviceId,
                                final String name,
                                final Object job,
                                final Map<String, Serializable> config,
                                final long period,
                                final boolean canRunConcurrently)
     throws SchedulerException {
-        this.addPeriodicJob(bundleId, name, job, config, period, canRunConcurrently, false);
+        this.addPeriodicJob(bundleId, serviceId, name, job, config, period, canRunConcurrently, false);
     }
 
     /**
      * @see org.apache.sling.commons.scheduler.Scheduler#addPeriodicJob(java.lang.String, java.lang.Object, java.util.Map, long, boolean, boolean)
      */
     public void addPeriodicJob(final Long bundleId,
+            final Long serviceId,
             final String name,
             final Object job,
             final Map<String, Serializable> config,
@@ -338,7 +348,7 @@ public class QuartzScheduler implements BundleListener {
             final boolean canRunConcurrently,
             final boolean startImmediate)
     throws SchedulerException {
-        this.scheduleJob(bundleId, job,
+        this.scheduleJob(bundleId, serviceId, job,
                 PERIODIC(period, startImmediate).name(name).config(config).canRunConcurrently(canRunConcurrently));
     }
 
@@ -361,18 +371,22 @@ public class QuartzScheduler implements BundleListener {
     /**
      * @see org.apache.sling.commons.scheduler.Scheduler#fireJob(java.lang.Object, java.util.Map)
      */
-    public void fireJob(final Long bundleId, final Object job, final Map<String, Serializable> config)
+    public void fireJob(final Long bundleId,
+            final Long serviceId,
+            final Object job, final Map<String, Serializable> config)
     throws SchedulerException {
-        this.scheduleJob(bundleId, job,
+        this.scheduleJob(bundleId, serviceId, job,
                 NOW().config(config));
     }
 
     /**
      * @see org.apache.sling.commons.scheduler.Scheduler#fireJobAt(java.lang.String, java.lang.Object, java.util.Map, java.util.Date)
      */
-    public void fireJobAt(final Long bundleId, final String name, final Object job, final Map<String, Serializable> config, final Date date)
+    public void fireJobAt(final Long bundleId,
+            final Long serviceId,
+            final String name, final Object job, final Map<String, Serializable> config, final Date date)
     throws SchedulerException {
-        this.scheduleJob(bundleId, job,
+        this.scheduleJob(bundleId, serviceId, job,
                 AT(date).name(name).config(config));
     }
 
@@ -380,11 +394,12 @@ public class QuartzScheduler implements BundleListener {
      * @see org.apache.sling.commons.scheduler.Scheduler#fireJob(java.lang.Object, java.util.Map, int, long)
      */
     public boolean fireJob(final Long bundleId,
+                           final Long serviceId,
                            final Object job,
                            final Map<String, Serializable> config,
                            final int times,
                            final long period) {
-        return this.schedule(bundleId, job,
+        return this.schedule(bundleId, serviceId, job,
                 NOW(times, period).config(config));
     }
 
@@ -392,13 +407,14 @@ public class QuartzScheduler implements BundleListener {
      * @see org.apache.sling.commons.scheduler.Scheduler#fireJobAt(java.lang.String, java.lang.Object, java.util.Map, java.util.Date, int, long)
      */
     public boolean fireJobAt(final Long bundleId,
+                             final Long serviceId,
                              final String name,
                              final Object job,
                              final Map<String, Serializable> config,
                              final Date date,
                              final int times,
                              final long period) {
-        return this.schedule(bundleId, job,
+        return this.schedule(bundleId, serviceId, job,
                 AT(date, times, period).name(name).config(config));
     }
 
@@ -574,9 +590,9 @@ public class QuartzScheduler implements BundleListener {
     /**
      * @see org.apache.sling.commons.scheduler.Scheduler#schedule(java.lang.Object, org.apache.sling.commons.scheduler.ScheduleOptions)
      */
-    public boolean schedule(final Long bundleId, final Object job, final ScheduleOptions options) {
+    public boolean schedule(final Long bundleId, final Long serviceId, final Object job, final ScheduleOptions options) {
         try {
-            this.scheduleJob(bundleId, job, options);
+            this.scheduleJob(bundleId, serviceId, job, options);
             return true;
         } catch (final IllegalArgumentException iae) {
             // ignore this and return false
@@ -615,7 +631,7 @@ public class QuartzScheduler implements BundleListener {
      * @throws SchedulerException if the job can't be scheduled
      * @throws IllegalArgumentException If the preconditions are not met
      */
-    private void scheduleJob(final Long bundleId, final Object job, final ScheduleOptions options)
+    private void scheduleJob(final Long bundleId, final Long serviceId, final Object job, final ScheduleOptions options)
     throws SchedulerException {
         this.checkJob(job);
 
@@ -657,7 +673,7 @@ public class QuartzScheduler implements BundleListener {
             final Trigger trigger = opts.trigger.withIdentity(name).build();
 
             // create the data map
-            final JobDataMap jobDataMap = this.initDataMap(bundleId, name, job, opts);
+            final JobDataMap jobDataMap = this.initDataMap(bundleId, serviceId, name, job, opts);
 
             final JobDetail detail = this.createJobDetail(name, jobDataMap, opts.canRunConcurrently);
 
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/SchedulerServiceFactory.java b/src/main/java/org/apache/sling/commons/scheduler/impl/SchedulerServiceFactory.java
index 7afbe46..dd92b43 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/SchedulerServiceFactory.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/SchedulerServiceFactory.java
@@ -53,7 +53,7 @@ public class SchedulerServiceFactory implements Scheduler {
      * @see org.apache.sling.commons.scheduler.Scheduler#schedule(java.lang.Object, org.apache.sling.commons.scheduler.ScheduleOptions)
      */
     public boolean schedule(final Object job, final ScheduleOptions options) {
-        return this.scheduler.schedule(this.bundleId, job, options);
+        return this.scheduler.schedule(this.bundleId, null, job, options);
     }
 
     /**
@@ -104,7 +104,7 @@ public class SchedulerServiceFactory implements Scheduler {
     public void addJob(final String name, final Object job,
             final Map<String, Serializable> config, final String schedulingExpression,
             final boolean canRunConcurrently) throws Exception {
-        this.scheduler.addJob(this.bundleId, name, job, config, schedulingExpression, canRunConcurrently);
+        this.scheduler.addJob(this.bundleId, null, name, job, config, schedulingExpression, canRunConcurrently);
     }
 
     /**
@@ -113,7 +113,7 @@ public class SchedulerServiceFactory implements Scheduler {
     public void addPeriodicJob(final String name, final Object job,
             final Map<String, Serializable> config, final long period,
             final boolean canRunConcurrently) throws Exception {
-        this.scheduler.addPeriodicJob(this.bundleId, name, job, config, period, canRunConcurrently);
+        this.scheduler.addPeriodicJob(this.bundleId, null, name, job, config, period, canRunConcurrently);
     }
 
     /**
@@ -123,7 +123,7 @@ public class SchedulerServiceFactory implements Scheduler {
             final Map<String, Serializable> config, final long period,
             final boolean canRunConcurrently, final boolean startImmediate)
             throws Exception {
-        this.scheduler.addPeriodicJob(this.bundleId, name, job, config, period, canRunConcurrently, startImmediate);
+        this.scheduler.addPeriodicJob(this.bundleId, null, name, job, config, period, canRunConcurrently, startImmediate);
     }
 
     /**
@@ -131,7 +131,7 @@ public class SchedulerServiceFactory implements Scheduler {
      */
     public void fireJob(final Object job, final Map<String, Serializable> config)
             throws Exception {
-        this.scheduler.fireJob(this.bundleId, job, config);
+        this.scheduler.fireJob(this.bundleId, null, job, config);
     }
 
     /**
@@ -139,7 +139,7 @@ public class SchedulerServiceFactory implements Scheduler {
      */
     public boolean fireJob(final Object job, final Map<String, Serializable> config,
             final int times, final long period) {
-        return this.scheduler.fireJob(this.bundleId, job, config, times, period);
+        return this.scheduler.fireJob(this.bundleId, null, job, config, times, period);
     }
 
     /**
@@ -147,7 +147,7 @@ public class SchedulerServiceFactory implements Scheduler {
      */
     public void fireJobAt(final String name, final Object job,
             final Map<String, Serializable> config, final Date date) throws Exception {
-        this.scheduler.fireJob(this.bundleId, job, config);
+        this.scheduler.fireJob(this.bundleId, null, job, config);
     }
 
     /**
@@ -155,7 +155,7 @@ public class SchedulerServiceFactory implements Scheduler {
      */
     public boolean fireJobAt(final String name, final Object job,
             final Map<String, Serializable> config, final Date date, final int times, final long period) {
-        return this.scheduler.fireJobAt(this.bundleId, name, job, config, date, times, period);
+        return this.scheduler.fireJobAt(this.bundleId, null, name, job, config, date, times, period);
     }
 
     public void removeJob(final String name) throws NoSuchElementException {
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/SettingsSupport.java b/src/main/java/org/apache/sling/commons/scheduler/impl/SettingsSupport.java
new file mode 100644
index 0000000..e43e59e
--- /dev/null
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/SettingsSupport.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.sling.commons.scheduler.impl;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.felix.scr.annotations.Activate;
+import org.apache.felix.scr.annotations.Component;
+import org.apache.felix.scr.annotations.Deactivate;
+import org.apache.sling.settings.SlingSettingsService;
+import org.osgi.framework.BundleContext;
+import org.osgi.framework.Constants;
+import org.osgi.framework.InvalidSyntaxException;
+import org.osgi.framework.ServiceEvent;
+import org.osgi.framework.ServiceListener;
+import org.osgi.framework.ServiceReference;
+
+/**
+ * The <code>SettingsSupport</code> listens for the settings service.
+ */
+@Component
+public class SettingsSupport {
+
+    private static final String SETTINGS_NAME = "org.apache.sling.settings.SlingSettingsService";
+
+    /** The listener for the settings service. */
+    private volatile Listener settingsListener;
+
+    /**
+     * Start the component.
+     * @param bc Bundle context
+     */
+    @Activate
+    protected void activate(final BundleContext bc) {
+        this.settingsListener = new Listener(bc);
+        this.settingsListener.start();
+    }
+
+    /**
+     * Stop the component.
+     */
+    @Deactivate
+    protected void deactivate() {
+        if ( this.settingsListener != null ) {
+            this.settingsListener.stop();
+            this.settingsListener = null;
+        }
+    }
+
+    /**
+     * Helper class listening for the settings service
+     */
+    protected static final class Listener implements ServiceListener {
+
+        /** The bundle context. */
+        private final BundleContext bundleContext;
+
+        private final AtomicBoolean active = new AtomicBoolean(false);
+
+        /**
+         * Constructor
+         */
+        public Listener(final BundleContext bundleContext) {
+            this.bundleContext = bundleContext;
+        }
+
+        /**
+         * Start the listener.
+         * First register a service listener and then check for the service.
+         */
+        public void start() {
+            try {
+                bundleContext.addServiceListener(this, "("
+                        + Constants.OBJECTCLASS + "=" + SETTINGS_NAME + ")");
+            } catch (final InvalidSyntaxException ise) {
+                // this should really never happen
+                throw new RuntimeException("Unexpected exception occured.", ise);
+            }
+            active.set(true);
+            this.retainService();
+        }
+
+        /**
+         * Unregister the listener.
+         */
+        public void stop() {
+            if ( active.compareAndSet(true, false) ) {
+                bundleContext.removeServiceListener(this);
+            }
+        }
+
+        /**
+         * Try to get the service and the Sling ID
+         */
+        private synchronized void retainService() {
+            final ServiceReference reference = bundleContext.getServiceReference(SETTINGS_NAME);
+            if ( reference != null ) {
+                final SlingSettingsService service = (SlingSettingsService)bundleContext.getService(reference);
+                if ( service != null ) {
+                    QuartzJobExecutor.SLING_ID = service.getSlingId();
+                    this.bundleContext.ungetService(reference);
+                    // stop the listener, we don't need it anymore
+                    this.stop();
+                }
+            }
+        }
+
+        /**
+         * @see org.osgi.framework.ServiceListener#serviceChanged(org.osgi.framework.ServiceEvent)
+         */
+        public void serviceChanged(final ServiceEvent event) {
+            if (event.getType() == ServiceEvent.REGISTERED) {
+                this.retainService();
+            }
+        }
+    }
+}
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/TopologyHandler.java b/src/main/java/org/apache/sling/commons/scheduler/impl/TopologyHandler.java
index c328893..69881fe 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/TopologyHandler.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/TopologyHandler.java
@@ -16,7 +16,9 @@
  */
 package org.apache.sling.commons.scheduler.impl;
 
+import org.apache.felix.scr.annotations.Activate;
 import org.apache.felix.scr.annotations.Component;
+import org.apache.felix.scr.annotations.Deactivate;
 import org.apache.felix.scr.annotations.Service;
 import org.apache.sling.discovery.TopologyEvent;
 import org.apache.sling.discovery.TopologyEvent.Type;
@@ -30,12 +32,21 @@ import org.apache.sling.discovery.TopologyEventListener;
 @Service(value=TopologyEventListener.class)
 public class TopologyHandler implements TopologyEventListener {
 
+    @Activate
+    public void activate() {
+        QuartzJobExecutor.DISCOVERY_AVAILABLE.set(true);
+    }
+
+    @Deactivate
+    public void deactivate() {
+        QuartzJobExecutor.DISCOVERY_AVAILABLE.set(false);
+    }
+
     /**
      * @see org.apache.sling.discovery.TopologyEventListener#handleTopologyEvent(org.apache.sling.discovery.TopologyEvent)
      */
     public void handleTopologyEvent(final TopologyEvent event) {
         if ( event.getType() == Type.TOPOLOGY_INIT || event.getType() == Type.TOPOLOGY_CHANGED ) {
-            QuartzJobExecutor.SLING_ID = event.getNewView().getLocalInstance().getSlingId();
             QuartzJobExecutor.IS_LEADER.set(event.getNewView().getLocalInstance().isLeader());
             QuartzJobExecutor.DISCOVERY_INFO_AVAILABLE.set(true);
         } else if ( event.getType() == Type.TOPOLOGY_CHANGING ) {
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/WebConsolePrinter.java b/src/main/java/org/apache/sling/commons/scheduler/impl/WebConsolePrinter.java
index 47f44be..b4dfefd 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/WebConsolePrinter.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/WebConsolePrinter.java
@@ -72,6 +72,7 @@ public class WebConsolePrinter {
                 pw.println(s.getSchedulerName());
                 pw.print  ("Id     : ");
                 pw.println(s.getSchedulerInstanceId());
+                pw.println();
                 final List<String> groups = s.getJobGroupNames();
                 for(final String group : groups) {
                     final Set<JobKey> keys = s.getJobKeys(GroupMatcher.jobGroupEquals(group));
@@ -96,12 +97,47 @@ public class WebConsolePrinter {
                             if ( runOn != null ) {
                                 pw.print(", runOn: ");
                                 pw.print(Arrays.toString(runOn));
-                            }
+                                // check run on information
+                                if ( runOn.length == 1 &&
+                                     (org.apache.sling.commons.scheduler.Scheduler.VALUE_RUN_ON_LEADER.equals(runOn[0]) || org.apache.sling.commons.scheduler.Scheduler.VALUE_RUN_ON_SINGLE.equals(runOn[0])) ) {
+                                    if ( QuartzJobExecutor.DISCOVERY_AVAILABLE.get() ) {
+                                        if ( QuartzJobExecutor.DISCOVERY_INFO_AVAILABLE.get() ) {
+                                            if ( !QuartzJobExecutor.IS_LEADER.get() ) {
+                                                pw.print(" (inactive: not leader)");
+                                            }
+                                        } else {
+                                            pw.print(" (inactive: no discovery info)");
+                                        }
+                                    } else {
+                                        pw.print(" (inactive: no discovery)");
+                                    }
+                                } else { // sling IDs
+                                    final String myId = QuartzJobExecutor.SLING_ID;
+                                    if ( myId == null ) {
+                                        pw.print(" (inactive: no Sling settings)");
+                                    } else {
+                                        boolean schedule = false;
+                                        for(final String id : runOn ) {
+                                            if ( myId.equals(id) ) {
+                                                schedule = true;
+                                                break;
+                                            }
+                                        }
+                                        if ( !schedule ) {
+                                            pw.print(" (inactive: Sling ID)");
+                                        }
+                                    }
+                                }                            }
                             final Long bundleId = (Long)detail.getJobDataMap().get(QuartzScheduler.DATA_MAP_BUNDLE_ID);
                             if ( bundleId != null ) {
                                 pw.print(", bundleId: ");
                                 pw.print(String.valueOf(bundleId));
                             }
+                            final Long serviceId = (Long)detail.getJobDataMap().get(QuartzScheduler.DATA_MAP_SERVICE_ID);
+                            if ( serviceId != null ) {
+                                pw.print(", serviceId: ");
+                                pw.print(String.valueOf(serviceId));
+                            }
                             pw.println();
                             for(final Trigger trigger : s.getTriggersOfJob(key)) {
                                 pw.print("Trigger : ");
@@ -119,5 +155,6 @@ public class WebConsolePrinter {
         } else {
             pw.println("Status : not active");
         }
+        pw.println();
     }
 }
diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/WhiteboardHandler.java b/src/main/java/org/apache/sling/commons/scheduler/impl/WhiteboardHandler.java
index 11bcb29..697e2e9 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/WhiteboardHandler.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/WhiteboardHandler.java
@@ -132,7 +132,8 @@ public class WhiteboardHandler {
         }
         final String expression = (String)ref.getProperty(Scheduler.PROPERTY_SCHEDULER_EXPRESSION);
         if ( expression != null ) {
-            this.scheduler.schedule(ref.getBundle().getBundleId(), job, this.scheduler.EXPR(expression)
+            this.scheduler.schedule(ref.getBundle().getBundleId(), (Long)ref.getProperty(Constants.SERVICE_ID),
+                    job, this.scheduler.EXPR(expression)
                     .name(name)
                     .canRunConcurrently((concurrent != null ? concurrent : true))
                     .onInstancesOnly(runOnOpts));
@@ -155,7 +156,8 @@ public class WhiteboardHandler {
                         this.logger.debug("Ignoring service {} : scheduler times is less than 1.", ref);
                     } else {
                         final int t = (times != null ? times : -1);
-                        this.scheduler.schedule(ref.getBundle().getBundleId(), job, this.scheduler.AT(date, t, period)
+                        this.scheduler.schedule(ref.getBundle().getBundleId(), (Long)ref.getProperty(Constants.SERVICE_ID),
+                                job, this.scheduler.AT(date, t, period)
                                 .name(name)
                                 .canRunConcurrently((concurrent != null ? concurrent : true))
                                 .onInstancesOnly(runOnOpts));
