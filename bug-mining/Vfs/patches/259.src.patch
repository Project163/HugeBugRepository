diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/tar/TarFileSystem.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/tar/TarFileSystem.java
index 51a8b354..0be63082 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/tar/TarFileSystem.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/tar/TarFileSystem.java
@@ -20,9 +20,9 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.util.ArrayList;
 import java.util.Collection;
-import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
 import java.util.zip.GZIPInputStream;
 
 import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
@@ -30,6 +30,7 @@ import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.commons.vfs2.Capability;
+import org.apache.commons.vfs2.FileName;
 import org.apache.commons.vfs2.FileObject;
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileSystemOptions;
@@ -44,17 +45,21 @@ import org.apache.commons.vfs2.provider.bzip2.Bzip2FileObject;
  * A read-only file system for Tar files.
  */
 public class TarFileSystem extends AbstractFileSystem {
-    private final char[] ENC = {'!'};
-
-    private static final int DEFAULT_INDEX_SIZE = 100;
-
     private static final Log LOG = LogFactory.getLog(TarFileSystem.class);
 
+    private final char[] ENC = {'!'};
+
     private final File file;
+
     private TarArchiveInputStream tarFile;
 
+    /**
+     * Cache doesn't need to be synchronized since it is read-only.
+     */
+    private final Map<FileName, FileObject> cache = new HashMap<>();
+
     protected TarFileSystem(final AbstractFileName rootName, final FileObject parentLayer,
-            final FileSystemOptions fileSystemOptions) throws FileSystemException {
+        final FileSystemOptions fileSystemOptions) throws FileSystemException {
         super(rootName, parentLayer, fileSystemOptions);
 
         // Make a local copy of the file
@@ -70,17 +75,93 @@ public class TarFileSystem extends AbstractFileSystem {
         // tarFile = createTarFile(this.file);
     }
 
+    /**
+     * Returns the capabilities of this file system.
+     */
+    @Override
+    protected void addCapabilities(final Collection<Capability> caps) {
+        caps.addAll(TarFileProvider.capabilities);
+    }
+
+    /**
+     * Creates a file object.
+     */
+    @Override
+    protected FileObject createFile(final AbstractFileName name) throws FileSystemException {
+        // This is only called for files which do not exist in the Tar file
+        return new TarFileObject(name, null, this, false);
+    }
+
+    protected TarArchiveInputStream createTarFile(final File file) throws FileSystemException {
+        try {
+            if ("tgz".equalsIgnoreCase(getRootName().getScheme())) {
+                return new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(file)));
+            } else if ("tbz2".equalsIgnoreCase(getRootName().getScheme())) {
+                return new TarArchiveInputStream(
+                    Bzip2FileObject.wrapInputStream(file.getAbsolutePath(), new FileInputStream(file)));
+            }
+            return new TarArchiveInputStream(new FileInputStream(file));
+        } catch (final IOException ioe) {
+            throw new FileSystemException("vfs.provider.tar/open-tar-file.error", file, ioe);
+        }
+    }
+
+    protected TarFileObject createTarFileObject(final AbstractFileName name, final TarArchiveEntry entry)
+        throws FileSystemException {
+        return new TarFileObject(name, entry, this, true);
+    }
+
+    @Override
+    protected void doCloseCommunicationLink() {
+        // Release the tar file
+        try {
+            if (tarFile != null) {
+                tarFile.close();
+                tarFile = null;
+            }
+        } catch (final IOException e) {
+            // getLogger().warn("vfs.provider.tar/close-tar-file.error :" + file, e);
+            VfsLog.warn(getLogger(), LOG, "vfs.provider.tar/close-tar-file.error :" + file, e);
+        }
+    }
+
+    /**
+     * Returns a cached file.
+     */
+    @Override
+    protected FileObject getFileFromCache(final FileName name) {
+        return cache.get(name);
+    }
+
+    public InputStream getInputStream(final TarArchiveEntry entry) throws FileSystemException {
+        resetTarFile();
+        try {
+            while (!tarFile.getNextEntry().equals(entry)) {
+            }
+            return tarFile;
+        } catch (final IOException e) {
+            throw new FileSystemException(e);
+        }
+    }
+
+    protected TarArchiveInputStream getTarFile() throws FileSystemException {
+        if (tarFile == null && this.file.exists()) {
+            recreateTarFile();
+        }
+
+        return tarFile;
+    }
+
     @Override
     public void init() throws FileSystemException {
         super.init();
 
         // Build the index
         try {
-            final List<TarFileObject> strongRef = new ArrayList<>(DEFAULT_INDEX_SIZE);
             TarArchiveEntry entry;
             while ((entry = getTarFile().getNextTarEntry()) != null) {
                 final AbstractFileName name = (AbstractFileName) getFileSystemManager().resolveName(getRootName(),
-                        UriParser.encode(entry.getName(), ENC));
+                    UriParser.encode(entry.getName(), ENC));
 
                 // Create the file
                 TarFileObject fileObj;
@@ -92,22 +173,18 @@ public class TarFileSystem extends AbstractFileSystem {
 
                 fileObj = createTarFileObject(name, entry);
                 putFileToCache(fileObj);
-                strongRef.add(fileObj);
-                fileObj.holdObject(strongRef);
 
                 // Make sure all ancestors exist
                 // TODO - create these on demand
                 TarFileObject parent = null;
                 for (AbstractFileName parentName = (AbstractFileName) name
-                        .getParent(); parentName != null; fileObj = parent, parentName = (AbstractFileName) parentName
-                                .getParent()) {
+                    .getParent(); parentName != null; fileObj = parent, parentName = (AbstractFileName) parentName
+                        .getParent()) {
                     // Locate the parent
                     parent = (TarFileObject) getFileFromCache(parentName);
                     if (parent == null) {
                         parent = createTarFileObject(parentName, null);
                         putFileToCache(parent);
-                        strongRef.add(parent);
-                        parent.holdObject(strongRef);
                     }
 
                     // Attach child to parent
@@ -121,25 +198,18 @@ public class TarFileSystem extends AbstractFileSystem {
         }
     }
 
-    public InputStream getInputStream(final TarArchiveEntry entry) throws FileSystemException {
-        resetTarFile();
-        try {
-            while (!tarFile.getNextEntry().equals(entry)) {
-            }
-            return tarFile;
-        } catch (final IOException e) {
-            throw new FileSystemException(e);
-        }
+    /**
+     * Adds a file object to the cache.
+     */
+    @Override
+    protected void putFileToCache(final FileObject file) {
+        cache.put(file.getName(), file);
     }
 
-    protected void resetTarFile() throws FileSystemException {
-        // Reading specific entries requires skipping through the tar file from the beginning
-        // Not especially elegant, but we don't have the ability to seek to specific positions
-        // with an input stream.
-        if (this.file.exists()) {
-            recreateTarFile();
-        }
-    }
+    /**
+     * will be called after all file-objects closed their streams. protected void notifyAllStreamsClosed() {
+     * closeCommunicationLink(); }
+     */
 
     private void recreateTarFile() throws FileSystemException {
         if (this.tarFile != null) {
@@ -154,66 +224,20 @@ public class TarFileSystem extends AbstractFileSystem {
         this.tarFile = tarFile;
     }
 
-    protected TarArchiveInputStream getTarFile() throws FileSystemException {
-        if (tarFile == null && this.file.exists()) {
-            recreateTarFile();
-        }
-
-        return tarFile;
-    }
-
-    protected TarFileObject createTarFileObject(final AbstractFileName name, final TarArchiveEntry entry)
-            throws FileSystemException {
-        return new TarFileObject(name, entry, this, true);
-    }
-
-    protected TarArchiveInputStream createTarFile(final File file) throws FileSystemException {
-        try {
-            if ("tgz".equalsIgnoreCase(getRootName().getScheme())) {
-                return new TarArchiveInputStream(new GZIPInputStream(new FileInputStream(file)));
-            } else if ("tbz2".equalsIgnoreCase(getRootName().getScheme())) {
-                return new TarArchiveInputStream(
-                        Bzip2FileObject.wrapInputStream(file.getAbsolutePath(), new FileInputStream(file)));
-            }
-            return new TarArchiveInputStream(new FileInputStream(file));
-        } catch (final IOException ioe) {
-            throw new FileSystemException("vfs.provider.tar/open-tar-file.error", file, ioe);
-        }
-    }
-
-    @Override
-    protected void doCloseCommunicationLink() {
-        // Release the tar file
-        try {
-            if (tarFile != null) {
-                tarFile.close();
-                tarFile = null;
-            }
-        } catch (final IOException e) {
-            // getLogger().warn("vfs.provider.tar/close-tar-file.error :" + file, e);
-            VfsLog.warn(getLogger(), LOG, "vfs.provider.tar/close-tar-file.error :" + file, e);
-        }
-    }
-
     /**
-     * Returns the capabilities of this file system.
+     * remove a cached file.
      */
     @Override
-    protected void addCapabilities(final Collection<Capability> caps) {
-        caps.addAll(TarFileProvider.capabilities);
+    protected void removeFileFromCache(final FileName name) {
+        cache.remove(name);
     }
 
-    /**
-     * Creates a file object.
-     */
-    @Override
-    protected FileObject createFile(final AbstractFileName name) throws FileSystemException {
-        // This is only called for files which do not exist in the Tar file
-        return new TarFileObject(name, null, this, false);
+    protected void resetTarFile() throws FileSystemException {
+        // Reading specific entries requires skipping through the tar file from the beginning
+        // Not especially elegant, but we don't have the ability to seek to specific positions
+        // with an input stream.
+        if (this.file.exists()) {
+            recreateTarFile();
+        }
     }
-
-    /**
-     * will be called after all file-objects closed their streams. protected void notifyAllStreamsClosed() {
-     * closeCommunicationLink(); }
-     */
 }
diff --git a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/zip/ZipFileSystem.java b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/zip/ZipFileSystem.java
index e49bca48..72a0d32a 100644
--- a/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/zip/ZipFileSystem.java
+++ b/commons-vfs2/src/main/java/org/apache/commons/vfs2/provider/zip/ZipFileSystem.java
@@ -19,11 +19,9 @@ package org.apache.commons.vfs2.provider.zip;
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
@@ -80,7 +78,6 @@ public class ZipFileSystem extends AbstractFileSystem {
 
         try {
             // Build the index
-            final List<ZipFileObject> strongRef = new ArrayList<>(getZipFile().size());
             final Enumeration<? extends ZipEntry> entries = getZipFile().entries();
             while (entries.hasMoreElements()) {
                 final ZipEntry entry = entries.nextElement();
@@ -97,8 +94,6 @@ public class ZipFileSystem extends AbstractFileSystem {
 
                 fileObj = createZipFileObject(name, entry);
                 putFileToCache(fileObj);
-                strongRef.add(fileObj);
-                fileObj.holdObject(strongRef);
 
                 // Make sure all ancestors exist
                 // TODO - create these on demand
@@ -111,8 +106,6 @@ public class ZipFileSystem extends AbstractFileSystem {
                     if (parent == null) {
                         parent = createZipFileObject(parentName, null);
                         putFileToCache(parent);
-                        strongRef.add(parent);
-                        parent.holdObject(strongRef);
                     }
 
                     // Attach child to parent
diff --git a/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/tar/test/TarFileSystemTestCase.java b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/tar/test/TarFileSystemTestCase.java
new file mode 100644
index 00000000..a5ccc9c1
--- /dev/null
+++ b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/tar/test/TarFileSystemTestCase.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.vfs2.provider.tar.test;
+
+import org.apache.commons.vfs2.FileObject;
+import org.apache.commons.vfs2.FileSystemException;
+import org.apache.commons.vfs2.FilesCache;
+import org.apache.commons.vfs2.cache.WeakRefFilesCache;
+import org.apache.commons.vfs2.impl.StandardFileSystemManager;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.io.File;
+
+public class TarFileSystemTestCase {
+
+    @Test
+    public void testTarFileUseDefaultFilesCache() throws FileSystemException {
+        testUseWeakRefFilesCache("tar", "src/test/resources/test-data/test.tar", null);
+    }
+
+    @Test
+    @SuppressWarnings("resource") // Managed by the file system, no need to close.
+    public void testTarFileUseWeakRefFilesCache() throws FileSystemException {
+        testUseWeakRefFilesCache("tar", "src/test/resources/test-data/test.tar", new WeakRefFilesCache());
+    }
+
+    @Test
+    public void testTbz2FileUseDefautlFilesCache() throws FileSystemException {
+        testUseWeakRefFilesCache("tbz2", "src/test/resources/test-data/test.tbz2", null);
+    }
+
+    @Test
+    @SuppressWarnings("resource") // Managed by the file system, no need to close.
+    public void testTbz2FileUseWeakRefFilesCache() throws FileSystemException {
+        testUseWeakRefFilesCache("tbz2", "src/test/resources/test-data/test.tbz2", new WeakRefFilesCache());
+    }
+
+    @Test
+    public void testTgzFileUseDefaultFilesCache() throws FileSystemException {
+        testUseWeakRefFilesCache("tgz", "src/test/resources/test-data/test.tgz", null);
+    }
+
+    @Test
+    @SuppressWarnings("resource") // Managed by the file system, no need to close.
+    public void testTgzFileUseWeakRefFilesCache() throws FileSystemException {
+        testUseWeakRefFilesCache("tgz", "src/test/resources/test-data/test.tgz", new WeakRefFilesCache());
+    }
+
+    /**
+     * Sets a file system's file cache to use WeakReference, and test resolve file after GC.
+     *
+     * @param filesCache TODO
+     */
+    private void testUseWeakRefFilesCache(final String scheme, final String filePath, final FilesCache filesCache)
+        throws FileSystemException {
+
+        final String fileUri = scheme + ":file:" + new File(filePath).getAbsolutePath();
+        FileObject fileObject = null;
+
+        try (final StandardFileSystemManager manager = new StandardFileSystemManager()) {
+            if (filesCache != null) {
+                manager.setFilesCache(filesCache);
+            }
+            manager.init();
+
+            int cnt = 0;
+            while (cnt < 100_000) {
+                cnt++;
+
+                // resolve file, assert fileObject exist. clear fileObject to null and wait GC.
+                try {
+                    fileObject = manager.resolveFile(fileUri);
+                    Assert.assertTrue(fileObject.exists());
+                } finally {
+                    if (fileObject != null) {
+                        fileObject.close();
+                    }
+                    fileObject = null;
+                }
+
+                // every 200 times suggest one gc
+                if (cnt % 200 == 0) {
+                    System.gc();
+                }
+            }
+        }
+    }
+}
diff --git a/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/zip/test/ZipFileSystemTestCase.java b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/zip/test/ZipFileSystemTestCase.java
new file mode 100644
index 00000000..792f6e38
--- /dev/null
+++ b/commons-vfs2/src/test/java/org/apache/commons/vfs2/provider/zip/test/ZipFileSystemTestCase.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.vfs2.provider.zip.test;
+
+import java.io.File;
+
+import org.apache.commons.vfs2.FileObject;
+import org.apache.commons.vfs2.FileSystemException;
+import org.apache.commons.vfs2.cache.WeakRefFilesCache;
+import org.apache.commons.vfs2.impl.StandardFileSystemManager;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class ZipFileSystemTestCase {
+
+    /**
+     * Sets a file system's file cache to use WeakReference, and test resolve file after GC.
+     */
+    @Test
+    public void testZipFileUseWeakRefFilesCache() throws FileSystemException {
+
+        File file = new File("src/test/resources/test-data/test.zip");
+        String fileUri = "zip:file:" + file.getAbsolutePath();
+        FileObject fileObject = null;
+
+        try (StandardFileSystemManager manager = new StandardFileSystemManager()) {
+            // set file system's file cache use WeakReference, and init file system
+            @SuppressWarnings("resource") // Managed by the file system, no need to close.
+            final WeakRefFilesCache filesCache = new WeakRefFilesCache();
+            manager.setFilesCache(filesCache);
+            manager.init();
+
+            int cnt = 0;
+            while (cnt < 100_000) {
+                cnt++;
+
+                // resolve file, assert fileObject exist. clear fileObject to null and wait GC.
+                try {
+                    fileObject = manager.resolveFile(fileUri);
+                    Assert.assertTrue(fileObject.exists());
+                } finally {
+                    if (fileObject != null) {
+                        fileObject.close();
+                    }
+                    fileObject = null;
+                }
+                // every 200 times suggest one gc
+                if (cnt % 200 == 0) {
+                    System.gc();
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index ece6b3db..27e2283b 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -50,6 +50,10 @@ The <action> type attribute can be add,update,fix,remove.
 <!--        [Local] Need an easy way to convert from a FileObject to a File. -->
 <!--       </action> -->
 <!-- START Might need to be moved to the next version -->
+      <!-- FIXES -->
+      <action devissue="VFS-748" dev="ggregory" due-to="PeterAlfredLee, Gary Gregory" type="update">
+        TarProvider Incorrectly marks file IMAGINARY after garbage collection with WeakRefFilesCache, #97.
+      </action>
       <!-- UPDATES -->
       <action dev="ggregory" due-to="PeterAlfredLee" type="update">
         Modify some code use for-each loop and stream API #142.
