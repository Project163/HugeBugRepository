diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 2b7b10ab..64dc19fd 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -24,6 +24,9 @@
     </properties>
     <body>
         <release version="1.3" date="TBD" description="Maintenance and feature Release">
+            <action issue="EXEC-78" dev="sebb" type="update" date="2014-01-11">
+                No need to use System.class.getMethod("getenv",... any more
+            </action>
             <action issue="EXEC-77" dev="britter" type="update" date="2014-01-10">
                 Update JUnit dependency to 4.11
             </action>
diff --git a/src/main/java/org/apache/commons/exec/environment/DefaultProcessingEnvironment.java b/src/main/java/org/apache/commons/exec/environment/DefaultProcessingEnvironment.java
index 7e1f993c..5f443de7 100644
--- a/src/main/java/org/apache/commons/exec/environment/DefaultProcessingEnvironment.java
+++ b/src/main/java/org/apache/commons/exec/environment/DefaultProcessingEnvironment.java
@@ -22,8 +22,6 @@ import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.StringReader;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Map;
@@ -47,7 +45,7 @@ import org.apache.commons.exec.PumpStreamHandler;
 public class DefaultProcessingEnvironment {
 
     /** the line separator of the system */
-    private static final String LINE_SEPARATOR = System.getProperty("line.separator");
+//    private static final String LINE_SEPARATOR = System.getProperty("line.separator");
 
     /** the environment variables of the process */
     protected Map<String, String> procEnvironment;
@@ -80,48 +78,40 @@ public class DefaultProcessingEnvironment {
      */
     protected Map<String, String> createProcEnvironment() throws IOException {
         if (procEnvironment == null) {
-            try {
-                final Method getenvs = System.class.getMethod("getenv", (java.lang.Class[]) null);
-                final Map<String, String> env = (Map<String, String>) getenvs.invoke(null, (java.lang.Object[]) null);
-                procEnvironment = createEnvironmentMap();
-                procEnvironment.putAll(env);
-            } catch (final NoSuchMethodException e) {
-                // ok, just not on JDK 1.5
-            } catch (final IllegalAccessException e) {
-                // Unexpected error obtaining environment - using JDK 1.4 method
-            } catch (final InvocationTargetException e) {
-                // Unexpected error obtaining environment - using JDK 1.4 method
-            }
-        }
-
-        if (procEnvironment == null) {
+            final Map<String, String> env = System.getenv();
             procEnvironment = createEnvironmentMap();
-            final BufferedReader in = runProcEnvCommand();
-
-            String var = null;
-            String line;
-            while ((line = in.readLine()) != null) {
-                if (line.indexOf('=') == -1) {
-                    // Chunk part of previous env var (UNIX env vars can
-                    // contain embedded new lines).
-                    if (var == null) {
-                        var = LINE_SEPARATOR + line;
-                    } else {
-                        var += LINE_SEPARATOR + line;
-                    }
-                } else {
-                    // New env var...append the previous one if we have it.
-                    if (var != null) {
-                        EnvironmentUtils.addVariableToEnvironment(procEnvironment, var);
-                    }
-                    var = line;
-                }
-            }
-            // Since we "look ahead" before adding, there's one last env var.
-            if (var != null) {
-                EnvironmentUtils.addVariableToEnvironment(procEnvironment, var);
-            }
+            procEnvironment.putAll(env);
         }
+
+// No longer needed
+//        if (procEnvironment == null) {
+//            procEnvironment = createEnvironmentMap();
+//            final BufferedReader in = runProcEnvCommand();
+//
+//            String var = null;
+//            String line;
+//            while ((line = in.readLine()) != null) {
+//                if (line.indexOf('=') == -1) {
+//                    // Chunk part of previous env var (UNIX env vars can
+//                    // contain embedded new lines).
+//                    if (var == null) {
+//                        var = LINE_SEPARATOR + line;
+//                    } else {
+//                        var += LINE_SEPARATOR + line;
+//                    }
+//                } else {
+//                    // New env var...append the previous one if we have it.
+//                    if (var != null) {
+//                        EnvironmentUtils.addVariableToEnvironment(procEnvironment, var);
+//                    }
+//                    var = line;
+//                }
+//            }
+//            // Since we "look ahead" before adding, there's one last env var.
+//            if (var != null) {
+//                EnvironmentUtils.addVariableToEnvironment(procEnvironment, var);
+//            }
+//        }
         return procEnvironment;
     }
 
@@ -130,14 +120,17 @@ public class DefaultProcessingEnvironment {
      *
      * @return a reader containing the output of the process 
      * @throws IOException starting the process failed
+     * @deprecated No longer needed
      */
+    @Deprecated
     protected BufferedReader runProcEnvCommand() throws IOException {
-        final ByteArrayOutputStream out = new ByteArrayOutputStream();
-        final Executor exe = new DefaultExecutor();
-        exe.setStreamHandler(new PumpStreamHandler(out));
-        // ignore the exit value - Just try to use what we got
-        exe.execute(getProcEnvCommand());
-        return new BufferedReader(new StringReader(toString(out)));
+//        final ByteArrayOutputStream out = new ByteArrayOutputStream();
+//        final Executor exe = new DefaultExecutor();
+//        exe.setStreamHandler(new PumpStreamHandler(out));
+//        // ignore the exit value - Just try to use what we got
+//        exe.execute(getProcEnvCommand());
+//        return new BufferedReader(new StringReader(toString(out)));
+        return null;
     }
 
     /**
@@ -145,78 +138,80 @@ public class DefaultProcessingEnvironment {
      * variables.
      *
      * @return the command line
+     * @deprecated No longer needed
      */
+    @Deprecated
     protected CommandLine getProcEnvCommand() {
-        String executable;
-        String[] arguments = null;
-        if (OS.isFamilyOS2()) {
-            // OS/2 - use same mechanism as Windows 2000
-            executable = "cmd";
-            
-            arguments = new String[] {"/c", "set"};
-        } else if (OS.isFamilyWindows()) {
-            // Determine if we're running under XP/2000/NT or 98/95
-            if (OS.isFamilyWin9x()) {
-                executable = "command.com";
-                // Windows 98/95
-            } else {
-                executable = "cmd";
-                // Windows XP/2000/NT/2003
-            }
-            arguments = new String[] {"/c", "set"};
-        } else if (OS.isFamilyZOS() || OS.isFamilyUnix()) {
-            // On most systems one could use: /bin/sh -c env
-
-            // Some systems have /bin/env, others /usr/bin/env, just try
-            if (new File("/bin/env").canRead()) {
-                executable = "/bin/env";
-            } else if (new File("/usr/bin/env").canRead()) {
-                executable = "/usr/bin/env";
-            } else {
-                // rely on PATH
-                executable = "env";
-            }
-        } else if (OS.isFamilyNetware() || OS.isFamilyOS400()) {
-            // rely on PATH
-            executable = "env";
-        } else {
-            // MAC OS 9 and previous
-            // TODO: I have no idea how to get it, someone must fix it
-            executable = null;
-        }
+//        String executable;
+//        String[] arguments = null;
+//        if (OS.isFamilyOS2()) {
+//            // OS/2 - use same mechanism as Windows 2000
+//            executable = "cmd";
+//            
+//            arguments = new String[] {"/c", "set"};
+//        } else if (OS.isFamilyWindows()) {
+//            // Determine if we're running under XP/2000/NT or 98/95
+//            if (OS.isFamilyWin9x()) {
+//                executable = "command.com";
+//                // Windows 98/95
+//            } else {
+//                executable = "cmd";
+//                // Windows XP/2000/NT/2003
+//            }
+//            arguments = new String[] {"/c", "set"};
+//        } else if (OS.isFamilyZOS() || OS.isFamilyUnix()) {
+//            // On most systems one could use: /bin/sh -c env
+//
+//            // Some systems have /bin/env, others /usr/bin/env, just try
+//            if (new File("/bin/env").canRead()) {
+//                executable = "/bin/env";
+//            } else if (new File("/usr/bin/env").canRead()) {
+//                executable = "/usr/bin/env";
+//            } else {
+//                // rely on PATH
+//                executable = "env";
+//            }
+//        } else if (OS.isFamilyNetware() || OS.isFamilyOS400()) {
+//            // rely on PATH
+//            executable = "env";
+//        } else {
+//            // MAC OS 9 and previous
+//            // TODO: I have no idea how to get it, someone must fix it
+//            executable = null;
+//        }
         CommandLine commandLine = null;
-        if (executable != null) {
-            commandLine = new CommandLine(executable);
-            commandLine.addArguments(arguments);
-        }
+//        if (executable != null) {
+//            commandLine = new CommandLine(executable);
+//            commandLine.addArguments(arguments);
+//        }
         return commandLine;
     }
 
-    /**
-     * ByteArrayOutputStream#toString doesn't seem to work reliably on OS/390,
-     * at least not the way we use it in the execution context.
-     * 
-     * @param bos
-     *            the output stream that one wants to read
-     * @return the output stream as a string, read with special encodings in the
-     *         case of z/os and os/400
-     */
-    private String toString(final ByteArrayOutputStream bos) {
-        if (OS.isFamilyZOS()) {
-            try {
-                return bos.toString("Cp1047");
-            } catch (final java.io.UnsupportedEncodingException e) {
-                // noop default encoding used
-            }
-        } else if (OS.isFamilyOS400()) {
-            try {
-                return bos.toString("Cp500");
-            } catch (final java.io.UnsupportedEncodingException e) {
-                // noop default encoding used
-            }
-        }
-        return bos.toString();
-    }
+//    /**
+//     * ByteArrayOutputStream#toString doesn't seem to work reliably on OS/390,
+//     * at least not the way we use it in the execution context.
+//     * 
+//     * @param bos
+//     *            the output stream that one wants to read
+//     * @return the output stream as a string, read with special encodings in the
+//     *         case of z/os and os/400
+//     */
+//    private String toString(final ByteArrayOutputStream bos) {
+//        if (OS.isFamilyZOS()) {
+//            try {
+//                return bos.toString("Cp1047");
+//            } catch (final java.io.UnsupportedEncodingException e) {
+//                // noop default encoding used
+//            }
+//        } else if (OS.isFamilyOS400()) {
+//            try {
+//                return bos.toString("Cp500");
+//            } catch (final java.io.UnsupportedEncodingException e) {
+//                // noop default encoding used
+//            }
+//        }
+//        return bos.toString();
+//    }
 
     /**
      * Creates a map that obeys the casing rules of the current platform for key
diff --git a/src/main/java/org/apache/commons/exec/environment/OpenVmsProcessingEnvironment.java b/src/main/java/org/apache/commons/exec/environment/OpenVmsProcessingEnvironment.java
index 0ff9d801..033f7f6a 100644
--- a/src/main/java/org/apache/commons/exec/environment/OpenVmsProcessingEnvironment.java
+++ b/src/main/java/org/apache/commons/exec/environment/OpenVmsProcessingEnvironment.java
@@ -17,74 +17,81 @@
 
 package org.apache.commons.exec.environment;
 
-import java.io.BufferedReader;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.commons.exec.CommandLine;
+//import java.io.BufferedReader;
+//import java.io.IOException;
+//import java.util.HashMap;
+//import java.util.Map;
+//
+//import org.apache.commons.exec.CommandLine;
 
 /**
  * Helper class to determine the environment variable
  * for VMS.
  *
  * @version $Id$
+ * @deprecated No longer needed
  */
+@Deprecated
 public class OpenVmsProcessingEnvironment extends DefaultProcessingEnvironment {
 
-    /**
-     * Find the list of environment variables for this process.
-     *
-     * @return a map containing the environment variables
-     * @throws IOException the operation failed
-     */    
-    @Override
-    protected Map<String, String> createProcEnvironment() throws IOException {
-        if (procEnvironment == null) {
-            final BufferedReader in = runProcEnvCommand();
-            procEnvironment = addVMSenvironmentVariables(new HashMap<String, String>(), in);
-        }
-
-        return procEnvironment;
-    }
-
-    /**
-     * Determine the OS specific command line to get a list of environment
-     * variables.
-     *
-     * @return the command line
-     */    
-    @Override
-    protected CommandLine getProcEnvCommand() {
-        final CommandLine commandLine = new CommandLine("show");
-        commandLine.addArgument("symbol/global"); // the parser assumes symbols are global
-        commandLine.addArgument("*");
-        return commandLine;
-    }
-
-    /**
-     * This method is VMS specific and used by getProcEnvironment(). Parses VMS
-     * symbols from <code>in</code> and adds them to <code>environment</code>.
-     * <code>in</code> is expected to be the output of "SHOW SYMBOL/GLOBAL *".
-     *
-     * @param environment the current environment
-     * @param in the reader from the process to determine VMS env variables
-     * @return the updated environment
-     * @throws IOException operation failed
+    /*
+     * Hopefully removing super-class overrides won't cause Clirr error.
+     * If necessary can just delegate to super-class. 
      */
-    private Map<String, String> addVMSenvironmentVariables(final Map<String, String> environment,
-            final BufferedReader in) throws IOException {
-        String line;
-        while ((line = in.readLine()) != null) {
-            final String SEP = "=="; // global symbol separator
-            final int sepidx = line.indexOf(SEP);
-            if (sepidx > 0) {
-                final String name = line.substring(0, sepidx).trim();
-                String value = line.substring(sepidx+SEP.length()).trim();
-                value = value.substring(1,value.length()-1); // drop enclosing quotes
-                environment.put(name,value);
-            }
-        }
-        return environment;
-    }
+
+//    /**
+//     * Find the list of environment variables for this process.
+//     *
+//     * @return a map containing the environment variables
+//     * @throws IOException the operation failed
+//     */    
+//    @Override
+//    protected Map<String, String> createProcEnvironment() throws IOException {
+//        if (procEnvironment == null) {
+//            final BufferedReader in = runProcEnvCommand();
+//            procEnvironment = addVMSenvironmentVariables(new HashMap<String, String>(), in);
+//        }
+//
+//        return procEnvironment;
+//    }
+//
+//    /**
+//     * Determine the OS specific command line to get a list of environment
+//     * variables.
+//     *
+//     * @return the command line
+//     */    
+//    @Override
+//    protected CommandLine getProcEnvCommand() {
+//        final CommandLine commandLine = new CommandLine("show");
+//        commandLine.addArgument("symbol/global"); // the parser assumes symbols are global
+//        commandLine.addArgument("*");
+//        return commandLine;
+//    }
+//
+//    /**
+//     * This method is VMS specific and used by getProcEnvironment(). Parses VMS
+//     * symbols from <code>in</code> and adds them to <code>environment</code>.
+//     * <code>in</code> is expected to be the output of "SHOW SYMBOL/GLOBAL *".
+//     *
+//     * @param environment the current environment
+//     * @param in the reader from the process to determine VMS env variables
+//     * @return the updated environment
+//     * @throws IOException operation failed
+//     */
+//    private Map<String, String> addVMSenvironmentVariables(final Map<String, String> environment,
+//            final BufferedReader in) throws IOException {
+//        String line;
+//        while ((line = in.readLine()) != null) {
+//            final String SEP = "=="; // global symbol separator
+//            final int sepidx = line.indexOf(SEP);
+//            if (sepidx > 0) {
+//                final String name = line.substring(0, sepidx).trim();
+//                String value = line.substring(sepidx+SEP.length()).trim();
+//                value = value.substring(1,value.length()-1); // drop enclosing quotes
+//                environment.put(name,value);
+//            }
+//        }
+//        return environment;
+//    }
 }
