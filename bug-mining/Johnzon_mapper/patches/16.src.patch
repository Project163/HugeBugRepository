diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index e18ef78d..d24e44cf 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -882,7 +882,11 @@ public class Mapper implements Closeable {
             if (JsonObject.class == type || JsonStructure.class == type) {
                 return jsonValue;
             }
-            return buildObject(type, JsonObject.class.cast(jsonValue));
+            final boolean typedAdapter = TypeAwareAdapter.class.isInstance(itemConverter);
+            final Object object = buildObject(
+                    typedAdapter ? TypeAwareAdapter.class.cast(itemConverter).getTo() : type,
+                    JsonObject.class.cast(jsonValue));
+            return typedAdapter ? itemConverter.to(object) : object;
         } else if (JsonArray.class.isInstance(jsonValue)) {
             if (JsonArray.class == type || JsonStructure.class == type) {
                 return jsonValue;
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/TypeAwareAdapter.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/TypeAwareAdapter.java
new file mode 100644
index 00000000..cff2fc02
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/TypeAwareAdapter.java
@@ -0,0 +1,26 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper;
+
+import java.lang.reflect.Type;
+
+public interface TypeAwareAdapter<A, B> extends Adapter<A, B> {
+    Type getTo();
+    Type getFrom();
+}
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Converters.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Converters.java
index 72d3e621..a852aff5 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Converters.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Converters.java
@@ -20,6 +20,7 @@ package org.apache.johnzon.mapper.reflection;
 
 import org.apache.johnzon.mapper.Adapter;
 import org.apache.johnzon.mapper.Converter;
+import org.apache.johnzon.mapper.TypeAwareAdapter;
 import org.apache.johnzon.mapper.internal.ConverterAdapter;
 
 import java.lang.reflect.ParameterizedType;
@@ -34,9 +35,9 @@ public class Converters {
 
     // TODO: more ParameterizedType and maybe TypeClosure support
     public static boolean matches(final Type type, final Adapter<?, ?> adapter) {
+        Type convertType = null;
         if (ConverterAdapter.class.isInstance(adapter)) {
             final Converter delegate = ConverterAdapter.class.cast(adapter).getConverter();
-            Type convertType = null;
             if (Converter.TypeAccess.class.isInstance(delegate)) {
                 convertType = Converter.TypeAccess.class.cast(delegate).type();
             } else {
@@ -47,39 +48,40 @@ public class Converters {
                     }
                 }
             }
+        } else if (TypeAwareAdapter.class.isInstance(adapter)) {
+            convertType = TypeAwareAdapter.class.cast(adapter).getFrom();
+        }
 
-            if (convertType == null) { // compatibility, previously nested converter were not supported
-                return true;
-            }
+        if (convertType == null) { // compatibility, previously nested converter were not supported
+            return true;
+        }
 
-            if (ParameterizedType.class.isInstance(type)) {
-                final ParameterizedType parameterizedType = ParameterizedType.class.cast(type);
-                final Type rawType = parameterizedType.getRawType();
-                if (Class.class.isInstance(rawType)) {
-                    final Class<?> clazz = Class.class.cast(rawType);
-                    if (Collection.class.isAssignableFrom(clazz) && parameterizedType.getActualTypeArguments().length == 1) {
-                        final Type argType = parameterizedType.getActualTypeArguments()[0];
-                        if (Class.class.isInstance(argType) && Class.class.isInstance(convertType)) {
-                            return !Class.class.cast(convertType).isAssignableFrom(Class.class.cast(argType));
-                        }
-                    } else if (Map.class.isAssignableFrom(clazz) && parameterizedType.getActualTypeArguments().length == 2) {
-                        final Type argType = parameterizedType.getActualTypeArguments()[1];
-                        if (Class.class.isInstance(argType) && Class.class.isInstance(convertType)) {
-                            return !Class.class.cast(convertType).isAssignableFrom(Class.class.cast(argType));
-                        }
+        if (ParameterizedType.class.isInstance(type)) {
+            final ParameterizedType parameterizedType = ParameterizedType.class.cast(type);
+            final Type rawType = parameterizedType.getRawType();
+            if (Class.class.isInstance(rawType)) {
+                final Class<?> clazz = Class.class.cast(rawType);
+                if (Collection.class.isAssignableFrom(clazz) && parameterizedType.getActualTypeArguments().length == 1) {
+                    final Type argType = parameterizedType.getActualTypeArguments()[0];
+                    if (Class.class.isInstance(argType) && Class.class.isInstance(convertType)) {
+                        return !Class.class.cast(convertType).isAssignableFrom(Class.class.cast(argType));
+                    }
+                } else if (Map.class.isAssignableFrom(clazz) && parameterizedType.getActualTypeArguments().length == 2) {
+                    final Type argType = parameterizedType.getActualTypeArguments()[1];
+                    if (Class.class.isInstance(argType) && Class.class.isInstance(convertType)) {
+                        return !Class.class.cast(convertType).isAssignableFrom(Class.class.cast(argType));
                     }
-                    return true; // actually here we suppose we dont know
                 }
+                return true; // actually here we suppose we dont know
             }
-            if (Class.class.isInstance(type)) {
-                final Class<?> clazz = Class.class.cast(type);
-                if (clazz.isArray()) {
-                    return !Class.class.cast(convertType).isAssignableFrom(clazz.getComponentType());
-                }
+        }
+        if (Class.class.isInstance(type)) {
+            final Class<?> clazz = Class.class.cast(type);
+            if (clazz.isArray()) {
+                return !Class.class.cast(convertType).isAssignableFrom(clazz.getComponentType());
             }
-        } else {
-            // TODO? earlier surely
         }
+
         return true;
     }
 }
