diff --git a/src/main/java/org/apache/commons/jexl3/JexlException.java b/src/main/java/org/apache/commons/jexl3/JexlException.java
index f9862d8b..63ed9c66 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlException.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlException.java
@@ -543,7 +543,18 @@ public class JexlException extends RuntimeException {
          * Undefined variable flag.
          */
         private final boolean undefined;
-               
+                          
+        /**
+         * Creates a new Property exception instance.
+         *
+         * @param node the offending ASTnode
+         * @param pty  the unknown property
+         * @deprecated 3.2
+         */
+        @Deprecated
+        public Property(JexlNode node, String pty) {
+            this(node, pty, true, null);
+        }    
         /**
          * Creates a new Property exception instance.
          *
@@ -611,6 +622,19 @@ public class JexlException extends RuntimeException {
         msg.append(pty);
         return msg.toString();
     }
+    
+    /**
+     * Generates a message for an unsolvable property error.
+     *
+     * @param node the node where the error occurred
+     * @param var the variable
+     * @return the error message
+     * @deprecated 3.2
+     */
+    @Deprecated
+    public static String propertyError(JexlNode node, String var) {
+        return propertyError(node, var, true);
+    }
 
     /**
      * Thrown when a method or ctor is unknown, ambiguous or inaccessible.
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
index fbe5c2b5..84c8e8a1 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
@@ -73,6 +73,15 @@ abstract class AbstractExecutor {
     static Object[] makeArgs(Object... args) {
         return args;
     }
+    
+    /**
+     * Gets the class of an object or Object if null.
+     * @param instance the instance
+     * @return the class
+     */
+    static Class<?> classOf(Object instance) {
+        return instance == null? Object.class : instance.getClass();
+    }
 
     /** The class this executor applies to. */
     protected final Class<?> objectClass;
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java
index c1da6f5e..93d435ae 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/DuckSetExecutor.java
@@ -38,6 +38,8 @@ import java.lang.reflect.InvocationTargetException;
 public final class DuckSetExecutor extends AbstractExecutor.Set {
     /** The property, may be null. */
     private final Object property;
+    /** The property value class. */
+    private final Class<?> valueClass;
 
     /**
      * Discovers a DuckSetExecutor.
@@ -53,7 +55,7 @@ public final class DuckSetExecutor extends AbstractExecutor.Set {
         if (method == null) {
             method = is.getMethod(clazz, "put", makeArgs(key, value));
         }
-        return method == null? null : new DuckSetExecutor(clazz, method, key);
+        return method == null? null : new DuckSetExecutor(clazz, method, key, value);
     }
 
     /**
@@ -61,10 +63,12 @@ public final class DuckSetExecutor extends AbstractExecutor.Set {
      * @param clazz the class the set method applies to
      * @param method the method called through this executor
      * @param key the key to use as 1st argument to the set method
+     * @param value the value to use as 2nd argument to the set method
      */
-    private DuckSetExecutor(Class<?> clazz, java.lang.reflect.Method method, Object key) {
+    private DuckSetExecutor(Class<?> clazz, java.lang.reflect.Method method, Object key, Object value) {
         super(clazz, method);
         property = key;
+        valueClass = classOf(value);
     }
 
     @Override
@@ -87,7 +91,8 @@ public final class DuckSetExecutor extends AbstractExecutor.Set {
             && objectClass.equals(obj.getClass())
             && method !=  null
             && ((property != null && property.equals(key))
-                || (property == null && key == null))) {
+                || (property == null && key == null))
+            && valueClass.equals(classOf(value))) {
             try {
                 Object[] args = {property, value};
                 method.invoke(obj, args);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java
index ce439dc0..6a881f83 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MapSetExecutor.java
@@ -28,6 +28,8 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
     private static final java.lang.reflect.Method MAP_SET = initMarker(Map.class, "put", Object.class, Object.class);
     /** The property. */
     private final Object property;
+    /** The property value class. */
+    private final Class<?> valueClass;
 
     /**
      * Attempts to discover a MapSetExecutor.
@@ -40,7 +42,7 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
      */
     public static MapSetExecutor discover(Introspector is, Class<?> clazz, Object identifier, Object value) {
         if (Map.class.isAssignableFrom(clazz)) {
-            return new MapSetExecutor(clazz, MAP_SET, identifier);
+            return new MapSetExecutor(clazz, MAP_SET, identifier, value);
         } else {
             return null;
         }
@@ -51,10 +53,12 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
      * @param clazz the class the set method applies to
      * @param method the method called through this executor
      * @param key the key to use as 1st argument to the set method
+     * @param value the value to use as 2nd argument to the set method
      */
-    private MapSetExecutor(Class<?> clazz, java.lang.reflect.Method method, Object key) {
+    private MapSetExecutor(Class<?> clazz, java.lang.reflect.Method method, Object key, Object arg) {
         super(clazz, method);
         property = key;
+        valueClass = classOf(arg);
     }
 
     @Override
@@ -76,7 +80,8 @@ public final class MapSetExecutor extends AbstractExecutor.Set {
             && method != null
             && objectClass.equals(obj.getClass())
             && ((property == null && key == null)
-                || (property != null && key != null && property.getClass().equals(key.getClass())))) {
+                || (property != null && key != null && property.getClass().equals(key.getClass())))
+            && valueClass.equals(classOf(value))) {
             @SuppressWarnings("unchecked") // ctor only allows Map instances - see discover() method
             final Map<Object,Object> map = ((Map<Object, Object>) obj);
             map.put(key, value);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java
index 71fbccd6..88edc21a 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/PropertySetExecutor.java
@@ -28,6 +28,8 @@ public class PropertySetExecutor extends AbstractExecutor.Set {
     private static final int SET_START_INDEX = 3;
     /** The property. */
     protected final String property;
+    /** The property value class. */
+    protected final Class<?> valueClass;
 
     /**
      * Discovers a PropertySetExecutor.
@@ -36,15 +38,15 @@ public class PropertySetExecutor extends AbstractExecutor.Set {
      * @param is       the introspector
      * @param clazz    the class to find the get method from
      * @param property the property name to find
-     * @param arg      the value to assign to the property
+     * @param value      the value to assign to the property
      * @return the executor if found, null otherwise
      */
-    public static PropertySetExecutor discover(Introspector is, Class<?> clazz, String property, Object arg) {
+    public static PropertySetExecutor discover(Introspector is, Class<?> clazz, String property, Object value) {
         if (property == null || property.isEmpty()) {
             return null;
         }
-        java.lang.reflect.Method method = discoverSet(is, clazz, property, arg);
-        return method != null? new PropertySetExecutor(clazz, method, property) : null;
+        java.lang.reflect.Method method = discoverSet(is, clazz, property, value);
+        return method != null? new PropertySetExecutor(clazz, method, property, value) : null;
     }
 
     /**
@@ -52,10 +54,12 @@ public class PropertySetExecutor extends AbstractExecutor.Set {
      * @param clazz  the class the set method applies to
      * @param method the method called through this executor
      * @param key    the key to use as 1st argument to the set method
+     * @param value    the value
      */
-    protected PropertySetExecutor(Class<?> clazz, java.lang.reflect.Method method, String key) {
+    protected PropertySetExecutor(Class<?> clazz, java.lang.reflect.Method method, String key, Object value) {
         super(clazz, method);
         property = key;
+        valueClass = classOf(value);
     }
 
     @Override
@@ -81,14 +85,16 @@ public class PropertySetExecutor extends AbstractExecutor.Set {
     }
 
     @Override
-    public Object tryInvoke(Object o, Object identifier, Object arg) {
+    public Object tryInvoke(Object o, Object identifier, Object value) {
         if (o != null && method != null
             // ensure method name matches the property name
             && property.equals(castString(identifier))
             // object class should be same as executor's method declaring class
-            && objectClass.equals(o.getClass())) {
+            && objectClass.equals(o.getClass())
+            // argument class should be eq
+            && valueClass.equals(classOf(value))) {
             try {
-                return invoke(o, arg);
+                return invoke(o, value);
             } catch (InvocationTargetException xinvoke) {
                 return TRY_FAILED; // fail
             } catch (IllegalAccessException xill) {
