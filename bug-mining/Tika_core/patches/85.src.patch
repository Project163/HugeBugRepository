diff --git a/tika-core/src/main/java/org/apache/tika/extractor/ParserContainerExtractor.java b/tika-core/src/main/java/org/apache/tika/extractor/ParserContainerExtractor.java
index b0dcda329..24f0d1474 100644
--- a/tika-core/src/main/java/org/apache/tika/extractor/ParserContainerExtractor.java
+++ b/tika-core/src/main/java/org/apache/tika/extractor/ParserContainerExtractor.java
@@ -25,7 +25,7 @@ import org.apache.tika.config.TikaConfig;
 import org.apache.tika.detect.DefaultDetector;
 import org.apache.tika.detect.Detector;
 import org.apache.tika.exception.TikaException;
-import org.apache.tika.io.TemporaryFiles;
+import org.apache.tika.io.TemporaryResources;
 import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.mime.MediaType;
@@ -106,7 +106,7 @@ public class ParserContainerExtractor implements ContainerExtractor {
                 InputStream stream, ContentHandler ignored,
                 Metadata metadata, ParseContext context)
                 throws IOException, SAXException, TikaException {
-            TemporaryFiles tmp = new TemporaryFiles();
+            TemporaryResources tmp = new TemporaryResources();
             try {
                 TikaInputStream tis = TikaInputStream.get(stream, tmp);
 
@@ -121,8 +121,13 @@ public class ParserContainerExtractor implements ContainerExtractor {
                     // Use a temporary file to process the stream twice
                     File file = tis.getFile();
 
-                    // Let the handler process the embedded resource 
-                    handler.handle(filename, type, TikaInputStream.get(file));
+                    // Let the handler process the embedded resource
+                    InputStream input = TikaInputStream.get(file);
+                    try {
+                        handler.handle(filename, type, input);
+                    } finally {
+                        input.close();
+                    }
 
                     // Recurse
                     extractor.extract(tis, extractor, handler);
diff --git a/tika-core/src/main/java/org/apache/tika/extractor/ParsingEmbeddedDocumentExtractor.java b/tika-core/src/main/java/org/apache/tika/extractor/ParsingEmbeddedDocumentExtractor.java
index ef07d2f29..8f233bf49 100644
--- a/tika-core/src/main/java/org/apache/tika/extractor/ParsingEmbeddedDocumentExtractor.java
+++ b/tika-core/src/main/java/org/apache/tika/extractor/ParsingEmbeddedDocumentExtractor.java
@@ -25,7 +25,7 @@ import java.io.InputStream;
 
 import org.apache.tika.exception.TikaException;
 import org.apache.tika.io.CloseShieldInputStream;
-import org.apache.tika.io.TemporaryFiles;
+import org.apache.tika.io.TemporaryResources;
 import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.parser.DelegatingParser;
@@ -90,7 +90,7 @@ public class ParsingEmbeddedDocumentExtractor implements EmbeddedDocumentExtract
         }
 
         // Use the delegate parser to parse this entry
-        TemporaryFiles tmp = new TemporaryFiles();
+        TemporaryResources tmp = new TemporaryResources();
         try {
             DELEGATING_PARSER.parse(
                     TikaInputStream.get(new CloseShieldInputStream(stream), tmp),
@@ -99,7 +99,7 @@ public class ParsingEmbeddedDocumentExtractor implements EmbeddedDocumentExtract
         } catch (TikaException e) {
             // Could not parse the entry, just skip the content
         } finally {
-            tmp.dispose();
+            tmp.close();
         }
 
         if(outputHtml) {
diff --git a/tika-core/src/main/java/org/apache/tika/io/TemporaryFiles.java b/tika-core/src/main/java/org/apache/tika/io/TemporaryFiles.java
index 853ec5393..8312ce8bb 100755
--- a/tika-core/src/main/java/org/apache/tika/io/TemporaryFiles.java
+++ b/tika-core/src/main/java/org/apache/tika/io/TemporaryFiles.java
@@ -16,24 +16,19 @@
  */
 package org.apache.tika.io;
 
-import java.io.File;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
 
-public class TemporaryFiles {
-
-    private final List<File> files = new ArrayList<File>();
-
-    public File createTemporaryFile() throws IOException {
-        File file = File.createTempFile("apache-tika-", ".tmp");
-        files.add(file);
-        return file;
-    }
+/**
+ * @deprecated Use the {@link TemporaryResources} class instead
+ */
+public class TemporaryFiles extends TemporaryResources {
 
+    @Override
     public void dispose() {
-        for (File file : files) {
-            file.delete();
+        try {
+            close();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
     }
 
diff --git a/tika-core/src/main/java/org/apache/tika/io/TemporaryResources.java b/tika-core/src/main/java/org/apache/tika/io/TemporaryResources.java
new file mode 100644
index 000000000..dd8ad260a
--- /dev/null
+++ b/tika-core/src/main/java/org/apache/tika/io/TemporaryResources.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.tika.io;
+
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.apache.tika.exception.TikaException;
+
+/**
+ * Utility class for tracking and ultimately closing or otherwise disposing
+ * a collection of temporary resources.
+ * <p>
+ * Note that this class is not thread-safe.
+ *
+ * @since Apache Tika 1.0
+ */
+public class TemporaryResources implements Closeable {
+
+    /**
+     * Tracked resources in LIFO order.
+     */
+    private final LinkedList<Closeable> resources = new LinkedList<Closeable>();
+
+    /**
+     * Directory for temporary files, <code>null</code> for the system default.
+     */
+    private File tmp = null;
+
+    /**
+     * Sets the directory to be used for the temporary files created by
+     * the {@link #createTemporaryFile()} method.
+     *
+     * @param tmp temporary file directory,
+     *            or <code>null</code> for the system default
+     */
+    public void setTemporaryFileDirectory(File tmp) {
+        this.tmp = tmp;
+    }
+
+    /**
+     * Creates and returns a temporary file that will automatically be
+     * deleted when the {@link #close()} method is called.
+     *
+     * @return
+     * @throws IOException
+     */
+    public File createTemporaryFile() throws IOException {
+        final File file = File.createTempFile("apache-tika-", ".tmp", tmp);
+        addResource(new Closeable() {
+            public void close() throws IOException {
+                if (!file.delete()) {
+                    throw new IOException(
+                            "Could not delete temporary file "
+                            + file.getPath());
+                }
+            }
+        });
+        return file;
+    }
+
+    /**
+     * Adds a new resource to the set of tracked resources that will all be
+     * closed when the {@link #close()} method is called.
+     *
+     * @param resource resource to be tracked
+     */
+    public void addResource(Closeable resource) {
+        resources.addFirst(resource);
+    }
+
+    /**
+     * Returns the latest of the tracked resources that implements or
+     * extends the given interface or class.
+     *
+     * @param klass interface or class
+     * @return matching resource, or <code>null</code> if not found
+     */
+    @SuppressWarnings("unchecked")
+    public <T extends Closeable> T getResource(Class<T> klass) {
+        for (Closeable resource : resources) {
+            if (klass.isAssignableFrom(resource.getClass())) {
+                return (T) resource;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Closes all tracked resources. The resources are closed in reverse order
+     * from how they were added.
+     * <p>
+     * Any thrown exceptions from managed resources are collected and
+     * then re-thrown only once all the resources have been closed.
+     *
+     * @throws IOException if one or more of the tracked resources
+     *                     could not be closed
+     */
+    public void close() throws IOException {
+        // Release all resources and keep track of any exceptions
+        List<IOException> exceptions = new LinkedList<IOException>();
+        for (Closeable resource : resources) {
+            try {
+                resource.close();
+            } catch (IOException e) {
+                exceptions.add(e);
+            }
+        }
+        resources.clear();
+
+        // Throw any exceptions that were captured from above
+        if (!exceptions.isEmpty()) {
+            if (exceptions.size() == 1) {
+                throw exceptions.get(0);
+            } else {
+                throw new IOExceptionWithCause(
+                        "Multiple IOExceptions" + exceptions,
+                        exceptions.get(0));
+            }
+        }
+    }
+
+    /**
+     * Calls the {@link #close()} method and wraps the potential
+     * {@link IOException} into a {@link TikaException} for convenience
+     * when used within Tika.
+     *
+     * @throws TikaException if one or more of the tracked resources
+     *                       could not be closed
+     */
+    public void dispose() throws TikaException {
+        try {
+            close();
+        } catch (IOException e) {
+            throw new TikaException("Failed to close temporary resources", e);
+        }
+    }
+
+}
diff --git a/tika-core/src/main/java/org/apache/tika/io/TikaInputStream.java b/tika-core/src/main/java/org/apache/tika/io/TikaInputStream.java
index 54a199fae..0c5138a1c 100644
--- a/tika-core/src/main/java/org/apache/tika/io/TikaInputStream.java
+++ b/tika-core/src/main/java/org/apache/tika/io/TikaInputStream.java
@@ -30,6 +30,7 @@ import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.channels.FileChannel;
 import java.sql.Blob;
 import java.sql.SQLException;
 
@@ -84,34 +85,54 @@ public class TikaInputStream extends TaggedInputStream {
      * when you <em>don't</em> explicitly close the returned stream. The
      * recommended access pattern is:
      * <pre>
-     * TemporaryFiles tmp = new TemporaryFiles();
+     * TemporaryResources tmp = new TemporaryResources();
      * try {
      *     TikaInputStream stream = TikaInputStream.get(..., tmp);
      *     // process stream but don't close it
      * } finally {
-     *     tmp.dispose();
+     *     tmp.close();
      * }
      * </pre>
+     * <p>
+     * The given stream instance will <em>not</em> be closed when the
+     * {@link TemporaryResources#close()} method is called. The caller
+     * is expected to explicitly close the original stream when it's no
+     * longer used.
      *
      * @param stream normal input stream
      * @return a TikaInputStream instance
      */
-    public static TikaInputStream get(InputStream stream, TemporaryFiles tmp) {
+    public static TikaInputStream get(
+            InputStream stream, TemporaryResources tmp) {
         if (stream instanceof TikaInputStream) {
             return (TikaInputStream) stream;
         } else {
+            // Make sure that the stream is buffered and that it
+            // (properly) supports the mark feature
+            if (!(stream instanceof BufferedInputStream)
+                    && !(stream instanceof ByteArrayInputStream)) {
+                stream = new BufferedInputStream(stream);
+            }
             return new TikaInputStream(stream, tmp, -1);
         }
     }
 
+    /**
+     * @deprecated Use the {@link #get(InputStream, TemporaryResources)} instead
+     */
+    public static TikaInputStream get(InputStream stream, TemporaryFiles tmp) {
+        return get(stream, (TemporaryResources) tmp);
+    }
+
     /**
      * Casts or wraps the given stream to a TikaInputStream instance.
      * This method can be used to access the functionality of this class
      * even when given just a normal input stream instance.
      * <p>
-     * Use this method instead of the {@link #get(InputStream, TemporaryFiles)}
-     * alternative when you <em>do</em> explicitly close the returned stream.
-     * The recommended access pattern is:
+     * Use this method instead of the
+     * {@link #get(InputStream, TemporaryResources)} alternative when you
+     * <em>do</em> explicitly close the returned stream. The recommended
+     * access pattern is:
      * <pre>
      * TikaInputStream stream = TikaInputStream.get(...);
      * try {
@@ -120,12 +141,16 @@ public class TikaInputStream extends TaggedInputStream {
      *     stream.close();
      * }
      * </pre>
+     * <p>
+     * The given stream instance will be closed along with any other resources
+     * associated with the returned TikaInputStream instance when the
+     * {@link #close()} method is called.
      *
      * @param stream normal input stream
      * @return a TikaInputStream instance
      */
     public static TikaInputStream get(InputStream stream) {
-        return get(stream, new TemporaryFiles());
+        return get(stream, new TemporaryResources());
     }
 
     /**
@@ -156,7 +181,8 @@ public class TikaInputStream extends TaggedInputStream {
     public static TikaInputStream get(byte[] data, Metadata metadata) {
         metadata.set(Metadata.CONTENT_LENGTH, Integer.toString(data.length));
         return new TikaInputStream(
-                new ByteArrayInputStream(data), new TemporaryFiles(), data.length);
+                new ByteArrayInputStream(data),
+                new TemporaryResources(), data.length);
     }
 
     /**
@@ -247,7 +273,7 @@ public class TikaInputStream extends TaggedInputStream {
         } else {
             return new TikaInputStream(
                     new BufferedInputStream(blob.getBinaryStream()),
-                    null, length);
+                    new TemporaryResources(), length);
         }
     }
 
@@ -355,25 +381,7 @@ public class TikaInputStream extends TaggedInputStream {
 
         return new TikaInputStream(
                 new BufferedInputStream(connection.getInputStream()),
-                new TemporaryFiles(), length);
-    }
-
-    /**
-     * Makes sure that a stream is buffered and correctly supports the
-     * mark feature by wrapping the given stream to a
-     * {@link BufferedInputStream} if needed.
-     *
-     * @param stream original stream
-     * @return buffered stream that supports the mark feature
-     */
-    private static InputStream withBufferingAndMarkSupport(InputStream stream) {
-        if (stream instanceof ByteArrayInputStream) {
-            return stream;
-        } else if (stream instanceof BufferedInputStream) {
-            return stream;
-        } else {
-            return new BufferedInputStream(stream);
-        }
+                new TemporaryResources(), length);
     }
 
     /**
@@ -386,9 +394,9 @@ public class TikaInputStream extends TaggedInputStream {
     private File file;
 
     /**
-     * Temporary file provider.
+     * Tracker of temporary resources.
      */
-    private final TemporaryFiles tmp;
+    private final TemporaryResources tmp;
 
     /**
      * Total length of the stream, or -1 if unknown.
@@ -422,20 +430,25 @@ public class TikaInputStream extends TaggedInputStream {
     private TikaInputStream(File file) throws FileNotFoundException {
         super(new BufferedInputStream(new FileInputStream(file)));
         this.file = file;
-        this.tmp = new TemporaryFiles();
+        this.tmp = new TemporaryResources();
         this.length = file.length();
     }
 
     /**
      * Creates a TikaInputStream instance. This private constructor is used
      * by the static factory methods based on the available information.
+     * <p>
+     * The given stream needs to be included in the given temporary resource
+     * collection if the caller wants it also to get closed when the
+     * {@link #close()} method is invoked.
      *
      * @param stream <em>buffered</em> stream (must support the mark feature)
+     * @param tmp tracker for temporary resources associated with this stream
      * @param length total length of the stream, or -1 if unknown
      */
     private TikaInputStream(
-            InputStream stream, TemporaryFiles tmp, long length) {
-        super(withBufferingAndMarkSupport(stream));
+            InputStream stream, TemporaryResources tmp, long length) {
+        super(stream);
         this.file = null;
         this.tmp = tmp;
         this.length = length;
@@ -489,6 +502,9 @@ public class TikaInputStream extends TaggedInputStream {
      */
     public void setOpenContainer(Object container) {
         openContainer = container;
+        if (container instanceof Closeable) {
+            tmp.addResource((Closeable) container);
+        }
     }
 
     public boolean hasFile() {
@@ -497,11 +513,10 @@ public class TikaInputStream extends TaggedInputStream {
 
     public File getFile() throws IOException {
         if (file == null) {
-            if (in == null) {
-                throw new IOException("Stream has already been read");
-            } else if (position > 0) {
+            if (position > 0) {
                 throw new IOException("Stream is already being read");
             } else {
+                // Spool the entire stream into a temporary file
                 file = tmp.createTemporaryFile();
                 OutputStream out = new FileOutputStream(file);
                 try {
@@ -509,15 +524,37 @@ public class TikaInputStream extends TaggedInputStream {
                 } finally {
                     out.close();
                 }
-                in.close();
-                // Re-point the stream at the file now we have it
-                in = new BufferedInputStream(new FileInputStream(file));
+
+                // Create a new input stream and make sure it'll get closed
+                FileInputStream newStream = new FileInputStream(file);
+                tmp.addResource(newStream);
+
+                // Replace the spooled stream with the new stream in a way
+                // that still ends up closing the old stream if or when the
+                // close() method is called. The closing of the new stream
+                // is already being handled as noted above.
+                final InputStream oldStream = in;
+                in = new BufferedInputStream(newStream) {
+                    @Override
+                    public void close() throws IOException {
+                        oldStream.close();
+                    }
+                };
+
                 length = file.length();
             }
         }
         return file;
     }
 
+    public FileChannel getFileChannel() throws IOException {
+        FileInputStream fis = new FileInputStream(getFile());
+        tmp.addResource(fis);
+        FileChannel channel = fis.getChannel();
+        tmp.addResource(channel);
+        return channel;
+    }
+
     public boolean hasLength() {
         return length != -1;
     }
@@ -548,47 +585,11 @@ public class TikaInputStream extends TaggedInputStream {
         return position;
     }
 
-    @Override
-    public int available() throws IOException {
-        if (in == null) {
-            return 0;
-        } else {
-            return super.available();
-        }
-    }
-
     @Override
     public long skip(long ln) throws IOException {
-        if (in == null) {
-            return 0;
-        } else {
-            long n = super.skip(ln);
-            position += n;
-            return n;
-        }
-    }
-
-    @Override
-    public int read() throws IOException {
-        if (in == null) {
-            return -1;
-        } else {
-            return super.read();
-        }
-    }
-
-    @Override
-    public int read(byte[] bts, int off, int len) throws IOException {
-        if (in == null) {
-            return -1;
-        } else {
-            return super.read(bts, off, len);
-        }
-    }
-
-    @Override
-    public int read(byte[] bts) throws IOException {
-        return read(bts, 0, bts.length);
+        long n = super.skip(ln);
+        position += n;
+        return n;
     }
 
     @Override
@@ -611,33 +612,22 @@ public class TikaInputStream extends TaggedInputStream {
 
     @Override
     public void close() throws IOException {
-        if (in != null) {
-            in.close();
-            in = null;
-        }
-        if (openContainer != null) {
-           if (openContainer instanceof Closeable) {
-              ((Closeable)openContainer).close();
-           }
-           openContainer = null;
-        }
         file = null;
-        tmp.dispose();
-    }
+        mark = -1;
 
-    @Override
-    protected void beforeRead(int n) throws IOException {
-        if (in == null) {
-            throw new IOException("End of the stream reached");
-        }
+        // The close method was explicitly called, so we indeed
+        // are expected to close the input stream. Handle that
+        // by adding that stream as a resource to be tracked before
+        // closing all of them. This way also possible exceptions from
+        // the close() calls get managed properly.
+        tmp.addResource(in);
+        tmp.close();
     }
 
     @Override
-    protected void afterRead(int n) throws IOException {
+    protected void afterRead(int n) {
         if (n != -1) {
             position += n;
-        } else if (mark == -1) {
-            close();
         }
     }
 
diff --git a/tika-core/src/main/java/org/apache/tika/parser/AutoDetectParser.java b/tika-core/src/main/java/org/apache/tika/parser/AutoDetectParser.java
index 853691afb..36b858377 100644
--- a/tika-core/src/main/java/org/apache/tika/parser/AutoDetectParser.java
+++ b/tika-core/src/main/java/org/apache/tika/parser/AutoDetectParser.java
@@ -23,7 +23,7 @@ import org.apache.tika.config.TikaConfig;
 import org.apache.tika.detect.DefaultDetector;
 import org.apache.tika.detect.Detector;
 import org.apache.tika.exception.TikaException;
-import org.apache.tika.io.TemporaryFiles;
+import org.apache.tika.io.TemporaryResources;
 import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.mime.MediaType;
@@ -114,7 +114,7 @@ public class AutoDetectParser extends CompositeParser {
             InputStream stream, ContentHandler handler,
             Metadata metadata, ParseContext context)
             throws IOException, SAXException, TikaException {
-        TemporaryFiles tmp = new TemporaryFiles();
+        TemporaryResources tmp = new TemporaryResources();
         try {
             TikaInputStream tis = TikaInputStream.get(stream, tmp);
 
diff --git a/tika-core/src/main/java/org/apache/tika/parser/CompositeParser.java b/tika-core/src/main/java/org/apache/tika/parser/CompositeParser.java
index 5b797183b..70b947163 100644
--- a/tika-core/src/main/java/org/apache/tika/parser/CompositeParser.java
+++ b/tika-core/src/main/java/org/apache/tika/parser/CompositeParser.java
@@ -27,7 +27,7 @@ import java.util.Map;
 import java.util.Set;
 
 import org.apache.tika.exception.TikaException;
-import org.apache.tika.io.TemporaryFiles;
+import org.apache.tika.io.TemporaryResources;
 import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.mime.MediaType;
@@ -234,7 +234,7 @@ public class CompositeParser extends AbstractParser {
             Metadata metadata, ParseContext context)
             throws IOException, SAXException, TikaException {
         Parser parser = getParser(metadata);
-        TemporaryFiles tmp = new TemporaryFiles();
+        TemporaryResources tmp = new TemporaryResources();
         try {
             TikaInputStream taggedStream = TikaInputStream.get(stream, tmp);
             TaggedContentHandler taggedHandler = new TaggedContentHandler(handler);
diff --git a/tika-core/src/main/java/org/apache/tika/parser/NetworkParser.java b/tika-core/src/main/java/org/apache/tika/parser/NetworkParser.java
index b83d9d47b..76bcb8f61 100644
--- a/tika-core/src/main/java/org/apache/tika/parser/NetworkParser.java
+++ b/tika-core/src/main/java/org/apache/tika/parser/NetworkParser.java
@@ -30,7 +30,7 @@ import java.util.Set;
 import org.apache.tika.exception.TikaException;
 import org.apache.tika.io.CloseShieldInputStream;
 import org.apache.tika.io.IOUtils;
-import org.apache.tika.io.TemporaryFiles;
+import org.apache.tika.io.TemporaryResources;
 import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.mime.MediaType;
@@ -64,7 +64,7 @@ public class NetworkParser extends AbstractParser {
             InputStream stream, ContentHandler handler,
             Metadata metadata, ParseContext context)
             throws IOException, SAXException, TikaException {
-        TemporaryFiles tmp = new TemporaryFiles();
+        TemporaryResources tmp = new TemporaryResources();
         try {
             TikaInputStream tis = TikaInputStream.get(stream, tmp);
             parse(tis, handler, metadata, context);
diff --git a/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java b/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java
index 1702d6fe2..632c76824 100644
--- a/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java
+++ b/tika-core/src/main/java/org/apache/tika/parser/external/ExternalParser.java
@@ -34,7 +34,7 @@ import java.util.regex.Pattern;
 import org.apache.tika.exception.TikaException;
 import org.apache.tika.io.IOUtils;
 import org.apache.tika.io.NullOutputStream;
-import org.apache.tika.io.TemporaryFiles;
+import org.apache.tika.io.TemporaryResources;
 import org.apache.tika.io.TikaInputStream;
 import org.apache.tika.metadata.Metadata;
 import org.apache.tika.mime.MediaType;
@@ -80,9 +80,8 @@ public class ExternalParser extends AbstractParser {
      * @see Runtime#exec(String[])
      */
     private String[] command = new String[] { "cat" };
-    
-    private TemporaryFiles tmp = new TemporaryFiles();
-    
+
+    private TemporaryResources tmp = new TemporaryResources();
 
     public Set<MediaType> getSupportedTypes(ParseContext context) {
         return getSupportedTypes();
