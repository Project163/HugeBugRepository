diff --git a/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java b/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java
index 7e36dc08..3cf6cdfc 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java
@@ -16,6 +16,8 @@
  */
 package org.apache.commons.jexl3;
 
+import org.apache.commons.jexl3.introspection.JexlMethod;
+
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.MathContext;
@@ -41,9 +43,108 @@ import java.math.MathContext;
  * @since 2.0
  */
 public class JexlArithmetic {
-    /** Maker class for null operand exceptions. */
-    public static class NullOperand extends ArithmeticException {
+    /**
+     * The overridable operators.
+     * @since 3.0
+     */
+    public enum Operator {
+        ADD("+", "add", 2),
+        SUBTRACT("-", "subtract", 2),
+        MULTIPLY("*", "multiply", 2),
+        DIVIDE("/", "divide", 2),
+        MOD("%", "mod", 2),
+        AND("&", "bitwiseAnd", 2),
+        OR("|", "bitwiseOr", 2),
+        XOR("^", "bitwiseXor", 2),
+        NOT("!", "logicalNot", 1),
+        COMPLEMENT("-", "bitwiseComplement", 1),
+        EQ("==", "equals", 2),
+        LT("<", "lessThan", 2),
+        LTE("<=", "lessThanOrEqual", 2),
+        GT(">", "greaterThan", 2),
+        GTE(">=", "greaterThanOrEqual", 2),
+        ABS("+", "abs", 1),
+        NEGATE("-", "negate", 1),
+        SIZE("size", "size", 1),
+        EMPTY("empty", "empty", 1);
+
+        /**
+         * The operator symbol.
+         */
+        private final String operator;
+        /**
+         * The associated operator method name.
+         */
+        private final String methodName;
+        /**
+         * The method arity.
+         */
+        private final int arity;
+
+        /**
+         * Creates an operator.
+         * @param o the operator name
+         * @param m the method name associated to this operator in a JexlArithmetic
+         * @param arity the number of parameters for the method
+         */
+        Operator(String o, String m, int arity) {
+            this.operator = o;
+            this.methodName = m;
+            this.arity = arity;
+        }
+
+        /**
+         * Gets this operator symbol.
+         * @return the symbol
+         */
+        public final String getOperatorSymbol() {
+            return operator;
+        }
+
+        /**
+         * Gets this operator method name in a JexlArithmetic.
+         * @return the method name
+         */
+        public final String getMethodName() {
+            return methodName;
+        }
+
+        /**
+         * Gets this operator number of parameters.
+         * @return the method arity
+         */
+        public int getArity() {
+            return arity;
+        }
     }
+
+    /**
+     * The interface that uberspects JexlArithmetic classes.
+     * <p>This allows overloaded operator methods discovery.
+     */
+    public interface Uberspect {
+        /**
+         * Gets the most specific method for a monadic operator.
+         * @param operator the operator
+         * @param arg the argument
+         * @return the most specific method or null if no specific override could be found
+         */
+        JexlMethod getOperator(JexlArithmetic.Operator operator, Object arg);
+        Object tryInvokeOperator(JexlArithmetic.Operator operator, Object arg);
+
+        /**
+         * Gets the most specific method for a diadic operator.
+         * @param operator the operator
+         * @param lhs the left hand side argument
+         * @param rhs the right hand side argument
+         * @return the most specific method or null if no specific override could be found
+         */
+        JexlMethod getOperator(JexlArithmetic.Operator operator, Object lhs, Object rhs);
+        Object tryInvokeOperator(JexlArithmetic.Operator operator, Object lhs, Object rhs);
+    }
+
+    /** Maker class for null operand exceptions. */
+    public static class NullOperand extends ArithmeticException {}
     /** Double.MAX_VALUE as BigDecimal. */
     protected static final BigDecimal BIGD_DOUBLE_MAX_VALUE = BigDecimal.valueOf(Double.MAX_VALUE);
     /** Double.MIN_VALUE as BigDecimal. */
@@ -748,6 +849,15 @@ public class JexlArithmetic {
         return Long.valueOf(~l);
     }
 
+    /**
+     * Performs a logical not.
+     * @param val the operand
+     * @return !val
+     */
+    public Object logicalNot(Object val) {
+        return toBoolean(val) ? Boolean.FALSE : Boolean.TRUE;
+    }
+
     /**
      * Performs a comparison.
      * @param left     the left operand
diff --git a/src/main/java/org/apache/commons/jexl3/JexlEngine.java b/src/main/java/org/apache/commons/jexl3/JexlEngine.java
index 243b07ca..d7ee8119 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlEngine.java
@@ -44,6 +44,14 @@ import java.nio.charset.Charset;
  * @since 2.0
  */
 public abstract class JexlEngine {
+    /** A marker for invocation failures in tryInvoke. */
+    public static final Object TRY_FAILED = new Object() {
+        @Override
+        public String toString() {
+            return "tryExecute failed";
+        }
+    };
+    
     /**
      * The thread local context.
      */
@@ -462,7 +470,7 @@ public abstract class JexlEngine {
      * @param c  column number
      * @return a JexlInfo instance
      */
-    protected JexlInfo createInfo(String fn, int l, int c) {
+    public JexlInfo createInfo(String fn, int l, int c) {
         return new JexlInfo(fn, l, c);
     }
 
@@ -472,7 +480,7 @@ public abstract class JexlEngine {
      * outside of o.a.c.jexl3.</p>
      * @return a JexlInfo instance
      */
-    protected JexlInfo createInfo() {
+    public JexlInfo createInfo() {
         JexlInfo info = null;
         Throwable xinfo = new Throwable();
         xinfo.fillInStackTrace();
@@ -483,7 +491,7 @@ public abstract class JexlEngine {
             se = stack[s];
             String className = se.getClassName();
             if (!className.equals(name)) {
-                // go deeper if called from jexl3 implementation classes
+                // go deeper if called from jexl implementation classes
                 if (className.startsWith("org.apache.commons.jexl3.internal.")
                     || className.startsWith("org.apache.commons.jexl3.J")) {
                     name = className;
diff --git a/src/main/java/org/apache/commons/jexl3/JexlException.java b/src/main/java/org/apache/commons/jexl3/JexlException.java
index 3faaa771..30294f99 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlException.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlException.java
@@ -437,6 +437,34 @@ public class JexlException extends RuntimeException {
         }
     }
 
+    /**
+     * Thrown to break a loop.
+     * @since 3.0
+     */
+    public static class Break extends JexlException {
+        /**
+         * Creates a new instance of Break.
+         * @param node the break
+         */
+        public Break(JexlNode node) {
+            super(node, "break loop", null);
+        }
+    }
+
+    /**
+     * Thrown to continue a loop.
+     * @since 3.0
+     */
+    public static class Continue extends JexlException {
+        /**
+         * Creates a new instance of Continue.
+         * @param node the continue
+         */
+        public Continue(JexlNode node) {
+            super(node, "continue loop", null);
+        }
+    }
+
     /**
      * Detailed info message about this error.
      * Format is "debug![begin,end]: string \n msg" where:
diff --git a/src/main/java/org/apache/commons/jexl3/JexlInfo.java b/src/main/java/org/apache/commons/jexl3/JexlInfo.java
index 66c225d0..2011c987 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlInfo.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlInfo.java
@@ -61,6 +61,10 @@ public class JexlInfo {
         column = c;
     }
 
+    public JexlInfo at(int l, int c) {
+        return new JexlInfo(name, l, c);
+    }
+
     protected JexlInfo(JexlInfo copy) {
         name = copy.getName();
         line = copy.getLine();
diff --git a/src/main/java/org/apache/commons/jexl3/JxltEngine.java b/src/main/java/org/apache/commons/jexl3/JxltEngine.java
index 24fbfec4..7bba004c 100644
--- a/src/main/java/org/apache/commons/jexl3/JxltEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/JxltEngine.java
@@ -16,7 +16,9 @@
  */
 package org.apache.commons.jexl3;
 
+import org.apache.commons.jexl3.internal.TemplateEngine;
 import java.io.Reader;
+import java.io.StringReader;
 import java.io.Writer;
 import java.util.List;
 import java.util.Set;
@@ -41,7 +43,7 @@ public abstract class JxltEngine {
     /**
      * The sole type of (runtime) exception the JxltEngine can throw.
      */
-    public static class Exception extends RuntimeException {
+    public static class Exception extends JexlException {
         /** Serial version UID. */
         private static final long serialVersionUID = 201112030113L;
 
@@ -50,8 +52,8 @@ public abstract class JxltEngine {
          * @param msg the exception message
          * @param cause the exception cause
          */
-        public Exception(String msg, Throwable cause) {
-            super(msg, cause);
+        public Exception(JexlInfo info, String msg, Throwable cause) {
+            super(info, msg, cause);
         }
     }
 
@@ -203,7 +205,23 @@ public abstract class JxltEngine {
      * @throws Exception if an error occurs and the {@link JexlEngine}
      * is not silent
      */
-    public abstract Expression createExpression(String expression);
+    public Expression createExpression(String expression) {
+        return createExpression(null, expression);
+    }
+
+    /**
+     * Creates a a {@link Expression} from an expression string.
+     * Uses & fills up the expression cache if any.
+     * <p>
+     * If the underlying JEXL engine is silent, errors will be logged through its logger as warnings.
+     * </p>
+     * @param info the {@link JexlInfo} source information
+     * @param expression the {@link Template} string expression
+     * @return the {@link Expression}, null if silent and an error occured
+     * @throws Exception if an error occurs and the {@link JexlEngine}
+     * is not silent
+     */
+    public abstract Expression createExpression(JexlInfo info, String expression);
 
     /**
      * A template is a JEXL script that evaluates by writing its content through a Writer.
@@ -290,27 +308,64 @@ public abstract class JxltEngine {
 
     /**
      * Creates a new template.
+     * @param info the jexl info (file, line, column)
      * @param prefix the directive prefix
      * @param source the source
      * @param parms the parameter names
      * @return the template
      */
-    public abstract Template createTemplate(String prefix, Reader source, String... parms);
+    public abstract Template createTemplate(JexlInfo info, String prefix, Reader source, String... parms);
 
     /**
      * Creates a new template.
+     * @param info the source info
+     * @param parms the parameter names
+     * @param source the source
+     * @return the template
+     */
+    public Template createTemplate(JexlInfo info, String source, String... parms) {
+        return createTemplate(info, "$$", new StringReader(source), parms);
+    }
+
+    /**
+     * Creates a new template.
+     * @param info the source info
+     * @param source the source
+     * @return the template
+     */
+    public Template createTemplate(JexlInfo info, String source) {
+        return createTemplate(info, "$$", new StringReader(source), (String[]) null);
+    }
+
+    /**
+     * Creates a new template.
+     * @param prefix the directive prefix
      * @param source the source
      * @param parms the parameter names
      * @return the template
      */
-    public abstract Template createTemplate(String source, String... parms);
+    public Template createTemplate(String prefix, Reader source, String... parms) {
+        return createTemplate(null, prefix, source, parms);
+    }
 
     /**
      * Creates a new template.
      * @param source the source
+     * @param parms the parameter names
      * @return the template
      */
-    public abstract Template createTemplate(String source);
+    public Template createTemplate(String source, String... parms) {
+        return createTemplate(null, source, parms);
+    }
+
+    /**
+     * Creates a new template.
+     * @param source the source
+     * @return the template
+     */
+    public Template createTemplate(String source) {
+        return createTemplate(null, source);
+    }
 
     /**
      * Gets the {@link JexlEngine} underlying this template engine.
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Debugger.java b/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
index da1dbcfe..182e6603 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
@@ -31,7 +31,9 @@ import org.apache.commons.jexl3.parser.ASTBitwiseComplNode;
 import org.apache.commons.jexl3.parser.ASTBitwiseOrNode;
 import org.apache.commons.jexl3.parser.ASTBitwiseXorNode;
 import org.apache.commons.jexl3.parser.ASTBlock;
+import org.apache.commons.jexl3.parser.ASTBreak;
 import org.apache.commons.jexl3.parser.ASTConstructorNode;
+import org.apache.commons.jexl3.parser.ASTContinue;
 import org.apache.commons.jexl3.parser.ASTDivNode;
 import org.apache.commons.jexl3.parser.ASTEQNode;
 import org.apache.commons.jexl3.parser.ASTERNode;
@@ -490,6 +492,16 @@ public final class Debugger extends ParserVisitor implements JexlInfo.Detail {
         return check(node, "false", data);
     }
 
+    @Override
+    protected Object visit(ASTContinue node, Object data) {
+        return check(node, "continue", data);
+    }
+
+    @Override
+    protected Object visit(ASTBreak node, Object data) {
+        return check(node, "break", data);
+    }
+
     @Override
     protected Object visit(ASTForeachStatement node, Object data) {
         builder.append("for(");
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Engine.java b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
index 8dbb08c9..31636faf 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Engine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Engine.java
@@ -156,6 +156,9 @@ public class Engine extends JexlEngine {
         this.cache = conf.cache() <= 0 ? null : new SoftCache<String, ASTJexlScript>(conf.cache());
         this.cacheThreshold = conf.cacheThreshold();
         this.charset = conf.charset();
+        if (uberspect == null) {
+            throw new IllegalArgumentException("uberspect can not be null");
+        }
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index ed62f6ce..53ae96e7 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -17,6 +17,7 @@
 package org.apache.commons.jexl3.internal;
 
 import org.apache.commons.jexl3.JexlArithmetic;
+import static org.apache.commons.jexl3.JexlArithmetic.Operator;
 import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.JexlException;
@@ -36,7 +37,9 @@ import org.apache.commons.jexl3.parser.ASTBitwiseComplNode;
 import org.apache.commons.jexl3.parser.ASTBitwiseOrNode;
 import org.apache.commons.jexl3.parser.ASTBitwiseXorNode;
 import org.apache.commons.jexl3.parser.ASTBlock;
+import org.apache.commons.jexl3.parser.ASTBreak;
 import org.apache.commons.jexl3.parser.ASTConstructorNode;
+import org.apache.commons.jexl3.parser.ASTContinue;
 import org.apache.commons.jexl3.parser.ASTDivNode;
 import org.apache.commons.jexl3.parser.ASTEQNode;
 import org.apache.commons.jexl3.parser.ASTERNode;
@@ -110,6 +113,8 @@ public class Interpreter extends ParserVisitor {
     protected final JexlUberspect uberspect;
     /** The arithmetic handler. */
     protected final JexlArithmetic arithmetic;
+    /** The overloaded arithmetic operators. */
+    protected final JexlArithmetic.Uberspect operators;
     /** The map of symboled functions. */
     protected final Map<String, Object> functions;
     /** The map of symboled functions. */
@@ -163,6 +168,7 @@ public class Interpreter extends ParserVisitor {
         }
         this.functions = jexl.functions;
         this.strictArithmetic = this.arithmetic.isStrict();
+        this.operators = uberspect.getArithmetic(arithmetic);
         this.cache = jexl.cache != null;
         this.frame = eFrame;
         this.functors = null;
@@ -383,6 +389,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.ADD, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.add(left, right);
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "+ error", xrt);
@@ -394,6 +406,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.SUBTRACT, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.subtract(left, right);
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "- error", xrt);
@@ -405,6 +423,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.AND, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.bitwiseAnd(left, right);
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "& error", xrt);
@@ -415,6 +439,12 @@ public class Interpreter extends ParserVisitor {
     protected Object visit(ASTBitwiseComplNode node, Object data) {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.COMPLEMENT, left);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.bitwiseComplement(left);
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "~ error", xrt);
@@ -426,6 +456,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.OR, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.bitwiseOr(left, right);
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "| error", xrt);
@@ -437,6 +473,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.XOR, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.bitwiseXor(left, right);
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "^ error", xrt);
@@ -458,6 +500,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.DIVIDE, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.divide(left, right);
         } catch (ArithmeticException xrt) {
             if (!strictArithmetic) {
@@ -473,6 +521,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.EQ, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.equals(left, right) ? Boolean.TRUE : Boolean.FALSE;
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "== error", xrt);
@@ -484,6 +538,16 @@ public class Interpreter extends ParserVisitor {
         return Boolean.FALSE;
     }
 
+    @Override
+    protected Object visit(ASTContinue node, Object data) {
+        throw new JexlException.Continue(node);
+    }
+
+    @Override
+    protected Object visit(ASTBreak node, Object data) {
+        throw new JexlException.Break(node);
+    }
+
     @Override
     protected Object visit(ASTForeachStatement node, Object data) {
         Object result = null;
@@ -512,8 +576,14 @@ public class Interpreter extends ParserVisitor {
                     } else {
                         frame.set(symbol, value);
                     }
-                    // execute statement
-                    result = statement.jjtAccept(this, data);
+                    try {
+                        // execute statement
+                        result = statement.jjtAccept(this, data);
+                    } catch(JexlException.Break stmtBreak) {
+                        break;
+                    } catch(JexlException.Continue stmtContinue) {
+                        //continue;
+                    }
                 }
             }
         }
@@ -525,6 +595,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.GTE, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.greaterThanOrEqual(left, right) ? Boolean.TRUE : Boolean.FALSE;
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, ">= error", xrt);
@@ -536,6 +612,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.GT, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.greaterThan(left, right) ? Boolean.TRUE : Boolean.FALSE;
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "> error", xrt);
@@ -762,6 +844,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.LTE, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.lessThanOrEqual(left, right) ? Boolean.TRUE : Boolean.FALSE;
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "<= error", xrt);
@@ -773,6 +861,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.LT, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.lessThan(left, right) ? Boolean.TRUE : Boolean.FALSE;
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, "< error", xrt);
@@ -818,6 +912,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.MOD, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.mod(left, right);
         } catch (ArithmeticException xrt) {
             if (!strictArithmetic) {
@@ -833,6 +933,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.MULTIPLY, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             return arithmetic.multiply(left, right);
         } catch (ArithmeticException xrt) {
             JexlNode xnode = findNullOperand(xrt, node, left, right);
@@ -845,6 +951,12 @@ public class Interpreter extends ParserVisitor {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.EQ, left, right);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return arithmetic.toBoolean(result)? Boolean.FALSE : Boolean.TRUE;
+                }
+            }
             return arithmetic.equals(left, right) ? Boolean.FALSE : Boolean.TRUE;
         } catch (ArithmeticException xrt) {
             JexlNode xnode = findNullOperand(xrt, node, left, right);
@@ -855,7 +967,17 @@ public class Interpreter extends ParserVisitor {
     @Override
     protected Object visit(ASTNotNode node, Object data) {
         Object val = node.jjtGetChild(0).jjtAccept(this, data);
-        return arithmetic.toBoolean(val) ? Boolean.FALSE : Boolean.TRUE;
+        try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.NOT, val);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
+            return arithmetic.toBoolean(val) ? Boolean.FALSE : Boolean.TRUE;
+        } catch (ArithmeticException xrt) {
+            throw new JexlException(node, "arithmetic error", xrt);
+        }
     }
 
     @Override
@@ -932,6 +1054,12 @@ public class Interpreter extends ParserVisitor {
         JexlNode valNode = node.jjtGetChild(0);
         Object val = valNode.jjtAccept(this, data);
         try {
+            if (operators != null) {
+                Object result = operators.tryInvokeOperator(Operator.NEGATE, val);
+                if (result != JexlEngine.TRY_FAILED) {
+                    return result;
+                }
+            }
             Object number = arithmetic.negate(val);
             // attempt to recoerce to literal class
             if (valNode instanceof ASTNumberLiteral && number instanceof Number) {
@@ -952,9 +1080,15 @@ public class Interpreter extends ParserVisitor {
             if (isCancelled()) {
                 throw new JexlException.Cancel(node);
             }
-            // execute statement
             if (node.jjtGetNumChildren() > 1) {
-                result = node.jjtGetChild(1).jjtAccept(this, data);
+                try {
+                    // execute statement
+                    result = node.jjtGetChild(1).jjtAccept(this, data);
+                } catch(JexlException.Break stmtBreak) {
+                    break;
+                } catch(JexlException.Continue stmtContinue) {
+                    //continue;
+                }
             }
         }
         return result;
@@ -966,13 +1100,13 @@ public class Interpreter extends ParserVisitor {
         if (val == null) {
             throw new JexlException(node, "size() : argument is null", null);
         }
-        return Integer.valueOf(sizeOf(node, val));
+        return sizeOf(node, val);
     }
 
     @Override
     protected Object visit(ASTSizeMethod node, Object data) {
         Object val = node.jjtGetChild(0).jjtAccept(this, data);
-        return Integer.valueOf(sizeOf(node, val));
+        return sizeOf(node, val);
     }
 
     @Override
@@ -994,10 +1128,16 @@ public class Interpreter extends ParserVisitor {
      * @param object the object to check the rmptyness of.
      * @return the boolean
      */
-    private Boolean isEmpty(JexlNode node, Object object) {
+    private Object isEmpty(JexlNode node, Object object) {
         if (object == null) {
             return Boolean.TRUE;
         }
+        if (operators != null) {
+            Object result = operators.tryInvokeOperator(Operator.EMPTY, object);
+            if (result != JexlEngine.TRY_FAILED) {
+                return result;
+            }
+        }
         if (object instanceof Number) {
             return ((Number) object).intValue() == 0 ? Boolean.TRUE : Boolean.FALSE;
         }
@@ -1013,57 +1153,65 @@ public class Interpreter extends ParserVisitor {
         // Map isn't a collection
         if (object instanceof Map<?, ?>) {
             return ((Map<?, ?>) object).isEmpty() ? Boolean.TRUE : Boolean.FALSE;
-        } else {
-            // check if there is an isEmpty method on the object that returns a
-            // boolean and if so, just use it
-            JexlMethod vm = uberspect.getMethod(object, "isEmpty", EMPTY_PARAMS);
-            if (vm != null && vm.getReturnType() == Boolean.TYPE) {
-                Boolean result;
-                try {
-                    result = (Boolean) vm.invoke(object, EMPTY_PARAMS);
-                } catch (Exception e) {
-                    throw new JexlException(node, "empty() : error executing", e);
-                }
-                return result;
+        }
+        // check if there is an isEmpty method on the object that returns a
+        // boolean and if so, just use it
+        JexlMethod vm = uberspect.getMethod(object, "isEmpty", EMPTY_PARAMS);
+        if (vm != null && vm.getReturnType() == Boolean.TYPE) {
+            Boolean result;
+            try {
+                result = (Boolean) vm.invoke(object, EMPTY_PARAMS);
+            } catch (Exception e) {
+                throw new JexlException(node, "empty() : error executing", e);
             }
-            throw new JexlException(node, "empty() : unsupported type : " + object.getClass(), null);
+            return result;
         }
+        throw new JexlException(node, "empty() : unsupported type : " + object.getClass(), null);
     }
 
     /**
-     * Calculate the
-     * <code>size</code> of various types: Collection, Array, Map, String, and anything that has a int size() method.
+     * Calculate the <code>size</code> of various types:
+     * Collection, Array, Map, String, and anything that has a int size() method.
      *
      * @param node   the node that gave the value to size
      * @param object the object to get the size of.
      * @return the size of val
      */
-    private int sizeOf(JexlNode node, Object object) {
+    private Object sizeOf(JexlNode node, Object object) {
         if (object == null) {
             return 0;
-        } else if (object instanceof Collection<?>) {
+        }
+        if (operators != null) {
+            Object result = operators.tryInvokeOperator(Operator.SIZE, object);
+            if (result != JexlEngine.TRY_FAILED) {
+                return result;
+            }
+        }
+        if (object instanceof Collection<?>) {
             return ((Collection<?>) object).size();
-        } else if (object.getClass().isArray()) {
+        }
+        if (object.getClass().isArray()) {
             return Array.getLength(object);
-        } else if (object instanceof Map<?, ?>) {
+        }
+        if (object instanceof Map<?, ?>) {
             return ((Map<?, ?>) object).size();
-        } else if (object instanceof String) {
+        }
+        if (object instanceof String) {
             return ((String) object).length();
-        } else {
-            // check if there is a size method on the object that returns an
-            // integer and if so, just use it
-            JexlMethod vm = uberspect.getMethod(object, "size", EMPTY_PARAMS);
-            if (vm != null && vm.getReturnType() == Integer.TYPE) {
-                Integer result;
-                try {
-                    result = (Integer) vm.invoke(object, EMPTY_PARAMS);
-                } catch (Exception e) {
-                    throw new JexlException(node, "size() : error executing", e);
-                }
-                return result.intValue();
+        }
+        // check if there is a size method on the object that returns an
+        // integer and if so, just use it
+        JexlMethod vm = uberspect.getMethod(object, "size", EMPTY_PARAMS);
+        if (vm != null && vm.getReturnType() == Integer.TYPE) {
+            Integer result;
+            try {
+                result = (Integer) vm.invoke(object, EMPTY_PARAMS);
+            } catch (Exception e) {
+                throw new JexlException(node, "size() : error executing", e);
             }
-            throw new JexlException(node, "size() : unsupported type : " + object.getClass(), null);
+            return result;
         }
+        throw new JexlException(node, "size() : unsupported type : " + object.getClass(), null);
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
index 7a05bb39..9c00cdb4 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/TemplateEngine.java
@@ -19,6 +19,7 @@ package org.apache.commons.jexl3.internal;
 import org.apache.commons.jexl3.JexlContext;
 import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.JexlException;
+import org.apache.commons.jexl3.JexlInfo;
 import org.apache.commons.jexl3.JxltEngine;
 import org.apache.commons.jexl3.internal.Engine.VarCollector;
 import org.apache.commons.jexl3.introspection.JexlMethod;
@@ -209,6 +210,10 @@ public final class TemplateEngine extends JxltEngine {
          */
         abstract ExpressionType getType();
 
+        JexlInfo getInfo() {
+            return null;
+        }
+
         @Override
         public final String toString() {
             StringBuilder strb = new StringBuilder();
@@ -250,7 +255,7 @@ public final class TemplateEngine extends JxltEngine {
                 Interpreter interpreter = jexl.createInterpreter(context, frame);
                 return prepare(interpreter);
             } catch (JexlException xjexl) {
-                Exception xuel = createException("prepare", this, xjexl);
+                Exception xuel = createException(xjexl.getInfo(), "prepare", this, xjexl);
                 if (jexl.isSilent()) {
                     jexl.logger.warn(xuel.getMessage(), xuel.getCause());
                     return null;
@@ -268,7 +273,7 @@ public final class TemplateEngine extends JxltEngine {
                 Interpreter interpreter = jexl.createInterpreter(context, frame);
                 return evaluate(interpreter);
             } catch (JexlException xjexl) {
-                Exception xuel = createException("prepare", this, xjexl);
+                Exception xuel = createException(xjexl.getInfo(), "prepare", this, xjexl);
                 if (jexl.isSilent()) {
                     jexl.logger.warn(xuel.getMessage(), xuel.getCause());
                     return null;
@@ -389,6 +394,11 @@ public final class TemplateEngine extends JxltEngine {
         protected void getVariables(Engine.VarCollector collector) {
             jexl.getVariables(node, collector);
         }
+
+        @Override
+        JexlInfo getInfo() {
+            return node.jexlInfo();
+        }
     }
 
     /** An immediate unified expression: ${jexl}. */
@@ -598,32 +608,34 @@ public final class TemplateEngine extends JxltEngine {
         }
     }
 
+
     @Override
-    public JxltEngine.Expression createExpression(String expression) {
+    public JxltEngine.Expression createExpression(JexlInfo info, String expression) {
+        if (info == null) {
+            info = jexl.createInfo();
+        }
         Exception xuel = null;
         TemplateExpression stmt = null;
         try {
             if (cache == null) {
-                stmt = parseExpression(expression, null);
+                stmt = parseExpression(info, expression, null);
             } else {
                 synchronized (cache) {
                     stmt = cache.get(expression);
                     if (stmt == null) {
-                        stmt = parseExpression(expression, null);
+                        stmt = parseExpression(info, expression, null);
                         cache.put(expression, stmt);
                     }
                 }
             }
         } catch (JexlException xjexl) {
-            xuel = new Exception("failed to parse '" + expression + "'", xjexl);
-        } catch (Exception xany) {
-            xuel = xany;
-        } finally {
-            if (xuel != null) {
-                if (jexl.isSilent()) {
-                    jexl.logger.warn(xuel.getMessage(), xuel.getCause());
-                    return null;
-                }
+            xuel = new Exception(xjexl.getInfo(), "failed to parse '" + expression + "'", xjexl);
+        }
+        if (xuel != null) {
+            if (jexl.isSilent()) {
+                jexl.logger.warn(xuel.getMessage(), xuel.getCause());
+                stmt = null;
+            } else {
                 throw xuel;
             }
         }
@@ -637,7 +649,7 @@ public final class TemplateEngine extends JxltEngine {
      * @param xany   the exception
      * @return an exception containing an explicit error message
      */
-    private Exception createException(String action, TemplateExpression expr, java.lang.Exception xany) {
+    private Exception createException(JexlInfo info, String action, TemplateExpression expr, java.lang.Exception xany) {
         StringBuilder strb = new StringBuilder("failed to ");
         strb.append(action);
         if (expr != null) {
@@ -653,7 +665,7 @@ public final class TemplateEngine extends JxltEngine {
                 strb.append(causeMsg);
             }
         }
-        return new Exception(strb.toString(), xany);
+        return new Exception(info, strb.toString(), xany);
     }
 
     /** The different parsing states. */
@@ -679,16 +691,19 @@ public final class TemplateEngine extends JxltEngine {
      * @return the unified expression instance
      * @throws JexlException if an error occur during parsing
      */
-    private TemplateExpression parseExpression(String expr, Scope scope) {
+    private TemplateExpression parseExpression(JexlInfo info, String expr, Scope scope) {
         final int size = expr.length();
         ExpressionBuilder builder = new ExpressionBuilder(0);
         StringBuilder strb = new StringBuilder(size);
         ParseState state = ParseState.CONST;
+        int immediate1 = 0;
+        int deferred1 = 0;
         int inner1 = 0;
         boolean nested = false;
         int inested = -1;
-        for (int i = 0; i < size; ++i) {
-            char c = expr.charAt(i);
+        int lineno = info.getLine();
+        for (int column = 0; column < size; ++column) {
+            char c = expr.charAt(column);
             switch (state) {
                 default: // in case we ever add new unified expresssion type
                     throw new UnsupportedOperationException("unexpected unified expression type");
@@ -696,7 +711,7 @@ public final class TemplateEngine extends JxltEngine {
                     if (c == immediateChar) {
                         state = ParseState.IMMEDIATE0;
                     } else if (c == deferredChar) {
-                        inested = i;
+                        inested = column;
                         state = ParseState.DEFERRED0;
                     } else if (c == '\\') {
                         state = ParseState.ESCAPE;
@@ -739,16 +754,24 @@ public final class TemplateEngine extends JxltEngine {
                     break;
                 case IMMEDIATE1: // ${...
                     if (c == '}') {
-                        // materialize the immediate expr
-                        String src = strb.toString();
-                        TemplateExpression iexpr = new ImmediateExpression(
-                                src,
-                                jexl.parse(null, src, scope, false, noscript),
-                                null);
-                        builder.add(iexpr);
-                        strb.delete(0, Integer.MAX_VALUE);
-                        state = ParseState.CONST;
+                        if (immediate1 > 0) {
+                            immediate1 -= 1;
+                            strb.append(c);
+                        } else {
+                            // materialize the immediate expr
+                            String src = strb.toString();
+                            TemplateExpression iexpr = new ImmediateExpression(
+                                    src,
+                                    jexl.parse(info.at(lineno, column), src, scope, false, noscript),
+                                    null);
+                            builder.add(iexpr);
+                            strb.delete(0, Integer.MAX_VALUE);
+                            state = ParseState.CONST;
+                        }
                     } else {
+                        if (c == '{') {
+                            immediate1 += 1;
+                        }
                         // do buildup expr
                         strb.append(c);
                     }
@@ -757,36 +780,42 @@ public final class TemplateEngine extends JxltEngine {
                     // skip inner strings (for '}')
                     if (c == '"' || c == '\'') {
                         strb.append(c);
-                        i = StringParser.readString(strb, expr, i + 1, c);
+                        column = StringParser.readString(strb, expr, column + 1, c);
                         continue;
                     }
                     // nested immediate in deferred; need to balance count of '{' & '}'
                     if (c == '{') {
-                        if (expr.charAt(i - 1) == immediateChar) {
+                        if (expr.charAt(column - 1) == immediateChar) {
                             inner1 += 1;
                             strb.deleteCharAt(strb.length() - 1);
                             nested = true;
+                        } else {
+                            deferred1 += 1;
+                            strb.append(c);
                         }
                         continue;
                     }
                     // closing '}'
                     if (c == '}') {
                         // balance nested immediate
-                        if (inner1 > 0) {
+                        if (deferred1 > 0) {
+                            deferred1 -= 1;
+                            strb.append(c);
+                        } else if (inner1 > 0) {
                             inner1 -= 1;
-                        } else {
+                        } else  {
                             // materialize the nested/deferred expr
                             String src = strb.toString();
                             TemplateExpression dexpr;
                             if (nested) {
                                 dexpr = new NestedExpression(
-                                        expr.substring(inested, i + 1),
-                                        jexl.parse(null, src, scope, false, noscript),
+                                        expr.substring(inested, column + 1),
+                                        jexl.parse(info.at(lineno, column), src, scope, false, noscript),
                                         null);
                             } else {
                                 dexpr = new DeferredExpression(
                                         strb.toString(),
-                                        jexl.parse(null, src, scope, false, noscript),
+                                        jexl.parse(info.at(lineno, column), src, scope, false, noscript),
                                         null);
                             }
                             builder.add(dexpr);
@@ -810,10 +839,13 @@ public final class TemplateEngine extends JxltEngine {
                     }
                     state = ParseState.CONST;
             }
+            if (c == '\n') {
+                lineno += 1;
+            }
         }
         // we should be in that state
         if (state != ParseState.CONST) {
-            throw new Exception("malformed expression: " + expr, null);
+            throw new Exception(info.at(lineno, 0), "malformed expression: " + expr, null);
         }
         // if any chars were buffered, add them as a constant
         if (strb.length() > 0) {
@@ -839,6 +871,8 @@ public final class TemplateEngine extends JxltEngine {
     private static final class Block {
         /** The type of block, verbatim or directive. */
         private final BlockType type;
+        /** The block start line info. */
+        private final int line;
         /** The actual content. */
         private final String body;
 
@@ -847,8 +881,9 @@ public final class TemplateEngine extends JxltEngine {
          * @param theType  the type
          * @param theBlock the content
          */
-        Block(BlockType theType, String theBlock) {
+        Block(BlockType theType, int theLine, String theBlock) {
             type = theType;
+            line = theLine;
             body = theBlock;
         }
 
@@ -898,7 +933,7 @@ public final class TemplateEngine extends JxltEngine {
          * @throws NullPointerException     if either the directive prefix or input is null
          * @throws IllegalArgumentException if the directive prefix is invalid
          */
-        public TemplateScript(String directive, Reader reader, String... parms) {
+        public TemplateScript(JexlInfo info, String directive, Reader reader, String... parms) {
             if (directive == null) {
                 throw new NullPointerException("null prefix");
             }
@@ -911,7 +946,7 @@ public final class TemplateEngine extends JxltEngine {
             if (reader == null) {
                 throw new NullPointerException("null input");
             }
-            Scope scope = new Scope(null, parms);
+            Scope scope = parms == null ? null : new Scope(null, parms);
             prefix = directive;
             List<Block> blocks = readTemplate(prefix, reader);
             List<TemplateExpression> uexprs = new ArrayList<TemplateExpression>();
@@ -933,13 +968,17 @@ public final class TemplateEngine extends JxltEngine {
                 }
             }
             // create the script
-            script = jexl.parse(null, strb.toString(), scope, false, false);
+            if (info == null) {
+                info = jexl.createInfo();
+            }
+            // allow lambda defining params
+            script = jexl.parse(info.at(0, 0), strb.toString(), scope, false, false).script();
             scope = script.getScope();
             // createExpression the exprs using the code frame for those appearing after the first block of code
             for (int b = 0; b < blocks.size(); ++b) {
                 Block block = blocks.get(b);
                 if (block.type == BlockType.VERBATIM) {
-                    uexprs.add(TemplateEngine.this.parseExpression(block.body, b > codeStart ? scope : null));
+                    uexprs.add(TemplateEngine.this.parseExpression(info.at(block.line, 0), block.body, b > codeStart ? scope : null));
                 }
             }
             source = blocks.toArray(new Block[blocks.size()]);
@@ -1035,7 +1074,7 @@ public final class TemplateEngine extends JxltEngine {
         /** The wrapped context. */
         private final JexlContext wrap;
         /** The array of TemplateEngine expressions. */
-        private final Expression[] exprs;
+        private final TemplateExpression[] exprs;
         /** The writer used to output. */
         private final Writer writer;
         /** The call frame. */
@@ -1049,7 +1088,7 @@ public final class TemplateEngine extends JxltEngine {
          * @param out         the output writer
          */
         protected TemplateContext(JexlContext jcontext, Scope.Frame jframe,
-                Expression[] expressions, Writer out) {
+                TemplateExpression[] expressions, Writer out) {
             wrap = jcontext;
             frame = jframe;
             exprs = expressions;
@@ -1112,14 +1151,14 @@ public final class TemplateEngine extends JxltEngine {
             if (e < 0 || e >= exprs.length) {
                 return;
             }
-            Expression expr = exprs[e];
+            TemplateExpression expr = exprs[e];
             if (expr.isDeferred()) {
                 expr = expr.prepare(wrap);
             }
             if (expr instanceof CompositeExpression) {
                 printComposite((CompositeExpression) expr);
             } else {
-                doPrint(expr.evaluate(this));
+                doPrint(expr.getInfo(), expr.evaluate(this));
             }
         }
 
@@ -1133,7 +1172,7 @@ public final class TemplateEngine extends JxltEngine {
             Object value;
             for (int e = 0; e < size; ++e) {
                 value = cexprs[e].evaluate(this);
-                doPrint(value);
+                doPrint(cexprs[e].getInfo(), value);
             }
         }
 
@@ -1144,7 +1183,7 @@ public final class TemplateEngine extends JxltEngine {
          * </p>
          * @param arg the argument to print out
          */
-        private void doPrint(Object arg) {
+        private void doPrint(JexlInfo info, Object arg) {
             try {
                 if (arg instanceof CharSequence) {
                     writer.write(arg.toString());
@@ -1159,9 +1198,9 @@ public final class TemplateEngine extends JxltEngine {
                     }
                 }
             } catch (java.io.IOException xio) {
-                throw createException("call print", null, xio);
+                throw createException(info, "call print", null, xio);
             } catch (java.lang.Exception xany) {
-                throw createException("invoke print", null, xany);
+                throw createException(info, "invoke print", null, xany);
             }
         }
     }
@@ -1245,6 +1284,7 @@ public final class TemplateEngine extends JxltEngine {
 
     /**
      * Reads lines of a template grouping them by typed blocks.
+     * @param info the source info
      * @param prefix the directive prefix
      * @param source the source reader
      * @return the list of blocks
@@ -1261,6 +1301,8 @@ public final class TemplateEngine extends JxltEngine {
         BlockType type = null;
         int prefixLen;
         Iterator<CharSequence> lines = readLines(reader);
+        int lineno = 0;
+        int start = 0;
         while (lines.hasNext()) {
             CharSequence line = lines.next();
             if (line == null) {
@@ -1275,15 +1317,17 @@ public final class TemplateEngine extends JxltEngine {
                     type = BlockType.VERBATIM;
                     strb.append(line.subSequence(0, line.length()));
                 }
+                start = lineno;
             } else if (type == BlockType.DIRECTIVE) {
                 // switch to verbatim if necessary
                 prefixLen = startsWith(line, prefix);
                 if (prefixLen < 0) {
-                    Block directive = new Block(BlockType.DIRECTIVE, strb.toString());
+                    Block directive = new Block(BlockType.DIRECTIVE, start, strb.toString());
                     strb.delete(0, Integer.MAX_VALUE);
                     blocks.add(directive);
                     type = BlockType.VERBATIM;
                     strb.append(line.subSequence(0, line.length()));
+                    start = lineno;
                 } else {
                     // still a directive
                     strb.append(line.subSequence(prefixLen, line.length()));
@@ -1292,19 +1336,21 @@ public final class TemplateEngine extends JxltEngine {
                 // switch to directive if necessary
                 prefixLen = startsWith(line, prefix);
                 if (prefixLen >= 0) {
-                    Block verbatim = new Block(BlockType.VERBATIM, strb.toString());
+                    Block verbatim = new Block(BlockType.VERBATIM, start, strb.toString());
                     strb.delete(0, Integer.MAX_VALUE);
                     blocks.add(verbatim);
                     type = BlockType.DIRECTIVE;
                     strb.append(line.subSequence(prefixLen, line.length()));
+                    start = lineno;
                 } else {
                     strb.append(line.subSequence(0, line.length()));
                 }
             }
+            lineno += 1;
         }
         // input may be null
         if (type != null && strb.length() > 0) {
-            Block block = new Block(type, strb.toString());
+            Block block = new Block(type, start, strb.toString());
             blocks.add(block);
         }
         blocks.trimToSize();
@@ -1312,17 +1358,8 @@ public final class TemplateEngine extends JxltEngine {
     }
 
     @Override
-    public TemplateScript createTemplate(String prefix, Reader source, String... parms) {
-        return new TemplateScript(prefix, source, parms);
+    public TemplateScript createTemplate(JexlInfo info, String prefix, Reader source, String... parms) {
+        return new TemplateScript(info, prefix, source, parms);
     }
 
-    @Override
-    public TemplateScript createTemplate(String source, String... parms) {
-        return new TemplateScript("$$", new StringReader(source), parms);
-    }
-
-    @Override
-    public TemplateScript createTemplate(String source) {
-        return new TemplateScript("$$", new StringReader(source), (String[]) null);
-    }
 }
\ No newline at end of file
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
index 0b1e1721..59895efe 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/AbstractExecutor.java
@@ -16,6 +16,7 @@
  */
 package org.apache.commons.jexl3.internal.introspection;
 
+import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.introspection.JexlPropertyGet;
 import org.apache.commons.jexl3.introspection.JexlPropertySet;
@@ -29,12 +30,7 @@ import org.apache.commons.jexl3.introspection.JexlPropertySet;
  */
 abstract class AbstractExecutor {
     /** A marker for invocation failures in tryInvoke. */
-    public static final Object TRY_FAILED = new Object() {
-        @Override
-        public String toString() {
-            return "tryExecute failed";
-        }
-    };
+    public static final Object TRY_FAILED = JexlEngine.TRY_FAILED;
 
     /**
      * A helper to initialize the marker methods (array.get, list.get, etc...).
@@ -191,7 +187,7 @@ abstract class AbstractExecutor {
      * @return true if tryExecute failed, false otherwise
      */
     public final boolean tryFailed(Object exec) {
-        return exec == TRY_FAILED;
+        return exec == JexlEngine.TRY_FAILED;
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java
index 744704a3..43353797 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ClassMap.java
@@ -34,7 +34,7 @@ import java.util.concurrent.ConcurrentMap;
 
 /**
  * A cache of introspection information for a specific class instance.
- * Keys objects by an agregation of the method name and the classes
+ * Keys objects by an aggregation of the method name and the classes
  * that make up the parameters.
  * <p>
  * Originally taken from the Velocity tree so we can be self-sufficient.
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java
index 6f121d04..23320b06 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/ConstructorMethod.java
@@ -35,8 +35,8 @@ public final class ConstructorMethod implements JexlMethod {
      * @param args constructor arguments
      * @return a {@link JexlMethod}
      */
-    public static ConstructorMethod discover(Introspector is, Object ctorHandle, Object[] args) {
-        String className = null;
+    public static ConstructorMethod discover(Introspector is, Object ctorHandle, Object... args) {
+        String className;
         Class<?> clazz = null;
         if (ctorHandle instanceof Class<?>) {
             clazz = (Class<?>) ctorHandle;
@@ -62,7 +62,7 @@ public final class ConstructorMethod implements JexlMethod {
     }
 
     @Override
-    public Object invoke(Object obj, Object[] params) throws Exception {
+    public Object invoke(Object obj, Object... params) throws Exception {
         Class<?> ctorClass = ctor.getDeclaringClass();
         boolean invoke = true;
         if (obj != null) {
@@ -79,7 +79,7 @@ public final class ConstructorMethod implements JexlMethod {
     }
 
     @Override
-    public Object tryInvoke(String name, Object obj, Object[] params) {
+    public Object tryInvoke(String name, Object obj, Object... params) {
         try {
             Class<?> ctorClass = ctor.getDeclaringClass();
             boolean invoke = true;
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java
index 5daf3b49..883ac817 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodExecutor.java
@@ -16,6 +16,7 @@
  */
 package org.apache.commons.jexl3.internal.introspection;
 
+import org.apache.commons.jexl3.JexlEngine;
 import java.lang.reflect.Array;
 import java.lang.reflect.InvocationTargetException;
 
@@ -72,7 +73,7 @@ public final class MethodExecutor extends AbstractExecutor.Method {
         if (method != null) {
             Class<?>[] formal = method.getParameterTypes();
             // if the last parameter is an array, the method is considered as vararg
-            if (formal != null && method.isVarArgs()) {
+            if (formal != null && MethodKey.isVarArgs(method)) {
                 vastart = formal.length - 1;
                 vaclass = formal[vastart].getComponentType();
             }
@@ -82,7 +83,7 @@ public final class MethodExecutor extends AbstractExecutor.Method {
     }
 
     @Override
-    public Object invoke(Object o, Object[] args) throws IllegalAccessException, InvocationTargetException  {
+    public Object invoke(Object o, Object... args) throws IllegalAccessException, InvocationTargetException  {
         if (vaClass != null) {
             args = handleVarArg(args);
         }
@@ -94,7 +95,7 @@ public final class MethodExecutor extends AbstractExecutor.Method {
     }
 
     @Override
-    public Object tryInvoke(String name, Object obj, Object[] args) {
+    public Object tryInvoke(String name, Object obj, Object... args) {
         MethodKey tkey = new MethodKey(name, args);
         // let's assume that invocation will fly if the declaring class is the
         // same and arguments have the same type
@@ -102,12 +103,12 @@ public final class MethodExecutor extends AbstractExecutor.Method {
             try {
                 return invoke(obj, args);
             } catch (InvocationTargetException xinvoke) {
-                return TRY_FAILED; // fail
+                return JexlEngine.TRY_FAILED; // fail
             } catch (IllegalAccessException xill) {
-                return TRY_FAILED;// fail
+                return JexlEngine.TRY_FAILED;// fail
             }
         }
-        return TRY_FAILED;
+        return JexlEngine.TRY_FAILED;
     }
 
 
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java
index e87fd56e..44e9ed0e 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java
@@ -49,6 +49,7 @@ public final class MethodKey {
     private static final int PRIMITIVE_SIZE = 13;
     /** The primitive type to class conversion map. */
     private static final Map<Class<?>, Class<?>> PRIMITIVE_TYPES;
+
     static {
         PRIMITIVE_TYPES = new HashMap<Class<?>, Class<?>>(PRIMITIVE_SIZE);
         PRIMITIVE_TYPES.put(Boolean.TYPE, Boolean.class);
@@ -215,6 +216,35 @@ public final class MethodKey {
         return builder.toString();
     }
 
+    /**
+     * Checks whether a method is accepts a variable number of arguments.
+     * <p>May be due to a subtle bug in some JVMs, if a varargs method is an override, depending on (may be) the
+     * class introspection order, the isVarargs flag on the method itself will be false.
+     * To circumvent the potential problem, fetch the method with the same signature from iniial method declaring class,
+     * - which will be different if overriden  -and get the varargs flag from it.
+     * @param method the method to check for varargs
+     * @return true if declared varargs, false otherwise
+     */
+    public static boolean isVarArgs(Method method) {
+        if (method == null) {
+            return false;
+        }
+        if (method.isVarArgs()) {
+            return true;
+        }
+        // if this is an override, was it actually declared as varargs?
+        Class<?> clazz = method.getDeclaringClass();
+        try {
+            Method m = clazz.getMethod(method.getName(), method.getParameterTypes());
+            if (m.isVarArgs()) {
+                return true;
+            }
+        } catch (NoSuchMethodException xignore) {
+            // this should not happen...
+        }
+        return false;
+    }
+
     /**
      * Gets the most specific method that is applicable to the parameters of this key.
      * @param methods a list of methods.
@@ -344,7 +374,7 @@ public final class MethodKey {
         }
 
         /* Check for identity or widening reference conversion */
-        if (formal.isAssignableFrom(actual) && (formal.isArray() == actual.isArray())) {
+        if (formal.isAssignableFrom(actual) && (actual != null && formal.isArray() == actual.isArray())) {
             return true;
         }
 
@@ -459,12 +489,8 @@ public final class MethodKey {
              * the end of the below loop, the list will contain exactly one method,
              * (the most specific method) otherwise we have ambiguity.
              */
-
             LinkedList<T> maximals = new LinkedList<T>();
-
-            for (Iterator<T> applicable = applicables.iterator();
-                    applicable.hasNext();) {
-                T app = applicable.next();
+            for (T app : applicables) {
                 Class<?>[] appArgs = getParameterTypes(app);
 
                 boolean lessSpecific = false;
@@ -477,19 +503,19 @@ public final class MethodKey {
                     switch (moreSpecific(appArgs, getParameterTypes(max))) {
                         case MORE_SPECIFIC:
                             /*
-                             * This method is more specific than the previously
-                             * known maximally specific, so remove the old maximum.
-                             */
+                            * This method is more specific than the previously
+                            * known maximally specific, so remove the old maximum.
+                            */
                             maximal.remove();
                             break;
 
                         case LESS_SPECIFIC:
                             /*
-                             * This method is less specific than some of the
-                             * currently known maximally specific methods, so we
-                             * won't add it into the set of maximally specific
-                             * methods
-                             */
+                            * This method is less specific than some of the
+                            * currently known maximally specific methods, so we
+                            * won't add it into the set of maximally specific
+                            * methods
+                            */
 
                             lessSpecific = true;
                             break;
@@ -578,11 +604,11 @@ public final class MethodKey {
 
         /**
          * Checks whether a parameter class is a primitive.
-         * @param c the parameter class
+         * @param c              the parameter class
          * @param possibleVararg true if this is the last parameter which can be a primitive array (vararg call)
          * @return true if primitive, false otherwise
          */
-        private boolean isPrimitive(Class<?> c,  boolean possibleVarArg) {
+        private boolean isPrimitive(Class<?> c, boolean possibleVarArg) {
             if (c != null) {
                 if (c.isPrimitive()) {
                     return true;
@@ -723,9 +749,10 @@ public final class MethodKey {
         protected Class<?>[] getParameterTypes(Method app) {
             return app.getParameterTypes();
         }
+
         @Override
         public boolean isVarArgs(Method app) {
-            return app.isVarArgs();
+            return MethodKey.isVarArgs(app);
         }
     };
     /**
@@ -736,6 +763,7 @@ public final class MethodKey {
         protected Class<?>[] getParameterTypes(Constructor<?> app) {
             return app.getParameterTypes();
         }
+
         @Override
         public boolean isVarArgs(Constructor<?> app) {
             return app.isVarArgs();
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/SandboxUberspect.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/SandboxUberspect.java
index b26e130a..04073004 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/SandboxUberspect.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/SandboxUberspect.java
@@ -16,12 +16,14 @@
  */
 package org.apache.commons.jexl3.internal.introspection;
 
-import java.util.Iterator;
+import org.apache.commons.jexl3.JexlArithmetic;
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.introspection.JexlPropertyGet;
 import org.apache.commons.jexl3.introspection.JexlPropertySet;
-import org.apache.commons.jexl3.introspection.JexlUberspect;
 import org.apache.commons.jexl3.introspection.JexlSandbox;
+import org.apache.commons.jexl3.introspection.JexlUberspect;
+
+import java.util.Iterator;
 
 /**
  * An uberspect that controls usage of properties, methods and contructors through a sandbox.
@@ -69,7 +71,7 @@ public final class SandboxUberspect implements JexlUberspect {
      * {@inheritDoc}
      */
     @Override
-    public JexlMethod getConstructor(Object ctorHandle, Object[] args) {
+    public JexlMethod getConstructor(Object ctorHandle, Object... args) {
         final String className;
         if (ctorHandle instanceof Class<?>) {
             Class<?> clazz = (Class<?>) ctorHandle;
@@ -89,9 +91,10 @@ public final class SandboxUberspect implements JexlUberspect {
      * {@inheritDoc}
      */
     @Override
-    public JexlMethod getMethod(Object obj, String method, Object[] args) {
+    public JexlMethod getMethod(Object obj, String method, Object... args) {
         if (obj != null && method != null) {
-            String actual = sandbox.execute(obj.getClass().getName(), method);
+            String objClassName = (obj instanceof Class) ? ((Class<?>)obj).getName() : obj.getClass().getName();
+            String actual = sandbox.execute(objClassName, method);
             if (actual != null) {
                 return uberspect.getMethod(obj, actual, args);
             }
@@ -135,4 +138,12 @@ public final class SandboxUberspect implements JexlUberspect {
     public Iterator<?> getIterator(Object obj) {
         return uberspect.getIterator(obj);
     }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic) {
+        return uberspect.getArithmetic(arithmetic);
+    }
 }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java b/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java
index eaad80e0..07237731 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java
@@ -16,6 +16,10 @@
  */
 package org.apache.commons.jexl3.internal.introspection;
 
+
+import org.apache.commons.jexl3.JexlArithmetic;
+import org.apache.commons.jexl3.JexlArithmetic.Operator;
+import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.introspection.JexlPropertyGet;
 import org.apache.commons.jexl3.introspection.JexlPropertySet;
@@ -26,10 +30,13 @@ import org.apache.log4j.Logger;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 
+import java.util.EnumSet;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.ConcurrentHashMap;
 
 import java.lang.ref.Reference;
 import java.lang.ref.SoftReference;
@@ -45,7 +52,7 @@ public class Uberspect implements JexlUberspect {
     /**
      * Publicly exposed special failure object returned by tryInvoke.
      */
-    public static final Object TRY_FAILED = AbstractExecutor.TRY_FAILED;
+    public static final Object TRY_FAILED = JexlEngine.TRY_FAILED;
     /** The logger to use for all warnings & errors. */
     protected final Logger rlog;
     /** The introspector version. */
@@ -54,6 +61,12 @@ public class Uberspect implements JexlUberspect {
     private volatile Reference<Introspector> ref;
     /** The class loader reference; used to recreate the Introspector when necessary. */
     private volatile Reference<ClassLoader> loader;
+    /**
+     * The map from arithmetic classes to overloaded operator sets.
+     * <p>This keeps track of which operator methods are overloaded per JexlArithemtic classes
+     * allowing a fail fast test during interpretation by avoiding seeking a method when there is none.
+     */
+    private final Map<Class<? extends JexlArithmetic>, Set<Operator>> operatorMap;
 
     /**
      * Creates a new Uberspect.
@@ -63,6 +76,7 @@ public class Uberspect implements JexlUberspect {
         rlog = runtimeLogger;
         ref = new SoftReference<Introspector>(null);
         loader = new SoftReference<ClassLoader>(getClass().getClassLoader());
+        operatorMap = new ConcurrentHashMap<Class<? extends JexlArithmetic>, Set<Operator>>();
         version = new AtomicInteger(0);
     }
 
@@ -101,6 +115,7 @@ public class Uberspect implements JexlUberspect {
                 ref = new SoftReference<Introspector>(intro);
             }
             loader = new SoftReference<ClassLoader>(intro.getLoader());
+            operatorMap.clear();
             version.incrementAndGet();
         }
     }
@@ -194,7 +209,7 @@ public class Uberspect implements JexlUberspect {
     }
 
     @Override
-    public JexlMethod getMethod(Object obj, String method, Object[] args) {
+    public JexlMethod getMethod(Object obj, String method, Object... args) {
         return MethodExecutor.discover(base(), obj, method, args);
     }
 
@@ -331,7 +346,7 @@ public class Uberspect implements JexlUberspect {
             // look for an iterator() method to support the JDK5 Iterable
             // interface or any user tools/DTOs that want to work in
             // foreach without implementing the Collection interface
-            JexlMethod it = getMethod(obj, "iterator", null);
+            JexlMethod it = getMethod(obj, "iterator", (Object[]) null);
             if (it != null && Iterator.class.isAssignableFrom(it.getReturnType())) {
                 return (Iterator<Object>) it.invoke(obj, (Object[]) null);
             }
@@ -344,9 +359,97 @@ public class Uberspect implements JexlUberspect {
     }
 
     @Override
-    public JexlMethod getConstructor(Object ctorHandle, Object[] args) {
+    public JexlMethod getConstructor(Object ctorHandle, Object... args) {
         return ConstructorMethod.discover(base(), ctorHandle, args);
     }
+
+    /**
+     * The concrete uberspect Arithmetic class.
+     */
+    protected class ArithmeticUberspect implements JexlArithmetic.Uberspect {
+        private final JexlArithmetic arithmetic;
+        private final EnumSet<Operator> overloads;
+
+        private ArithmeticUberspect(JexlArithmetic arithmetic, Set<Operator> overloads) {
+            this.arithmetic = arithmetic;
+            this.overloads = EnumSet.copyOf(overloads);
+        }
+
+        @Override
+        public JexlMethod getOperator(JexlArithmetic.Operator operator, Object arg) {
+            return overloads.contains(operator) && arg != null?
+                   getMethod(arithmetic, operator.getMethodName(), arg) : null;
+        }
+
+        @Override
+        public JexlMethod getOperator(JexlArithmetic.Operator operator, Object lhs, Object rhs) {
+            return overloads.contains(operator) && lhs != null && rhs != null?
+                   getMethod(arithmetic, operator.getMethodName(), lhs, rhs) : null;
+        }
+
+        @Override
+        public Object tryInvokeOperator(JexlArithmetic.Operator operator, Object lhs, Object rhs) {
+            JexlMethod method = getOperator(operator, lhs, rhs);
+            if (method != null) {
+                try {
+                    return method.invoke(arithmetic, lhs, rhs);
+                } catch(Exception xany) {
+                    throw new ArithmeticException(xany.getMessage());
+                }
+            }
+            return JexlEngine.TRY_FAILED;
+        }
+
+        @Override
+        public Object tryInvokeOperator(JexlArithmetic.Operator operator, Object arg) {
+            JexlMethod method = getOperator(operator, arg);
+            if (method != null) {
+                try {
+                    return method.invoke(arithmetic, arg);
+                } catch(Exception xany) {
+                    throw new ArithmeticException(xany.getMessage());
+                }
+            }
+            return JexlEngine.TRY_FAILED;
+        }
+    }
+
+    @Override
+    public JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic) {
+        JexlArithmetic.Uberspect jau = null;
+        if (arithmetic != null) {
+            Set<Operator> ops = operatorMap.get(arithmetic.getClass());
+            if (ops == null) {
+                ops = EnumSet.noneOf(Operator.class);
+                for (JexlArithmetic.Operator op : JexlArithmetic.Operator.values()) {
+                    Method[] methods = getMethods(arithmetic.getClass(), op.getMethodName());
+                    if (methods != null) {
+                        for (Method method : methods) {
+                            Class<?>[] parms = method.getParameterTypes();
+                            if (parms.length != op.getArity()) {
+                                continue;
+                            }
+                            boolean root = true;
+                            for (int p = 0; root && p < parms.length; ++p) {
+                                if (!Object.class.equals(parms[p])) {
+                                    root = false;
+                                }
+                            }
+                            if (!root) {
+                                ops.add(op);
+                            }
+                        }
+                    }
+                }
+                operatorMap.put(arithmetic.getClass(), ops);
+            }
+            if (!ops.isEmpty()) {
+                jau = new ArithmeticUberspect(arithmetic, ops);
+            }
+        }
+        return jau;
+    }
+
     /**
      * May be a way to extend/improve sandboxing by choosing actual method for resolution.
      **
diff --git a/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java b/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java
index 021f5b28..b93bccde 100644
--- a/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java
+++ b/src/main/java/org/apache/commons/jexl3/introspection/JexlMethod.java
@@ -36,7 +36,7 @@ public interface JexlMethod {
      * @return the result
      * @throws Exception on any error.
      */
-    Object invoke(Object obj, Object[] params) throws Exception;
+    Object invoke(Object obj, Object... params) throws Exception;
 
     /**
      * Attempts to reuse this JexlMethod, checking that it is compatible with
@@ -48,7 +48,7 @@ public interface JexlMethod {
      * @return the result of the method invocation that should be checked by tryFailed to determine if it succeeded
      * or failed.
      */
-    Object tryInvoke(String name, Object obj, Object[] params);
+    Object tryInvoke(String name, Object obj, Object... params);
 
     /**
      * Checks whether a tryInvoke return value indicates a failure or not.
diff --git a/src/main/java/org/apache/commons/jexl3/introspection/JexlUberspect.java b/src/main/java/org/apache/commons/jexl3/introspection/JexlUberspect.java
index 9c8b069d..b503249b 100644
--- a/src/main/java/org/apache/commons/jexl3/introspection/JexlUberspect.java
+++ b/src/main/java/org/apache/commons/jexl3/introspection/JexlUberspect.java
@@ -17,6 +17,7 @@
 
 package org.apache.commons.jexl3.introspection;
 
+import org.apache.commons.jexl3.JexlArithmetic;
 import java.util.Iterator;
 
 /**
@@ -46,7 +47,7 @@ public interface JexlUberspect {
      * @return a {@link JexlMethod}
      * @since 3.0
      */
-    JexlMethod getConstructor(Object ctorHandle, Object[] args);
+    JexlMethod getConstructor(Object ctorHandle, Object... args);
 
     /**
      * Returns a JexlMethod.
@@ -55,7 +56,7 @@ public interface JexlUberspect {
      * @param args method arguments
      * @return a {@link JexlMethod}
      */
-    JexlMethod getMethod(Object obj, String method, Object[] args);
+    JexlMethod getMethod(Object obj, String method, Object... args);
 
     /**
      * Property getter.
@@ -83,4 +84,12 @@ public interface JexlUberspect {
      */
     Iterator<?> getIterator(Object obj);
 
+    /**
+     * Gets an arithmetic operator resolver for a given arithmetic instance.
+     * @param arithmetic the arithmetic instance
+     * @return the arithmetic uberspect or null if no operator method were override
+     */
+    JexlArithmetic.Uberspect getArithmetic(JexlArithmetic arithmetic);
+
+
 }
\ No newline at end of file
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTStringLiteral.java b/src/main/java/org/apache/commons/jexl3/parser/ASTStringLiteral.java
index 58e9bb6b..383e6e31 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTStringLiteral.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTStringLiteral.java
@@ -17,6 +17,8 @@
 package org.apache.commons.jexl3.parser;
 
 public final class ASTStringLiteral extends JexlNode implements JexlNode.Constant<String> {
+    /** The actual literal value; the inherited 'value' member may host a cached getter. */
+    private String literal = null;
 
     ASTStringLiteral(int id) {
         super(id);
@@ -28,7 +30,7 @@ public final class ASTStringLiteral extends JexlNode implements JexlNode.Constan
 
     @Override
     public String toString() {
-        return value.toString();
+        return this.literal;
     }
 
     /**
@@ -37,7 +39,7 @@ public final class ASTStringLiteral extends JexlNode implements JexlNode.Constan
      */
     @Override
     public String getLiteral() {
-        return value.toString();
+        return this.literal;
     }
 
 
@@ -48,7 +50,7 @@ public final class ASTStringLiteral extends JexlNode implements JexlNode.Constan
     }
 
     void setLiteral(String literal) {
-        value = literal;
+        this.literal = literal;
     }
 
 
diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
index 39070241..c0c54c96 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
@@ -175,6 +175,10 @@ public abstract class JexlParser extends StringParser {
         }
     }
 
+    protected void throwParsingException(JexlNode node) {
+        throwParsingException(null, node);
+    }
+
     /**
      * Throws a parsing exception.
      * @param xclazz the class of exception
diff --git a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
index 36e1a033..19f10d57 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
@@ -38,6 +38,8 @@ import org.apache.commons.jexl3.internal.Scope;
 
 public final class Parser extends JexlParser
 {
+    private int loopCount = 0;
+
     public ASTJexlScript parse(JexlInfo info, String jexlSrc, Scope scope, boolean registers, boolean expr) {
         try {
             // If registers are allowed, the default parser state has to be REGISTERS.
@@ -99,6 +101,8 @@ PARSER_END(Parser)
     | < RETURN : "return" >
     | < FUNCTION : "function" >
     | < LAMBDA : "->" >
+    | < BREAK : "break" >
+    | < CONTINUE : "continue" >
 }
 
 <FOR_EACH_IN> TOKEN : /* foreach in */
@@ -233,6 +237,8 @@ void Statement() #void : {}
     | WhileStatement()
     | ExpressionStatement()
     | ReturnStatement()
+    | Continue()
+    | Break()
     | Var()
 }
 
@@ -256,7 +262,7 @@ void IfStatement() : {}
 
 void WhileStatement() : {}
 {
-    <WHILE> <LPAREN> Expression() <RPAREN> Statement()
+    <WHILE> <LPAREN> Expression() <RPAREN>  { loopCount += 1; } Statement() { loopCount -= 1; }
 }
 
 void ReturnStatement() : {}
@@ -264,11 +270,21 @@ void ReturnStatement() : {}
     <RETURN> Expression()
 }
 
+void Continue() #Continue : {}
+{
+    <CONTINUE> { if (loopCount == 0) { throwParsingException(jjtThis); } }
+}
+
+void Break() #Break : {}
+{
+    <BREAK> { if (loopCount == 0) { throwParsingException(jjtThis); } }
+}
+
 void ForeachStatement() : {}
 {
-    <FOR> <LPAREN> ForEachVar() <COLON>  Expression() <RPAREN> Statement()
+    <FOR> <LPAREN> ForEachVar() <COLON>  Expression() <RPAREN> { loopCount += 1; } Statement() { loopCount -= 1; }
 |
-    <FOREACH> <LPAREN> ForEachVar() <IN>  Expression() <RPAREN> Statement()
+    <FOREACH> <LPAREN> ForEachVar() <IN>  Expression() <RPAREN>  { loopCount += 1; } Statement() { loopCount -= 1; }
 }
 
 void ForEachVar() #Reference : {}
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java b/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java
index ed53b713..e3169930 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java
@@ -48,6 +48,10 @@ public abstract class ParserVisitor {
 
     protected abstract Object visit(ASTWhileStatement node, Object data);
 
+    protected abstract Object visit(ASTContinue node, Object data);
+    
+    protected abstract Object visit(ASTBreak node, Object data);
+
     protected abstract Object visit(ASTForeachStatement node, Object data);
 
     protected abstract Object visit(ASTReturnStatement node, Object data);
diff --git a/src/test/java/org/apache/commons/jexl3/ForEachTest.java b/src/test/java/org/apache/commons/jexl3/ForEachTest.java
index 8c9bac13..ee6ce666 100644
--- a/src/test/java/org/apache/commons/jexl3/ForEachTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ForEachTest.java
@@ -96,7 +96,7 @@ public class ForEachTest extends JexlTestCase {
     }
 
     public void testForEachWithBlock() throws Exception {
-        JexlScript exs0 = JEXL.createScript("for(in : list) { x = x + in; }");
+        JexlScript exs0 = JEXL.createScript("for(var in : list) { x = x + in; }");
         JexlScript exs1 = JEXL.createScript("foreach(item in list) { x = x + item; }");
         JexlScript []exs = { exs0, exs1 };
         JexlContext jc = new MapContext();
@@ -110,7 +110,7 @@ public class ForEachTest extends JexlTestCase {
     }
 
     public void testForEachWithListExpression() throws Exception {
-        JexlScript e = JEXL.createScript("for(item : list.keySet()) item");
+        JexlScript e = JEXL.createScript("for(var item : list.keySet()) item");
         JexlContext jc = new MapContext();
         Map<?, ?> map = System.getProperties();
         String lastKey = (String) new ArrayList<Object>(map.keySet()).get(System.getProperties().size() - 1);
@@ -120,7 +120,7 @@ public class ForEachTest extends JexlTestCase {
     }
 
     public void testForEachWithProperty() throws Exception {
-        JexlScript e = JEXL.createScript("for(item : list.cheeseList) item");
+        JexlScript e = JEXL.createScript("for(var item : list.cheeseList) item");
         JexlContext jc = new MapContext();
         jc.set("list", new Foo());
         Object o = e.execute(jc);
@@ -128,10 +128,50 @@ public class ForEachTest extends JexlTestCase {
     }
 
     public void testForEachWithIteratorMethod() throws Exception {
-        JexlScript e = JEXL.createScript("for(item : list.cheezy) item");
+        JexlScript e = JEXL.createScript("for(var item : list.cheezy) item");
         JexlContext jc = new MapContext();
         jc.set("list", new Foo());
         Object o = e.execute(jc);
         assertEquals("Result is not last evaluated expression", "brie", o);
     }
+
+    public void testForEachBreakMethod() throws Exception {
+        JexlScript e = JEXL.createScript(
+                "var rr = -1; for(var item : [1, 2, 3 ,4 ,5, 6]) { if (item == 3) { rr = item; break; }} rr"
+        );
+        JexlContext jc = new MapContext();
+        jc.set("list", new Foo());
+        Object o = e.execute(jc);
+        assertEquals("Result is not last evaluated expression", 3, o);
+    }
+
+    public void testForEachContinueMethod() throws Exception {
+        JexlScript e = JEXL.createScript(
+                "var rr = 0; for(var item : [1, 2, 3 ,4 ,5, 6]) { if (item <= 3) continue; rr = rr + item;}"
+        );
+        JexlContext jc = new MapContext();
+        jc.set("list", new Foo());
+        Object o = e.execute(jc);
+        assertEquals("Result is not last evaluated expression", 15, o);
+    }
+
+    public void testForEachContinueBroken() throws Exception {
+        try {
+            JexlScript e = JEXL.createScript("var rr = 0; continue;");
+            fail("continue is out of loop!");
+        } catch (JexlException.Parsing xparse) {
+            String str = xparse.detailedMessage();
+            assertTrue(str.contains("continue"));
+        }
+    }
+
+    public void testForEachBreakBroken() throws Exception {
+        try {
+            JexlScript e = JEXL.createScript("if (true) { break; }");
+            fail("break is out of loop!");
+        } catch (JexlException.Parsing xparse) {
+            String str = xparse.detailedMessage();
+            assertTrue(str.contains("break"));
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/java/org/apache/commons/jexl3/JXLTTest.java b/src/test/java/org/apache/commons/jexl3/JXLTTest.java
index ec6ffe3b..991c56df 100644
--- a/src/test/java/org/apache/commons/jexl3/JXLTTest.java
+++ b/src/test/java/org/apache/commons/jexl3/JXLTTest.java
@@ -27,6 +27,7 @@ import java.io.Writer;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
+import junit.framework.Assert;
 
 /**
  * Test cases for the UnifiedEL.
@@ -205,6 +206,42 @@ public class JXLTTest extends JexlTestCase {
         assertEquals(source, getSource(expr.toString()));
     }
 
+    public void testConstant2() throws Exception {
+        JexlContext none = null;
+        final String source = "${size({'map':123,'map2':456})}";
+        JxltEngine.Expression expr = JXLT.createExpression(source);
+        //assertTrue("prepare should return same expression", expr.prepare(none) == expr);
+        Object o = expr.evaluate(none);
+        assertTrue("expression should be immediate", expr.isImmediate());
+        assertEquals(2, o);
+
+        assertEquals(source, getSource(expr.toString()));
+    }
+
+    public void testConstant3() throws Exception {
+        JexlContext none = null;
+        final String source = "#{size({'map':123,'map2':456})}";
+        JxltEngine.Expression expr = JXLT.createExpression(source);
+        //assertTrue("prepare should return same expression", expr.prepare(none) == expr);
+        Object o = expr.evaluate(none);
+        assertTrue("expression should be deferred", expr.isDeferred());
+        assertEquals(2, o);
+
+        assertEquals(source, getSource(expr.toString()));
+    }
+
+    public void testConstant4() throws Exception {
+        JexlContext none = null;
+        final String source = "#{ ${size({'1':2,'2': 3})} }";
+        JxltEngine.Expression expr = JXLT.createExpression(source);
+        //assertTrue("prepare should return same expression", expr.prepare(none) == expr);
+        Object o = expr.evaluate(none);
+        assertTrue("expression should be deferred", expr.isDeferred());
+        assertEquals(2, o);
+
+        assertEquals(source, getSource(expr.toString()));
+    }
+
     public void testDeferred() throws Exception {
         JexlContext none = null;
         final String source = "#{'world'}";
@@ -340,6 +377,20 @@ public class JXLTTest extends JexlTestCase {
         String dstr = t.toString();
         assertNotNull(dstr);
     }
+    public void testTemplate10() throws Exception {
+        String source = "$$(x)->{ if(x) {\nx is ${x}\n$$ } else {\n${'no x'}\n$$ } }\n";
+        StringWriter strw;
+        String output;
+
+        JxltEngine.Template t = JXLT.createTemplate("$$", new StringReader(source), (String[])null);
+        String dstr = t.asString();
+        assertNotNull(dstr);
+
+        strw = new StringWriter();
+        t.evaluate(context, strw, 42);
+        output = strw.toString();
+        assertEquals("x is 42\n", output);
+    }
 
     public void testTemplate1() throws Exception {
         String source = "$$ if(x) {\nx is ${x}\n$$ } else {\n${'no x'}\n$$ }\n";
@@ -462,6 +513,29 @@ public class JXLTTest extends JexlTestCase {
         assertEquals(ctl, output);
     }
 
+    public void testReport1() throws Exception {
+        String rpt =
+                  "<report>\n"
+                + "this is ${x}\n"
+                + "${x + 1}\n"
+                + "${x + 2}\n"
+                + "${x + 3}\n"
+                + "</report>\n";
+        JxltEngine.Template t = JXLT.createTemplate("$$", new StringReader(rpt));
+        StringWriter strw = new StringWriter();
+        context.set("x", 42);
+        t.evaluate(context, strw, 42);
+        String output = strw.toString();
+        int count = 0;
+        for(int i = 0; i < output.length(); ++i) {
+            char c = output.charAt(i);
+            if ('\n' == c) {
+                count += 1;
+            }
+        }
+        assertEquals(6, count);
+    }
+
 
     public void testOneLiner() throws Exception {
         JxltEngine.Template t = JXLT.createTemplate("$$", new StringReader("fourty-two"));
