diff --git a/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml b/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
index 362ace8c1..47203a163 100644
--- a/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
+++ b/tika-core/src/main/resources/org/apache/tika/mime/tika-mimetypes.xml
@@ -3212,6 +3212,12 @@
     <glob pattern="*.warc"/>
   </mime-type>
 
+  <mime-type type="application/warc+gz">
+    <acronym>WARC</acronym>
+    <_comment>WARC</_comment>
+    <glob pattern="*.warc.gz"/>
+  </mime-type>
+
   <mime-type type="application/wasm">
     <acronym>Wasm</acronym>
     <_comment>Web Assembly</_comment>
diff --git a/tika-core/src/test/java/org/apache/tika/TikaTest.java b/tika-core/src/test/java/org/apache/tika/TikaTest.java
index a00d7b2b0..c20229b59 100644
--- a/tika-core/src/test/java/org/apache/tika/TikaTest.java
+++ b/tika-core/src/test/java/org/apache/tika/TikaTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.tika;
 
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
@@ -101,6 +102,33 @@ public abstract class TikaTest {
         assertFalse(haystack.contains(needle), needle + " unexpectedly found in:\n" + haystack);
     }
 
+    public static void assertMetadataListEquals(List<Metadata> metadataListA,
+                                          List<Metadata> metadataListB,
+                                    Set<String> fieldsToIgnore) {
+        assertEquals(metadataListA.size(), metadataListB.size(), "different sizes");
+        for (int i = 0; i < metadataListA.size(); i++) {
+            Metadata mA = metadataListA.get(i);
+            Metadata mB = metadataListB.get(i);
+            Set<String> mAFields = new HashSet<>();
+            for (String n : mA.names()) {
+                if (fieldsToIgnore.contains(n)) {
+                    continue;
+                }
+                mAFields.add(n);
+                assertArrayEquals(mA.getValues(n), mB.getValues(n), "problem with " + n +
+                        " in metadata index=" + i);
+            }
+            Set<String> mBFields = new HashSet<>();
+            for (String n : mB.names()) {
+                if (fieldsToIgnore.contains(n)) {
+                    continue;
+                }
+                mBFields.add(n);
+            }
+            assertEquals(mAFields, mBFields);
+        }
+    }
+
     /**
      * Test that in at least one item in metadataList, all keys and values
      * in minExpected are contained.
@@ -315,6 +343,14 @@ public abstract class TikaTest {
         return getRecursiveMetadata(filePath, new ParseContext());
     }
 
+    protected List<Metadata> getRecursiveMetadata(String filePath,
+                                                  BasicContentHandlerFactory.HANDLER_TYPE handlerType)
+            throws Exception {
+        return getRecursiveMetadata(filePath, TikaTest.AUTO_DETECT_PARSER, new Metadata(),
+                new ParseContext(), true,
+                handlerType);
+    }
+
     protected List<Metadata> getRecursiveMetadata(String filePath, Metadata metadata)
             throws Exception {
         return getRecursiveMetadata(filePath, metadata, new ParseContext());
@@ -340,6 +376,16 @@ public abstract class TikaTest {
         }
     }
 
+    protected List<Metadata> getRecursiveMetadata(String filePath, Parser wrapped,
+                                                  Metadata metadata, ParseContext context,
+                                                  boolean suppressException,
+                                                  BasicContentHandlerFactory.HANDLER_TYPE handlerType)
+            throws Exception {
+        try (InputStream is = getResourceAsStream("/test-documents/" + filePath)) {
+            return getRecursiveMetadata(is, wrapped, metadata, context, suppressException, handlerType);
+        }
+    }
+
     protected List<Metadata> getRecursiveMetadata(Path path, ParseContext context,
                                                   boolean suppressException) throws Exception {
         Metadata metadata = new Metadata();
@@ -406,6 +452,23 @@ public abstract class TikaTest {
         return handler.getMetadataList();
     }
 
+    protected List<Metadata> getRecursiveMetadata(InputStream is, Parser p, Metadata metadata,
+                                                  ParseContext context, boolean suppressException,
+                                                  BasicContentHandlerFactory.HANDLER_TYPE handlerType)
+            throws Exception {
+        RecursiveParserWrapper wrapper = new RecursiveParserWrapper(p);
+        RecursiveParserWrapperHandler handler = new RecursiveParserWrapperHandler(
+                new BasicContentHandlerFactory(handlerType, -1));
+        try {
+            wrapper.parse(is, handler, metadata, context);
+        } catch (Exception e) {
+            if (!suppressException) {
+                throw e;
+            }
+        }
+        return handler.getMetadataList();
+    }
+
     protected List<Metadata> getRecursiveMetadata(String filePath, ParseContext context)
             throws Exception {
         RecursiveParserWrapper wrapper = new RecursiveParserWrapper(AUTO_DETECT_PARSER);
