diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index 7d24e231..b74c1057 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -163,7 +163,7 @@ public class Mapper implements Closeable {
         }
         final JsonObjectGenerator objectGenerator = new JsonObjectGenerator(builderFactory);
         writeObject(object, objectGenerator, null,
-                isDeduplicateObjects(object.getClass()) ? new JsonPointerTracker(null, "/") : null);
+                isDedup(object.getClass()) ? new JsonPointerTracker(null, "/") : null);
         return objectGenerator.getResult();
     }
 
@@ -193,19 +193,7 @@ public class Mapper implements Closeable {
 
     public void writeObjectWithGenerator(final Object object, final JsonGenerator generator) {
         writeObject(object, generator, null,
-                isDeduplicateObjects(object.getClass()) ? new JsonPointerTracker(null, "/") : null);
-    }
-
-    private boolean isDeduplicateObjects(Class<?> rootType) {
-        Boolean dedup = config.isDeduplicateObjects();
-        if (dedup == null) {
-            Mappings.ClassMapping classMapping = mappings.findOrCreateClassMapping(rootType);
-            if (classMapping != null) {
-                dedup = classMapping.isDeduplicateObjects();
-            }
-        }
-
-        return dedup != null ? dedup : false;
+                isDedup(object.getClass()) ? new JsonPointerTracker(null, "/") : null);
     }
 
     public void writeObject(final Object object, final OutputStream stream) {
@@ -389,7 +377,17 @@ public class Mapper implements Closeable {
         if (clazz instanceof Class &&
                 JsonValue.class != clazz && JsonStructure.class != clazz &&
                 JsonObject.class != clazz && JsonArray.class != clazz) {
-            return isDeduplicateObjects((Class) clazz);
+            Boolean dedup = config.isDeduplicateObjects();
+            if (dedup == null) {
+                // TODO: never call it more than once per clazz, should be done after once ClassMapping is obtained, not here!
+                //       -> revisit org.apache.johnzon.mapper.Mappings.findOrCreateClassMapping (isPrimitive should drop)
+                //       -> revisit org.apache.johnzon.mapper.access.FieldAccessMode.isIgnored(java.lang.String, java.lang.Class<?>)
+                Mappings.ClassMapping classMapping = mappings.findOrCreateClassMapping(clazz);
+                if (classMapping != null) {
+                    dedup = classMapping.isDeduplicateObjects();
+                }
+            }
+            return dedup != null ? dedup : false;
         }
         return false;
     }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
index 37259d7b..23141be3 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
@@ -408,6 +408,9 @@ public class Mappings {
     }
 
     public ClassMapping findOrCreateClassMapping(final Type clazz) {
+        if (isPrimitive(clazz)) {
+            return null;
+        }
         return doFindOrCreateClassMapping(clazz, emptyMap(), false);
     }
 
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAccessMode.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAccessMode.java
index d87cd1b4..d954cdcc 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAccessMode.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAccessMode.java
@@ -23,6 +23,7 @@ import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.johnzon.mapper.Adapter;
@@ -41,7 +42,7 @@ public class FieldAccessMode extends BaseAccessMode {
         final Map<String, Reader> readers = new HashMap<String, Reader>();
         for (final Map.Entry<String, Field> f : fields(clazz, true).entrySet()) {
             final String key = f.getKey();
-            if (isIgnored(key) || Meta.getAnnotation(f.getValue(), JohnzonAny.class) != null) {
+            if (isIgnored(key, f.getValue().getDeclaringClass()) || Meta.getAnnotation(f.getValue(), JohnzonAny.class) != null) {
                 continue;
             }
 
@@ -56,7 +57,7 @@ public class FieldAccessMode extends BaseAccessMode {
         final Map<String, Writer> writers = new HashMap<String, Writer>();
         for (final Map.Entry<String, Field> f : fields(clazz, false).entrySet()) {
             final String key = f.getKey();
-            if (isIgnored(key)) {
+            if (isIgnored(key, f.getValue().getDeclaringClass())) {
                 continue;
             }
 
@@ -71,6 +72,10 @@ public class FieldAccessMode extends BaseAccessMode {
         return property != null ? property.value() : key;
     }
 
+    protected boolean isIgnored(final String key, final Class<?> clazz) {
+        return isIgnored(key) || (clazz.getName().startsWith("java.") && (Map.class.isAssignableFrom(clazz) || List.class.isAssignableFrom(clazz)));
+    }
+
     protected boolean isIgnored(final String key) {
         return key.contains("$");
     }
