diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index ebb54705..edbbf12a 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -69,6 +69,7 @@ New Features in 3.2:
 Bugs Fixed in 3.2:
 ==================
 
+* JEXL-290:      Safe navigation fails on chained method calls
 * JEXL-285:      For statement variable may seem unaffected by iteration
 * JEXL-282:      Pragmas with antish names are broken
 * JEXL-281:      MethodExecutor incorrectly tests for empty parameters list
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index 17a404a9..4937d5bc 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -1441,7 +1441,9 @@ public class Interpreter extends InterpreterBase {
                 object = data;
                 if (object == null) {
                     // no object, we fail
-                    return unsolvableMethod(methodNode, "<null>.<?>(...)");
+                    return node.isSafeLhs(jexl.safe)
+                        ? null
+                        : unsolvableMethod(methodNode, "<null>.<?>(...)");
                 }
             } else {
                 // edge case of antish var used as functor
@@ -1453,8 +1455,10 @@ public class Interpreter extends InterpreterBase {
         Object result = method;
         for (int a = 1; a < node.jjtGetNumChildren(); ++a) {
             if (result == null) {
-                // no method, we fail
-                return unsolvableMethod(methodNode, "<?>.<null>(...)");
+                // no method, we fail// variable unknown in context and not a local
+                return node.isSafeLhs(jexl.safe)
+                        ? null
+                        : unsolvableMethod(methodNode, "<?>.<null>(...)");
             }
             ASTArguments argNode = (ASTArguments) node.jjtGetChild(a);
             result = call(node, object, result, argNode);
@@ -1527,8 +1531,11 @@ public class Interpreter extends InterpreterBase {
             symbol = -1 - 1; // -2;
             methodName = null;
             cacheable = false;
+        } else if (!node.isSafeLhs(jexl.safe)) {
+            return unsolvableMethod(node, "?(...)");
         } else {
-            return unsolvableMethod(node, "?");
+            // safe lhs
+            return null;
         }
         
         // solving the call site
@@ -1629,7 +1636,9 @@ public class Interpreter extends InterpreterBase {
                 }
             }
             // we have either evaluated and returned or no method was found
-            return unsolvableMethod(node, methodName);
+            return node.isSafeLhs(jexl.safe)
+                    ? null
+                    : unsolvableMethod(node, methodName);
         } catch (JexlException xthru) {
             throw xthru;
         } catch (Exception xany) {
diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java b/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java
index 7033178e..66b74d75 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlNode.java
@@ -202,6 +202,13 @@ public abstract class JexlNode extends SimpleNode {
         if (this instanceof ASTReference) {
             return jjtGetChild(0).isSafeLhs(safe);
         }
+        if (this instanceof ASTMethodNode) {
+            if (this.jjtGetNumChildren() > 1
+                && this.jjtGetChild(0) instanceof ASTIdentifierAccess
+                && (((ASTIdentifierAccess) this.jjtGetChild(0)).isSafe() || safe)) {
+                return true;
+            }
+        }
         JexlNode parent = this.jjtGetParent();
         if (parent == null) {
             return false;
diff --git a/src/site/xdoc/changes.xml b/src/site/xdoc/changes.xml
index cbdf89d3..e38b4df5 100644
--- a/src/site/xdoc/changes.xml
+++ b/src/site/xdoc/changes.xml
@@ -26,6 +26,9 @@
     </properties>
     <body>
         <release version="3.2" date="unreleased">
+            <action dev="henrib" type="fix" issue="JEXL-290"> 
+                Safe navigation fails on chained method calls
+            </action>
             <action dev="henrib" type="fix" issue="JEXL-285"> 
                 For statement variable may seem unaffected by iteration
             </action>
diff --git a/src/test/java/org/apache/commons/jexl3/Issues200Test.java b/src/test/java/org/apache/commons/jexl3/Issues200Test.java
index 04d3b136..1e475189 100644
--- a/src/test/java/org/apache/commons/jexl3/Issues200Test.java
+++ b/src/test/java/org/apache/commons/jexl3/Issues200Test.java
@@ -722,7 +722,6 @@ public class Issues200Test extends JexlTestCase {
     
     @Test
     public void test279b() throws Exception {
-        final Log logger = null;//LogFactory.getLog(Issues200Test.class);
         Object result;
         JexlScript script;
         JexlContext ctxt = new Context279();
@@ -734,7 +733,7 @@ public class Issues200Test extends JexlTestCase {
         Assert.assertEquals("a", result);
         result = script.execute(ctxt, (Object) null);
         Assert.assertNull(result);
-    }
+    } 
     
     @Test
     public void test285() throws Exception {
@@ -795,4 +794,36 @@ public class Issues200Test extends JexlTestCase {
         List<String> ctl = Arrays.asList("g", "h", "i", "j", "k", "l");
         Assert.assertEquals(ctl, out);
     }
+        
+    @Test
+    public void test290() throws Exception {
+        Object result;
+        JexlScript script;
+        String[] srcs = new String[]{
+            "(x)->{ x.nothing().nothing() }",
+            "(x)->{ x.toString().nothing() }",
+            "(x)->{ x.nothing().nothing() }",
+            "(x)->{ (x.nothing()).nothing() }"
+        };
+        for (boolean safe : new boolean[]{true, false}) {
+            JexlEngine jexl = new JexlBuilder().safe(safe).strict(true).create();
+            for (String src : srcs) {
+                script = jexl.createScript(src);
+                try {
+                    result = script.execute(null, "abc");
+                    if (!safe) {
+                        Assert.fail("should have failed: " + src);
+                    } else {
+                        Assert.assertNull("non-null result ?!", result);
+                    }
+                } catch (JexlException.Method xmethod) {
+                    if (safe) {
+                        Assert.fail(src + ", should not have thrown " + xmethod);
+                    } else {
+                        Assert.assertTrue(src + ": " + xmethod.toString(), xmethod.toString().contains("nothing"));
+                    }
+                } 
+            }
+        }
+    }
 }
