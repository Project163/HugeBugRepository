diff --git a/src/java/org/apache/commons/dbcp/AbandonedTrace.java b/src/java/org/apache/commons/dbcp/AbandonedTrace.java
index ea9c3ab1..4d36b65c 100644
--- a/src/java/org/apache/commons/dbcp/AbandonedTrace.java
+++ b/src/java/org/apache/commons/dbcp/AbandonedTrace.java
@@ -40,7 +40,7 @@ public class AbandonedTrace {
     /** A stack trace of the code that created me (if in debug mode) */
     private volatile Exception createdBy;
     /** A list of objects created by children of this object */
-    private final List trace = new ArrayList();
+    private final List traceList = new ArrayList();
     /** Last time this connection was used */
     private volatile long lastUsed = 0;
 
@@ -146,8 +146,8 @@ public class AbandonedTrace {
      * @param trace AbandonedTrace object to add
      */
     protected void addTrace(AbandonedTrace trace) {
-        synchronized (this.trace) {
-            this.trace.add(trace);
+        synchronized (this.traceList) {
+            this.traceList.add(trace);
         }
         setLastUsed();
     }
@@ -157,8 +157,8 @@ public class AbandonedTrace {
      * object.
      */
     protected void clearTrace() {
-        synchronized(this.trace) {
-            this.trace.clear();
+        synchronized(this.traceList) {
+            this.traceList.clear();
         }
     }
 
@@ -168,8 +168,8 @@ public class AbandonedTrace {
      * @return List of objects
      */
     protected List getTrace() {
-        synchronized (this.trace) {
-            return new ArrayList(trace);
+        synchronized (this.traceList) {
+            return new ArrayList(traceList);
         }
     }
 
@@ -181,8 +181,8 @@ public class AbandonedTrace {
         if (createdBy != null && config != null) {
             createdBy.printStackTrace(config.getLogWriter());
         }
-        synchronized(this.trace) {
-            Iterator it = this.trace.iterator();
+        synchronized(this.traceList) {
+            Iterator it = this.traceList.iterator();
             while (it.hasNext()) {
                 AbandonedTrace at = (AbandonedTrace)it.next();
                 at.printStackTrace();
@@ -196,8 +196,8 @@ public class AbandonedTrace {
      * @param trace AbandonedTrace object to remove
      */
     protected void removeTrace(AbandonedTrace trace) {
-        synchronized(this.trace) {
-            this.trace.remove(trace);
+        synchronized(this.traceList) {
+            this.traceList.remove(trace);
         }
     }
 
diff --git a/src/java/org/apache/commons/dbcp/BasicDataSource.java b/src/java/org/apache/commons/dbcp/BasicDataSource.java
index 6649b5d4..1aae3370 100644
--- a/src/java/org/apache/commons/dbcp/BasicDataSource.java
+++ b/src/java/org/apache/commons/dbcp/BasicDataSource.java
@@ -1048,15 +1048,15 @@ public class BasicDataSource implements DataSource {
     /**
      * <strong>BasicDataSource does NOT support this method. </strong>
      *
-     * @param username Database user on whose behalf the Connection
+     * @param user Database user on whose behalf the Connection
      *   is being made
-     * @param password The database user's password
+     * @param pass The database user's password
      *
      * @throws UnsupportedOperationException
      * @throws SQLException if a database access error occurs
      * @return nothing - always throws UnsupportedOperationException
      */
-    public Connection getConnection(String username, String password) throws SQLException {
+    public Connection getConnection(String user, String pass) throws SQLException {
         // This method isn't supported by the PoolingDataSource returned by
         // the createDataSource
         throw new UnsupportedOperationException("Not supported by BasicDataSource");
@@ -1523,11 +1523,11 @@ public class BasicDataSource implements DataSource {
      * 
      * @param driverConnectionFactory JDBC connection factory
      * @param statementPoolFactory statement pool factory (null if statement pooling is turned off)
-     * @param abandonedConfig abandoned connection tracking configuration (null if no tracking)
+     * @param configuration abandoned connection tracking configuration (null if no tracking)
      * @throws SQLException if an error occurs creating the PoolableConnectionFactory
      */
     protected void createPoolableConnectionFactory(ConnectionFactory driverConnectionFactory,
-            KeyedObjectPoolFactory statementPoolFactory, AbandonedConfig abandonedConfig) throws SQLException {
+            KeyedObjectPoolFactory statementPoolFactory, AbandonedConfig configuration) throws SQLException {
         PoolableConnectionFactory connectionFactory = null;
         try {
             connectionFactory =
@@ -1541,7 +1541,7 @@ public class BasicDataSource implements DataSource {
                                               defaultAutoCommit,
                                               defaultTransactionIsolation,
                                               defaultCatalog,
-                                              abandonedConfig);
+                                              configuration);
             validateConnectionFactory(connectionFactory);
         } catch (RuntimeException e) {
             throw e;
diff --git a/src/java/org/apache/commons/dbcp/PoolingDataSource.java b/src/java/org/apache/commons/dbcp/PoolingDataSource.java
index 9f46b5aa..656c1092 100644
--- a/src/java/org/apache/commons/dbcp/PoolingDataSource.java
+++ b/src/java/org/apache/commons/dbcp/PoolingDataSource.java
@@ -275,16 +275,16 @@ public class PoolingDataSource implements DataSource {
                 return true;
             }
             // Use superclass accessor to skip access test
-            Connection delegate = super.getInnermostDelegate();
-            if (delegate == null) {
+            Connection conn = super.getInnermostDelegate();
+            if (conn == null) {
                 return false;
             }
             if (obj instanceof DelegatingConnection) {    
                 DelegatingConnection c = (DelegatingConnection) obj;
-                return c.innermostDelegateEquals(delegate);
+                return c.innermostDelegateEquals(conn);
             }
             else {
-                return delegate.equals(obj);
+                return conn.equals(obj);
             }
         }
 
diff --git a/src/java/org/apache/commons/dbcp/cpdsadapter/DriverAdapterCPDS.java b/src/java/org/apache/commons/dbcp/cpdsadapter/DriverAdapterCPDS.java
index 64455d72..e525c983 100644
--- a/src/java/org/apache/commons/dbcp/cpdsadapter/DriverAdapterCPDS.java
+++ b/src/java/org/apache/commons/dbcp/cpdsadapter/DriverAdapterCPDS.java
@@ -152,9 +152,11 @@ public class DriverAdapterCPDS
                      
     /**
      * Attempt to establish a database connection.
+     * @param username name to be used for the connection
+     * @param pass password to be used fur the connection
      */
     public PooledConnection getPooledConnection(String username, 
-                                                String password)
+                                                String pass)
             throws SQLException {
         getConnectionCalled = true;
         /*
@@ -195,13 +197,13 @@ public class DriverAdapterCPDS
             PooledConnectionImpl pci = null;
             if (connectionProperties != null) {
                 connectionProperties.put("user", username);
-                connectionProperties.put("password", password);
+                connectionProperties.put("password", pass);
                 pci = new PooledConnectionImpl(
                         DriverManager.getConnection(getUrl(), connectionProperties), 
                         stmtPool);
             } else {
                 pci = new PooledConnectionImpl(
-                        DriverManager.getConnection(getUrl(), username, password), 
+                        DriverManager.getConnection(getUrl(), username, pass), 
                         stmtPool);
             }
             pci.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
@@ -216,7 +218,7 @@ public class DriverAdapterCPDS
                         stmtPool);
             } else {
                 pci = new PooledConnectionImpl(
-                        DriverManager.getConnection(getUrl(), username, password), 
+                        DriverManager.getConnection(getUrl(), username, pass), 
                         stmtPool);
             }
             pci.setAccessToUnderlyingConnectionAllowed(isAccessToUnderlyingConnectionAllowed());
diff --git a/src/java/org/apache/commons/dbcp/datasources/InstanceKeyDataSource.java b/src/java/org/apache/commons/dbcp/datasources/InstanceKeyDataSource.java
index 05b1b6b0..b4f50b67 100644
--- a/src/java/org/apache/commons/dbcp/datasources/InstanceKeyDataSource.java
+++ b/src/java/org/apache/commons/dbcp/datasources/InstanceKeyDataSource.java
@@ -97,7 +97,7 @@ public abstract class InstanceKeyDataSource
 
     private boolean getConnectionCalled = false;
 
-    private ConnectionPoolDataSource cpds = null;
+    private ConnectionPoolDataSource dataSource = null;
     /** DataSource Name used to find the ConnectionPoolDataSource */
     private String dataSourceName = null;
     private boolean defaultAutoCommit = false;
@@ -175,7 +175,7 @@ public abstract class InstanceKeyDataSource
      * @return value of connectionPoolDataSource.
      */
     public ConnectionPoolDataSource getConnectionPoolDataSource() {
-        return cpds;
+        return dataSource;
     }
     
     /**
@@ -190,12 +190,12 @@ public abstract class InstanceKeyDataSource
             throw new IllegalStateException(
                 "Cannot set the DataSource, if JNDI is used.");
         }
-        if (cpds != null) 
+        if (dataSource != null) 
         {
             throw new IllegalStateException(
                 "The CPDS has already been set. It cannot be altered.");
         }
-        cpds = v;
+        dataSource = v;
         instanceKey = InstanceKeyObjectFactory.registerNewInstance(this);
     }
 
@@ -219,7 +219,7 @@ public abstract class InstanceKeyDataSource
      */
     public void setDataSourceName(String v) {
         assertInitializationAllowed();
-        if (cpds != null) {
+        if (dataSource != null) {
             throw new IllegalStateException(
                 "Cannot set the JNDI name for the DataSource, if already " +
                 "set using setConnectionPoolDataSource.");
@@ -741,7 +741,7 @@ public abstract class InstanceKeyDataSource
         testCPDS(String username, String password)
         throws javax.naming.NamingException, SQLException {
         // The source of physical db connections
-        ConnectionPoolDataSource cpds = this.cpds;
+        ConnectionPoolDataSource cpds = this.dataSource;
         if (cpds == null) {            
             Context ctx = null;
             if (jndiEnvironment == null) {
diff --git a/src/java/org/apache/commons/dbcp/managed/LocalXAConnectionFactory.java b/src/java/org/apache/commons/dbcp/managed/LocalXAConnectionFactory.java
index 7aacd130..b8ed0e87 100644
--- a/src/java/org/apache/commons/dbcp/managed/LocalXAConnectionFactory.java
+++ b/src/java/org/apache/commons/dbcp/managed/LocalXAConnectionFactory.java
@@ -84,7 +84,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
      */
     protected static class LocalXAResource implements XAResource {
         private final Connection connection;
-        private Xid xid;
+        private Xid currentXid;
         private boolean originalAutoCommit;
 
         public LocalXAResource(Connection localTransaction) {
@@ -97,7 +97,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
          * @return the current xid of the transaction branch associated with this XAResource.
          */
         public synchronized Xid getXid() {
-            return xid;
+            return currentXid;
         }
 
         /**
@@ -115,7 +115,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                 // first time in this transaction
 
                 // make sure we aren't already in another tx
-                if (this.xid != null) {
+                if (this.currentXid != null) {
                     throw new XAException("Already enlisted in another transaction with xid " + xid);
                 }
 
@@ -134,10 +134,10 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                     throw (XAException) new XAException("Count not turn off auto commit for a XA transaction").initCause(e);
                 }
 
-                this.xid = xid;
+                this.currentXid = xid;
             } else if (flag == XAResource.TMRESUME) {
-                if (xid != this.xid) {
-                    throw new XAException("Attempting to resume in different transaction: expected " + this.xid + ", but was " + xid);
+                if (xid != this.currentXid) {
+                    throw new XAException("Attempting to resume in different transaction: expected " + this.currentXid + ", but was " + xid);
                 }
             } else {
                 throw new XAException("Unknown start flag " + flag);
@@ -153,7 +153,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
          */
         public synchronized void end(Xid xid, int flag) throws XAException {
             if (xid == null) throw new NullPointerException("xid is null");
-            if (!this.xid.equals(xid)) throw new XAException("Invalid Xid: expected " + this.xid + ", but was " + xid);
+            if (!this.currentXid.equals(xid)) throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
 
             // This notification tells us that the application server is done using this
             // connection for the time being.  The connection is still associated with an
@@ -198,7 +198,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
          */
         public synchronized void commit(Xid xid, boolean flag) throws XAException {
             if (xid == null) throw new NullPointerException("xid is null");
-            if (!this.xid.equals(xid)) throw new XAException("Invalid Xid: expected " + this.xid + ", but was " + xid);
+            if (!this.currentXid.equals(xid)) throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
 
             try {
                 // make sure the connection isn't already closed
@@ -217,7 +217,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                     connection.setAutoCommit(originalAutoCommit);
                 } catch (SQLException e) {
                 }
-                this.xid = null;
+                this.currentXid = null;
             }
         }
 
@@ -229,7 +229,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
          */
         public synchronized void rollback(Xid xid) throws XAException {
             if (xid == null) throw new NullPointerException("xid is null");
-            if (!this.xid.equals(xid)) throw new XAException("Invalid Xid: expected " + this.xid + ", but was " + xid);
+            if (!this.currentXid.equals(xid)) throw new XAException("Invalid Xid: expected " + this.currentXid + ", but was " + xid);
 
             try {
                 connection.rollback();
@@ -240,7 +240,7 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
                     connection.setAutoCommit(originalAutoCommit);
                 } catch (SQLException e) {
                 }
-                this.xid = null;
+                this.currentXid = null;
             }
         }
 
@@ -260,8 +260,8 @@ public class LocalXAConnectionFactory implements XAConnectionFactory {
          * @param xid the id of the transaction to forget
          */
         public synchronized void forget(Xid xid) {
-            if (xid != null && this.xid.equals(xid)) {
-                this.xid = null;
+            if (xid != null && this.currentXid.equals(xid)) {
+                this.currentXid = null;
             }
         }
 
diff --git a/src/java/org/apache/commons/dbcp/managed/TransactionContext.java b/src/java/org/apache/commons/dbcp/managed/TransactionContext.java
index d871cda2..c247c627 100644
--- a/src/java/org/apache/commons/dbcp/managed/TransactionContext.java
+++ b/src/java/org/apache/commons/dbcp/managed/TransactionContext.java
@@ -38,7 +38,7 @@ import java.lang.ref.WeakReference;
  */
 public class TransactionContext {
     private final TransactionRegistry transactionRegistry;
-    private final WeakReference transaction;
+    private final WeakReference transactionRef;
     private Connection sharedConnection;
 
     /**
@@ -54,7 +54,7 @@ public class TransactionContext {
         if (transactionRegistry == null) throw new NullPointerException("transactionRegistry is null");
         if (transaction == null) throw new NullPointerException("transaction is null");
         this.transactionRegistry = transactionRegistry;
-        this.transaction = new WeakReference(transaction);
+        this.transactionRef = new WeakReference(transaction);
     }
 
     /**
@@ -127,7 +127,7 @@ public class TransactionContext {
      */
     public boolean isActive() throws SQLException {
         try {
-            Transaction transaction = (Transaction) this.transaction.get();
+            Transaction transaction = (Transaction) this.transactionRef.get();
             if (transaction == null) {
                 return false;
             }
@@ -139,7 +139,7 @@ public class TransactionContext {
     }
 
     private Transaction getTransaction() throws SQLException {
-        Transaction transaction = (Transaction) this.transaction.get();
+        Transaction transaction = (Transaction) this.transactionRef.get();
         if (transaction == null) {
             throw new SQLException("Unable to enlist connection because the transaction has been garbage collected");
         }
diff --git a/xdocs/changes.xml b/xdocs/changes.xml
index e63831c0..1f95f790 100644
--- a/xdocs/changes.xml
+++ b/xdocs/changes.xml
@@ -49,6 +49,9 @@ The <action> type attribute can be add,update,fix,remove.
      changes below since 1.2.2 applies to both the 1.3 and 1.4 release.  Other than
      the one issue related to adding JDBC 4 support (DBCP-191), all bug fixes
      or new features are included in both DBCP 1.3 and 1.4 ">
+      <action dev="sebb" type="update" issue="DBCP-314" due-to="Sebastian Bazley">
+        Renamed variables with duplicate names in different scopes.
+      </action>
       <action dev="psteitz" type="update" issue="DBCP-312" due-to="Glen Mazza">
         Clarified javadoc for BasicDataSource close() method.
       </action>
