diff --git a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JohnzonBuilder.java b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JohnzonBuilder.java
index dc72159f..3c78f3ee 100644
--- a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JohnzonBuilder.java
+++ b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JohnzonBuilder.java
@@ -65,6 +65,7 @@ import java.util.SimpleTimeZone;
 import java.util.TimeZone;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 
@@ -72,6 +73,7 @@ import javax.json.JsonBuilderFactory;
 import javax.json.bind.Jsonb;
 import javax.json.bind.JsonbBuilder;
 import javax.json.bind.JsonbConfig;
+import javax.json.bind.JsonbException;
 import javax.json.bind.adapter.JsonbAdapter;
 import javax.json.bind.config.BinaryDataStrategy;
 import javax.json.bind.config.PropertyNamingStrategy;
@@ -422,7 +424,6 @@ public class JohnzonBuilder implements JsonbBuilder {
     private Map<AdapterKey, Adapter<?, ?>> createJava8Converters(final MapperBuilder builder) {
         final Map<AdapterKey, Adapter<?, ?>> converters = new HashMap<>();
 
-        final TimeZone timeZoneUTC = TimeZone.getTimeZone("UTC");
         final ZoneId zoneIDUTC = ZoneId.of("UTC");
 
         // built-in converters not in mapper
@@ -451,42 +452,45 @@ public class JohnzonBuilder implements JsonbBuilder {
         converters.put(new AdapterKey(Date.class, String.class), new ConverterAdapter<>(new Converter<Date>() {
             @Override
             public String toString(final Date instance) {
-                return LocalDateTime.ofInstant(instance.toInstant(), zoneIDUTC).toString();
+                return ZonedDateTime.ofInstant(instance.toInstant(), zoneIDUTC)
+                        .format(DateTimeFormatter.ISO_ZONED_DATE_TIME);
             }
 
             @Override
             public Date fromString(final String text) {
-                return Date.from(LocalDateTime.parse(text).toInstant(ZoneOffset.UTC));
+                try {
+                    return Date.from(ZonedDateTime.parse(text).toInstant());
+                } catch (final DateTimeParseException dte) {
+                    return Date.from(LocalDateTime.parse(text).toInstant(ZoneOffset.UTC));
+                }
             }
         }));
         converters.put(new AdapterKey(Calendar.class, String.class), new ConverterAdapter<>(new Converter<Calendar>() {
             @Override
             public String toString(final Calendar instance) {
-                return ZonedDateTime.ofInstant(instance.toInstant(), instance.getTimeZone().toZoneId()).toString();
+                return toStringCalendar(instance);
             }
 
             @Override
             public Calendar fromString(final String text) {
-                final ZonedDateTime zonedDateTime = ZonedDateTime.parse(text);
-                final Calendar calendar = Calendar.getInstance();
-                calendar.setTimeZone(TimeZone.getTimeZone(zonedDateTime.getZone()));
-                calendar.setTimeInMillis(zonedDateTime.toInstant().toEpochMilli());
-                return calendar;
+                return fromCalendar(text, zdt -> {
+                    final Calendar instance = Calendar.getInstance();
+                    instance.clear();
+                    instance.setTimeZone(TimeZone.getTimeZone(zdt.getZone()));
+                    instance.setTimeInMillis(zdt.toInstant().toEpochMilli());
+                    return instance;
+                });
             }
         }));
         converters.put(new AdapterKey(GregorianCalendar.class, String.class), new ConverterAdapter<>(new Converter<GregorianCalendar>() {
             @Override
             public String toString(final GregorianCalendar instance) {
-                return instance.toZonedDateTime().toString();
+                return toStringCalendar(instance);
             }
 
             @Override
             public GregorianCalendar fromString(final String text) {
-                final ZonedDateTime zonedDateTime = ZonedDateTime.parse(text);
-                final GregorianCalendar calendar = new GregorianCalendar();
-                calendar.setTimeZone(TimeZone.getTimeZone(zonedDateTime.getZone()));
-                calendar.setTimeInMillis(zonedDateTime.toInstant().toEpochMilli());
-                return calendar;
+                return fromCalendar(text, GregorianCalendar::from);
             }
         }));
         converters.put(new AdapterKey(TimeZone.class, String.class), new ConverterAdapter<>(new Converter<TimeZone>() {
@@ -497,7 +501,7 @@ public class JohnzonBuilder implements JsonbBuilder {
 
             @Override
             public TimeZone fromString(final String text) {
-                logIfDeprecatedTimeZone(text);
+                checkForDeprecatedTimeZone(text);
                 return TimeZone.getTimeZone(text);
             }
         }));
@@ -531,7 +535,7 @@ public class JohnzonBuilder implements JsonbBuilder {
 
             @Override
             public SimpleTimeZone fromString(final String text) {
-                logIfDeprecatedTimeZone(text);
+                checkForDeprecatedTimeZone(text);
                 final TimeZone timeZone = TimeZone.getTimeZone(text);
                 return new SimpleTimeZone(timeZone.getRawOffset(), timeZone.getID());
             }
@@ -620,6 +624,45 @@ public class JohnzonBuilder implements JsonbBuilder {
         return converters;
     }
 
+    private String toStringCalendar(final Calendar instance) {
+        if (!hasTime(instance)) { // spec
+            final LocalDate localDate = LocalDate.of(
+                    instance.get(Calendar.YEAR),
+                    instance.get(Calendar.MONTH) + 1,
+                    instance.get(Calendar.DAY_OF_MONTH));
+            return localDate.toString() +
+                    (instance.getTimeZone() != null ?
+                            instance.getTimeZone().toZoneId().getRules()
+                                    .getOffset(Instant.ofEpochMilli(TimeUnit.DAYS.toMillis(localDate.toEpochDay()))) : "");
+        }
+        return ZonedDateTime.ofInstant(instance.toInstant(), instance.getTimeZone().toZoneId())
+                .format(DateTimeFormatter.ISO_DATE_TIME);
+    }
+
+    private boolean hasTime(final Calendar instance) {
+        if (!instance.isSet(Calendar.HOUR_OF_DAY)) {
+            return false;
+        }
+        return instance.get(Calendar.HOUR_OF_DAY) != 0 ||
+            (instance.isSet(Calendar.MINUTE)&& instance.get(Calendar.MINUTE) != 0) ||
+            (instance.isSet(Calendar.SECOND) && instance.get(Calendar.SECOND) != 0);
+    }
+
+    private <T extends Calendar> T fromCalendar(final String text, final Function<ZonedDateTime, T> calendarSupplier) {
+        switch (text.length()) {
+            case 10: {
+                final ZonedDateTime date = LocalDate.parse(text)
+                        .atTime(0, 0, 0)
+                        .atZone(ZoneId.of("UTC"));
+                return calendarSupplier.apply(date);
+            }
+            default:
+                final ZonedDateTime zonedDateTime = ZonedDateTime.parse(text);
+                return calendarSupplier.apply(zonedDateTime);
+        }
+    }
+
+
     private void addDateFormatConfigConverters(final Map<AdapterKey, Adapter<?, ?>> converters, final ZoneId zoneIDUTC) {
         // config, override defaults
         config.getProperty(JsonbConfig.DATE_FORMAT).map(String.class::cast).ifPresent(dateFormat -> {
@@ -769,12 +812,12 @@ public class JohnzonBuilder implements JsonbBuilder {
         return ZonedDateTime.of(year, month, day, hour, minute, second, millisecond, zone);
     }
 
-    private static void logIfDeprecatedTimeZone(final String text) {
-        /* TODO: get the list, UTC is clearly not deprecated but uses 3 letters
-        if (text.length() == 3) { // don't fail but log it
-            Logger.getLogger(JohnzonBuilder.class.getName()).severe("Deprecated timezone: " + text);
+    private static void checkForDeprecatedTimeZone(final String text) {
+        switch (text) {
+            case "CST": // really for TCK, this sucks for end users so we don't fail for all deprecated zones
+                throw new JsonbException("Deprecated timezone: '" + text + '"');
+            default:
         }
-         */
     }
 
     private Map<String, ?> generatorConfig() {
diff --git a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java
index 0fa1ef0e..d9e3e5e0 100644
--- a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java
+++ b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/JsonbAccessMode.java
@@ -657,8 +657,8 @@ public class JsonbAccessMode implements AccessMode, Closeable {
 
     private boolean isReversedAdapter(final Class<?> payloadType, final Class<?> aClass, final Adapter<?, ?> instance) {
         if (TypeAwareAdapter.class.isInstance(instance)) {
-            return !payloadType.isAssignableFrom(Class.class.cast(TypeAwareAdapter.class.cast(instance).getTo()))
-                    && payloadType.isAssignableFrom(Class.class.cast(TypeAwareAdapter.class.cast(instance).getFrom()));
+            return payloadType.isAssignableFrom(Class.class.cast(TypeAwareAdapter.class.cast(instance).getTo()))
+                    && !payloadType.isAssignableFrom(Class.class.cast(TypeAwareAdapter.class.cast(instance).getFrom()));
         }
         final Type[] genericInterfaces = aClass.getGenericInterfaces();
         return Stream.of(genericInterfaces).filter(ParameterizedType.class::isInstance)
diff --git a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/converter/JsonbDateConverter.java b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/converter/JsonbDateConverter.java
index e800495d..72c63e0e 100644
--- a/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/converter/JsonbDateConverter.java
+++ b/johnzon-jsonb/src/main/java/org/apache/johnzon/jsonb/converter/JsonbDateConverter.java
@@ -24,6 +24,7 @@ import java.time.LocalDateTime;
 import java.time.ZoneId;
 import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
 import java.util.Date;
 
 import javax.json.bind.annotation.JsonbDateFormat;
@@ -32,7 +33,9 @@ public class JsonbDateConverter extends JsonbDateConverterBase<Date> {
     private static final ZoneId UTC = ZoneId.of("UTC");
 
     // TODO: cheap impl to avoid to rely on exceptions, better can be to parse format
+    //       -> rewrite it
     private volatile boolean hasTimezone = true;
+    private volatile boolean isIso = false;
 
     public JsonbDateConverter(final JsonbDateFormat dateFormat) {
         super(dateFormat);
@@ -54,43 +57,71 @@ public class JsonbDateConverter extends JsonbDateConverterBase<Date> {
 
     private Date fromStringWithFormatter(final String text) {
         final boolean hasTimezone = this.hasTimezone;
+        final boolean isIso = this.isIso;
         try {
+            if (isIso) {
+                return fromIso(text);
+            }
             if (hasTimezone) {
                 return fromZonedDateTime(text);
             }
             return fromLocalDateTime(text);
         } catch (final DateTimeException dte) {
             this.hasTimezone = !hasTimezone;
-            if (hasTimezone) {
-                return fromLocalDateTime(text);
+            try {
+                if (hasTimezone) {
+                    return fromLocalDateTime(text);
+                }
+                return fromZonedDateTime(text);
+            } catch (final DateTimeException dte2) {
+                final Date from = fromIso(text);
+                this.isIso = !isIso;
+                return from;
             }
-            return fromZonedDateTime(text);
         }
     }
 
+    private Date fromIso(final String text) {
+        return Date.from(ZonedDateTime.parse(text, DateTimeFormatter.ISO_ZONED_DATE_TIME).toInstant());
+    }
+
     private String toStringWithFormatter(final Date instance) {
         final boolean hasTimezone = this.hasTimezone;
+        final boolean isIso = this.isIso;
         final Instant instant = Instant.ofEpochMilli(instance.getTime());
         try {
+            if (isIso) {
+                return toIsoString(instant);
+            }
             if (hasTimezone) {
                 return toStringFromZonedDateTime(instant);
             }
             return toStringFromLocalDateTime(instant);
         } catch (final DateTimeException dte) {
-            this.hasTimezone = !hasTimezone;
-            if (hasTimezone) {
-                return toStringFromLocalDateTime(instant);
+            try {
+                this.hasTimezone = !hasTimezone;
+                if (hasTimezone) {
+                    return toStringFromLocalDateTime(instant);
+                }
+                return toStringFromZonedDateTime(instant);
+            } catch (final DateTimeException dte2) {
+                this.isIso = !isIso;
+                return toIsoString(instant);
             }
-            return toStringFromZonedDateTime(instant);
         }
     }
 
+    private String toIsoString(final Instant instant) {
+        return DateTimeFormatter.ISO_ZONED_DATE_TIME.format(ZonedDateTime.ofInstant(instant, UTC));
+    }
+
     private Date fromLocalDateTime(final String text) {
         return Date.from(LocalDateTime.parse(text, formatter).toInstant(ZoneOffset.UTC));
     }
 
     private Date fromZonedDateTime(final String text) {
-        return Date.from(ZonedDateTime.parse(text, formatter).toInstant());
+        final ZonedDateTime zonedDateTime = ZonedDateTime.parse(text, formatter);
+        return Date.from(zonedDateTime.toInstant());
     }
 
     private String toStringFromLocalDateTime(final Instant instant) {
diff --git a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/ClassConverterTest.java b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/ClassConverterTest.java
index 940404a5..cb8c45fe 100644
--- a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/ClassConverterTest.java
+++ b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/ClassConverterTest.java
@@ -93,16 +93,16 @@ public class ClassConverterTest {
         }
     }
 
-    public static class MyAdapter implements JsonbAdapter<Switch, Whole> {
+    public static class MyAdapter implements JsonbAdapter<Whole, Switch> {
         @Override
-        public Whole adaptToJson(final Switch obj) throws Exception {
+        public Whole adaptFromJson(final Switch obj) throws Exception {
             final Whole whole = new Whole();
             whole.name = obj.name2.replace("<", "").replace(">", "");
             return whole;
         }
 
         @Override
-        public Switch adaptFromJson(final Whole obj) throws Exception {
+        public Switch adaptToJson(final Whole obj) throws Exception {
             final Switch aSwitch = new Switch();
             aSwitch.name2 = '>' + obj.name + '<';
             return aSwitch;
diff --git a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/DateFormatTest.java b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/DateFormatTest.java
index 14709ea6..81d077e2 100644
--- a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/DateFormatTest.java
+++ b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/DateFormatTest.java
@@ -19,6 +19,7 @@
 package org.apache.johnzon.jsonb;
 
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
 
 import java.text.SimpleDateFormat;
 import java.time.ZoneId;
@@ -26,7 +27,10 @@ import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
 import java.util.Calendar;
 import java.util.Date;
+import java.util.GregorianCalendar;
 import java.util.Locale;
+import java.util.TimeZone;
+import java.util.stream.Stream;
 
 import javax.json.bind.Jsonb;
 import javax.json.bind.JsonbBuilder;
@@ -43,6 +47,46 @@ public class DateFormatTest {
     @Rule
     public final JsonbRule jsonb = new JsonbRule();
 
+    @Test
+    public void dateRoundTrip() {
+        final Date date = new Date(1);
+        final String str = jsonb.toJson(date);
+        final Date date1 = jsonb.fromJson(str, Date.class);
+        final String dateReser = jsonb.toJson(date1);
+        final Date reDeser = jsonb.fromJson(dateReser, Date.class);
+        assertEquals(date.getTime(), reDeser.getTime());
+    }
+
+    @Test
+    public void calendarCanBeParsed() {
+        Stream.of("{\"instance\":\"1970-01-01T00:00+01:00[Europe/Paris]\"}",
+                "{\"instance\":\"1970-01-01\"}")
+                .forEach(json -> {
+                    final Calendar cal = jsonb.fromJson(json, CalendarHolder.class).getInstance();
+                    assertNotNull(cal);
+                    // todo: assert value, fixed bug was that it was not even parseable
+                });
+    }
+
+    @Test
+    public void dateCanBeParsed() {
+        final Date date = new Date(70, 0, 1);
+
+        final GregorianCalendar calendar = new GregorianCalendar();
+        calendar.setTime(date);
+        calendar.setTimeZone(TimeZone.getTimeZone("UTC"));
+        final DateTimeFormatter dtf = DateTimeFormatter.ISO_DATE_TIME;
+        final String value = dtf.format(calendar.toZonedDateTime()).replace("]", "\\]")
+                .replace("[", "\\[").replace("+", "\\+");
+
+        Stream.of("{\"instance\":\"" + value + "\"}")
+                .forEach(json -> {
+                    final Date unmarshalled = jsonb.fromJson(json, DateHolder.class).getInstance();
+                    assertNotNull(unmarshalled);
+                    // todo: assert value, fixed bug was that it was not even parseable
+                });
+    }
+
     @Test
     public void dateFormatMethods() {
         final Date instance = new Date(0);
@@ -86,6 +130,20 @@ public class DateFormatTest {
         }
     }
 
+    public static class CalendarHolder implements Holder<Calendar> {
+        private Calendar instance;
+
+        @Override
+        public Calendar getInstance() {
+            return instance;
+        }
+
+        @Override
+        public void setInstance(final Calendar instance) {
+            this.instance = instance;
+        }
+    }
+
     public static class DateHolder implements Holder<Date> {
         private Date instance;
 
@@ -97,7 +155,7 @@ public class DateFormatTest {
 
         @Override
         @JsonbDateFormat(value = "E DD MMM yyyy HH:mm:ss z", locale = "de")
-        public void setInstance(Date instance) {
+        public void setInstance(final Date instance) {
             this.instance = instance;
         }
     }
diff --git a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JsonbTypesTest.java b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JsonbTypesTest.java
index d6d7817e..dcf77cd5 100644
--- a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JsonbTypesTest.java
+++ b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/JsonbTypesTest.java
@@ -63,31 +63,15 @@ public class JsonbTypesTest {
         final LocalDate localDate = LocalDate.of(2015, 1, 1);
         final LocalTime localTime = LocalTime.of(1, 2, 3);
         final LocalDateTime localDateTime = LocalDateTime.of(2015, 1, 1, 1, 1);
-        final String dateTime = localDateTime.toString();
-        final ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.of("UTC"));
-        final String expected = "{" +
-            "\"calendar\":\"" + zonedDateTime + "\"," +
-            "\"date\":\"" + localDateTime + "\"," +
-            "\"duration\":\"PT30S\"," +
-            "\"gregorianCalendar\":\"" + zonedDateTime.toString() + "\"," +
-            "\"instant\":\"" + Instant.ofEpochMilli(TimeUnit.DAYS.toMillis(localDate.toEpochDay())) + "\"," +
-            "\"localDate\":\"" + localDate + "\"," +
-            "\"localDateTime\":\"" + dateTime + "\"," +
-            "\"localTime\":\"" + localTime + "\"," +
-            "\"offsetDateTime\":\"" + OffsetDateTime.of(localDateTime, ZoneOffset.UTC) + "\"," +
-            "\"offsetTime\":\"" + OffsetTime.of(localDateTime.toLocalTime(), ZoneOffset.UTC) + "\"," +
-            "\"optionalDouble\":3.4," +
-            "\"optionalInt\":1," +
-            "\"optionalLong\":2," +
-            "\"optionalString\":\"yes\"," +
-            "\"period\":\"P1M10D\"," +
-            "\"simpleTimeZone\":\"UTC\"," +
-            "\"timeZone\":\"UTC\"," +
-            "\"uri\":\"http://localhost:2222\"," +
-            "\"url\":\"http://localhost:1111\"," +
-            "\"zoneId\":\"UTC\"," +
-            "\"zoneOffset\":\"Z\"" +
-            "}";
+        final String expected = "{\"calendar\":\"2015-01-01T01:01:00Z[UTC]\",\"date\":\"2015-01-01T01:01:00Z[UTC]\"," +
+                "\"duration\":\"PT30S\",\"gregorianCalendar\":\"2015-01-01T01:01:00Z[UTC]\"," +
+                "\"instant\":\"2015-01-01T00:00:00Z\",\"localDate\":\"2015-01-01\"," +
+                "\"localDateTime\":\"2015-01-01T01:01\",\"localTime\":\"01:02:03\"," +
+                "\"offsetDateTime\":\"2015-01-01T01:01Z\",\"offsetTime\":\"01:01Z\"," +
+                "\"optionalDouble\":3.4,\"optionalInt\":1,\"optionalLong\":2,\"optionalString\":\"yes\"," +
+                "\"period\":\"P1M10D\",\"simpleTimeZone\":\"UTC\",\"timeZone\":\"UTC\"," +
+                "\"uri\":\"http://localhost:2222\",\"url\":\"http://localhost:1111\"," +
+                "\"zoneId\":\"UTC\",\"zoneOffset\":\"Z\"}";
 
         final Jsonb jsonb = newJsonb();
 
diff --git a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/OverrideDefaultAdaptersTest.java b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/OverrideDefaultAdaptersTest.java
index 99b2f227..6b5c1b8b 100644
--- a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/OverrideDefaultAdaptersTest.java
+++ b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/OverrideDefaultAdaptersTest.java
@@ -40,12 +40,12 @@ public class OverrideDefaultAdaptersTest {
     @Test
     public void run() throws Exception {
         final ZonedDateTime zdtString = ZonedDateTime.ofInstant(new Date(0).toInstant(), ZoneId.of("UTC"));
-        try (final Jsonb jsonb = JsonbBuilder.create(new JsonbConfig().withAdapters(new ZonedDateTimeFallbackDateAdapter()))) {
-            final DateHolder holder = jsonb.fromJson("{\"date\":\"" + zdtString + "\"}", DateHolder.class);
+        try (final Jsonb jsonb = JsonbBuilder.create(new JsonbConfig().withAdapters(new ZonedDateTimeWithFallback()))) {
+            final DateHolder holder = jsonb.fromJson("{\"date\":\"" + zdtString + "i\"}", DateHolder.class);
             assertEquals(new Date(0).getTime(), holder.date.getTime());
         }
         try (final Jsonb jsonb = JsonbBuilder.create()) {
-            jsonb.fromJson("{\"date\":\"" + zdtString + "\"}", DateHolder.class);
+            jsonb.fromJson("{\"date\":\"" + zdtString + "i\"}", DateHolder.class);
             fail();
         } catch (final JsonbException je) {
             // expected
@@ -57,7 +57,7 @@ public class OverrideDefaultAdaptersTest {
         public Date date;
     }
 
-    public static class ZonedDateTimeFallbackDateAdapter implements JsonbAdapter<Date, String> {
+    public static class ZonedDateTimeWithFallback implements JsonbAdapter<Date, String> {
         private static final ZoneId UTC = ZoneId.of("UTC");
 
         @Override
@@ -65,7 +65,7 @@ public class OverrideDefaultAdaptersTest {
             try {
                 return Date.from(LocalDateTime.parse(obj).toInstant(ZoneOffset.UTC));
             } catch (final DateTimeParseException pe) {
-                return new Date(ZonedDateTime.parse(obj).toInstant().toEpochMilli());
+                return new Date(ZonedDateTime.parse(obj.substring(0, obj.length() - 1)).toInstant().toEpochMilli());
             }
         }
 
diff --git a/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/TimezoneTest.java b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/TimezoneTest.java
new file mode 100644
index 00000000..c5020342
--- /dev/null
+++ b/johnzon-jsonb/src/test/java/org/apache/johnzon/jsonb/TimezoneTest.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.jsonb;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.TimeZone;
+
+import org.apache.johnzon.jsonb.test.JsonbRule;
+import org.junit.Rule;
+import org.junit.Test;
+
+public class TimezoneTest {
+    @Rule
+    public final JsonbRule jsonb = new JsonbRule();
+
+    @Test
+    public void exceptionOnDeprecated() {
+        final TimeZoneHolder holder = new TimeZoneHolder();
+        holder.instance = TimeZone.getTimeZone("CST");
+        jsonb.toJson(holder);
+    }
+
+    @Test
+    public void valid() {
+        final TimeZoneHolder holder = new TimeZoneHolder();
+        holder.instance = TimeZone.getTimeZone("UTC");
+        assertEquals("{\"instance\":\"UTC\"}", jsonb.toJson(holder));
+    }
+
+    public static class TimeZoneHolder {
+        public TimeZone instance;
+    }
+}
