diff --git a/pom.xml b/pom.xml
index e7a7bdb..b07ac06 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,12 +24,11 @@
         <groupId>org.apache.sling</groupId>
         <artifactId>sling</artifactId>
         <version>7</version>
-        <relativePath>../../../parent/pom.xml</relativePath>
     </parent>
 
     <artifactId>org.apache.sling.commons.classloader</artifactId>
     <packaging>bundle</packaging>
-    <version>1.0.1-SNAPSHOT</version>
+    <version>1.1.0-SNAPSHOT</version>
 
     <name>Apache Sling Dynamic Class Loader Support</name>
     <description>
@@ -58,7 +57,7 @@
                             org.apache.sling.commons.classloader.impl.Activator
                         </Bundle-Activator>
                         <Export-Package>
-                            org.apache.sling.commons.classloader;version=${pom.version}
+                            org.apache.sling.commons.classloader;version=1.1.0
                         </Export-Package>
                         <Private-Package>
                             org.apache.sling.commons.classloader.impl
diff --git a/src/main/java/org/apache/sling/commons/classloader/DynamicClassLoaderProvider.java b/src/main/java/org/apache/sling/commons/classloader/DynamicClassLoaderProvider.java
index cdac258..bf7985e 100644
--- a/src/main/java/org/apache/sling/commons/classloader/DynamicClassLoaderProvider.java
+++ b/src/main/java/org/apache/sling/commons/classloader/DynamicClassLoaderProvider.java
@@ -33,8 +33,22 @@ public interface DynamicClassLoaderProvider {
      * as one of its parent class loaders. This ensures that the returned
      * class loader has access to all dynamically loaded classes that
      * are not part of this class loader.
+     * When the class loader is not needed anymore, it is released by
+     * calling the {@link #release(ClassLoader)} method.
      * @param parent The parent class loader for this dynamic class loader.
      * @return The class loader.
+     * @see #release(ClassLoader)
      */
     ClassLoader getClassLoader(ClassLoader parent);
+
+    /**
+     * Release the provided class loader.
+     * When the class loader is not needed anymore, e.g. when the dynamic class
+     * loader is shutdown, it is released with this method.
+     * The implementation can use this hook to free any allocated resources etc.
+     * @param classLoader The class loader.
+     * @see #getClassLoader(ClassLoader)
+     * @since 2.0
+     */
+    void release(ClassLoader classLoader);
 }
diff --git a/src/main/java/org/apache/sling/commons/classloader/impl/DynamicClassLoaderManagerImpl.java b/src/main/java/org/apache/sling/commons/classloader/impl/DynamicClassLoaderManagerImpl.java
index 6dabeb1..6c15c19 100644
--- a/src/main/java/org/apache/sling/commons/classloader/impl/DynamicClassLoaderManagerImpl.java
+++ b/src/main/java/org/apache/sling/commons/classloader/impl/DynamicClassLoaderManagerImpl.java
@@ -43,6 +43,9 @@ public class DynamicClassLoaderManagerImpl
     /** The cached chain of class loaders. */
     private ClassLoader[] cache;
 
+    /** The cached chain of dynamic class loader providers. */
+    private DynamicClassLoaderProvider[] providerCache;
+
     /** Is this still active? */
     private volatile boolean active = true;
 
@@ -62,6 +65,7 @@ public class DynamicClassLoaderManagerImpl
         super(ctx, DynamicClassLoaderProvider.class.getName(), null);
         this.pckAdminCL = new PackageAdminClassLoader(pckAdmin, parent, factory);
         this.cache = new ClassLoader[] {this.pckAdminCL};
+        this.providerCache = new DynamicClassLoaderProvider[0];
         this.open();
         this.facade = new ClassLoaderFacade(this);
     }
@@ -70,10 +74,13 @@ public class DynamicClassLoaderManagerImpl
         if ( this.trackingCount < this.getTrackingCount() ) {
             final ServiceReference[] refs = this.getServiceReferences();
             final ClassLoader[] loaders;
+            final DynamicClassLoaderProvider[] providers;
             if ( refs == null || refs.length == 0 ) {
                 loaders = new ClassLoader[] {this.pckAdminCL};
+                providers = new DynamicClassLoaderProvider[0];
             } else {
                 loaders = new ClassLoader[1 + refs.length];
+                providers = new DynamicClassLoaderProvider[refs.length];
                 Arrays.sort(refs, ServiceReferenceComparator.INSTANCE);
                 int index = 0;
                 for(final ServiceReference ref : refs) {
@@ -85,18 +92,38 @@ public class DynamicClassLoaderManagerImpl
                 }
                 loaders[index] = this.pckAdminCL;
             }
+            // release old class loaders
+            this.releaseProviders();
+
             // and now use new array
             this.cache = loaders;
+            this.providerCache = providers;
             this.trackingCount = this.getTrackingCount();
         }
     }
 
+    /**
+     * Free used class loader providers
+     */
+    private void releaseProviders() {
+        if ( this.providerCache != null ) {
+            for(int i=0; i<this.providerCache.length; i++) {
+                if ( this.cache[i] != null ) {
+                    this.providerCache[i].release(this.cache[i]);
+                }
+            }
+        }
+    }
+
     /**
      * Deactivate this service.
      */
     public void deactivate() {
+        this.releaseProviders();
         this.active = false;
         this.close();
+        this.providerCache = null;
+        this.cache = null;
     }
 
     /**
