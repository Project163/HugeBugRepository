diff --git a/RELEASE-NOTES.txt b/RELEASE-NOTES.txt
index ef675164..5de131f8 100644
--- a/RELEASE-NOTES.txt
+++ b/RELEASE-NOTES.txt
@@ -37,6 +37,7 @@ New Features in 3.3.1:
 
 Bugs Fixed in 3.3.1:
 ===================
+* JEXL-416:     Null-valued pragma throws NPE in 3.3
 * JEXL-415:     Incorrect template eval result
 * JEXL-414:     SoftCache may suffer from race conditions
 * JEXL-412:     Ambiguous syntax between namespace function call and map object definition.
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 48c734d0..d058c067 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -42,6 +42,9 @@
                 Allow 'trailing commas' or ellipsis while defining array, map and set literals
             </action>
             <!-- FIX -->
+            <action dev="henrib" type="fix" issue="JEXL-416" due-to="William Price" >
+                Null-valued pragma throws NPE in 3.3
+            </action>
             <action dev="henrib" type="fix" issue="JEXL-415" due-to="Xu Pengcheng" >
                 Incorrect template eval result.
             </action>
diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
index fa5f127f..5b6f1147 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
@@ -562,16 +562,20 @@ public abstract class JexlParser extends StringParser {
             }
         }
         // merge new value into a set created on the fly if key is already mapped
-        pragmas.merge(key, value, (previous, newValue)->{
-            if (previous instanceof Set<?>) {
-                ((Set<Object>) previous).add(newValue);
-                return previous;
-            }
-            final Set<Object> values = new LinkedHashSet<>();
-            values.add(previous);
-            values.add(newValue);
-            return values;
-        });
+        if (value == null) {
+            pragmas.putIfAbsent(key, null);
+        } else {
+            pragmas.merge(key, value, (previous, newValue) -> {
+                if (previous instanceof Set<?>) {
+                    ((Set<Object>) previous).add(newValue);
+                    return previous;
+                }
+                final Set<Object> values = new LinkedHashSet<>();
+                values.add(previous);
+                values.add(newValue);
+                return values;
+            });
+        }
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/jexl3/PragmaTest.java b/src/test/java/org/apache/commons/jexl3/PragmaTest.java
index a80ed537..95ba9068 100644
--- a/src/test/java/org/apache/commons/jexl3/PragmaTest.java
+++ b/src/test/java/org/apache/commons/jexl3/PragmaTest.java
@@ -376,4 +376,13 @@ public class PragmaTest extends JexlTestCase {
         final Object result = script.execute(jc);
         Assert.assertEquals(42, result);
     }
+
+    @Test
+    public void testIssue416() {
+        final JexlEngine jexl = new JexlBuilder().create();
+        JexlScript script = jexl.createScript("#pragma myNull null\n");
+        Map<String, Object> pragmas = script.getPragmas();
+        Assert.assertTrue("pragma key present?", pragmas.containsKey("myNull"));
+        Assert.assertNull("expected null value", pragmas.get("myNull"));
+    }
 }
