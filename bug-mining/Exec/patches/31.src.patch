diff --git a/src/main/java/org/apache/commons/exec/DefaultExecutor.java b/src/main/java/org/apache/commons/exec/DefaultExecutor.java
index 4cb82431..d1b4435e 100644
--- a/src/main/java/org/apache/commons/exec/DefaultExecutor.java
+++ b/src/main/java/org/apache/commons/exec/DefaultExecutor.java
@@ -16,13 +16,13 @@
  */
 package org.apache.commons.exec;
 
+import org.apache.commons.exec.launcher.CommandLauncher;
+import org.apache.commons.exec.launcher.CommandLauncherFactory;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.Map;
 
-import org.apache.commons.exec.launcher.CommandLauncher;
-import org.apache.commons.exec.launcher.CommandLauncherFactory;
-
 /**
  * The default class to start a subprocess. The implementation
  * allows to
@@ -331,9 +331,18 @@ public class DefaultExecutor implements Executor {
     private int executeInternal(final CommandLine command, final Map<String, String> environment,
             final File dir, final ExecuteStreamHandler streams) throws IOException {
 
-        setExceptionCaught(null);
+        final Process process;
+        exceptionCaught = null;
 
-        final Process process = this.launch(command, environment, dir);
+        try {
+            process = this.launch(command, environment, dir);
+        }
+        catch(final IOException e) {
+            if(watchdog != null) {
+                watchdog.failedToStart(e);
+            }
+            throw e;
+        }
 
         try {
             streams.setProcessInputStream(process.getOutputStream());
@@ -341,6 +350,9 @@ public class DefaultExecutor implements Executor {
             streams.setProcessErrorStream(process.getErrorStream());
         } catch (final IOException e) {
             process.destroy();
+            if(watchdog != null) {
+                watchdog.failedToStart(e);
+            }
             throw e;
         }
 
diff --git a/src/main/java/org/apache/commons/exec/ExecuteWatchdog.java b/src/main/java/org/apache/commons/exec/ExecuteWatchdog.java
index d2e8fe74..437efcc6 100644
--- a/src/main/java/org/apache/commons/exec/ExecuteWatchdog.java
+++ b/src/main/java/org/apache/commons/exec/ExecuteWatchdog.java
@@ -121,6 +121,18 @@ public class ExecuteWatchdog implements TimeoutObserver {
         }
     }
 
+    /**
+     * Notification that starting the process failed.
+     *
+     * @param e the offending exception
+     *
+     */
+    public synchronized void failedToStart(Exception e) {
+        this.processStarted = true;
+        this.caught = e;
+        this.notifyAll();
+    }
+
     /**
      * Stops the watcher. It will notify all threads possibly waiting on this
      * object.
@@ -220,11 +232,12 @@ public class ExecuteWatchdog implements TimeoutObserver {
     }
 
     /**
-     * Ensures that the process is started, so we do not race with asynch execution.
-     * The caller of this method must be holding the lock on this
+     * Ensures that the process is started or not already terminated
+     * so we do not race with asynch executionor hang forever. The
+     * caller of this method must be holding the lock on this
      */
     private void ensureStarted() {
-        while (!processStarted) {
+        while (!processStarted && caught == null) {
             try {
                 this.wait();
             } catch (final InterruptedException e) {
diff --git a/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java b/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java
index 9a5af671..d4e8b8d3 100644
--- a/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java
+++ b/src/test/java/org/apache/commons/exec/DefaultExecutorTest.java
@@ -18,30 +18,14 @@
 
 package org.apache.commons.exec;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.FileReader;
-import java.io.IOException;
+import org.apache.commons.exec.environment.EnvironmentUtils;
+import org.junit.*;
+
+import java.io.*;
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.commons.exec.environment.EnvironmentUtils;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Test;
+import static org.junit.Assert.*;
 
 /**
  * @version $Id$
@@ -377,8 +361,6 @@ public class DefaultExecutorTest {
     /**
      * Try to start an non-existing application which should result
      * in an exception.
-     *
-     * @throws Exception the test failed
      */
     @Test(expected = IOException.class)
     public void testExecuteNonExistingApplication() throws Exception {
@@ -389,19 +371,63 @@ public class DefaultExecutorTest {
     }
 
     /**
-     * Try to start an non-existing application asynchronously which should result
+     * Try to start an non-existing application which should result
      * in an exception.
+     */
+    @Test(expected = IOException.class)
+    public void testExecuteNonExistingApplicationWithWatchDog() throws Exception {
+        final CommandLine cl = new CommandLine(nonExistingTestScript);
+        final DefaultExecutor executor = new DefaultExecutor();
+        executor.setWatchdog(new ExecuteWatchdog(ExecuteWatchdog.INFINITE_TIMEOUT));
+
+        executor.execute(cl);
+    }
+
+    /**
+     * Try to start an non-existing application where the exception is caught/processed
+     * by the result handler.
+     */
+    @Test
+    public void testExecuteAsyncNonExistingApplication() throws Exception {
+        final CommandLine cl = new CommandLine(nonExistingTestScript);
+        final DefaultExecuteResultHandler resultHandler = new DefaultExecuteResultHandler();
+        final DefaultExecutor executor = new DefaultExecutor();
+
+        executor.execute(cl, resultHandler);
+        resultHandler.waitFor();
+
+        assertTrue(executor.isFailure(resultHandler.getExitValue()));
+        assertNotNull(resultHandler.getException());
+    }
+
+    /**
+     * Try to start an non-existing application where the exception is caught/processed
+     * by the result handler. The watchdog in notified to avoid waiting for the
+     * process infinitely.
      *
-     * @throws Exception the test failed
+     * @see <a href="https://issues.apache.org/jira/browse/EXEC-71">EXEC-71</a>
      */
     @Test
-    public void testExecuteAsyncWithNonExistingApplication() throws Exception {
+    public void testExecuteAsyncNonExistingApplicationWithWatchdog() throws Exception {
         final CommandLine cl = new CommandLine(nonExistingTestScript);
-        final DefaultExecuteResultHandler handler = new DefaultExecuteResultHandler();
-        exec.execute(cl, handler);
-        Thread.sleep(2000);
-        assertNotNull(handler.getException());
-        assertTrue(exec.isFailure(handler.getExitValue()));
+        final DefaultExecuteResultHandler resultHandler = new DefaultExecuteResultHandler() {
+            @Override
+            public void onProcessFailed(ExecuteException e) {
+                System.out.println("Process did not stop gracefully, had exception '" + e.getMessage() + "' while executing process");
+                super.onProcessFailed(e);
+            }
+        };
+        final DefaultExecutor executor = new DefaultExecutor();
+        executor.setWatchdog(new ExecuteWatchdog(ExecuteWatchdog.INFINITE_TIMEOUT));
+
+        executor.execute(cl, resultHandler);
+        resultHandler.waitFor();
+
+        assertTrue(executor.isFailure(resultHandler.getExitValue()));
+        assertNotNull(resultHandler.getException());
+        assertFalse(executor.getWatchdog().isWatching());
+        assertFalse(executor.getWatchdog().killedProcess());
+        executor.getWatchdog().destroyProcess();
     }
 
     /**
