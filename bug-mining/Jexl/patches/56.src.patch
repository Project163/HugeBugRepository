diff --git a/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java b/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java
index 264579fe..c890b7d7 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlArithmetic.java
@@ -21,6 +21,8 @@ import org.apache.commons.jexl3.introspection.JexlMethod;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.math.MathContext;
+import java.util.Collection;
+import java.util.Map;
 
 /**
  * Perform arithmetic.
@@ -50,7 +52,7 @@ public class JexlArithmetic {
      * @since 3.0
      */
     public enum Operator {
-        /** add(x, y). */
+        /** add(x, y). *//** add(x, y). */
         ADD("+", "add", 2),
         /** subtract(x, y). */
         SUBTRACT("-", "subtract", 2),
@@ -69,7 +71,7 @@ public class JexlArithmetic {
         /** logicalNot(x). */
         NOT("!", "logicalNot", 1),
         /** bitiwiseComplement(x). */
-        COMPLEMENT("-", "bitwiseComplement", 1),
+        COMPLEMENT("~", "bitwiseComplement", 1),
         /** equals(x, y). */
         EQ("==", "equals", 2),
         /** lessThan(x, y). */
@@ -82,10 +84,16 @@ public class JexlArithmetic {
         GTE(">=", "greaterThanOrEqual", 2),
         /** negate(x). */
         NEGATE("-", "negate", 1),
-        /** size(x). */
-        SIZE("size", "size", 1),
+        /** contains(x). */
+        CONTAINS("=~", "contains", 2),
+        /** startsWith(x, y). */
+        STARTSWITH("=^", "startsWith", 2),
+        /** endsWith(x, y). */
+        ENDSWITH("=$", "endsWith", 2),
         /** empty(x). */
-        EMPTY("empty", "empty", 1);
+        EMPTY("empty", "empty", 1),
+        /** size(x). */
+        SIZE("size", "size", 1);
 
         /**
          * The operator symbol.
@@ -252,9 +260,10 @@ public class JexlArithmetic {
 
         /**
          * Creates the actual "array" instance.
+         * @param extended true when the last argument is ', ...'
          * @return the array
          */
-        Object create();
+        Object create(boolean extended);
     }
 
     /**
@@ -279,7 +288,7 @@ public class JexlArithmetic {
 
         /**
          * Creates the actual "set" instance.
-         * @return the array
+         * @return the set
          */
         Object create();
     }
@@ -334,9 +343,9 @@ public class JexlArithmetic {
         final long lto = toLong(to);
         if ((lfrom >= Integer.MIN_VALUE && lfrom <= Integer.MAX_VALUE)
             && (lto >= Integer.MIN_VALUE && lto <= Integer.MAX_VALUE)) {
-            return new org.apache.commons.jexl3.internal.IntegerRange((int) lfrom, (int) lto);
+            return org.apache.commons.jexl3.internal.IntegerRange.create((int) lfrom, (int) lto);
         } else {
-            return new org.apache.commons.jexl3.internal.LongRange(lfrom, lto);
+            return org.apache.commons.jexl3.internal.LongRange.create(lfrom, lto);
         }
     }
 
@@ -836,13 +845,13 @@ public class JexlArithmetic {
     }
 
     /**
-     * Test if left regexp matches right.
+     * Test if left matches right.
      *
      * @param left  first value
      * @param right second value
-     * @return test result.
+     * @return test result or null if there is no arithmetic solution
      */
-    public boolean matches(Object left, Object right) {
+    public Boolean contains(Object left, Object right) {
         if (left == null && right == null) {
             //if both are null L == R
             return true;
@@ -851,12 +860,70 @@ public class JexlArithmetic {
             // we know both aren't null, therefore L != R
             return false;
         }
-        final String arg = left.toString();
+        // use arithmetic / pattern matching ?
         if (right instanceof java.util.regex.Pattern) {
-            return ((java.util.regex.Pattern) right).matcher(arg).matches();
-        } else {
-            return arg.matches(right.toString());
+            return ((java.util.regex.Pattern) right).matcher(left.toString()).matches();
+        }
+        if ( right instanceof String) {
+            return left.toString().matches(right.toString());
+        }
+        // try contains on map key
+        if (right instanceof Map<?, ?>) {
+            return ((Map<?, ?>) right).containsKey(left);
+        }
+        // try contains on collection
+        if (right instanceof Collection<?>) {
+            if (left instanceof Collection<?>) {
+                return ((Collection<?>) right).containsAll((Collection<?>) left);
+            }
+            // left in right ? <=> right.contains(left) ?
+            return ((Collection<?>) right).contains(left);
+        }
+        return null;
+    }
+
+    /**
+     * Test if left ends with right.
+     *
+     * @param left  first value
+     * @param right second value
+     * @return test result or null if there is no arithmetic solution
+     */
+    public Boolean endsWith(Object left, Object right) {
+        if (left == null && right == null) {
+            //if both are null L == R
+            return true;
+        }
+        if (left == null || right == null) {
+            // we know both aren't null, therefore L != R
+            return false;
+        }
+        if (left instanceof String) {
+            return ((String) left).endsWith(toString(right));
+        }
+        return null;
+    }
+
+    /**
+     * Test if left starts with right.
+     *
+     * @param left  first value
+     * @param right second value
+     * @return test result or null if there is no arithmetic solution
+     */
+    public Boolean startsWith(Object left, Object right) {
+        if (left == null && right == null) {
+            //if both are null L == R
+            return true;
+        }
+        if (left == null || right == null) {
+            // we know both aren't null, therefore L != R
+            return false;
+        }
+        if (left instanceof String) {
+            return ((String) left).startsWith(toString(right));
         }
+        return null;
     }
 
     /**
@@ -1182,10 +1249,12 @@ public class JexlArithmetic {
             if (Double.isNaN(dval.doubleValue())) {
                 return BigInteger.ZERO;
             } else {
-                return new BigInteger(dval.toString());
+                return BigInteger.valueOf(dval.longValue());
             }
         } else if (val instanceof Number) {
-            return new BigInteger(val.toString());
+            return BigInteger.valueOf(((Number) val).longValue());
+        } else if (val instanceof Boolean) {
+            return BigInteger.valueOf(((Boolean) val).booleanValue() ? 1L : 0L);
         } else if (val instanceof String) {
             String string = (String) val;
             if ("".equals(string)) {
@@ -1217,12 +1286,6 @@ public class JexlArithmetic {
         } else if (val == null) {
             controlNullOperand();
             return BigDecimal.ZERO;
-        } else if (val instanceof String) {
-            String string = (String) val;
-            if ("".equals(string)) {
-                return BigDecimal.ZERO;
-            }
-            return roundBigDecimal(new BigDecimal(string, getMathContext()));
         } else if (val instanceof Double) {
             if (Double.isNaN(((Double) val).doubleValue())) {
                 return BigDecimal.ZERO;
@@ -1231,6 +1294,14 @@ public class JexlArithmetic {
             }
         } else if (val instanceof Number) {
             return roundBigDecimal(new BigDecimal(val.toString(), getMathContext()));
+        } else if (val instanceof Boolean) {
+            return BigDecimal.valueOf(((Boolean) val).booleanValue() ? 1. : 0.);
+        } else if (val instanceof String) {
+            String string = (String) val;
+            if ("".equals(string)) {
+                return BigDecimal.ZERO;
+            }
+            return roundBigDecimal(new BigDecimal(string, getMathContext()));
         } else if (val instanceof Character) {
             int i = ((Character) val).charValue();
             return new BigDecimal(i);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java b/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java
index 3b8ed37d..d22ace90 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/ArrayBuilder.java
@@ -19,7 +19,9 @@ package org.apache.commons.jexl3.internal;
 import org.apache.commons.jexl3.JexlArithmetic;
 
 import java.lang.reflect.Array;
+import java.util.ArrayList;
 import java.util.IdentityHashMap;
+import java.util.List;
 import java.util.Map;
 
 /**
@@ -47,21 +49,21 @@ public class ArrayBuilder implements JexlArithmetic.ArrayBuilder {
      * @param parm a class
      * @return the primitive type or null it the argument is not unboxable
      */
-    private static Class<?> unboxingClass(Class<?> parm) {
+    protected static Class<?> unboxingClass(Class<?> parm) {
         Class<?> prim = BOXING_CLASSES.get(parm);
         return prim == null ? parm : prim;
     }
 
     /** The intended class array. */
-    private Class<?> commonClass = null;
+    protected Class<?> commonClass = null;
     /** Whether the array stores numbers. */
-    private boolean isNumber = true;
+    protected boolean isNumber = true;
     /** Whether we can try unboxing. */
-    private boolean unboxing = true;
+    protected boolean unboxing = true;
     /** The untyped list of items being added. */
-    private final Object[] untyped;
+    protected final Object[] untyped;
     /** Number of added items. */
-    private int added = 0;
+    protected int added = 0;
 
     /**
      * Creates a new builder.
@@ -108,11 +110,18 @@ public class ArrayBuilder implements JexlArithmetic.ArrayBuilder {
     }
 
     @Override
-    public Object create() {
+    public Object create(boolean extended) {
         if (untyped != null) {
-            int size = untyped.length;
+            if (extended) {
+                List<Object> list = new ArrayList<Object>(added);
+                for(int i = 0; i < added; ++i) {
+                    list.add(untyped[i]);
+                }
+                return list;
+            }
             // convert untyped array to the common class if not Object.class
             if (commonClass != null && !Object.class.equals(commonClass)) {
+                final int size = added;
                 // if the commonClass is a number, it has an equivalent primitive type, get it
                 if (unboxing) {
                     commonClass = unboxingClass(commonClass);
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Debugger.java b/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
index f113c134..46408662 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Debugger.java
@@ -40,6 +40,7 @@ import org.apache.commons.jexl3.parser.ASTERNode;
 import org.apache.commons.jexl3.parser.ASTEWNode;
 import org.apache.commons.jexl3.parser.ASTEmptyFunction;
 import org.apache.commons.jexl3.parser.ASTEmptyMethod;
+import org.apache.commons.jexl3.parser.ASTExtendedLiteral;
 import org.apache.commons.jexl3.parser.ASTFalseNode;
 import org.apache.commons.jexl3.parser.ASTForeachStatement;
 import org.apache.commons.jexl3.parser.ASTFunctionNode;
@@ -378,6 +379,12 @@ public final class Debugger extends ParserVisitor implements JexlInfo.Detail {
         return data;
     }
 
+    @Override
+    protected Object visit(ASTExtendedLiteral node, Object data) {
+        builder.append("...");
+        return data;
+    }
+
     @Override
     protected Object visit(ASTArrayLiteral node, Object data) {
         int num = node.jjtGetNumChildren();
@@ -650,11 +657,11 @@ public final class Debugger extends ParserVisitor implements JexlInfo.Detail {
         builder.append("{ ");
         if (num > 0) {
             accept(node.jjtGetChild(0), data);
-            for (int i = 1; i < num; ++i) {
-                builder.append(",");
-                accept(node.jjtGetChild(i), data);
+                for (int i = 1; i < num; ++i) {
+                    builder.append(",");
+                    accept(node.jjtGetChild(i), data);
+                }
             }
-        }
         builder.append(" }");
         return data;
     }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/IntegerRange.java b/src/main/java/org/apache/commons/jexl3/internal/IntegerRange.java
index 55fc3f99..bf89aca0 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/IntegerRange.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/IntegerRange.java
@@ -24,12 +24,26 @@ import java.util.NoSuchElementException;
 /**
  * A range of integers.
  */
-public class IntegerRange implements Collection<Integer> {
+public abstract class IntegerRange implements Collection<Integer> {
     /** The lower boundary. */
-    private final int min;
+    protected final int min;
     /** The upper boundary. */
-    private final int max;
+    protected final int max;
+
 
+    /**
+     * Creates a range, ascending or descending depending on boundaries order.
+     * @param from the lower inclusive boundary
+     * @param to   the higher inclusive boundary
+     * @return a range
+     */
+    public static IntegerRange create(int from, int to) {
+        if (from <= to) {
+            return new IntegerRange.Ascending(from, to);
+        } else {
+            return new IntegerRange.Descending(to, from);
+        }
+    }
     /**
      * Creates a new range.
      * @param from the lower inclusive boundary
@@ -64,7 +78,7 @@ public class IntegerRange implements Collection<Integer> {
 
     @Override
     public int hashCode() {
-        int hash = 7;
+        int hash = getClass().hashCode();
         hash = 13 * hash + this.min;
         hash = 13 * hash + this.max;
         return hash;
@@ -89,9 +103,7 @@ public class IntegerRange implements Collection<Integer> {
     }
 
     @Override
-    public Iterator<Integer> iterator() {
-        return new IntegerIterator(min, max);
-    }
+    public abstract Iterator<Integer> iterator();
 
     @Override
     public int size() {
@@ -185,12 +197,40 @@ public class IntegerRange implements Collection<Integer> {
     public void clear() {
         throw new UnsupportedOperationException();
     }
+
+    /**
+     * Ascending integer range.
+     */
+    public static class Ascending extends IntegerRange {
+        protected Ascending(int from, int to) {
+            super(from, to);
+        }
+
+        @Override
+        public Iterator<Integer> iterator() {
+            return new AscIntegerIterator(min, max);
+        }
+    }
+
+    /**
+     * Descending integer range.
+     */
+    public static class Descending extends IntegerRange {
+        protected Descending(int from, int to) {
+            super(from, to);
+        }
+
+        @Override
+        public Iterator<Integer> iterator() {
+            return new DescIntegerIterator(min, max);
+        }
+    }
 }
 
 /**
- * An iterator on an integer range.
+ * An ascending iterator on an integer range.
  */
-class IntegerIterator implements Iterator<Integer> {
+class AscIntegerIterator implements Iterator<Integer> {
     /** The lower boundary. */
     private final int min;
     /** The upper boundary. */
@@ -202,7 +242,7 @@ class IntegerIterator implements Iterator<Integer> {
      * @param l low boundary
      * @param h high boundary
      */
-    public IntegerIterator(int l, int h) {
+    public AscIntegerIterator(int l, int h) {
         min = l;
         max = h;
         cursor = min;
@@ -226,3 +266,43 @@ class IntegerIterator implements Iterator<Integer> {
         throw new UnsupportedOperationException("Not supported.");
     }
 }
+
+/**
+ * A descending iterator on an integer range.
+ */
+class DescIntegerIterator implements Iterator<Integer> {
+    /** The lower boundary. */
+    private final int min;
+    /** The upper boundary. */
+    private final int max;
+    /** The current value. */
+    private int cursor;
+    /**
+     * Creates a iterator on the range.
+     * @param l low boundary
+     * @param h high boundary
+     */
+    public DescIntegerIterator(int l, int h) {
+        min = l;
+        max = h;
+        cursor = max;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return cursor >= min;
+    }
+
+    @Override
+    public Integer next() {
+        if (cursor >= min) {
+            return cursor--;
+        }
+        throw new NoSuchElementException();
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+}
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index b33ee730..cc0bb138 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -46,6 +46,7 @@ import org.apache.commons.jexl3.parser.ASTERNode;
 import org.apache.commons.jexl3.parser.ASTEWNode;
 import org.apache.commons.jexl3.parser.ASTEmptyFunction;
 import org.apache.commons.jexl3.parser.ASTEmptyMethod;
+import org.apache.commons.jexl3.parser.ASTExtendedLiteral;
 import org.apache.commons.jexl3.parser.ASTFalseNode;
 import org.apache.commons.jexl3.parser.ASTForeachStatement;
 import org.apache.commons.jexl3.parser.ASTFunctionNode;
@@ -304,9 +305,9 @@ public class Interpreter extends ParserVisitor {
 
     /**
      * Triggered when an operator fails.
-     * @param node   the node where the error originated from
+     * @param node     the node where the error originated from
      * @param operator the method name
-     * @param cause the cause of error (if any)
+     * @param cause    the cause of error (if any)
      * @throws JexlException if isStrict
      */
     protected void operatorError(JexlNode node, JexlArithmetic.Operator operator, Throwable cause) {
@@ -430,7 +431,7 @@ public class Interpreter extends ParserVisitor {
                     return result;
                 }
             } catch (Exception xany) {
-                operatorError(node,  operator, xany);
+                operatorError(node, operator, xany);
             }
         }
         return JexlEngine.TRY_FAILED;
@@ -507,11 +508,17 @@ public class Interpreter extends ParserVisitor {
         int childCount = node.jjtGetNumChildren();
         JexlArithmetic.ArrayBuilder ab = arithmetic.arrayBuilder(childCount);
         if (ab != null) {
+            boolean extended = false;
             for (int i = 0; i < childCount; i++) {
-                Object entry = node.jjtGetChild(i).jjtAccept(this, data);
-                ab.add(entry);
+                JexlNode child = node.jjtGetChild(i);
+                if (child instanceof ASTExtendedLiteral) {
+                    extended = true;
+                } else {
+                    Object entry = node.jjtGetChild(i).jjtAccept(this, data);
+                    ab.add(entry);
+                }
             }
-            return ab.create();
+            return ab.create(extended);
         } else {
             return null;
         }
@@ -723,29 +730,33 @@ public class Interpreter extends ParserVisitor {
      */
     protected boolean startsWith(JexlNode node, String operator, Object left, Object right) {
         try {
-            if (left == null || right == null) {
-                return false;
+            // try operator overload
+            Object result = callOperator(node, Operator.STARTSWITH, left, right);
+            if (result instanceof Boolean) {
+                return (Boolean) result;
             }
-            if (left instanceof String) {
-                return ((String) left).startsWith(arithmetic.toString(right));
-            } else {
-                // try a startsWith method (duck type)
-                try {
-                    Object[] argv = {right};
-                    JexlMethod vm = uberspect.getMethod(left, "startsWith", argv);
+            // use arithmetic / pattern matching ?
+            Boolean matched = arithmetic.startsWith(left, right);
+            if (matched != null) {
+                return matched;
+            }
+            // try a startsWith method (duck type)
+            try {
+                Object[] argv = {right};
+                JexlMethod vm = uberspect.getMethod(left, "startsWith", argv);
+                if (vm != null && vm.getReturnType() == Boolean.TYPE) {
+                    return (Boolean) vm.invoke(left, argv);
+                }
+                if (arithmetic.narrowArguments(argv)) {
+                    vm = uberspect.getMethod(left, "startsWith", argv);
                     if (vm != null && vm.getReturnType() == Boolean.TYPE) {
                         return (Boolean) vm.invoke(left, argv);
-                    } else if (arithmetic.narrowArguments(argv)) {
-                        vm = uberspect.getMethod(left, "startsWith", argv);
-                        if (vm != null && vm.getReturnType() == Boolean.TYPE) {
-                            return (Boolean) vm.invoke(left, argv);
-                        }
                     }
-                } catch (InvocationTargetException e) {
-                    throw new JexlException(node, operator + " invocation error", e.getCause());
-                } catch (Exception e) {
-                    throw new JexlException(node, operator + " error", e);
                 }
+            } catch (InvocationTargetException e) {
+                throw new JexlException(node, operator + " invocation error", e.getCause());
+            } catch (Exception e) {
+                throw new JexlException(node, operator + " error", e);
             }
             // defaults to equal
             return arithmetic.equals(left, right) ? Boolean.TRUE : Boolean.FALSE;
@@ -778,32 +789,36 @@ public class Interpreter extends ParserVisitor {
      */
     protected boolean endsWith(JexlNode node, String operator, Object left, Object right) {
         try {
-            if (left == null || right == null) {
-                return false;
+            // try operator overload
+            Object result = callOperator(node, Operator.ENDSWITH, left, right);
+            if (result instanceof Boolean) {
+                return (Boolean) result;
             }
-            if (left instanceof String) {
-                return ((String) left).endsWith(arithmetic.toString(right));
-            } else {
-                // try a endsWith method (duck type)
-                try {
-                    Object[] argv = {right};
-                    JexlMethod vm = uberspect.getMethod(left, "endsWith", argv);
+            // use arithmetic / pattern matching ?
+            Boolean matched = arithmetic.endsWith(left, right);
+            if (matched != null) {
+                return matched;
+            }
+            // try a endsWith method (duck type)
+            try {
+                Object[] argv = {right};
+                JexlMethod vm = uberspect.getMethod(left, "endsWith", argv);
+                if (vm != null && vm.getReturnType() == Boolean.TYPE) {
+                    return (Boolean) vm.invoke(left, argv);
+                }
+                if (arithmetic.narrowArguments(argv)) {
+                    vm = uberspect.getMethod(left, "endsWith", argv);
                     if (vm != null && vm.getReturnType() == Boolean.TYPE) {
                         return (Boolean) vm.invoke(left, argv);
-                    } else if (arithmetic.narrowArguments(argv)) {
-                        vm = uberspect.getMethod(left, "endsWith", argv);
-                        if (vm != null && vm.getReturnType() == Boolean.TYPE) {
-                            return (Boolean) vm.invoke(left, argv);
-                        }
                     }
-                } catch (InvocationTargetException e) {
-                    throw new JexlException(node, operator + " invocation error", e.getCause());
-                } catch (Exception e) {
-                    throw new JexlException(node, operator + " error", e);
                 }
-                // defaults to equal
-                return arithmetic.equals(left, right) ? Boolean.TRUE : Boolean.FALSE;
+            } catch (InvocationTargetException e) {
+                throw new JexlException(node, operator + " invocation error", e.getCause());
+            } catch (Exception e) {
+                throw new JexlException(node, operator + " error", e);
             }
+            // defaults to equal
+            return arithmetic.equals(left, right) ? Boolean.TRUE : Boolean.FALSE;
         } catch (ArithmeticException xrt) {
             throw new JexlException(node, operator + " error", xrt);
         }
@@ -831,20 +846,17 @@ public class Interpreter extends ParserVisitor {
      * @param right the right operand
      * @return true if left matches right, false otherwise
      */
-    protected boolean matches(JexlNode node, String op, Object left, Object right) {
+    protected boolean contains(JexlNode node, String op, Object left, Object right) {
         try {
-            // use arithmetic / pattern matching ?
-            if (right instanceof java.util.regex.Pattern || right instanceof String) {
-                return arithmetic.matches(left, right);
+            // try operator overload
+            Object result = callOperator(node, Operator.CONTAINS, left, right);
+            if (result instanceof Boolean) {
+                return (Boolean) result;
             }
-            // left in right ? <=> right.contains(left) ?
-            // try contains on map key
-            if (right instanceof Map<?, ?>) {
-                return ((Map<?, ?>) right).containsKey(left);
-            }
-            // try contains on collection
-            if (right instanceof Collection<?>) {
-                return ((Collection<?>) right).contains(left);
+            // use arithmetic / pattern matching ?
+            Boolean matched = arithmetic.contains(left, right);
+            if (matched != null) {
+                return matched;
             }
             // try a contains method (duck type set)
             try {
@@ -885,14 +897,14 @@ public class Interpreter extends ParserVisitor {
     protected Object visit(ASTERNode node, Object data) {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
-        return matches(node, "=~", left, right) ? Boolean.TRUE : Boolean.FALSE;
+        return contains(node, "=~", left, right) ? Boolean.TRUE : Boolean.FALSE;
     }
 
     @Override
     protected Object visit(ASTNRNode node, Object data) {
         Object left = node.jjtGetChild(0).jjtAccept(this, data);
         Object right = node.jjtGetChild(1).jjtAccept(this, data);
-        return matches(node, "!~", left, right) ? Boolean.FALSE : Boolean.TRUE;
+        return contains(node, "!~", left, right) ? Boolean.FALSE : Boolean.TRUE;
     }
 
     @Override
@@ -963,6 +975,11 @@ public class Interpreter extends ParserVisitor {
         return new Object[]{key, value};
     }
 
+    @Override
+    protected Object visit(ASTExtendedLiteral node, Object data) {
+        return node;
+    }
+
     @Override
     protected Object visit(ASTSetLiteral node, Object data) {
         int childCount = node.jjtGetNumChildren();
@@ -1480,7 +1497,7 @@ public class Interpreter extends ParserVisitor {
                     if (right instanceof Closure) {
                         ((Closure) right).setHoisted(symbol, right);
                     }
-                    return right;
+                    return right; // 1
                 }
                 object = frame.get(symbol);
             } else {
@@ -1491,7 +1508,7 @@ public class Interpreter extends ParserVisitor {
                     } catch (UnsupportedOperationException xsupport) {
                         throw new JexlException(node, "context is readonly", xsupport);
                     }
-                    return right;
+                    return right; // 2
                 }
                 object = context.get(var.getName());
             }
@@ -1565,7 +1582,7 @@ public class Interpreter extends ParserVisitor {
                 } catch (UnsupportedOperationException xsupport) {
                     throw new JexlException(node, "context is readonly", xsupport);
                 }
-                return right;
+                return right; // 3
             }
         } else if (propertyNode instanceof ASTArrayAccess) {
             // can have multiple nodes - either an expression, integer literal or reference
@@ -1590,7 +1607,7 @@ public class Interpreter extends ParserVisitor {
         }
         // 3: one before last, assign
         setAttribute(object, property, right, propertyNode);
-        return right;
+        return right; // 4
     }
 
     @Override
diff --git a/src/main/java/org/apache/commons/jexl3/internal/LongRange.java b/src/main/java/org/apache/commons/jexl3/internal/LongRange.java
index bb18031d..fa9620ad 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/LongRange.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/LongRange.java
@@ -23,20 +23,35 @@ import java.util.NoSuchElementException;
 
 /**
  * A range of longs.
- * <p>Behaves as a readonly collection of longs.
+ * <p>
+ * Behaves as a readonly collection of longs.
  */
-public class LongRange implements Collection<Long>  {
+public abstract class LongRange implements Collection<Long> {
     /** The lower boundary. */
-    private final long min;
+    protected final long min;
     /** The upper boundary. */
-    private final long max;
+    protected final long max;
+
+    /**
+     * Creates a range, ascending or descending depending on boundaries order.
+     * @param from the lower inclusive boundary
+     * @param to   the higher inclusive boundary
+     * @return a range
+     */
+    public static LongRange create(long from, long to) {
+        if (from <= to) {
+            return new LongRange.Ascending(from, to);
+        } else {
+            return new LongRange.Descending(to, from);
+        }
+    }
 
     /**
      * Creates a new range.
      * @param from the lower inclusive boundary
-     * @param to  the higher inclusive boundary
+     * @param to   the higher inclusive boundary
      */
-    public LongRange(long from, long to) {
+    protected LongRange(long from, long to) {
         if (from > to) {
             max = from;
             min = to;
@@ -64,7 +79,7 @@ public class LongRange implements Collection<Long>  {
 
     @Override
     public int hashCode() {
-        int hash = 3;
+        int hash = getClass().hashCode();
         hash = 41 * hash + (int) (this.min ^ (this.min >>> 32));
         hash = 41 * hash + (int) (this.max ^ (this.max >>> 32));
         return hash;
@@ -89,13 +104,11 @@ public class LongRange implements Collection<Long>  {
     }
 
     @Override
-    public Iterator<Long> iterator() {
-        return new LongIterator(min, max);
-    }
+    public abstract Iterator<Long> iterator();
 
     @Override
     public int size() {
-        return (int)(max - min + 1);
+        return (int) (max - min + 1);
     }
 
     @Override
@@ -117,7 +130,7 @@ public class LongRange implements Collection<Long>  {
     public Object[] toArray() {
         final int size = size();
         Object[] array = new Object[size];
-        for(int a = 0; a < size; ++a) {
+        for (int a = 0; a < size; ++a) {
             array[a] = min + a;
         }
         return array;
@@ -148,7 +161,7 @@ public class LongRange implements Collection<Long>  {
 
     @Override
     public boolean containsAll(Collection<?> c) {
-        for(Object cc : c) {
+        for (Object cc : c) {
             if (!contains(cc)) {
                 return false;
             }
@@ -185,24 +198,53 @@ public class LongRange implements Collection<Long>  {
     public void clear() {
         throw new UnsupportedOperationException();
     }
+
+    /**
+     * Ascending long range.
+     */
+    public static class Ascending extends LongRange {
+        protected Ascending(long from, long to) {
+            super(from, to);
+        }
+
+        @Override
+        public Iterator<Long> iterator() {
+            return new AscLongIterator(min, max);
+        }
+    }
+
+    /**
+     * Descending long range.
+     */
+    public static class Descending extends LongRange {
+        protected Descending(long from, long to) {
+            super(from, to);
+        }
+
+        @Override
+        public Iterator<Long> iterator() {
+            return new DescLongIterator(min, max);
+        }
+    }
 }
 
 /**
  * An iterator on a long range.
  */
-class LongIterator implements Iterator<Long> {
+class AscLongIterator implements Iterator<Long> {
     /** The lower boundary. */
     private final long min;
     /** The upper boundary. */
     private final long max;
     /** The current value. */
     private long cursor;
+
     /**
      * Creates a iterator on the range.
      * @param l low boundary
      * @param h high boundary
      */
-    public LongIterator(long l, long h) {
+    AscLongIterator(long l, long h) {
         min = l;
         max = h;
         cursor = min;
@@ -226,3 +268,44 @@ class LongIterator implements Iterator<Long> {
         throw new UnsupportedOperationException();
     }
 }
+
+/**
+ * An iterator on a long range.
+ */
+class DescLongIterator implements Iterator<Long> {
+    /** The lower boundary. */
+    private final long min;
+    /** The upper boundary. */
+    private final long max;
+    /** The current value. */
+    private long cursor;
+
+    /**
+     * Creates a iterator on the range.
+     * @param l low boundary
+     * @param h high boundary
+     */
+    DescLongIterator(long l, long h) {
+        min = l;
+        max = h;
+        cursor = max;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return cursor >= min;
+    }
+
+    @Override
+    public Long next() {
+        if (cursor >= min) {
+            return cursor--;
+        }
+        throw new NoSuchElementException();
+    }
+
+    @Override
+    public void remove() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/org/apache/commons/jexl3/internal/MapBuilder.java b/src/main/java/org/apache/commons/jexl3/internal/MapBuilder.java
index 0662675a..66e7668d 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/MapBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/MapBuilder.java
@@ -25,7 +25,7 @@ import org.apache.commons.jexl3.JexlArithmetic;
  */
 public class MapBuilder implements JexlArithmetic.MapBuilder {
     /** The map being created. */
-    private final Map<Object, Object> map;
+    protected final Map<Object, Object> map;
 
     /**
      * Creates a new builder.
@@ -44,5 +44,4 @@ public class MapBuilder implements JexlArithmetic.MapBuilder {
     public Object create() {
         return map;
     }
-
 }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/SetBuilder.java b/src/main/java/org/apache/commons/jexl3/internal/SetBuilder.java
index 17e0145b..cdb0a361 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/SetBuilder.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/SetBuilder.java
@@ -25,7 +25,7 @@ import java.util.Set;
  */
 public class SetBuilder implements JexlArithmetic.SetBuilder {
     /** The set being created. */
-    private final Set<Object> set;
+    protected final Set<Object> set;
 
     /**
      * Creates a new builder.
@@ -44,5 +44,4 @@ public class SetBuilder implements JexlArithmetic.SetBuilder {
     public Object create() {
         return set;
     }
-
 }
diff --git a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
index 98828b88..622f1872 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
@@ -131,6 +131,7 @@ PARSER_END(Parser)
     | < COLON : ":" >
     | < COMMA : "," >
     | < DOT : "." >
+    | < ELIPSIS : "..." >
 }
 
 <*> TOKEN : { /* CONDITIONALS */
@@ -584,9 +585,20 @@ void StringLiteral() :
   { jjtThis.setLiteral(Parser.buildString(t.image, true)); }
 }
 
+void ExtendedLiteral() #ExtendedLiteral() : {}
+{
+   <ELIPSIS>
+}
+
 void ArrayLiteral() : {}
 {
-  <LBRACKET> (Expression() ( <COMMA> Expression() )*)? <RBRACKET>
+   <LBRACKET>
+   (
+        LOOKAHEAD(1) ExtendedLiteral()
+    |
+        (Expression() (LOOKAHEAD(2) <COMMA> Expression() )*)? (<COMMA> ExtendedLiteral())?
+   )
+   <RBRACKET>
 }
 
 void MapLiteral() : {}
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java b/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java
index ade21f81..2b8a55eb 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ParserVisitor.java
@@ -128,6 +128,8 @@ public abstract class ParserVisitor {
 
     protected abstract Object visit(ASTSetLiteral node, Object data);
 
+    protected abstract Object visit(ASTExtendedLiteral node, Object data);
+
     protected abstract Object visit(ASTArrayLiteral node, Object data);
 
     protected abstract Object visit(ASTRangeNode node, Object data);
diff --git a/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java b/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java
index e1844586..9a4a02f4 100644
--- a/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ArithmeticTest.java
@@ -467,6 +467,11 @@ public class ArithmeticTest extends JexlTestCase {
         Var(int v) {
             value = v;
         }
+
+        @Override
+        public String toString() {
+            return Integer.toString(value);
+        }
     }
 
     // an arithmetic that know how to subtract strings
@@ -531,6 +536,18 @@ public class ArithmeticTest extends JexlTestCase {
             return new Var(lhs.value ^ rhs.value);
         }
 
+        public Boolean contains(Var lhs, Var rhs) {
+            return lhs.toString().contains(rhs.toString());
+        }
+
+        public Boolean startsWith(Var lhs, Var rhs) {
+            return lhs.toString().startsWith(rhs.toString());
+        }
+
+        public Boolean endsWith(Var lhs, Var rhs) {
+            return lhs.toString().endsWith(rhs.toString());
+        }
+
         public Var bitwiseComplement(Var arg) {
             return new Var(~arg.value);
         }
@@ -584,8 +601,6 @@ public class ArithmeticTest extends JexlTestCase {
         Assert.assertEquals(false, result);
         result = script.execute(jc, new Var(43), new Var(42));
         Assert.assertEquals(false, result);
-        result = script.execute(jc, new Var(43), new Var(42));
-        Assert.assertEquals(false, result);
 
         script = jexl.createScript("(x, y)->{ x <= y }");
         result = script.execute(jc, 42, 43);
@@ -598,8 +613,30 @@ public class ArithmeticTest extends JexlTestCase {
         Assert.assertEquals(false, result);
         result = script.execute(jc, new Var(45), new Var(40));
         Assert.assertEquals(false, result);
-        result = script.execute(jc, new Var(46), new Var(39));
+
+        script = jexl.createScript("(x, y)->{ x > y }");
+        result = script.execute(jc, 42, 43);
+        Assert.assertEquals(false, result);
+        result = script.execute(jc, new Var(42), new Var(43));
+        Assert.assertEquals(false, result);
+        result = script.execute(jc, new Var(42), new Var(43));
+        Assert.assertEquals(false, result);
+        result = script.execute(jc, 43, 42);
+        Assert.assertEquals(true, result);
+        result = script.execute(jc, new Var(43), new Var(42));
+        Assert.assertEquals(true, result);
+
+        script = jexl.createScript("(x, y)->{ x >= y }");
+        result = script.execute(jc, 42, 43);
+        Assert.assertEquals(false, result);
+        result = script.execute(jc, new Var(42), new Var(43));
+        Assert.assertEquals(false, result);
+        result = script.execute(jc, new Var(41), new Var(44));
         Assert.assertEquals(false, result);
+        result = script.execute(jc, 43, 42);
+        Assert.assertEquals(true, result);
+        result = script.execute(jc, new Var(45), new Var(40));
+        Assert.assertEquals(true, result);
 
         script = jexl.createScript("(x, y)->{ x == y }");
         result = script.execute(jc, 42, 43);
@@ -612,32 +649,36 @@ public class ArithmeticTest extends JexlTestCase {
         Assert.assertEquals(false, result);
         result = script.execute(jc, new Var(45), new Var(40));
         Assert.assertEquals(false, result);
-        result = script.execute(jc, new Var(46), new Var(39));
+
+        script = jexl.createScript("(x, y)->{ x != y }");
+        result = script.execute(jc, 42, 43);
+        Assert.assertEquals(true, result);
+        result = script.execute(jc, new Var(42), new Var(43));
+        Assert.assertEquals(true, result);
+        result = script.execute(jc, new Var(44), new Var(44));
+        Assert.assertEquals(false, result);
+        result = script.execute(jc, 44, 44);
         Assert.assertEquals(false, result);
+        result = script.execute(jc, new Var(45), new Var(40));
+        Assert.assertEquals(true, result);
 
         script = jexl.createScript("(x, y)->{ x % y }");
         result = script.execute(jc, 4242, 100);
         Assert.assertEquals(42, result);
         result = script.execute(jc, new Var(4242), new Var(100));
         Assert.assertEquals(42, ((Var) result).value);
-        result = script.execute(jc, new Var(4242), new Var(100));
-        Assert.assertEquals(42, ((Var) result).value);
 
         script = jexl.createScript("(x, y)->{ x * y }");
         result = script.execute(jc, 6, 7);
         Assert.assertEquals(42, result);
         result = script.execute(jc, new Var(6), new Var(7));
         Assert.assertEquals(42, ((Var) result).value);
-        result = script.execute(jc, new Var(6), new Var(7));
-        Assert.assertEquals(42, ((Var) result).value);
 
         script = jexl.createScript("(x, y)->{ x + y }");
         result = script.execute(jc, 35, 7);
         Assert.assertEquals(42, result);
         result = script.execute(jc, new Var(35), new Var(7));
         Assert.assertEquals(42, ((Var) result).value);
-        result = script.execute(jc, new Var(35), new Var(7));
-        Assert.assertEquals(42, ((Var) result).value);
 
         script = jexl.createScript("(x, y)->{ x - y }");
         result = script.execute(jc, 49, 7);
@@ -648,20 +689,72 @@ public class ArithmeticTest extends JexlTestCase {
         Assert.assertEquals(42, result);
         result = script.execute(jc, new Var(50), new Var(8));
         Assert.assertEquals(42, ((Var) result).value);
-        result = script.execute(jc, new Var(50), new Var(8));
-        Assert.assertEquals(42, ((Var) result).value);
 
         script = jexl.createScript("(x)->{ -x }");
         result = script.execute(jc, -42);
         Assert.assertEquals(42, result);
         result = script.execute(jc, new Var(-42));
         Assert.assertEquals(42, ((Var) result).value);
-        result = script.execute(jc, new Var(-42));
-        Assert.assertEquals(42, ((Var) result).value);
         result = script.execute(jc, "pizza");
         Assert.assertEquals("azzip", result);
         result = script.execute(jc, -142);
         Assert.assertEquals(142, result);
+
+        script = jexl.createScript("(x)->{ ~x }");
+        result = script.execute(jc, -1);
+        Assert.assertEquals(0L, result);
+        result = script.execute(jc, new Var(-1));
+        Assert.assertEquals(0L, ((Var) result).value);
+        result = script.execute(jc, new Var(-42));
+        Assert.assertEquals(41, ((Var) result).value);
+
+        script = jexl.createScript("(x, y)->{ x ^ y }");
+        result = script.execute(jc, 35, 7);
+        Assert.assertEquals(36L, result);
+        result = script.execute(jc, new Var(35), new Var(7));
+        Assert.assertEquals(36L, ((Var) result).value);
+
+        script = jexl.createScript("(x, y)->{ x & y }");
+        result = script.execute(jc, 35, 7);
+        Assert.assertEquals(3L, result);
+        result = script.execute(jc, new Var(35), new Var(7));
+        Assert.assertEquals(3L, ((Var) result).value);
+
+        script = jexl.createScript("(x, y)->{ x =^ y }");
+        result = script.execute(jc, 3115, 31);
+        Assert.assertFalse((Boolean) result);
+        result = script.execute(jc, new Var(3115), new Var(31));
+        Assert.assertTrue((Boolean) result);
+
+        script = jexl.createScript("(x, y)->{ x !^ y }");
+        result = script.execute(jc, 3115, 31);
+        Assert.assertTrue((Boolean) result);
+        result = script.execute(jc, new Var(3115), new Var(31));
+        Assert.assertFalse((Boolean) result);
+
+        script = jexl.createScript("(x, y)->{ x =$ y }");
+        result = script.execute(jc, 3115, 15);
+        Assert.assertFalse((Boolean) result);
+        result = script.execute(jc, new Var(3115), new Var(15));
+        Assert.assertTrue((Boolean) result);
+
+        script = jexl.createScript("(x, y)->{ x !$ y }");
+        result = script.execute(jc, 3115, 15);
+        Assert.assertTrue((Boolean) result);
+        result = script.execute(jc, new Var(3115), new Var(15));
+        Assert.assertFalse((Boolean) result);
+
+        script = jexl.createScript("(x, y)->{ x =~ y }");
+        result = script.execute(jc, 3155, 15);
+        Assert.assertFalse((Boolean) result);
+        result = script.execute(jc, new Var(3155), new Var(15));
+        Assert.assertTrue((Boolean) result);
+
+        script = jexl.createScript("(x, y)->{ x !~ y }");
+        result = script.execute(jc, 3115, 15);
+        Assert.assertTrue((Boolean) result);
+        result = script.execute(jc, new Var(3155), new Var(15));
+        Assert.assertFalse((Boolean) result);
     }
 
     public static class Arithmetic132 extends JexlArithmetic {
@@ -786,9 +879,11 @@ public class ArithmeticTest extends JexlTestCase {
         public XmlArithmetic(boolean lenient) {
             super(lenient);
         }
+
         public boolean empty(org.w3c.dom.Element elt) {
             return !elt.hasAttributes() && !elt.hasChildNodes();
         }
+
         public int size(org.w3c.dom.Element elt) {
             return elt.getChildNodes().getLength();
         }
@@ -839,51 +934,51 @@ public class ArithmeticTest extends JexlTestCase {
 
     @Test
     public void testEmptyLong() throws Exception {
-       Object x;
-       x = JEXL.createScript("new('java.lang.Long', 4294967296)").execute(null);
-       Assert.assertEquals(4294967296L, ((Long) x).longValue());
-       x = JEXL.createScript("new('java.lang.Long', '4294967296')").execute(null);
-       Assert.assertEquals(4294967296L, ((Long) x).longValue());
-       x = JEXL.createScript("4294967296l").execute(null);
-       Assert.assertEquals(4294967296L, ((Long) x).longValue());
-       x = JEXL.createScript("4294967296L").execute(null);
-       Assert.assertEquals(4294967296L, ((Long) x).longValue());
-       checkEmpty(x, false);
-       x = JEXL.createScript("0L").execute(null);
-       Assert.assertEquals(0, ((Long) x).longValue());
-       checkEmpty(x, true);
+        Object x;
+        x = JEXL.createScript("new('java.lang.Long', 4294967296)").execute(null);
+        Assert.assertEquals(4294967296L, ((Long) x).longValue());
+        x = JEXL.createScript("new('java.lang.Long', '4294967296')").execute(null);
+        Assert.assertEquals(4294967296L, ((Long) x).longValue());
+        x = JEXL.createScript("4294967296l").execute(null);
+        Assert.assertEquals(4294967296L, ((Long) x).longValue());
+        x = JEXL.createScript("4294967296L").execute(null);
+        Assert.assertEquals(4294967296L, ((Long) x).longValue());
+        checkEmpty(x, false);
+        x = JEXL.createScript("0L").execute(null);
+        Assert.assertEquals(0, ((Long) x).longValue());
+        checkEmpty(x, true);
     }
 
     @Test
     public void testEmptyFloat() throws Exception {
-       Object x;
-       x = JEXL.createScript("4294967296.f").execute(null);
-       Assert.assertEquals(4294967296.0f, (Float) x, EPSILON);
-       checkEmpty(x, false);
-       x = JEXL.createScript("4294967296.0f").execute(null);
-       Assert.assertEquals(4294967296.0f, (Float) x, EPSILON);
-       checkEmpty(x, false);
-       x = JEXL.createScript("0.0f").execute(null);
-       Assert.assertEquals(0.0f, (Float) x, EPSILON);
-       checkEmpty(x, true);
-       x = Float.NaN;
-       checkEmpty(x, true);
+        Object x;
+        x = JEXL.createScript("4294967296.f").execute(null);
+        Assert.assertEquals(4294967296.0f, (Float) x, EPSILON);
+        checkEmpty(x, false);
+        x = JEXL.createScript("4294967296.0f").execute(null);
+        Assert.assertEquals(4294967296.0f, (Float) x, EPSILON);
+        checkEmpty(x, false);
+        x = JEXL.createScript("0.0f").execute(null);
+        Assert.assertEquals(0.0f, (Float) x, EPSILON);
+        checkEmpty(x, true);
+        x = Float.NaN;
+        checkEmpty(x, true);
     }
 
     @Test
     public void testEmptyDouble() throws Exception {
-       Object x;
-       x = JEXL.createScript("4294967296.d").execute(null);
-       Assert.assertEquals(4294967296.0d, (Double) x, EPSILON);
-       checkEmpty(x, false);
-       x = JEXL.createScript("4294967296.0d").execute(null);
-       Assert.assertEquals(4294967296.0d, (Double) x, EPSILON);
-       checkEmpty(x, false);
-       x = JEXL.createScript("0.0d").execute(null);
-       Assert.assertEquals(0.0d, (Double) x, EPSILON);
-       checkEmpty(x, true);
-       x = Double.NaN;
-       checkEmpty(x, true);
+        Object x;
+        x = JEXL.createScript("4294967296.d").execute(null);
+        Assert.assertEquals(4294967296.0d, (Double) x, EPSILON);
+        checkEmpty(x, false);
+        x = JEXL.createScript("4294967296.0d").execute(null);
+        Assert.assertEquals(4294967296.0d, (Double) x, EPSILON);
+        checkEmpty(x, false);
+        x = JEXL.createScript("0.0d").execute(null);
+        Assert.assertEquals(0.0d, (Double) x, EPSILON);
+        checkEmpty(x, true);
+        x = Double.NaN;
+        checkEmpty(x, true);
 
     }
 
@@ -898,4 +993,95 @@ public class ArithmeticTest extends JexlTestCase {
         empty = (Boolean) s2.execute(null, x);
         Assert.assertEquals(expect, empty);
     }
+
+    @Test
+    public void testCoerceInteger() throws Exception {
+        JexlArithmetic ja = JEXL.getArithmetic();
+        JexlEvalContext ctxt = new JexlEvalContext();
+        ctxt.setStrictArithmetic(true);
+        String stmt = "a = 34L; b = 45.0D; c=56.0F; d=67B; e=78H;";
+        JexlScript expr = JEXL.createScript(stmt);
+        /* Object value = */ expr.execute(ctxt);
+        Assert.assertEquals(34, ja.toInteger(ctxt.get("a")));
+        Assert.assertEquals(45, ja.toInteger(ctxt.get("b")));
+        Assert.assertEquals(56, ja.toInteger(ctxt.get("c")));
+        Assert.assertEquals(67, ja.toInteger(ctxt.get("d")));
+        Assert.assertEquals(78, ja.toInteger(ctxt.get("e")));
+        Assert.assertEquals(10, ja.toInteger("10"));
+        Assert.assertEquals(1, ja.toInteger(true));
+        Assert.assertEquals(0, ja.toInteger(false));
+    }
+
+    @Test
+    public void testCoerceLong() throws Exception {
+        JexlArithmetic ja = JEXL.getArithmetic();
+        JexlEvalContext ctxt = new JexlEvalContext();
+        ctxt.setStrictArithmetic(true);
+        String stmt = "a = 34L; b = 45.0D; c=56.0F; d=67B; e=78H;";
+        JexlScript expr = JEXL.createScript(stmt);
+        /* Object value = */ expr.execute(ctxt);
+        Assert.assertEquals(34L, ja.toLong(ctxt.get("a")));
+        Assert.assertEquals(45L, ja.toLong(ctxt.get("b")));
+        Assert.assertEquals(56L, ja.toLong(ctxt.get("c")));
+        Assert.assertEquals(67L, ja.toLong(ctxt.get("d")));
+        Assert.assertEquals(78L, ja.toLong(ctxt.get("e")));
+        Assert.assertEquals(10L, ja.toLong("10"));
+        Assert.assertEquals(1L, ja.toLong(true));
+        Assert.assertEquals(0L, ja.toLong(false));
+    }
+
+    @Test
+    public void testCoerceDouble() throws Exception {
+        JexlArithmetic ja = JEXL.getArithmetic();
+        JexlEvalContext ctxt = new JexlEvalContext();
+        ctxt.setStrictArithmetic(true);
+        String stmt = "{a = 34L; b = 45.0D; c=56.0F; d=67B; e=78H; }";
+        JexlScript expr = JEXL.createScript(stmt);
+        /* Object value = */ expr.execute(ctxt);
+        Assert.assertEquals(34, ja.toDouble(ctxt.get("a")), EPSILON);
+        Assert.assertEquals(45, ja.toDouble(ctxt.get("b")), EPSILON);
+        Assert.assertEquals(56, ja.toDouble(ctxt.get("c")), EPSILON);
+        Assert.assertEquals(67, ja.toDouble(ctxt.get("d")), EPSILON);
+        Assert.assertEquals(78, ja.toDouble(ctxt.get("e")), EPSILON);
+        Assert.assertEquals(10d, ja.toDouble("10"), EPSILON);
+        Assert.assertEquals(1.D, ja.toDouble(true), EPSILON);
+        Assert.assertEquals(0.D, ja.toDouble(false), EPSILON);
+    }
+
+    @Test
+    public void testCoerceBigInteger() throws Exception {
+        JexlArithmetic ja = JEXL.getArithmetic();
+        JexlEvalContext ctxt = new JexlEvalContext();
+        ctxt.setStrictArithmetic(true);
+        String stmt = "{a = 34L; b = 45.0D; c=56.0F; d=67B; e=78H; }";
+        JexlScript expr = JEXL.createScript(stmt);
+        /* Object value = */ expr.execute(ctxt);
+        Assert.assertEquals(BigInteger.valueOf(34), ja.toBigInteger(ctxt.get("a")));
+        Assert.assertEquals(BigInteger.valueOf(45), ja.toBigInteger(ctxt.get("b")));
+        Assert.assertEquals(BigInteger.valueOf(56), ja.toBigInteger(ctxt.get("c")));
+        Assert.assertEquals(BigInteger.valueOf(67), ja.toBigInteger(ctxt.get("d")));
+        Assert.assertEquals(BigInteger.valueOf(78), ja.toBigInteger(ctxt.get("e")));
+        Assert.assertEquals(BigInteger.valueOf(10), ja.toBigInteger("10"));
+        Assert.assertEquals(BigInteger.valueOf(1), ja.toBigInteger(true));
+        Assert.assertEquals(BigInteger.valueOf(0), ja.toBigInteger(false));
+    }
+
+    @Test
+    public void testCoerceBigDecimal() throws Exception {
+        JexlArithmetic ja = JEXL.getArithmetic();
+        JexlEvalContext ctxt = new JexlEvalContext();
+        ctxt.setStrictArithmetic(true);
+        String stmt = "{a = 34L; b = 45.0D; c=56.0F; d=67B; e=78H; }";
+        JexlScript expr = JEXL.createScript(stmt);
+        /* Object value = */ expr.execute(ctxt);
+        Assert.assertEquals(BigDecimal.valueOf(34), ja.toBigDecimal(ctxt.get("a")));
+        Assert.assertEquals(BigDecimal.valueOf(45.), ja.toBigDecimal(ctxt.get("b")));
+        Assert.assertEquals(BigDecimal.valueOf(56.), ja.toBigDecimal(ctxt.get("c")));
+        Assert.assertEquals(BigDecimal.valueOf(67), ja.toBigDecimal(ctxt.get("d")));
+        Assert.assertEquals(BigDecimal.valueOf(78), ja.toBigDecimal(ctxt.get("e")));
+        Assert.assertEquals(BigDecimal.valueOf(10), ja.toBigDecimal("10"));
+        Assert.assertEquals(BigDecimal.valueOf(1.), ja.toBigDecimal(true));
+        Assert.assertEquals(BigDecimal.valueOf(0.), ja.toBigDecimal(false));
+    }
+
 }
diff --git a/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java b/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java
index 1cde150f..f7ea3dd8 100644
--- a/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java
+++ b/src/test/java/org/apache/commons/jexl3/ArrayLiteralTest.java
@@ -17,11 +17,12 @@
 package org.apache.commons.jexl3;
 
 import java.util.Arrays;
+import java.util.List;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
- * Tests for array literals
+ * Tests for array literals.
  * @since 2.0
  */
 @SuppressWarnings({"UnnecessaryBoxing", "AssertEqualsBetweenInconvertibleTypes"})
@@ -31,97 +32,120 @@ public class ArrayLiteralTest extends JexlTestCase {
         super("ArrayLiteralTest");
     }
 
+    @Test
+    public void testEmptyArrayLiteral() throws Exception {
+        JexlContext jc = new MapContext();
+        Object o;
+        o = JEXL.createExpression("[]").evaluate(jc);
+        Assert.assertTrue(o instanceof Object[]);
+        Assert.assertEquals(0, ((Object[]) o).length);
+        o = JEXL.createExpression("[...]").evaluate(jc);
+        Assert.assertTrue(o instanceof List<?>);
+        Assert.assertEquals(0, ((List<?>) o).size());
+    }
+
     @Test
     public void testLiteralWithStrings() throws Exception {
-        JexlExpression e = JEXL.createExpression( "[ 'foo' , 'bar' ]" );
+        JexlExpression e = JEXL.createExpression("[ 'foo' , 'bar' ]");
+        JexlContext jc = new MapContext();
+
+        Object o = e.evaluate(jc);
+        Object[] check = {"foo", "bar"};
+        Assert.assertTrue(Arrays.equals(check, (Object[]) o));
+    }
+
+    @Test
+    public void testLiteralWithElipsis() throws Exception {
+        JexlExpression e = JEXL.createExpression("[ 'foo' , 'bar', ... ]");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        Object[] check = { "foo", "bar" };
-        Assert.assertTrue( Arrays.equals(check, (Object[])o) );
+        Object o = e.evaluate(jc);
+        Object[] check = {"foo", "bar"};
+        Assert.assertEquals(Arrays.asList(check), o);
+        Assert.assertEquals(2, ((List<?>) o).size());
     }
 
     @Test
     public void testLiteralWithOneEntry() throws Exception {
-        JexlExpression e = JEXL.createExpression( "[ 'foo' ]" );
+        JexlExpression e = JEXL.createExpression("[ 'foo' ]");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        Object[] check = { "foo" };
-        Assert.assertTrue( Arrays.equals(check, (Object[])o) );
+        Object o = e.evaluate(jc);
+        Object[] check = {"foo"};
+        Assert.assertTrue(Arrays.equals(check, (Object[]) o));
     }
 
     @Test
     public void testLiteralWithNumbers() throws Exception {
-        JexlExpression e = JEXL.createExpression( "[ 5.0 , 10 ]" );
+        JexlExpression e = JEXL.createExpression("[ 5.0 , 10 ]");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        Object[] check = { new Double(5), new Integer(10) };
-        Assert.assertTrue( Arrays.equals(check, (Object[])o) );
-        Assert.assertTrue (o.getClass().isArray() && o.getClass().getComponentType().equals(Number.class));
+        Object o = e.evaluate(jc);
+        Object[] check = {new Double(5), new Integer(10)};
+        Assert.assertTrue(Arrays.equals(check, (Object[]) o));
+        Assert.assertTrue(o.getClass().isArray() && o.getClass().getComponentType().equals(Number.class));
     }
 
     @Test
     public void testLiteralWithNulls() throws Exception {
-        String []exprs = {
+        String[] exprs = {
             "[ null , 10 ]",
             "[ 10 , null ]",
             "[ 10 , null , 10]",
             "[ '10' , null ]",
             "[ null, '10' , null ]"
         };
-        Object [][]checks = {
+        Object[][] checks = {
             {null, new Integer(10)},
             {new Integer(10), null},
             {new Integer(10), null, new Integer(10)},
-            { "10", null },
-            { null, "10", null }
+            {"10", null},
+            {null, "10", null}
         };
         JexlContext jc = new MapContext();
-        for(int t = 0; t < exprs.length; ++t) {
-            JexlExpression e = JEXL.createExpression( exprs[t] );
-            Object o = e.evaluate( jc );
-            Assert.assertTrue(exprs[t], Arrays.equals(checks[t], (Object[])o) );
+        for (int t = 0; t < exprs.length; ++t) {
+            JexlExpression e = JEXL.createExpression(exprs[t]);
+            Object o = e.evaluate(jc);
+            Assert.assertTrue(exprs[t], Arrays.equals(checks[t], (Object[]) o));
         }
 
     }
 
     @Test
     public void testLiteralWithIntegers() throws Exception {
-        JexlExpression e = JEXL.createExpression( "[ 5 , 10 ]" );
+        JexlExpression e = JEXL.createExpression("[ 5 , 10 ]");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        int[] check = { 5, 10 };
-        Assert.assertTrue( Arrays.equals(check, (int[])o) );
+        Object o = e.evaluate(jc);
+        int[] check = {5, 10};
+        Assert.assertTrue(Arrays.equals(check, (int[]) o));
     }
 
     @Test
     public void testSizeOfSimpleArrayLiteral() throws Exception {
-        JexlExpression e = JEXL.createExpression( "size([ 'foo' , 'bar' ])" );
+        JexlExpression e = JEXL.createExpression("size([ 'foo' , 'bar' ])");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        Assert.assertEquals( new Integer( 2 ), o );
+        Object o = e.evaluate(jc);
+        Assert.assertEquals(new Integer(2), o);
     }
 
     @Test
     public void notestCallingMethodsOnNewMapLiteral() throws Exception {
-        JexlExpression e = JEXL.createExpression( "size({ 'foo' : 'bar' }.values())" );
+        JexlExpression e = JEXL.createExpression("size({ 'foo' : 'bar' }.values())");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        Assert.assertEquals( new Integer( 1 ), o );
+        Object o = e.evaluate(jc);
+        Assert.assertEquals(new Integer(1), o);
     }
 
     @Test
     public void testNotEmptySimpleArrayLiteral() throws Exception {
-        JexlExpression e = JEXL.createExpression( "empty([ 'foo' , 'bar' ])" );
+        JexlExpression e = JEXL.createExpression("empty([ 'foo' , 'bar' ])");
         JexlContext jc = new MapContext();
 
-        Object o = e.evaluate( jc );
-        Assert.assertFalse( (Boolean) o );
+        Object o = e.evaluate(jc);
+        Assert.assertFalse((Boolean) o);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/jexl3/SetLiteralTest.java b/src/test/java/org/apache/commons/jexl3/SetLiteralTest.java
index fcb46a1e..ad8c5cd1 100644
--- a/src/test/java/org/apache/commons/jexl3/SetLiteralTest.java
+++ b/src/test/java/org/apache/commons/jexl3/SetLiteralTest.java
@@ -116,8 +116,8 @@ public class SetLiteralTest extends JexlTestCase {
         };
         JexlContext jc = new MapContext();
         for (int t = 0; t < exprs.length; ++t) {
-            JexlExpression e = JEXL.createExpression(exprs[t]);
-            Object o = e.evaluate(jc);
+            JexlScript e = JEXL.createScript(exprs[t]);
+            Object o = e.execute(jc);
             Assert.assertTrue(exprs[t], Objects.equals(checks[t], o));
         }
 
diff --git a/src/test/java/org/apache/commons/jexl3/internal/RangeTest.java b/src/test/java/org/apache/commons/jexl3/internal/RangeTest.java
index 0ffad642..82484726 100644
--- a/src/test/java/org/apache/commons/jexl3/internal/RangeTest.java
+++ b/src/test/java/org/apache/commons/jexl3/internal/RangeTest.java
@@ -48,9 +48,37 @@ public class RangeTest extends JexlTestCase {
         super.tearDown();
     }
 
+    private void checkIteration(LongRange lr, long first, long last) throws Exception {
+        Iterator<Long> ii = lr.iterator();
+        if (ii.hasNext()) {
+            long l = ii.next();
+            Assert.assertEquals(first, l);
+            while(ii.hasNext()) {
+                l = ii.next();
+            }
+            Assert.assertEquals(last, l);
+        } else {
+            Assert.fail("empty iterator?");
+        }
+    }
+
+    private void checkIteration(IntegerRange ir, int first, int last) throws Exception {
+        Iterator<Integer> ii = ir.iterator();
+        if (ii.hasNext()) {
+            int l = ii.next();
+            Assert.assertEquals(first, l);
+            while(ii.hasNext()) {
+                l = ii.next();
+            }
+            Assert.assertEquals(last, l);
+        } else {
+            Assert.fail("empty iterator?");
+        }
+    }
+
     @Test
-    public void testRanges() {
-        LongRange lr0 = new LongRange(20,10);
+    public void testRanges() throws Exception {
+        LongRange lr0 = LongRange.create(20,10);
         Assert.assertEquals(10L, lr0.getMin());
         Assert.assertEquals(20L, lr0.getMax());
         Assert.assertFalse(lr0.isEmpty());
@@ -59,14 +87,16 @@ public class RangeTest extends JexlTestCase {
         Assert.assertFalse(lr0.contains(30L));
         Assert.assertFalse(lr0.contains(5L));
         Assert.assertFalse(lr0.contains(null));
-        LongRange lr1 = new LongRange(10,20);
-        Assert.assertEquals(lr0, lr1);
+        checkIteration(lr0, 20L, 10L);
+        LongRange lr1 = LongRange.create(10,20);
+        checkIteration(lr1, 10L, 20L);
         Assert.assertTrue(lr0.containsAll(lr1));
-        LongRange lr2 = new LongRange(10,15);
+        LongRange lr2 = LongRange.create(10,15);
         Assert.assertNotEquals(lr0, lr2);
         Assert.assertTrue(lr0.containsAll(lr2));
         Assert.assertFalse(lr2.containsAll(lr1));
-        IntegerRange ir0 = new IntegerRange(20,10);
+        IntegerRange ir0 = IntegerRange.create(20,10);
+        checkIteration(ir0, 20, 10);
         Assert.assertEquals(10, ir0.getMin());
         Assert.assertEquals(20, ir0.getMax());
         Assert.assertFalse(ir0.isEmpty());
@@ -75,17 +105,17 @@ public class RangeTest extends JexlTestCase {
         Assert.assertFalse(ir0.contains(30));
         Assert.assertFalse(ir0.contains(5));
         Assert.assertFalse(ir0.contains(null));
-        IntegerRange ir1 = new IntegerRange(10,20);
-        Assert.assertEquals(ir0, ir1);
+        IntegerRange ir1 = IntegerRange.create(10,20);
+        checkIteration(ir1, 10, 20);
         Assert.assertTrue(ir0.containsAll(ir1));
         Assert.assertNotEquals(ir0, lr0);
         Assert.assertNotEquals(ir1, lr1);
-        IntegerRange ir2 = new IntegerRange(10,15);
+        IntegerRange ir2 = IntegerRange.create(10,15);
         Assert.assertNotEquals(ir0, ir2);
         Assert.assertTrue(ir0.containsAll(ir2));
         Assert.assertFalse(ir2.containsAll(ir1));
 
-        long lc0 = 10;
+        long lc0 = 20;
         Iterator<Long> il0 = lr0.iterator();
         while(il0.hasNext()) {
             long v0 = il0.next();
@@ -102,9 +132,9 @@ public class RangeTest extends JexlTestCase {
             } catch(UnsupportedOperationException xuo) {
                 // ok
             }
-            lc0 += 1;
+            lc0 -= 1;
         }
-        Assert.assertEquals(21L, lc0);
+        Assert.assertEquals(9L, lc0);
         try {
             il0.next();
             Assert.fail();
@@ -112,7 +142,7 @@ public class RangeTest extends JexlTestCase {
             // ok
         }
 
-        int ic0 = 10;
+        int ic0 = 20;
         Iterator<Integer> ii0 = ir0.iterator();
         while(ii0.hasNext()) {
             int v0 = ii0.next();
@@ -129,9 +159,9 @@ public class RangeTest extends JexlTestCase {
             } catch(UnsupportedOperationException xuo) {
                 // ok
             }
-            ic0 += 1;
+            ic0 -= 1;
         }
-        Assert.assertEquals(21, ic0);
+        Assert.assertEquals(9, ic0);
         try {
             ii0.next();
             Assert.fail();
diff --git a/src/test/java/org/apache/commons/jexl3/internal/Util.java b/src/test/java/org/apache/commons/jexl3/internal/Util.java
index 5d0b88d1..9d3f6513 100644
--- a/src/test/java/org/apache/commons/jexl3/internal/Util.java
+++ b/src/test/java/org/apache/commons/jexl3/internal/Util.java
@@ -71,7 +71,7 @@ public class Util {
             } catch (JexlException xjexl) {
                 throw new RuntimeException("check parse failed: "
                         + expressiondbg
-                        + " /******** */ "
+                        + " /*********/ "
                         + entry.getKey(), xjexl);
 
             }
