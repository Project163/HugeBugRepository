diff --git a/src/test/java/org/apache/commons/exec/issues/Exec65Test.java b/src/test/java/org/apache/commons/exec/issues/Exec65Test.java
index ec45ff4b..e6029c89 100644
--- a/src/test/java/org/apache/commons/exec/issues/Exec65Test.java
+++ b/src/test/java/org/apache/commons/exec/issues/Exec65Test.java
@@ -24,8 +24,9 @@ import org.apache.commons.exec.ExecuteWatchdog;
 import org.apache.commons.exec.OS;
 import org.apache.commons.exec.PumpStreamHandler;
 import org.apache.commons.exec.TestUtil;
-import org.junit.Ignore;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TestName;
 
 import java.io.File;
 
@@ -38,67 +39,82 @@ import static org.junit.Assert.assertTrue;
  */
 public class Exec65Test {
 
-    private static final int TIMEOUT = 3000;
+    private static final int TEST_TIMEOUT = 15000;
+    private static final int WATCHDOG_TIMEOUT = 3000;
+    private static final String OS_NAME = System.getProperty("os.name");
+
     private final File testDir = new File("src/test/scripts");
 
-    @Test(expected = ExecuteException.class, timeout = 15000)
-    public void testExec65WitSleepUsingCommandLine() throws Exception
-    {
-        if(OS.isFamilyUnix())
-        {
+    @Rule public TestName name = new TestName();
+
+    @Test(expected = ExecuteException.class, timeout = TEST_TIMEOUT)
+    public void testExec65WitSleepUsingSleepCommandDirectly() throws Exception {
+
+        if (OS.isFamilyUnix()) {
+            final ExecuteWatchdog watchdog = new ExecuteWatchdog(WATCHDOG_TIMEOUT);
             final DefaultExecutor executor = new DefaultExecutor();
-            executor.setStreamHandler(new PumpStreamHandler(System.out, System.err));
-            final ExecuteWatchdog watchdog = new ExecuteWatchdog(TIMEOUT);
-            executor.setWatchdog(watchdog);
             final CommandLine command = new CommandLine("sleep");
             command.addArgument("60");
+            executor.setStreamHandler(new PumpStreamHandler(System.out, System.err));
+            executor.setWatchdog(watchdog);
 
             executor.execute(command);
+        } else {
+            String msg = String.format("The test '%s' does not support the following OS : %s", name.getMethodName(), OS_NAME);
+            System.out.println(msg);
+            throw new ExecuteException(msg, 0);
         }
     }
 
-    @Test(expected = ExecuteException.class, timeout = 15000)
-    public void testExec65WithSleepUsingShellScript() throws Exception
-    {
+    @Test(expected = ExecuteException.class, timeout = TEST_TIMEOUT)
+    public void testExec65WithSleepUsingShellScript() throws Exception {
+
         final DefaultExecutor executor = new DefaultExecutor();
         executor.setStreamHandler(new PumpStreamHandler(System.out, System.err));
-        final ExecuteWatchdog watchdog = new ExecuteWatchdog(TIMEOUT);
-        executor.setWatchdog(watchdog);
+        executor.setWatchdog(new ExecuteWatchdog(WATCHDOG_TIMEOUT));
         final CommandLine command = new CommandLine(TestUtil.resolveScriptForOS(testDir + "/sleep"));
 
         executor.execute(command);
     }
 
-    @Ignore("This test does not work under Linux but nicely on Mac OS X")
-    @Test(timeout = 15000)
-    public void testExec65WithSleepUsingShellScriptAndRuntimeDirectly() throws Exception
-    {
+    /**
+     * This is the original code snippet from the JIRA to show that
+     * killing the process actually works with JDK only but it does
+     * not re-direct any streams.
+     */
+    @Test(timeout = TEST_TIMEOUT)
+    public void testExec65WithSleepUsingShellScriptAndJDKOnly() throws Exception {
+
         Process process = Runtime.getRuntime().exec(TestUtil.resolveScriptForOS(testDir + "/sleep").getAbsolutePath());
-        Thread.sleep(3000);
+        Thread.sleep(WATCHDOG_TIMEOUT);
 
         process.destroy();
-
-        process.waitFor();
+        while (process.isAlive()) {
+            Thread.sleep(100);
+        }
 
         assertTrue(process.exitValue() != 0);
     }
 
     /**
      * Please note that this tests make assumptions about the environment. It assumes
-     * that user "root" exists and that the current user is not a "sudoer" already.
+     * that user "root" exists and that the current user is not a "sudoer" already
+     * (thereby requiring a password).
      */
-    @Test(expected = ExecuteException.class, timeout = 15000)
-    public void testExec65WithSudoUsingShellScript() throws Exception
-    {
-        if(OS.isFamilyUnix())
-        {
+    @Test(expected = ExecuteException.class, timeout = TEST_TIMEOUT)
+    public void testExec65WithSudoUsingShellScript() throws Exception {
+
+        if (OS.isFamilyUnix()) {
             final DefaultExecutor executor = new DefaultExecutor();
             executor.setStreamHandler(new PumpStreamHandler(System.out, System.err, System.in));
-            final ExecuteWatchdog watchdog = new ExecuteWatchdog(TIMEOUT);
-            executor.setWatchdog(watchdog);
+            executor.setWatchdog(new ExecuteWatchdog(WATCHDOG_TIMEOUT));
             final CommandLine command = new CommandLine(TestUtil.resolveScriptForOS(testDir + "/issues/exec-65"));
 
             executor.execute(command);
+        } else {
+            String msg = String.format("The test '%s' does not support the following OS : %s", name.getMethodName(), OS_NAME);
+            System.out.println(msg);
+            throw new ExecuteException(msg, 0);
         }
     }
 }
