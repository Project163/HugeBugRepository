diff --git a/apache-rat-core/src/main/java/org/apache/rat/configuration/XMLConfigurationReader.java b/apache-rat-core/src/main/java/org/apache/rat/configuration/XMLConfigurationReader.java
index 0bf2dda8..e92a2baf 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/configuration/XMLConfigurationReader.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/configuration/XMLConfigurationReader.java
@@ -126,6 +126,21 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
         };
     }
 
+    /**
+     * Creates textual representation of a node for display.
+     * @param node the node to create the textual representation of.
+     * @return The textual representation of the node for display.
+     */
+    private String nodeText(final Node node) {
+        StringBuilder stringBuilder = new StringBuilder().append("<").append(node.getNodeName());
+        NamedNodeMap attr = node.getAttributes();
+        for (int i = 0; i < attr.getLength(); i++) {
+            Node n = attr.item(i);
+            stringBuilder.append(String.format(" %s='%s'", n.getNodeName(), n.getNodeValue()));
+        }
+        return stringBuilder.append(">").toString();
+    }
+
     @Override
     public void addLicenses(final URI uri) {
         read(uri);
@@ -327,22 +342,27 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
      */
     private Pair<Boolean, List<Node>> processChildNodes(final Description description, final Node parent,
             final BiPredicate<Node, Description> childProcessor) {
-        boolean foundChildren = false;
-        List<Node> children = new ArrayList<>();
-        // check XML child nodes.
-        if (parent.hasChildNodes()) {
-
-            nodeListConsumer(parent.getChildNodes(), n -> {
-                if (n.getNodeType() == Node.ELEMENT_NODE) {
-                    children.add(n);
+        try {
+            boolean foundChildren = false;
+            List<Node> children = new ArrayList<>();
+            // check XML child nodes.
+            if (parent.hasChildNodes()) {
+
+                nodeListConsumer(parent.getChildNodes(), n -> {
+                    if (n.getNodeType() == Node.ELEMENT_NODE) {
+                        children.add(n);
+                    }
+                });
+                foundChildren = !children.isEmpty();
+                if (foundChildren) {
+                    processChildren(description, children, childProcessor);
                 }
-            });
-            foundChildren = !children.isEmpty();
-            if (foundChildren) {
-                processChildren(description, children, childProcessor);
             }
+            return new ImmutablePair<>(foundChildren, children);
+        } catch (RuntimeException exception) {
+            DefaultLog.getInstance().error(String.format("Child node extraction error in: '%s'", nodeText(parent)));
+            throw exception;
         }
-        return new ImmutablePair<>(foundChildren, children);
     }
 
     /**
@@ -408,6 +428,7 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
             }
 
         } catch (DOMException e) {
+            DefaultLog.getInstance().error(String.format("Matcher error in: '%s'", nodeText(matcherNode)));
             throw new ConfigurationException(e);
         }
         return builder.hasId() ? new IDRecordingBuilder(matchers, builder) : builder;
@@ -445,34 +466,39 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
      * @return the License definition.
      */
     private ILicense parseLicense(final Node licenseNode) {
-        ILicense.Builder builder = ILicense.builder();
-        // get the description for the builder
-        Description description = builder.getDescription();
-        // set the BUILDER_PARAM options from the description
-        processBuilderParams(description, builder);
-        // set the children from attributes.
-        description.setChildren(builder, attributes(licenseNode));
-        // set children from the child nodes
-        Pair<Boolean, List<Node>> pair = processChildNodes(description, licenseNode,
-                licenseChildNodeProcessor(builder, description));
-        List<Node> children = pair.getRight();
-
-        // check for inline nodes that can accept child nodes.
-        List<Description> childDescriptions = description.getChildren().values().stream()
-                .filter(d -> XMLConfig.isLicenseInline(d.getCommonName())).collect(Collectors.toList());
-        for (Description childDescription : childDescriptions) {
-            Iterator<Node> iter = children.iterator();
-            while (iter.hasNext()) {
-                callSetter(childDescription, builder, parseMatcher(iter.next()));
-                iter.remove();
+        try {
+            ILicense.Builder builder = ILicense.builder();
+            // get the description for the builder
+            Description description = builder.getDescription();
+            // set the BUILDER_PARAM options from the description
+            processBuilderParams(description, builder);
+            // set the children from attributes.
+            description.setChildren(builder, attributes(licenseNode));
+            // set children from the child nodes
+            Pair<Boolean, List<Node>> pair = processChildNodes(description, licenseNode,
+                    licenseChildNodeProcessor(builder, description));
+            List<Node> children = pair.getRight();
+
+            // check for inline nodes that can accept child nodes.
+            List<Description> childDescriptions = description.getChildren().values().stream()
+                    .filter(d -> XMLConfig.isLicenseInline(d.getCommonName())).collect(Collectors.toList());
+            for (Description childDescription : childDescriptions) {
+                Iterator<Node> iter = children.iterator();
+                while (iter.hasNext()) {
+                    callSetter(childDescription, builder, parseMatcher(iter.next()));
+                    iter.remove();
+                }
             }
-        }
 
-        if (!children.isEmpty()) {
-            children.forEach(n -> DefaultLog.getInstance().warn(String.format("unrecognised child node '%s' in node '%s'%n",
-                    n.getNodeName(), licenseNode.getNodeName())));
+            if (!children.isEmpty()) {
+                children.forEach(n -> DefaultLog.getInstance().warn(String.format("unrecognised child node '%s' in node '%s'%n",
+                        n.getNodeName(), licenseNode.getNodeName())));
+            }
+            return builder.build();
+        } catch (RuntimeException exception) {
+            DefaultLog.getInstance().error(String.format("License error in: '%s'", nodeText(licenseNode)));
+            throw exception;
         }
-        return builder.build();
     }
 
     @Override
@@ -519,12 +545,17 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
      */
     private void parseFamily(final Node familyNode) {
         if (XMLConfig.FAMILY.equals(familyNode.getNodeName())) {
-            ILicenseFamily result = parseFamily(attributes(familyNode));
-            if (result == null) {
-                throw new ConfigurationException(
-                        String.format("families/family tag requires %s attribute", XMLConfig.ATT_ID));
+            try {
+                ILicenseFamily result = parseFamily(attributes(familyNode));
+                if (result == null) {
+                    throw new ConfigurationException(
+                            String.format("families/family tag requires %s attribute", XMLConfig.ATT_ID));
+                }
+                licenseFamilies.add(result);
+            } catch (RuntimeException exception) {
+                DefaultLog.getInstance().error(String.format("Family error in: '%s'", nodeText(familyNode)));
+                throw exception;
             }
-            licenseFamilies.add(result);
         }
     }
 
@@ -535,21 +566,26 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
      */
     private void parseApproved(final Node approvedNode) {
         if (XMLConfig.FAMILY.equals(approvedNode.getNodeName())) {
-            Map<String, String> attributes = attributes(approvedNode);
-            if (attributes.containsKey(XMLConfig.ATT_LICENSE_REF)) {
-                approvedFamilies.add(attributes.get(XMLConfig.ATT_LICENSE_REF));
-            } else if (attributes.containsKey(XMLConfig.ATT_ID)) {
-                ILicenseFamily target = parseFamily(attributes);
-                if (target != null) {
-                    licenseFamilies.add(target);
-                    String familyCategory = target.getFamilyCategory();
-                    if (StringUtils.isNotBlank(familyCategory)) {
-                        approvedFamilies.add(familyCategory);
+            try {
+                Map<String, String> attributes = attributes(approvedNode);
+                if (attributes.containsKey(XMLConfig.ATT_LICENSE_REF)) {
+                    approvedFamilies.add(attributes.get(XMLConfig.ATT_LICENSE_REF));
+                } else if (attributes.containsKey(XMLConfig.ATT_ID)) {
+                    ILicenseFamily target = parseFamily(attributes);
+                    if (target != null) {
+                        licenseFamilies.add(target);
+                        String familyCategory = target.getFamilyCategory();
+                        if (StringUtils.isNotBlank(familyCategory)) {
+                            approvedFamilies.add(familyCategory);
+                        }
                     }
+                } else {
+                    throw new ConfigurationException(String.format("family tag requires %s or %s attribute",
+                            XMLConfig.ATT_LICENSE_REF, XMLConfig.ATT_ID));
                 }
-            } else {
-                throw new ConfigurationException(String.format("family tag requires %s or %s attribute",
-                        XMLConfig.ATT_LICENSE_REF, XMLConfig.ATT_ID));
+            } catch (RuntimeException exception) {
+                DefaultLog.getInstance().error(String.format("Approved error in: '%s'", nodeText(approvedNode)));
+                throw exception;
             }
         }
     }
@@ -569,11 +605,16 @@ public final class XMLConfigurationReader implements LicenseReader, MatcherReade
     }
 
     private void parseMatcherBuilder(final Node classNode) {
-        Map<String, String> attributes = attributes(classNode);
-        if (attributes.get(XMLConfig.ATT_CLASS_NAME) == null) {
-            throw new ConfigurationException("matcher must have a " + XMLConfig.ATT_CLASS_NAME + " attribute");
+        try {
+            Map<String, String> attributes = attributes(classNode);
+            if (attributes.get(XMLConfig.ATT_CLASS_NAME) == null) {
+                throw new ConfigurationException("matcher must have a " + XMLConfig.ATT_CLASS_NAME + " attribute");
+            }
+            MatcherBuilderTracker.addBuilder(attributes.get(XMLConfig.ATT_CLASS_NAME), attributes.get(XMLConfig.ATT_NAME));
+        } catch (RuntimeException exception) {
+            DefaultLog.getInstance().error(String.format("Matcher error in: '%s'", nodeText(classNode)));
+            throw exception;
         }
-        MatcherBuilderTracker.addBuilder(attributes.get(XMLConfig.ATT_CLASS_NAME), attributes.get(XMLConfig.ATT_NAME));
     }
 
     @Override
diff --git a/apache-rat-core/src/main/java/org/apache/rat/report/xml/writer/XmlWriter.java b/apache-rat-core/src/main/java/org/apache/rat/report/xml/writer/XmlWriter.java
index 53a0dfb6..128f32f6 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/report/xml/writer/XmlWriter.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/report/xml/writer/XmlWriter.java
@@ -482,7 +482,7 @@ public final class XmlWriter implements IXmlWriter {
 
     /**
      * Writes an attribute of an element. Note that this is only allowed directly
-     * after {@link #openElement(CharSequence)} or {@link #attribute}.
+     * after {@link #openElement(CharSequence)} or a previous {@code attribute} call.
      *
      * @param name the attribute name, not null
      * @param value the attribute value, not null
@@ -717,7 +717,7 @@ public final class XmlWriter implements IXmlWriter {
     }
 
     @Override
-    public void close() throws Exception {
+    public void close() throws IOException {
         closeDocument();
     }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/utils/Log.java b/apache-rat-core/src/main/java/org/apache/rat/utils/Log.java
index d12db3e6..624cb739 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/utils/Log.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/utils/Log.java
@@ -18,7 +18,6 @@
  */
 package org.apache.rat.utils;
 
-import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.io.Writer;
@@ -184,6 +183,15 @@ public interface Log {
      * @return the Writer backed by this log.
      */
     default Writer asWriter() {
+        return asWriter(Level.INFO);
+    }
+
+    /**
+     * Returns a Writer backed by this log. All messages are logged at "INFO" level.
+     * @return the Writer backed by this log.
+     * @param level the Log level to write at.
+     */
+    default Writer asWriter(Level level) {
         return new Writer() {
             private StringBuilder sb = new StringBuilder();
 
@@ -195,7 +203,7 @@ public interface Log {
                     sb.append(txt);
                 } else {
                     while (pos > -1) {
-                        Log.this.info(sb.append(txt, 0, pos).toString());
+                        Log.this.log(level, sb.append(txt, 0, pos).toString());
                         sb.delete(0, sb.length());
                         txt = txt.substring(pos + 1);
                         pos = txt.indexOf(System.lineSeparator());
@@ -207,15 +215,16 @@ public interface Log {
             @Override
             public void flush() {
                 if (sb.length() > 0) {
-                    Log.this.info(sb.toString());
+                    Log.this.log(level, sb.toString());
                 }
                 sb = new StringBuilder();
             }
 
             @Override
-            public void close() throws IOException {
+            public void close() {
                 flush();
             }
         };
     }
+
 }
