diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index 1f87bf83..0a7b76d5 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -89,22 +89,17 @@ public class Mapper implements Closeable {
     protected final Mappings mappings;
     protected final JsonReaderFactory readerFactory;
     protected final JsonGeneratorFactory generatorFactory;
-    protected final ConcurrentMap<AdapterKey, Adapter<?, ?>> adapters;
     protected final ConcurrentMap<Adapter<?, ?>, AdapterKey> reverseAdaptersRegistry = new ConcurrentHashMap<Adapter<?, ?>, AdapterKey>();
-    protected final int version;
     protected final ReaderHandler readerHandler;
     protected final Collection<Closeable> closeables;
 
     Mapper(final JsonReaderFactory readerFactory, final JsonGeneratorFactory generatorFactory, MapperConfig config,
-                  final Map<AdapterKey, Adapter<?, ?>> adapters,
-                  final int version, final Comparator<String> attributeOrder,
+                  final Comparator<String> attributeOrder,
                   final Collection<Closeable> closeables) {
         this.readerFactory = readerFactory;
         this.generatorFactory = generatorFactory;
         this.config = config;
-        this.adapters = new ConcurrentHashMap<AdapterKey, Adapter<?, ?>>(adapters);
-        this.version = version;
-        this.mappings = new Mappings(attributeOrder, config.getAccessMode(), version, this.adapters);
+        this.mappings = new Mappings(attributeOrder, config.getAccessMode(), config.getVersion(), config.getAdapters());
         this.readerHandler = ReaderHandler.create(readerFactory);
         this.closeables = closeables;
     }
@@ -187,8 +182,11 @@ public class Mapper implements Closeable {
         return converter.from(value);
     }
 
+    /**
+     * @deprecated see MapperConfig
+     */
     private Adapter findAdapter(final Type aClass) {
-        final Adapter<?, ?> converter = adapters.get(new AdapterKey(aClass, String.class));
+        final Adapter<?, ?> converter = config.getAdapters().get(new AdapterKey(aClass, String.class));
         if (converter != null) {
             return converter;
         }
@@ -196,20 +194,23 @@ public class Mapper implements Closeable {
             final Class<?> clazz = Class.class.cast(aClass);
             if (clazz.isEnum()) {
                 final Adapter<?, ?> enumConverter = new ConverterAdapter(new EnumConverter(clazz));
-                adapters.putIfAbsent(new AdapterKey(String.class, aClass), enumConverter);
+                config.getAdapters().putIfAbsent(new AdapterKey(String.class, aClass), enumConverter);
                 return enumConverter;
             }
         }
         return null;
     }
 
+    /**
+     * @deprecated see MapperConfig
+     */
     private Object convertTo(final Type aClass, final String text) {
         if (Object.class == aClass || String.class == aClass) {
             return text;
         }
         final Adapter converter = findAdapter(aClass);
         if (converter == null) {
-            adapters.putIfAbsent(new AdapterKey(String.class, aClass), FALLBACK_CONVERTER);
+            config.getAdapters().putIfAbsent(new AdapterKey(String.class, aClass), FALLBACK_CONVERTER);
             return FALLBACK_CONVERTER.to(text);
         }
         return converter.to(text);
@@ -402,7 +403,7 @@ public class Mapper implements Closeable {
         JsonGenerator generator = gen;
         for (final Map.Entry<String, Mappings.Getter> getterEntry : classMapping.getters.entrySet()) {
             final Mappings.Getter getter = getterEntry.getValue();
-            if (getter.version >= 0 && version >= getter.version) {
+            if (getter.version >= 0 && config.getVersion() >= getter.version) {
                 continue;
             }
 
@@ -478,7 +479,7 @@ public class Mapper implements Closeable {
                 return generator;
             }
             if(config.isTreatByteArrayAsBase64URL() && (type == byte[].class /*|| type == Byte[].class*/)) {
-                return generator.write(key, String.valueOf(Adapter.class.cast(adapters.get(new AdapterKey(byte[].class, String.class))).to(value)));
+                return generator.write(key, String.valueOf(Adapter.class.cast(config.getAdapters().get(new AdapterKey(byte[].class, String.class))).to(value)));
             }
 
             JsonGenerator gen = generator.writeStartArray(key);
@@ -800,7 +801,7 @@ public class Mapper implements Closeable {
         if (jsonValue.getValueType() == ValueType.OBJECT) {
             AdapterKey adapterKey = reverseAdaptersRegistry.get(converter);
             if (adapterKey == null) {
-                for (final Map.Entry<AdapterKey, Adapter<?, ?>> entry : adapters.entrySet()) {
+                for (final Map.Entry<AdapterKey, Adapter<?, ?>> entry : config.getAdapters().entrySet()) {
                     if (entry.getValue() == converter) {
                         adapterKey = entry.getKey();
                         reverseAdaptersRegistry.put(converter, adapterKey);
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
index c5073ac0..cf3c4d8b 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
@@ -23,23 +23,6 @@ import org.apache.johnzon.mapper.access.BaseAccessMode;
 import org.apache.johnzon.mapper.access.FieldAccessMode;
 import org.apache.johnzon.mapper.access.FieldAndMethodAccessMode;
 import org.apache.johnzon.mapper.access.MethodAccessMode;
-import org.apache.johnzon.mapper.converter.BigDecimalConverter;
-import org.apache.johnzon.mapper.converter.BigIntegerConverter;
-import org.apache.johnzon.mapper.converter.BooleanConverter;
-import org.apache.johnzon.mapper.converter.ByteConverter;
-import org.apache.johnzon.mapper.converter.CachedDelegateConverter;
-import org.apache.johnzon.mapper.converter.CharacterConverter;
-import org.apache.johnzon.mapper.converter.ClassConverter;
-import org.apache.johnzon.mapper.converter.DateConverter;
-import org.apache.johnzon.mapper.converter.DoubleConverter;
-import org.apache.johnzon.mapper.converter.FloatConverter;
-import org.apache.johnzon.mapper.converter.IntegerConverter;
-import org.apache.johnzon.mapper.converter.LocaleConverter;
-import org.apache.johnzon.mapper.converter.LongConverter;
-import org.apache.johnzon.mapper.converter.ShortConverter;
-import org.apache.johnzon.mapper.converter.StringConverter;
-import org.apache.johnzon.mapper.converter.URIConverter;
-import org.apache.johnzon.mapper.converter.URLConverter;
 import org.apache.johnzon.mapper.internal.AdapterKey;
 import org.apache.johnzon.mapper.internal.ConverterAdapter;
 
@@ -52,61 +35,26 @@ import javax.json.stream.JsonGeneratorFactory;
 import java.io.Closeable;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.net.URI;
-import java.net.URL;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
-import java.util.Date;
 import java.util.HashMap;
-import java.util.Locale;
 import java.util.Map;
 
 public class MapperBuilder {
     private static final Map<AdapterKey, Adapter<?, ?>> DEFAULT_CONVERTERS = new HashMap<AdapterKey, Adapter<?, ?>>(23);
 
-    static {
-        //DEFAULT_CONVERTERS.put(Date.class, new DateConverter("yyyy-MM-dd'T'HH:mm:ssZ")); // ISO8601 long RFC822 zone
-        DEFAULT_CONVERTERS.put(new AdapterKey(Date.class, String.class), new ConverterAdapter<Date>(new DateConverter("yyyyMMddHHmmssZ"))); // ISO8601 short
-        DEFAULT_CONVERTERS.put(new AdapterKey(URL.class, String.class), new ConverterAdapter<URL>(new URLConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(URI.class, String.class), new ConverterAdapter<URI>(new URIConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Class.class, String.class), new ConverterAdapter<Class<?>>(new ClassConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(String.class, String.class), new ConverterAdapter<String>(new StringConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(BigDecimal.class, String.class), new ConverterAdapter<BigDecimal>(new BigDecimalConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(BigInteger.class, String.class), new ConverterAdapter<BigInteger>(new BigIntegerConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Byte.class, String.class), new ConverterAdapter<Byte>(new CachedDelegateConverter<Byte>(new ByteConverter())));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Character.class, String.class), new ConverterAdapter<Character>(new CharacterConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Double.class, String.class), new ConverterAdapter<Double>(new DoubleConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Float.class, String.class), new ConverterAdapter<Float>(new FloatConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Integer.class, String.class), new ConverterAdapter<Integer>(new IntegerConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Long.class, String.class), new ConverterAdapter<Long>(new LongConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Short.class, String.class), new ConverterAdapter<Short>(new ShortConverter()));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Boolean.class, String.class), new ConverterAdapter<Boolean>(new CachedDelegateConverter<Boolean>(new BooleanConverter())));
-        DEFAULT_CONVERTERS.put(new AdapterKey(byte.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Byte.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(char.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Character.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(double.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Double.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(float.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Float.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(int.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Integer.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(long.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Long.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(short.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Short.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(boolean.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Boolean.class, String.class)));
-        DEFAULT_CONVERTERS.put(new AdapterKey(Locale.class, String.class), new LocaleConverter());
-    }
 
     private MapperConfig builderConfig = new MapperConfig();
 
     private JsonReaderFactory readerFactory;
     private JsonGeneratorFactory generatorFactory;
     private boolean supportHiddenAccess = true;
-    private int version = -1;
     private int maxSize = -1;
     private int bufferSize = -1;
     private String bufferStrategy;
     private Comparator<String> attributeOrder = null;
-    private final Map<AdapterKey, Adapter<?, ?>> adapters = new HashMap<AdapterKey, Adapter<?, ?>>(DEFAULT_CONVERTERS);
     private boolean supportConstructors;
     private boolean useGetterForCollections;
     private String accessModeName;
@@ -162,8 +110,6 @@ public class MapperBuilder {
         return new Mapper(
             readerFactory, generatorFactory,
             mapperConfig,
-            adapters,
-            version,
             attributeOrder,
             closeables);
     }
@@ -257,18 +203,18 @@ public class MapperBuilder {
 
     @Deprecated // use addAdapter
     public MapperBuilder addPropertyEditor(final Class<?> clazz, final Converter<?> converter) {
-        this.adapters.put(new AdapterKey(clazz, String.class), new ConverterAdapter(converter));
+        builderConfig.addAdapter(new AdapterKey(clazz, String.class), new ConverterAdapter(converter));
         return this;
     }
 
     @Deprecated // use addAdapter
     public MapperBuilder addConverter(final Type clazz, final Converter<?> converter) {
-        this.adapters.put(new AdapterKey(clazz, String.class), new ConverterAdapter(converter));
+        builderConfig.addAdapter(new AdapterKey(clazz, String.class), new ConverterAdapter(converter));
         return this;
     }
 
     public MapperBuilder addAdapter(final Type from, final Type to, final Adapter<?, ?> adapter) {
-        this.adapters.put(new AdapterKey(from, to), adapter);
+        builderConfig.addAdapter(new AdapterKey(from, to), adapter);
         return this;
     }
 
@@ -276,7 +222,7 @@ public class MapperBuilder {
         for (final Type gi : converter.getClass().getGenericInterfaces()) {
             if (ParameterizedType.class.isInstance(gi) && Adapter.class == ParameterizedType.class.cast(gi).getRawType()) {
                 final Type[] args = ParameterizedType.class.cast(gi).getActualTypeArguments();
-                this.adapters.put(new AdapterKey(args[0], args[1]), converter);
+                builderConfig.addAdapter(new AdapterKey(args[0], args[1]), converter);
                 return this;
             }
         }
@@ -284,7 +230,7 @@ public class MapperBuilder {
     }
 
     public MapperBuilder setVersion(final int version) {
-        this.version = version;
+        builderConfig.setVersion(version);
         return this;
     }
 
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java
index cb39a38a..39ee8cf7 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperConfig.java
@@ -18,16 +18,77 @@
  */
 package org.apache.johnzon.mapper;
 
+import java.lang.reflect.Type;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.URI;
+import java.net.URL;
 import java.nio.charset.Charset;
+import java.util.Date;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 import org.apache.johnzon.mapper.access.AccessMode;
+import org.apache.johnzon.mapper.converter.BigDecimalConverter;
+import org.apache.johnzon.mapper.converter.BigIntegerConverter;
+import org.apache.johnzon.mapper.converter.BooleanConverter;
+import org.apache.johnzon.mapper.converter.ByteConverter;
+import org.apache.johnzon.mapper.converter.CachedDelegateConverter;
+import org.apache.johnzon.mapper.converter.CharacterConverter;
+import org.apache.johnzon.mapper.converter.ClassConverter;
+import org.apache.johnzon.mapper.converter.DateConverter;
+import org.apache.johnzon.mapper.converter.DoubleConverter;
+import org.apache.johnzon.mapper.converter.EnumConverter;
+import org.apache.johnzon.mapper.converter.FloatConverter;
+import org.apache.johnzon.mapper.converter.IntegerConverter;
+import org.apache.johnzon.mapper.converter.LocaleConverter;
+import org.apache.johnzon.mapper.converter.LongConverter;
+import org.apache.johnzon.mapper.converter.ShortConverter;
+import org.apache.johnzon.mapper.converter.StringConverter;
+import org.apache.johnzon.mapper.converter.URIConverter;
+import org.apache.johnzon.mapper.converter.URLConverter;
+import org.apache.johnzon.mapper.internal.AdapterKey;
+import org.apache.johnzon.mapper.internal.ConverterAdapter;
 
 /**
  * Contains internal configuration for all the mapper stuff
  */
 class MapperConfig implements Cloneable {
+    private static final Map<AdapterKey, Adapter<?, ?>> DEFAULT_CONVERTERS = new HashMap<AdapterKey, Adapter<?, ?>>(23);
+    static {
+        //DEFAULT_CONVERTERS.put(Date.class, new DateConverter("yyyy-MM-dd'T'HH:mm:ssZ")); // ISO8601 long RFC822 zone
+        DEFAULT_CONVERTERS.put(new AdapterKey(Date.class, String.class), new ConverterAdapter<Date>(new DateConverter("yyyyMMddHHmmssZ"))); // ISO8601 short
+        DEFAULT_CONVERTERS.put(new AdapterKey(URL.class, String.class), new ConverterAdapter<URL>(new URLConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(URI.class, String.class), new ConverterAdapter<URI>(new URIConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Class.class, String.class), new ConverterAdapter<Class<?>>(new ClassConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(String.class, String.class), new ConverterAdapter<String>(new StringConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(BigDecimal.class, String.class), new ConverterAdapter<BigDecimal>(new BigDecimalConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(BigInteger.class, String.class), new ConverterAdapter<BigInteger>(new BigIntegerConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Byte.class, String.class), new ConverterAdapter<Byte>(new CachedDelegateConverter<Byte>(new ByteConverter())));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Character.class, String.class), new ConverterAdapter<Character>(new CharacterConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Double.class, String.class), new ConverterAdapter<Double>(new DoubleConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Float.class, String.class), new ConverterAdapter<Float>(new FloatConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Integer.class, String.class), new ConverterAdapter<Integer>(new IntegerConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Long.class, String.class), new ConverterAdapter<Long>(new LongConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Short.class, String.class), new ConverterAdapter<Short>(new ShortConverter()));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Boolean.class, String.class), new ConverterAdapter<Boolean>(new CachedDelegateConverter<Boolean>(new BooleanConverter())));
+        DEFAULT_CONVERTERS.put(new AdapterKey(byte.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Byte.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(char.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Character.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(double.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Double.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(float.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Float.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(int.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Integer.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(long.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Long.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(short.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Short.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(boolean.class, String.class), DEFAULT_CONVERTERS.get(new AdapterKey(Boolean.class, String.class)));
+        DEFAULT_CONVERTERS.put(new AdapterKey(Locale.class, String.class), new LocaleConverter());
+    }
+
+
+    private int version = -1;
+
     private boolean close = false;
     private boolean skipNull = true;
     private boolean skipEmptyArray = false;
@@ -38,6 +99,8 @@ class MapperConfig implements Cloneable {
     private boolean prettyPrint;
     private AccessMode accessMode;
     private Charset encoding = Charset.forName(System.getProperty("johnzon.mapper.encoding", "UTF-8"));
+    private ConcurrentMap<AdapterKey, Adapter<?, ?>> adapters = new ConcurrentHashMap<AdapterKey, Adapter<?, ?>>(DEFAULT_CONVERTERS);;
+
 
     //X TODO we need a more elaborated approache at the end, but for now it's fine
     private Map<Class<?>, ObjectConverter<?>> objectConverters = new HashMap<Class<?>, ObjectConverter<?>>();
@@ -134,6 +197,39 @@ class MapperConfig implements Cloneable {
         return objectConverters;
     }
 
+    public ConcurrentMap<AdapterKey, Adapter<?, ?>> getAdapters() {
+        return adapters;
+    }
+
+    void addAdapter(AdapterKey adapterKey, Adapter adapter) {
+        adapters.put(adapterKey, adapter);
+    }
+
+    public int getVersion() {
+        return version;
+    }
+
+    void setVersion(int version) {
+        this.version = version;
+    }
+
+    public Adapter findAdapter(final Type aClass) {
+        final Adapter<?, ?> converter = adapters.get(new AdapterKey(aClass, String.class));
+        if (converter != null) {
+            return converter;
+        }
+        if (Class.class.isInstance(aClass)) {
+            final Class<?> clazz = Class.class.cast(aClass);
+            if (clazz.isEnum()) {
+                final Adapter<?, ?> enumConverter = new ConverterAdapter(new EnumConverter(clazz));
+                adapters.putIfAbsent(new AdapterKey(String.class, aClass), enumConverter);
+                return enumConverter;
+            }
+        }
+        return null;
+    }
+
+
     @Override
     public MapperConfig clone() {
         try {
@@ -142,6 +238,4 @@ class MapperConfig implements Cloneable {
             return null;
         }
     }
-
-
 }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java
new file mode 100644
index 00000000..31295728
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingGeneratorImpl.java
@@ -0,0 +1,351 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.InvocationTargetException;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Collection;
+import java.util.Map;
+
+import javax.json.JsonValue;
+import javax.json.stream.JsonGenerator;
+import javax.xml.bind.DatatypeConverter;
+
+import org.apache.johnzon.mapper.internal.AdapterKey;
+
+public class MappingGeneratorImpl implements MappingGenerator {
+    private final MapperConfig config;
+    private final JsonGenerator generator;
+    protected final Mappings mappings;
+
+
+    MappingGeneratorImpl(MapperConfig config, JsonGenerator jsonGenerator, final Mappings mappings) {
+        this.config = config;
+        this.generator = jsonGenerator;
+        this.mappings = mappings;
+    }
+
+    @Override
+    public JsonGenerator getJsonGenerator() {
+        return generator;
+    }
+
+    @Override
+    public MappingGenerator writeObject(Object object) {
+        if (object == null) {
+            return this;
+        } else if (object instanceof JsonValue) {
+            generator.write((JsonValue) object);
+        } else {
+            doWriteObject(object);
+        }
+        return this;
+    }
+
+    private void doWriteObject(Object object) {
+        try {
+            if (object instanceof Map) {
+                generator.writeStartObject();
+                writeMapBody((Map<?, ?>) object, null);
+                generator.writeEnd();
+            }
+
+            if(writePrimitives(object)) {
+                return;
+            }
+
+            final Class<?> objectClass = object.getClass();
+            if (objectClass.isEnum()) {
+                final Adapter adapter = config.findAdapter(objectClass);
+                final String adaptedValue = adapter.from(object).toString(); // we know it ends as String for enums
+                generator.write(adaptedValue);
+                return;
+            }
+
+            generator.writeStartObject();
+            doWriteObjectBody(object);
+            generator.writeEnd();
+        } catch (final InvocationTargetException e) {
+            throw new MapperException(e);
+        } catch (final IllegalAccessException e) {
+            throw new MapperException(e);
+        }
+    }
+
+    private JsonGenerator writeMapBody(final Map<?, ?> object, final Adapter itemConverter) throws InvocationTargetException, IllegalAccessException {
+        for (final Map.Entry<?, ?> entry : ((Map<?, ?>) object).entrySet()) {
+            final Object value = entry.getValue();
+            final Object key = entry.getKey();
+
+            if (value == null) {
+                if (config.isSkipNull()) {
+                    continue;
+                } else {
+                    generator.writeNull(key == null ? "null" : key.toString());
+                    continue;
+                }
+            }
+
+            final Class<?> valueClass = value.getClass();
+            final boolean primitive = Mappings.isPrimitive(valueClass);
+            final boolean clazz = mappings.getClassMapping(valueClass) != null;
+            final boolean array = clazz || primitive ? false : valueClass.isArray();
+            final boolean collection = clazz || primitive || array ? false : Collection.class.isAssignableFrom(valueClass);
+            final boolean map = clazz || primitive || array || collection ? false : Map.class.isAssignableFrom(valueClass);
+            writeValue(valueClass,
+                    primitive, array, collection, map, itemConverter,
+                    key == null ? "null" : key.toString(), value);
+        }
+        return generator;
+    }
+
+    /**
+     * @return {@code true} if it was a primitive, {@code false} if the value did not get handled
+     */
+    private boolean writePrimitives(final Object value) {
+        boolean handled = false;
+        if (value == null) {
+            return true; // fake a write
+        }
+
+        final Class<?> type = value.getClass();
+        if (type == String.class) {
+            generator.write(value.toString());
+            handled = true;
+        } else if (type == long.class || type == Long.class) {
+            generator.write(Long.class.cast(value).longValue());
+            handled = true;
+        } else if (isInt(type)) {
+            generator.write(Number.class.cast(value).intValue());
+            handled = true;
+        } else if (isFloat(type)) {
+            final double doubleValue = Number.class.cast(value).doubleValue();
+            if (!Double.isNaN(doubleValue)) {
+                generator.write(doubleValue);
+            }
+            handled = true;
+        } else if (type == boolean.class || type == Boolean.class) {
+            generator.write(Boolean.class.cast(value));
+            return true;
+        } else if (type == BigDecimal.class) {
+            generator.write(BigDecimal.class.cast(value));
+            handled = true;
+        } else if (type == BigInteger.class) {
+            generator.write(BigInteger.class.cast(value));
+            handled = true;
+        } else if (type == char.class || type == Character.class) {
+            generator.write(Character.class.cast(value).toString());
+            handled = true;
+        }
+        return handled;
+    }
+
+    private boolean writePrimitives(final String key, final Class<?> type, final Object value) {
+        boolean handled = false;
+        if (type == String.class) {
+            generator.write(key, value.toString());
+            handled = true;
+        } else if (type == long.class || type == Long.class) {
+            generator.write(key, Long.class.cast(value).longValue());
+            handled = true;
+        } else if (isInt(type)) {
+            generator.write(key, Number.class.cast(value).intValue());
+            handled = true;
+        } else if (isFloat(type)) {
+            final double doubleValue = Number.class.cast(value).doubleValue();
+            if (!Double.isNaN(doubleValue)) {
+                generator.write(key, doubleValue);
+            }
+            handled = true;
+        } else if (type == boolean.class || type == Boolean.class) {
+            generator.write(key, Boolean.class.cast(value));
+            handled = true;
+        } else if (type == BigDecimal.class) {
+            generator.write(key, BigDecimal.class.cast(value));
+            handled = true;
+        } else if (type == BigInteger.class) {
+            generator.write(key, BigInteger.class.cast(value));
+            handled = true;
+        } else if (type == char.class || type == Character.class) {
+            generator.write(key, Character.class.cast(value).toString());
+            handled = true;
+        }
+        return handled;
+    }
+
+
+    private static boolean isInt(final Class<?> type) {
+        return type == int.class || type == Integer.class
+                || type == byte.class || type == Byte.class
+                || type == short.class || type == Short.class;
+    }
+
+    private static boolean isFloat(final Class<?> type) {
+        return type == double.class || type == Double.class
+                || type == float.class || type == Float.class;
+    }
+
+
+    private JsonGenerator doWriteObjectBody(final Object object) throws IllegalAccessException, InvocationTargetException {
+        final Class<?> objectClass = object.getClass();
+        final Mappings.ClassMapping classMapping = mappings.findOrCreateClassMapping(objectClass);
+        if (classMapping == null) {
+            throw new MapperException("No mapping for " + objectClass.getName());
+        }
+
+        for (final Map.Entry<String, Mappings.Getter> getterEntry : classMapping.getters.entrySet()) {
+            final Mappings.Getter getter = getterEntry.getValue();
+            if (getter.version >= 0 && config.getVersion() >= getter.version) {
+                continue;
+            }
+
+            final Object value = getter.reader.read(object);
+            if (JsonValue.class.isInstance(value)) {
+                generator.write(getterEntry.getKey(), JsonValue.class.cast(value));
+                continue;
+            }
+
+            if (value == null) {
+                if (config.isSkipNull() && !getter.reader.isNillable()) {
+                    continue;
+                } else {
+                    generator.writeNull(getterEntry.getKey());
+                    continue;
+                }
+            }
+
+            final Object val = getter.converter == null ? value : getter.converter.from(value);
+
+            writeValue(val.getClass(),
+                    getter.primitive, getter.array,
+                    getter.collection, getter.map,
+                    getter.itemConverter,
+                    getterEntry.getKey(),
+                    val);
+        }
+        return generator;
+    }
+
+    private void writeValue(final Class<?> type,
+                            final boolean primitive, final boolean array,
+                            final boolean collection, final boolean map,
+                            final Adapter itemConverter,
+                            final String key, final Object value) throws InvocationTargetException, IllegalAccessException {
+        if (array) {
+            final int length = Array.getLength(value);
+            if (length == 0 && config.isSkipEmptyArray()) {
+                return;
+            }
+
+            if(config.isTreatByteArrayAsBase64() && (type == byte[].class /*|| type == Byte[].class*/)) {
+                String base64EncodedByteArray = DatatypeConverter.printBase64Binary((byte[]) value);
+                generator.write(key, base64EncodedByteArray);
+                return;
+            }
+            if(config.isTreatByteArrayAsBase64URL() && (type == byte[].class /*|| type == Byte[].class*/)) {
+                generator.write(key, String.valueOf(Adapter.class.cast(config.getAdapters().get(new AdapterKey(byte[].class, String.class))).to(value)));
+                return;
+            }
+
+            generator.writeStartArray(key);
+            for (int i = 0; i < length; i++) {
+                final Object o = Array.get(value, i);
+                writeItem(itemConverter != null ? itemConverter.from(o) : o);
+            }
+            generator.writeEnd();
+            return;
+        } else if (collection) {
+            generator.writeStartArray(key);
+            for (final Object o : Collection.class.cast(value)) {
+                writeItem(itemConverter != null ? itemConverter.from(o) : o);
+            }
+            generator.writeEnd();
+            return;
+        } else if (map) {
+            generator.writeStartObject(key);
+            writeMapBody((Map<?, ?>) value, itemConverter);
+            generator.writeEnd();
+            return;
+        } else if (primitive) {
+            writePrimitives(key, type, value);
+            return;
+        } else {
+            final Adapter converter = config.findAdapter(type);
+            if (converter != null) {
+                final Object adapted = doConvertFrom(value, converter);
+                if (writePrimitives(key, adapted.getClass(), adapted)) {
+                    return;
+                }
+                writeValue(String.class, true, false, false, false, null, key, adapted);
+                return;
+            }
+            generator.writeStartObject(key);
+            doWriteObjectBody(value);
+            generator.writeEnd();
+        }
+    }
+
+    private void writeItem(final Object o) {
+        if (!writePrimitives(o)) {
+            if (Collection.class.isInstance(o)) {
+                doWriteArray(Collection.class.cast(o));
+            } else if (o != null && o.getClass().isArray()) {
+                final int length = Array.getLength(o);
+                if (length > 0 || !config.isSkipEmptyArray()) {
+                    generator.writeStartArray();
+                    for (int i = 0; i < length; i++) {
+                        writeItem(Array.get(o, i));
+                    }
+                    generator.writeEnd();
+                }
+            } else if (o == null) {
+                generator.writeNull();
+            } else {
+                doWriteObject(o);
+            }
+        }
+    }
+
+    private <T> void doWriteArray(final Collection<T> object) {
+        if (object == null) {
+            generator.writeStartArray().writeEnd();
+        } else {
+            generator.writeStartArray();
+            for (final T t : object) {
+                if (JsonValue.class.isInstance(t)) {
+                    generator.write(JsonValue.class.cast(t));
+                } else {
+                    writeItem(t);
+                }
+            }
+            generator.writeEnd();
+        }
+    }
+
+
+    private <T> Object doConvertFrom(final T value, final Adapter<T, Object> converter) {
+        if (converter == null) {
+            throw new MapperException("can't convert " + value + " to String");
+        }
+        return converter.from(value);
+    }
+
+}
