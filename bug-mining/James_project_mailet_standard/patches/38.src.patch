diff --git a/mailet/standard/src/main/java/org/apache/james/transport/matchers/AttachmentFileNameIs.java b/mailet/standard/src/main/java/org/apache/james/transport/matchers/AttachmentFileNameIs.java
index f0987cf620..57ee6337f3 100755
--- a/mailet/standard/src/main/java/org/apache/james/transport/matchers/AttachmentFileNameIs.java
+++ b/mailet/standard/src/main/java/org/apache/james/transport/matchers/AttachmentFileNameIs.java
@@ -36,12 +36,14 @@ import javax.mail.Part;
 import javax.mail.internet.MimeMessage;
 
 import org.apache.james.core.MailAddress;
-import org.apache.mailet.Experimental;
+import org.apache.james.mime4j.codec.DecodeMonitor;
+import org.apache.james.mime4j.codec.DecoderUtil;
 import org.apache.mailet.Mail;
 import org.apache.mailet.base.GenericMatcher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.common.annotations.VisibleForTesting;
 
 /**
  * <P>Checks if at least one attachment has a file name which matches any
@@ -57,7 +59,6 @@ import org.slf4j.LoggerFactory;
  * @version CVS $Revision$ $Date$
  * @since 2.2.0
  */
-@Experimental
 public class AttachmentFileNameIs extends GenericMatcher {
     private static final Logger LOGGER = LoggerFactory.getLogger(AttachmentFileNameIs.class);
     
@@ -84,13 +85,15 @@ public class AttachmentFileNameIs extends GenericMatcher {
     /**
      * Controls certain log messages.
      */
-    protected boolean isDebug = false;
+    @VisibleForTesting
+    boolean isDebug = false;
 
     /** contains ParsedMask instances, setup by init */
     private Mask[] masks = null;
     
     /** True if unzip is requested. */
-    protected boolean unzipIsRequested;
+    @VisibleForTesting
+    boolean unzipIsRequested;
     
 
     @Override
@@ -129,7 +132,6 @@ public class AttachmentFileNameIs extends GenericMatcher {
 
     /** 
      * Either every recipient is matching or neither of them.
-     * @param mail
      * @throws MessagingException if no matching attachment is found and at least one exception was thrown
      */
     @Override
@@ -245,7 +247,6 @@ public class AttachmentFileNameIs extends GenericMatcher {
      *@param part
      */
     protected boolean matchFoundInZip(Part part) throws MessagingException, IOException {
-
         try (ZipInputStream zis = new ZipInputStream(part.getInputStream())) {
             while (true) {
                 ZipEntry zipEntry = zis.getNextEntry();
@@ -266,11 +267,10 @@ public class AttachmentFileNameIs extends GenericMatcher {
 
     /**
      * Transforms <I>fileName<I> in a trimmed lowercase string usable for matching agains the masks.
-     *
-     * @param fileName
+     * Also decode encoded words.
      */
     protected String cleanFileName(String fileName) {
-        return fileName.toLowerCase(Locale.US).trim();
+        return DecoderUtil.decodeEncodedWords(fileName.toLowerCase(Locale.US).trim(), DecodeMonitor.SILENT);
     }
 }
 
diff --git a/mailet/standard/src/test/java/org/apache/james/transport/matchers/AttachmentFileNameIsTest.java b/mailet/standard/src/test/java/org/apache/james/transport/matchers/AttachmentFileNameIsTest.java
new file mode 100644
index 0000000000..7261bb9260
--- /dev/null
+++ b/mailet/standard/src/test/java/org/apache/james/transport/matchers/AttachmentFileNameIsTest.java
@@ -0,0 +1,586 @@
+/****************************************************************
+ * Licensed to the Apache Software Foundation (ASF) under one   *
+ * or more contributor license agreements.  See the NOTICE file *
+ * distributed with this work for additional information        *
+ * regarding copyright ownership.  The ASF licenses this file   *
+ * to you under the Apache License, Version 2.0 (the            *
+ * "License"); you may not use this file except in compliance   *
+ * with the License.  You may obtain a copy of the License at   *
+ *                                                              *
+ *   http://www.apache.org/licenses/LICENSE-2.0                 *
+ *                                                              *
+ * Unless required by applicable law or agreed to in writing,   *
+ * software distributed under the License is distributed on an  *
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+ * KIND, either express or implied.  See the License for the    *
+ * specific language governing permissions and limitations      *
+ * under the License.                                           *
+ ****************************************************************/
+
+package org.apache.james.transport.matchers;
+
+import static org.apache.mailet.base.MailAddressFixture.ANY_AT_JAMES;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.apache.james.core.builder.MimeMessageBuilder;
+import org.apache.james.util.ClassLoaderUtils;
+import org.apache.mailet.Mail;
+import org.apache.mailet.base.test.FakeMail;
+import org.apache.mailet.base.test.FakeMatcherConfig;
+import org.junit.jupiter.api.Test;
+
+class AttachmentFileNameIsTest {
+    @Test
+    void shouldMatchWhenMultipartMixedAndRightFileName() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithBodyParts(
+                    MimeMessageBuilder.bodyPartBuilder()
+                        .disposition("attachment")
+                        .filename("xxx.zip")))
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("xxx.zip")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldNotMatchWhenMultipartMixedAndWrongFileName() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithBodyParts(
+                    MimeMessageBuilder.bodyPartBuilder()
+                        .disposition("attachment")
+                        .filename("xxx.zip")))
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("yyy.zip")
+            .build());
+
+        assertThat(testee.match(mail))
+            .isNull();
+    }
+
+    @Test
+    void shouldMatchRecursively() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setContent(MimeMessageBuilder.multipartBuilder()
+                    .addBodies(MimeMessageBuilder.bodyPartBuilder()
+                        .data(MimeMessageBuilder.multipartBuilder()
+                            .addBody(MimeMessageBuilder.bodyPartBuilder()
+                                .disposition("attachment")
+                                .filename("xxx.zip"))
+                            .build()
+                        )))
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("xxx.zip")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldIgnoreMultipartAlternative() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setContent(MimeMessageBuilder.multipartBuilder()
+                    .subType("alternative")
+                    .addBody(MimeMessageBuilder.bodyPartBuilder()
+                        .disposition("attachment")
+                        .filename("xxx.zip")))
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("xxx.zip")
+            .build());
+
+        assertThat(testee.match(mail))
+            .isNull();
+    }
+
+    @Test
+    void shouldMatchSingleBody() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "attachment")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldSupportWildcardPrefix() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "attachment")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("*.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void doNotSupportSuffix() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "attachment")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file*")
+            .build());
+
+        assertThat(testee.match(mail))
+            .isNull();
+    }
+
+    @Test
+    void supportComaSeparatedValues() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "attachment")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("any.zip,*.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void supportSpaceSeparatedValues() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "attachment")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("any.zip,*.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void supportComaSpaceSeparatedValues() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "attachment")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("any.zip, *.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldNotMatchInNestedMessages() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithSubMessage(MimeMessageBuilder.mimeMessageBuilder()
+                    .setText("abc", "text/plain; name=\"file.txt\"")
+                    .addHeader("Content-Disposition", "attachment"))
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .isNull();
+    }
+
+    @Test
+    void shouldMatchNestedMessages() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithSubMessage(MimeMessageBuilder.mimeMessageBuilder()
+                    .setText("abc", "text/plain; name=\"file.txt\"")
+                    .addHeader("Content-Disposition", "attachment"))
+                .addHeader("Content-Disposition", "attachment; filename=\"msg.eml\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("msg.eml")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldMatchInline() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain; name=\"file.txt\"")
+                .addHeader("Content-Disposition", "inline")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldMatchWhenFileNameIsOnContentDisposition() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain")
+                .addHeader("Content-Disposition", "attachment; filename=\"file.txt\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldBeCaseInsensitive() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain")
+                .addHeader("Content-Disposition", "attachment; filename=\"FiLe.txt\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("fIlE.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldSupportMultilineFilename() throws Exception {
+        /*
+        Content-Type: text/plain;
+	      name*0=fiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii;
+	      name*1=iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiile;
+	      name*2=.txt; charset=us-ascii
+         */
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain;\r\n name=\"fiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiile.txt\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("fiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiile.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldSupportTrimming() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain")
+                .addHeader("Content-Disposition", "attachment; filename=\"  file.txt\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldSupportQEncoding() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain")
+                .addHeader("Content-Disposition", "attachment; filename=\"=?US-ASCII?Q?IHE=5FXDM.zip?=\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("IHE_XDM.zip")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void conditionShouldSupportQEncoding() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setText("abc", "text/plain")
+                .addHeader("Content-Disposition", "attachment; filename=\"=?ISO-8859-1?Q?2023_avis_d'=E9ch=E9ance_vakant_facture.pdf?=\"")
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("=?ISO-8859-1?Q?2023_avis_d'=E9ch=E9ance_vakant_facture.pdf?=")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void shouldLookupIntoZipEntryWhenRequested() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithBodyParts(MimeMessageBuilder.bodyPartBuilder()
+                    .filename("sonde.zip")
+                    .data(ClassLoaderUtils.getSystemResourceAsByteArray("sonde.zip")))
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("-z sonde.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .containsOnly(ANY_AT_JAMES);
+    }
+
+    @Test
+    void zipNestingIsNotSupported() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithBodyParts(MimeMessageBuilder.bodyPartBuilder()
+                    .filename("sonde.zip")
+                    .data(ClassLoaderUtils.getSystemResourceAsByteArray("nested.zip")))
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("-z sonde.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .isNull();
+    }
+
+    @Test
+    void shouldLookupIntoZipEntryOnlyWhenRequested() throws Exception {
+        Mail mail =  FakeMail.builder()
+            .name("mail")
+            .recipient(ANY_AT_JAMES)
+            .mimeMessage(MimeMessageBuilder.mimeMessageBuilder()
+                .setMultipartWithBodyParts(MimeMessageBuilder.bodyPartBuilder()
+                    .filename("sonde.zip")
+                    .data(ClassLoaderUtils.getSystemResourceAsByteArray("sonde.zip")))
+                .build())
+            .build();
+
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("sonde.txt")
+            .build());
+
+        assertThat(testee.match(mail))
+            .isNull();
+    }
+
+    @Test
+    void shouldSupportDebugMode() throws Exception {
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("-d file.txt")
+            .build());
+
+        assertThat(testee.isDebug).isTrue();
+    }
+
+    @Test
+    void debugModeShouldBeFalseByDefault() throws Exception {
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.isDebug).isFalse();
+    }
+
+    @Test
+    void shouldSupportUnzipMode() throws Exception {
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("-z file.txt")
+            .build());
+
+        assertThat(testee.unzipIsRequested).isTrue();
+    }
+
+    @Test
+    void unzipModeShouldBeFalseByDefault() throws Exception {
+        AttachmentFileNameIs testee = new AttachmentFileNameIs();
+
+        testee.init(FakeMatcherConfig.builder()
+            .matcherName("AttachmentFileNameIs")
+            .condition("file.txt")
+            .build());
+
+        assertThat(testee.unzipIsRequested).isFalse();
+    }
+}
\ No newline at end of file
diff --git a/mailet/standard/src/test/resources/nested.zip b/mailet/standard/src/test/resources/nested.zip
new file mode 100644
index 0000000000..3fa62a4bbc
Binary files /dev/null and b/mailet/standard/src/test/resources/nested.zip differ
diff --git a/mailet/standard/src/test/resources/sonde.zip b/mailet/standard/src/test/resources/sonde.zip
new file mode 100644
index 0000000000..3b5af5c7c6
Binary files /dev/null and b/mailet/standard/src/test/resources/sonde.zip differ
