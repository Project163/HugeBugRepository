diff --git a/src/main/java/org/apache/commons/jexl3/JexlOperator.java b/src/main/java/org/apache/commons/jexl3/JexlOperator.java
index 1332d1b1..5bc448ef 100644
--- a/src/main/java/org/apache/commons/jexl3/JexlOperator.java
+++ b/src/main/java/org/apache/commons/jexl3/JexlOperator.java
@@ -26,10 +26,15 @@ package org.apache.commons.jexl3;
  * For instance, '+' is associated to 'T add(L x, R y)'.</p>
  *
  * <p>The default JexlArithmetic implements generic versions of these methods using Object as arguments.
- * You can use your own derived JexlArithmetic that override and/or overload those operator methods; these methods
- * must be public,
- * must respect the return type when primitive
- * and may be overloaded multiple times with different signatures.</p>
+ * You can use your own derived JexlArithmetic that override and/or overload those operator methods.
+ * Note that these are overloads by convention, not actual Java overloads.
+ * The following rules apply to operator methods:</p>
+ * <ul>
+ * <li>Operator methods should be public</li>
+ * <li>Operators return type should be respected when primitive (int, boolean,...)</li>
+ * <li>Operators may be overloaded multiple times with different signatures</li>
+ * <li>Operators may return JexlEngine.TRY_AGAIN to fallback on default JEXL implementation</li>
+ * </ul>
  *
  * @since 3.0
  */
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
index 46d692bb..89db12a8 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Interpreter.java
@@ -24,12 +24,10 @@ import org.apache.commons.jexl3.JexlEngine;
 import org.apache.commons.jexl3.JexlException;
 import org.apache.commons.jexl3.JexlOperator;
 import org.apache.commons.jexl3.JexlScript;
-
 import org.apache.commons.jexl3.introspection.JexlMethod;
 import org.apache.commons.jexl3.introspection.JexlPropertyGet;
 import org.apache.commons.jexl3.introspection.JexlPropertySet;
 import org.apache.commons.jexl3.introspection.JexlUberspect.PropertyResolver;
-
 import org.apache.commons.jexl3.parser.ASTAddNode;
 import org.apache.commons.jexl3.parser.ASTAndNode;
 import org.apache.commons.jexl3.parser.ASTAnnotatedStatement;
@@ -134,6 +132,12 @@ public class Interpreter extends InterpreterBase {
     /** The map of dynamically creates namespaces, NamespaceFunctor or duck-types of those. */
     protected Map<String, Object> functors;
 
+    /**
+     * The thread local interpreter.
+     */
+    protected static final java.lang.ThreadLocal<Interpreter> INTER =
+                       new java.lang.ThreadLocal<Interpreter>();
+
     /**
      * Creates an interpreter.
      * @param engine   the engine creating this interpreter
@@ -168,6 +172,25 @@ public class Interpreter extends InterpreterBase {
         functions = ii.functions;
         functors = ii.functors;
     }
+    
+    /**
+     * @return the current interpreter frame
+     */
+    static Scope.Frame getCurrentFrame() {
+        Interpreter inter = INTER.get();
+        return inter != null? inter.frame : null;
+    }
+        
+    /**
+     * Swaps the current thread local interpreter.
+     * @param inter the interpreter or null
+     * @return the previous thread local interpreter
+     */
+    protected Interpreter putThreadInterpreter(Interpreter inter) {
+        Interpreter pinter = INTER.get();
+        INTER.set(inter);
+        return pinter;
+    }
 
     /**
      * Interpret the given script/expression.
@@ -181,8 +204,10 @@ public class Interpreter extends InterpreterBase {
     public Object interpret(JexlNode node) {
         JexlContext.ThreadLocal tcontext = null;
         JexlEngine tjexl = null;
+        Interpreter tinter = null;
         try {
             cancelCheck(node);
+            tinter = putThreadInterpreter(this);
             if (context instanceof JexlContext.ThreadLocal) {
                 tcontext = jexl.putThreadLocal((JexlContext.ThreadLocal) context);
             }
@@ -218,6 +243,7 @@ public class Interpreter extends InterpreterBase {
             if (context instanceof JexlContext.ThreadLocal) {
                 jexl.putThreadLocal(tcontext);
             }
+            putThreadInterpreter(tinter);
         }
         return null;
     }
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Scope.java b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
index f5bef11a..0625daf5 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Scope.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Scope.java
@@ -109,7 +109,7 @@ public final class Scope {
     private Integer getSymbol(String name, boolean hoist) {
         Integer register = namedVariables != null ? namedVariables.get(name) : null;
         if (register == null && hoist && parent != null) {
-            Integer pr = parent.getSymbol(name, false);
+            Integer pr = parent.getSymbol(name, true);
             if (pr != null) {
                 if (hoistedVariables == null) {
                     hoistedVariables = new LinkedHashMap<Integer, Integer>();
diff --git a/src/main/java/org/apache/commons/jexl3/internal/Script.java b/src/main/java/org/apache/commons/jexl3/internal/Script.java
index eeb727f9..9cf4343e 100644
--- a/src/main/java/org/apache/commons/jexl3/internal/Script.java
+++ b/src/main/java/org/apache/commons/jexl3/internal/Script.java
@@ -124,15 +124,26 @@ public class Script implements JexlScript, JexlExpression {
     public String getParsedText() {
         return getParsedText(2);
     }
-
+    
     @Override
     public String getParsedText(int indent) {
         Debugger debug = new Debugger();
         debug.setIndentation(indent);
-        debug.debug(script);
+        debug.debug(script, false);
         return debug.toString();
     }
 
+    @Override
+    public String toString() {
+        CharSequence src = source;
+        if (src == null) {
+            Debugger debug = new Debugger();
+            debug.debug(script, false);
+            src = debug.toString();
+        }
+        return src.toString();
+    }
+
     @Override
     public int hashCode() {
         // CSOFF: Magic number
@@ -161,17 +172,6 @@ public class Script implements JexlScript, JexlExpression {
         return true;
     }
 
-    @Override
-    public String toString() {
-        CharSequence src = source;
-        if (src == null) {
-            Debugger debug = new Debugger();
-            debug.debug(script);
-            src = debug.toString();
-        }
-        return src.toString();
-    }
-
     @Override
     public Object evaluate(JexlContext context) {
         return execute(context);
@@ -211,10 +211,11 @@ public class Script implements JexlScript, JexlExpression {
             if (sf != null) {
                 frame = sf.assign(args);
             } else {
-                frame = script.createFrame(args);
+                sf = Interpreter.getCurrentFrame();
+                frame = script.createFrame(sf, args);
             }
         }
-
+        
         @Override
         protected Scope.Frame createFrame(Object[] args) {
             return frame != null? frame.assign(args) : super.createFrame(args);
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java
index c6688535..e57f5868 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlLambda.java
@@ -16,8 +16,6 @@
  */
 package org.apache.commons.jexl3.parser;
 
-import org.apache.commons.jexl3.internal.Scope;
-
 /**
  * Lambda (function).
  */
@@ -36,20 +34,4 @@ public final class ASTJexlLambda extends ASTJexlScript {
     public boolean isTopLevel() {
         return jjtGetParent() == null;
     }
-
-    /**
-     * Creates an array of arguments by copying values up to the number of parameters.
-     * @param frame the calling frame
-     * @param values the argument values
-     * @return the arguments array
-     */
-    public Scope.Frame createFrame(Scope.Frame frame, Object... values) {
-        if (getScope() != null) {
-            Scope.Frame cframe = getScope().createFrame(frame);
-            if (cframe != null) {
-                return cframe.assign(values);
-            }
-        }
-        return null;
-    }
 }
diff --git a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
index 8dd89473..74c7bbc9 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/ASTJexlScript.java
@@ -59,7 +59,7 @@ public class ASTJexlScript extends JexlNode {
     }
       /**
      * Sets this script pragmas.
-     * @param pragmas the pragmas
+     * @param thePragmas the pragmas
      */
     public void setPragmas(Map<String, Object> thePragmas) {
         this.pragmas = thePragmas;
@@ -104,18 +104,28 @@ public class ASTJexlScript extends JexlNode {
 
     /**
      * Creates an array of arguments by copying values up to the number of parameters.
+     * @param caller the calling frame
      * @param values the argument values
      * @return the arguments array
      */
-    public Scope.Frame createFrame(Object... values) {
+    public Scope.Frame createFrame(Scope.Frame caller, Object... values) {
         if (scope != null) {
-            Scope.Frame frame = scope.createFrame(null);
+            Scope.Frame frame = scope.createFrame(caller);
             if (frame != null) {
                 return frame.assign(values);
             }
         }
         return null;
     }
+    
+    /**
+     * Creates an array of arguments by copying values up to the number of parameters.
+     * @param values the argument values
+     * @return the arguments array
+     */
+    public Scope.Frame createFrame(Object... values) {
+        return createFrame(null, values);
+    }
 
     /**
      * Gets the (maximum) number of arguments this script expects.
diff --git a/src/test/java/org/apache/commons/jexl3/Issues200Test.java b/src/test/java/org/apache/commons/jexl3/Issues200Test.java
index 31fb8f8f..7d4d47f8 100644
--- a/src/test/java/org/apache/commons/jexl3/Issues200Test.java
+++ b/src/test/java/org/apache/commons/jexl3/Issues200Test.java
@@ -652,5 +652,39 @@ public class Issues200Test extends JexlTestCase {
         result = script.execute(ctxt);
         Assert.assertTrue(result instanceof JexlScript);
     }
+         
+    @Test
+    public void test270() throws Exception {
+        JexlEngine jexl = new JexlBuilder().create();
+        JexlScript base = jexl.createScript("(x, y, z)->{ x + y + z }");
+        String text = base.toString();
+        JexlScript script = base.curry(5, 15);
+        Assert.assertEquals(text, script.toString());
+
+        JexlEvalContext ctxt = new JexlEvalContext();
+        ctxt.set("s", base);
+        script = jexl.createScript("return s");
+        Object result = script.execute(ctxt);
+        Assert.assertEquals(text, result.toString());
+
+        script = jexl.createScript("return s.curry(1)");
+        result = script.execute(ctxt);
+        Assert.assertEquals(text, result.toString());
+    }
         
+    @Test
+    public void test271a() throws Exception {
+        JexlEngine jexl = new JexlBuilder().strict(false).create();
+        JexlScript base = jexl.createScript("var base = 1; var x = (a)->{ var y = (b) -> {base + b}; return base + y(a)}; x(40)");
+        Object result = base.execute(null);
+        Assert.assertEquals(42, result);
+    }
+
+    @Test
+    public void test271b() throws Exception {
+        JexlEngine jexl = new JexlBuilder().strict(false).create();
+        JexlScript base = jexl.createScript("var base = 2; var sum = (x, y, z)->{ base + x + y + z }; var y = sum.curry(1); y(2,3)");
+        Object result = base.execute(null);
+        Assert.assertEquals(8, result);
+    }
 }
