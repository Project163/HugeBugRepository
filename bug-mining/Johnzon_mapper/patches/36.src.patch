diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index c8a163ea..5935c367 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -39,6 +39,7 @@ import java.io.Writer;
 import java.lang.reflect.Array;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.concurrent.ConcurrentHashMap;
@@ -56,6 +57,7 @@ public class Mapper implements Closeable {
     protected final ConcurrentMap<Adapter<?, ?>, AdapterKey> reverseAdaptersRegistry = new ConcurrentHashMap<Adapter<?, ?>, AdapterKey>();
     protected final ReaderHandler readerHandler;
     protected final Collection<Closeable> closeables;
+    protected final Charset charset;
 
     Mapper(final JsonReaderFactory readerFactory, final JsonGeneratorFactory generatorFactory, MapperConfig config,
                   final Collection<Closeable> closeables) {
@@ -65,6 +67,7 @@ public class Mapper implements Closeable {
         this.mappings = new Mappings(config);
         this.readerHandler = ReaderHandler.create(readerFactory);
         this.closeables = closeables;
+        this.charset = config.getEncoding() == null ? null : config.getEncoding();
     }
 
 
@@ -131,7 +134,7 @@ public class Mapper implements Closeable {
         writeObject(object, generator);
     }
 
-    private void writeObject(Object object, JsonGenerator generator) {
+    private void writeObject(final Object object, final JsonGenerator generator) {
         MappingGeneratorImpl mappingGenerator = new MappingGeneratorImpl(config, generator, mappings);
 
         RuntimeException originalException = null;
@@ -183,11 +186,11 @@ public class Mapper implements Closeable {
     }
 
     public <T> T readObject(final InputStream stream, final Type clazz) {
-        return mapObject(clazz, readerFactory.createReader(stream(stream)));
+        return mapObject(clazz, charset == null ? readerFactory.createReader(stream(stream)): readerFactory.createReader(stream(stream), charset));
     }
 
     public <T> Collection<T> readCollection(final InputStream stream, final ParameterizedType genericType) {
-        return mapObject(genericType, readerFactory.createReader(stream(stream)));
+        return mapObject(genericType, charset == null ? readerFactory.createReader(stream(stream)): readerFactory.createReader(stream(stream), charset));
     }
 
     public <T> T readJohnzonCollection(final InputStream stream, final JohnzonCollectionType<T> genericType) {
@@ -208,7 +211,7 @@ public class Mapper implements Closeable {
     }
 
     public <T> T readTypedArray(final InputStream stream, final Class<?> elementType, final Class<T> arrayType) {
-        final JsonReader reader = readerFactory.createReader(stream(stream));
+        final JsonReader reader = charset == null ? readerFactory.createReader(stream(stream)): readerFactory.createReader(stream(stream), charset);
         return arrayType.cast(mapArray(elementType, reader));
     }
 
@@ -218,7 +221,7 @@ public class Mapper implements Closeable {
     }
 
     public <T> T[] readArray(final InputStream stream, final Class<T> clazz) {
-        final JsonReader reader = readerFactory.createReader(stream(stream));
+        final JsonReader reader = charset == null ? readerFactory.createReader(stream(stream)): readerFactory.createReader(stream(stream), charset);
         return (T[]) mapArray(clazz, reader);
     }
 
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
index ae1eea63..8640863b 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
@@ -64,6 +64,8 @@ import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
+import static java.util.Arrays.asList;
+
 /**
  * This class is not concurrently usable as it contains state.
  */
@@ -121,7 +123,7 @@ public class MappingParserImpl implements MappingParser {
         if (JsonObject.class.isInstance(jsonValue)) {
             return (T) buildObject(targetType, JsonObject.class.cast(jsonValue), applyObjectConverter);
         }
-        if (JsonString.class.isInstance(jsonValue) && targetType == String.class) {
+        if (JsonString.class.isInstance(jsonValue) && (targetType == String.class || targetType == Object.class)) {
             return (T) JsonString.class.cast(jsonValue).getString();
         }
         if (JsonNumber.class.isInstance(jsonValue)) {
@@ -132,7 +134,7 @@ public class MappingParserImpl implements MappingParser {
             if (targetType == long.class || targetType == Long.class) {
                 return (T) Long.valueOf(number.longValue());
             }
-            if (targetType == double.class || targetType == Double.class) {
+            if (targetType == double.class || targetType == Double.class || targetType == Object.class) {
                 return (T) Double.valueOf(number.doubleValue());
             }
             if (targetType == BigDecimal.class) {
@@ -157,16 +159,18 @@ public class MappingParserImpl implements MappingParser {
                 }
 
                 return (T) mapCollection(mapping, jsonArray, null);
-
+            }
+            if (Object.class == targetType) {
+                return (T) new ArrayList(asList(Object[].class.cast(buildArrayWithComponentType(jsonArray, Object.class, null))));
             }
         }
         if (JsonValue.NULL == jsonValue) {
             return null;
         }
-        if (JsonValue.TRUE == jsonValue && (Boolean.class == targetType || boolean.class == targetType)) {
+        if (JsonValue.TRUE == jsonValue && (Boolean.class == targetType || boolean.class == targetType || Object.class == targetType)) {
             return (T) Boolean.TRUE;
         }
-        if (JsonValue.FALSE == jsonValue && (Boolean.class == targetType || boolean.class == targetType)) {
+        if (JsonValue.FALSE == jsonValue && (Boolean.class == targetType || boolean.class == targetType || Object.class == targetType)) {
             return (T) Boolean.FALSE;
         }
         throw new IllegalArgumentException("Unsupported " + jsonValue + " for type " + targetType);
diff --git a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
index 8b3d25d9..8da2388e 100644
--- a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
+++ b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
@@ -33,6 +33,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -157,6 +158,35 @@ public class MapperTest {
         assertOneDimension(k, 5);
     }
 
+    @Test
+    public void readMapWithJustObject() {
+        { // object
+            final Object raw = new MapperBuilder().build()
+                    .readObject(new ByteArrayInputStream(("{\"a\":1,\"b\":true,\"c\":null,\"d\":[1, 2], " +
+                                    "\"e\":[\"i\", \"j\"],\"k\":{\"a\":1,\"b\":true,\"c\":null,\"d\":[1, 2], \"e\":[\"i\", \"j\"]}}").getBytes()),
+                            Object.class);
+            final Map<String, Object> data = Map.class.cast(raw);
+            assertOneDimension(data, 6);
+
+            final Map<String, Object> k = (Map<String, Object>) data.get("k");
+            assertNotNull(k);
+            assertOneDimension(k, 5);
+        }
+        { // primitives
+            assertEquals(Boolean.TRUE, new MapperBuilder().build().readObject(new ByteArrayInputStream("true".getBytes()), Object.class));
+            assertEquals(Boolean.FALSE, new MapperBuilder().build().readObject(new ByteArrayInputStream("false".getBytes()), Object.class));
+            assertEquals(1., new MapperBuilder().setEncoding("UTF-8" /*otherwise guess algo fails, too small string*/).build()
+                    .readObject(new ByteArrayInputStream("1".getBytes()), Object.class));
+            assertEquals("val", new MapperBuilder().build().readObject(new ByteArrayInputStream("\"val\"".getBytes()), Object.class));
+            assertEquals(asList("val1", "val2"), new MapperBuilder().build().readObject(new ByteArrayInputStream("[\"val1\", \"val2\"]".getBytes()), Object.class));
+            assertEquals(new HashMap<String, Object>() {{
+                put("a", "val");
+                put("b", true);
+                put("c", 1);
+            }}, new MapperBuilder().build().readObject(new ByteArrayInputStream("{\"a\":\"val\", \"b\": true, \"c\": 1}".getBytes()), Object.class));
+        }
+    }
+
     private void assertOneDimension(final Map<String, Object> data, final int size) {
         assertEquals(size, data.size());
         assertEquals(1, data.get("a"));
