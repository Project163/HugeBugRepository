diff --git a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/ConfigurableJohnzonProvider.java b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/ConfigurableJohnzonProvider.java
index 2b9bd417..e942385c 100644
--- a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/ConfigurableJohnzonProvider.java
+++ b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/ConfigurableJohnzonProvider.java
@@ -42,16 +42,8 @@ import java.util.concurrent.atomic.AtomicReference;
 import static java.util.Arrays.asList;
 
 @Provider
-@Produces({
-    "application/json", "*/json",
-    "*/*+json", "*/x-json",
-    "*/javascript", "*/x-javascript"
-})
-@Consumes({
-    "application/json", "*/json",
-    "*/*+json", "*/x-json",
-    "*/javascript", "*/x-javascript"
-})
+@Produces("application/json")
+@Consumes("application/json")
 public class ConfigurableJohnzonProvider<T> implements MessageBodyWriter<T>, MessageBodyReader<T> {
     // build/configuration
     private MapperBuilder builder = new MapperBuilder();
diff --git a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JohnzonProvider.java b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JohnzonProvider.java
index 280ddbc7..b1e137f5 100644
--- a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JohnzonProvider.java
+++ b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JohnzonProvider.java
@@ -27,16 +27,8 @@ import javax.ws.rs.ext.Provider;
 import java.util.Collection;
 
 @Provider
-@Produces({
-    "application/json", "*/json",
-    "*/*+json", "*/x-json",
-    "*/javascript", "*/x-javascript"
-})
-@Consumes({
-    "application/json", "*/json",
-    "*/*+json", "*/x-json",
-    "*/javascript", "*/x-javascript"
-})
+@Produces("application/json")
+@Consumes("application/json")
 public class JohnzonProvider<T> extends DelegateProvider<T> {
     public JohnzonProvider(final Mapper mapper, final Collection<String> ignores) {
         super(new JohnzonMessageBodyReader<T>(mapper, ignores), new JohnzonMessageBodyWriter<T>(mapper, ignores));
diff --git a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JsrProvider.java b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JsrProvider.java
index 6b458941..06ec86d1 100644
--- a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JsrProvider.java
+++ b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/JsrProvider.java
@@ -24,16 +24,8 @@ import javax.ws.rs.Produces;
 import javax.ws.rs.ext.Provider;
 
 @Provider
-@Produces({
-    "application/json", "*/json",
-    "*/*+json", "*/x-json",
-    "*/javascript", "*/x-javascript"
-})
-@Consumes({
-    "application/json", "*/json",
-    "*/*+json", "*/x-json",
-    "*/javascript", "*/x-javascript"
-})
+@Produces("application/json")
+@Consumes("application/json")
 public class JsrProvider extends DelegateProvider<JsonStructure> {
     public JsrProvider() {
         super(new JsrMessageBodyReader(), new JsrMessageBodyWriter());
diff --git a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardConfigurableJohnzonProvider.java b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardConfigurableJohnzonProvider.java
new file mode 100644
index 00000000..23f51e0d
--- /dev/null
+++ b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardConfigurableJohnzonProvider.java
@@ -0,0 +1,206 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.jaxrs;
+
+import org.apache.johnzon.mapper.MapperBuilder;
+import org.apache.johnzon.mapper.access.AccessMode;
+
+import javax.json.JsonReaderFactory;
+import javax.json.stream.JsonGeneratorFactory;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.Produces;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.ext.MessageBodyReader;
+import javax.ws.rs.ext.MessageBodyWriter;
+import javax.ws.rs.ext.Provider;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.Comparator;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static java.util.Arrays.asList;
+
+@Provider
+@Produces({
+    "*/json",
+    "*/*+json", "*/x-json",
+    "*/javascript", "*/x-javascript"
+})
+@Consumes({
+    "*/json",
+    "*/*+json", "*/x-json",
+    "*/javascript", "*/x-javascript"
+})
+public class WildcardConfigurableJohnzonProvider<T> implements MessageBodyWriter<T>, MessageBodyReader<T> {
+    // build/configuration
+    private MapperBuilder builder = new MapperBuilder();
+    private List<String> ignores;
+
+    // runtime
+    private AtomicReference<JohnzonProvider<T>> delegate = new AtomicReference<JohnzonProvider<T>>();
+
+    private JohnzonProvider<T> instance() {
+        JohnzonProvider<T> instance;
+        do {
+            instance = delegate.get();
+            if (builder != null && delegate.compareAndSet(null, new JohnzonProvider<T>(builder.build(), ignores))) {
+                // reset build instances
+                builder = null;
+                ignores = null;
+            }
+        } while (instance == null);
+        return instance;
+    }
+
+    @Override
+    public boolean isReadable(final Class<?> rawType, final Type genericType,
+                              final Annotation[] annotations, final MediaType mediaType) {
+        return instance().isReadable(rawType, genericType, annotations, mediaType);
+    }
+
+    @Override
+    public T readFrom(final Class<T> rawType, final Type genericType,
+                      final Annotation[] annotations, final MediaType mediaType,
+                      final MultivaluedMap<String, String> httpHeaders,
+                      final InputStream entityStream) throws IOException {
+        return instance().readFrom(rawType, genericType, annotations, mediaType, httpHeaders, entityStream);
+    }
+
+    @Override
+    public long getSize(final T t, final Class<?> rawType, final Type genericType,
+                        final Annotation[] annotations, final MediaType mediaType) {
+        return instance().getSize(t, rawType, genericType, annotations, mediaType);
+    }
+
+    @Override
+    public boolean isWriteable(final Class<?> rawType, final Type genericType,
+                               final Annotation[] annotations, final MediaType mediaType) {
+        return instance().isWriteable(rawType, genericType, annotations, mediaType);
+    }
+
+    @Override
+    public void writeTo(final T t, final Class<?> rawType, final Type genericType,
+                        final Annotation[] annotations, final MediaType mediaType,
+                        final MultivaluedMap<String, Object> httpHeaders,
+                        final OutputStream entityStream) throws IOException {
+        instance().writeTo(t, rawType, genericType, annotations, mediaType, httpHeaders, entityStream);
+    }
+
+    // type=a,b,c|type2=d,e
+    public void setIgnoreFieldsForType(final String mapping) {
+        for (final String config : mapping.split(" *| *")) {
+            final String[] parts = config.split(" *= *");
+            try {
+                final Class<?> type = Thread.currentThread().getContextClassLoader().loadClass(parts[0]);
+                if (parts.length == 1) {
+                    builder.setIgnoreFieldsForType(type);
+                } else {
+                    builder.setIgnoreFieldsForType(type, parts[1].split(" *, *"));
+                }
+            } catch (final ClassNotFoundException e) {
+                throw new IllegalArgumentException(e);
+            }
+        }
+    }
+
+    public void setSupportConstructors(final boolean supportConstructors) {
+        builder.setSupportConstructors(supportConstructors);
+    }
+
+    public void setPretty(final boolean pretty) {
+        builder.setPretty(pretty);
+    }
+
+    public void setSupportGetterForCollections(final boolean supportGetterForCollections) {
+        builder.setSupportGetterForCollections(supportGetterForCollections);
+    }
+
+    public void setSupportsComments(final boolean supportsComments) {
+        builder.setSupportsComments(supportsComments);
+    }
+
+    public void setIgnores(final String ignores) {
+        this.ignores = ignores == null ? null : asList(ignores.split(" *, *"));
+    }
+
+    public void setAccessMode(final AccessMode mode) {
+        builder.setAccessMode(mode);
+    }
+
+    public void setAccessModeName(final String mode) {
+        builder.setAccessModeName(mode);
+    }
+
+    public void setSupportHiddenAccess(final boolean supportHiddenAccess) {
+        builder.setSupportHiddenAccess(supportHiddenAccess);
+    }
+
+    public void setAttributeOrder(final Comparator<String> attributeOrder) {
+        builder.setAttributeOrder(attributeOrder);
+    }
+
+    public void setReaderFactory(final JsonReaderFactory readerFactory) {
+        builder.setReaderFactory(readerFactory);
+    }
+
+    public void setGeneratorFactory(final JsonGeneratorFactory generatorFactory) {
+        builder.setGeneratorFactory(generatorFactory);
+    }
+
+    public void setDoCloseOnStreams(final boolean doCloseOnStreams) {
+        builder.setDoCloseOnStreams(doCloseOnStreams);
+    }
+
+    public void setVersion(final int version) {
+        builder.setVersion(version);
+    }
+
+    public void setSkipNull(final boolean skipNull) {
+        builder.setSkipNull(skipNull);
+    }
+
+    public void setSkipEmptyArray(final boolean skipEmptyArray) {
+        builder.setSkipEmptyArray(skipEmptyArray);
+    }
+
+    public void setBufferSize(final int bufferSize) {
+        builder.setBufferSize(bufferSize);
+    }
+
+    public void setBufferStrategy(final String bufferStrategy) {
+        builder.setBufferStrategy(bufferStrategy);
+    }
+
+    public void setMaxSize(final int size) {
+        builder.setMaxSize(size);
+    }
+
+    public void setTreatByteArrayAsBase64(final boolean treatByteArrayAsBase64) {
+        builder.setTreatByteArrayAsBase64(treatByteArrayAsBase64);
+    }
+
+    public void setEncoding(final String encoding) {
+        builder.setEncoding(encoding);
+    }
+}
diff --git a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardJohnzonProvider.java b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardJohnzonProvider.java
new file mode 100644
index 00000000..c573fff3
--- /dev/null
+++ b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardJohnzonProvider.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.jaxrs;
+
+import org.apache.johnzon.mapper.Mapper;
+import org.apache.johnzon.mapper.MapperBuilder;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.Produces;
+import javax.ws.rs.ext.Provider;
+import java.util.Collection;
+
+@Provider
+@Produces({
+    "*/json",
+    "*/*+json", "*/x-json",
+    "*/javascript", "*/x-javascript"
+})
+@Consumes({
+    "*/json",
+    "*/*+json", "*/x-json",
+    "*/javascript", "*/x-javascript"
+})
+public class WildcardJohnzonProvider<T> extends DelegateProvider<T> {
+    public WildcardJohnzonProvider(final Mapper mapper, final Collection<String> ignores) {
+        super(new JohnzonMessageBodyReader<T>(mapper, ignores), new JohnzonMessageBodyWriter<T>(mapper, ignores));
+    }
+
+    public WildcardJohnzonProvider() {
+        this(new MapperBuilder().setDoCloseOnStreams(false).build(), null);
+    }
+}
diff --git a/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardJsrProvider.java b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardJsrProvider.java
new file mode 100644
index 00000000..66d37916
--- /dev/null
+++ b/johnzon-jaxrs/src/main/java/org/apache/johnzon/jaxrs/WildcardJsrProvider.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.jaxrs;
+
+import javax.json.JsonStructure;
+import javax.ws.rs.Consumes;
+import javax.ws.rs.Produces;
+import javax.ws.rs.ext.Provider;
+
+@Provider
+@Produces({
+    "*/json",
+    "*/*+json", "*/x-json",
+    "*/javascript", "*/x-javascript"
+})
+@Consumes({
+    "*/json",
+    "*/*+json", "*/x-json",
+    "*/javascript", "*/x-javascript"
+})
+public class WildcardJsrProvider extends DelegateProvider<JsonStructure> {
+    public WildcardJsrProvider() {
+        super(new JsrMessageBodyReader(), new JsrMessageBodyWriter());
+    }
+}
diff --git a/johnzon-jaxrs/src/test/java/org/apache/johnzon/jaxrs/JohnzonProviderTest.java b/johnzon-jaxrs/src/test/java/org/apache/johnzon/jaxrs/JohnzonProviderTest.java
index b29a290b..405c77cf 100644
--- a/johnzon-jaxrs/src/test/java/org/apache/johnzon/jaxrs/JohnzonProviderTest.java
+++ b/johnzon-jaxrs/src/test/java/org/apache/johnzon/jaxrs/JohnzonProviderTest.java
@@ -30,6 +30,7 @@ import org.junit.Test;
 import javax.ws.rs.GET;
 import javax.ws.rs.POST;
 import javax.ws.rs.Path;
+import javax.ws.rs.Produces;
 import javax.ws.rs.WebApplicationException;
 import javax.ws.rs.core.GenericType;
 import javax.ws.rs.core.MediaType;
@@ -41,6 +42,7 @@ import java.lang.reflect.Type;
 import java.util.List;
 
 import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
@@ -52,7 +54,7 @@ public class JohnzonProviderTest {
     public static void bindEndpoint() throws Exception {
         final JAXRSServerFactoryBean sf = new JAXRSServerFactoryBean();
         sf.setResourceClasses(JohnzonResource.class);
-        sf.setProviders(asList(new JohnzonProvider<Object>()));
+        sf.setProviders(singletonList(new JohnzonProvider<Object>()));
         sf.setResourceProvider(JohnzonResource.class, new SingletonResourceProvider(new JohnzonResource(), false));
         sf.setAddress(ENDPOINT_ADDRESS);
         server = sf.create();
@@ -82,6 +84,12 @@ public class JohnzonProviderTest {
         assertEquals("ok", stream);
     }
 
+    @Test
+    public void primitive() {
+        final String val = client(MediaType.TEXT_PLAIN_TYPE).path("johnzon/primitive").get(String.class);
+        assertEquals("1986", val);
+    }
+
     @Test
     public void array() {
         final Johnzon[] johnzon = client().path("johnzon/all1").get(Johnzon[].class);
@@ -119,7 +127,11 @@ public class JohnzonProviderTest {
     }
 
     private static WebClient client() {
-        final WebClient client = WebClient.create(ENDPOINT_ADDRESS, asList(new JohnzonProvider<Object>())).accept(MediaType.APPLICATION_JSON_TYPE);
+        return client(MediaType.APPLICATION_JSON_TYPE);
+    }
+
+    private static WebClient client(final MediaType mediaType) {
+        final WebClient client = WebClient.create(ENDPOINT_ADDRESS, singletonList(new JohnzonProvider<Object>())).accept(mediaType);
         WebClient.getConfig(client).getRequestContext().put(LocalConduit.DIRECT_DISPATCH, Boolean.TRUE);
         return client;
     }
@@ -178,5 +190,12 @@ public class JohnzonProviderTest {
                 }
             };
         }
+
+        @GET
+        @Produces(MediaType.TEXT_PLAIN)
+        @Path("primitive")
+        public Integer primitive() {
+            return 1986;
+        }
     }
 }
