diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
index 4c286d6a..a13655ed 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MapperBuilder.java
@@ -195,7 +195,7 @@ public class MapperBuilder {
             } else if ("strict-method".equalsIgnoreCase(accessModeName)) {
                 accessMode = new MethodAccessMode(supportConstructors, supportHiddenAccess, false);
             } else if ("both".equalsIgnoreCase(accessModeName) || accessModeName == null) {
-                accessMode = new FieldAndMethodAccessMode(supportConstructors, supportHiddenAccess, useGetterForCollections);
+                accessMode = new FieldAndMethodAccessMode(supportConstructors, supportHiddenAccess, useGetterForCollections, false);
             } else {
                 throw new IllegalArgumentException("Unsupported access mode: " + accessModeName);
             }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAndMethodAccessMode.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAndMethodAccessMode.java
index d1e12111..1ae5425f 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAndMethodAccessMode.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/access/FieldAndMethodAccessMode.java
@@ -27,6 +27,7 @@ import java.beans.Introspector;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.HashMap;
@@ -36,12 +37,14 @@ import java.util.Map;
 public class FieldAndMethodAccessMode extends BaseAccessMode {
     private final FieldAccessMode fields;
     private final MethodAccessMode methods;
+    private final boolean alwaysPreferMethodVisibility;
 
     public FieldAndMethodAccessMode(final boolean useConstructor, final boolean acceptHiddenConstructor,
-                                    final boolean useGettersAsWriter) {
+                                    final boolean useGettersAsWriter, final boolean alwaysPreferMethodVisibility) {
         super(useConstructor, acceptHiddenConstructor);
         this.fields = new FieldAccessMode(useConstructor, acceptHiddenConstructor);
         this.methods = new MethodAccessMode(useConstructor, acceptHiddenConstructor, useGettersAsWriter);
+        this.alwaysPreferMethodVisibility = alwaysPreferMethodVisibility;
     }
 
     @Override
@@ -58,7 +61,7 @@ public class FieldAndMethodAccessMode extends BaseAccessMode {
                 m = getMethod("is" + Character.toUpperCase(key.charAt(0)) + (key.length() > 1 ? key.substring(1) : ""), clazz);
             }
             boolean skip = false;
-            if (m != null) {
+            if (m != null && Modifier.isPublic(m.getModifiers())) {
                 for (final Reader w : methodReaders.values()) {
                     if (MethodAccessMode.MethodDecoratedType.class.cast(w).getMethod().equals(m)) {
                         if (w.getAnnotation(JohnzonProperty.class) != null || w.getAnnotation(JohnzonIgnore.class) != null) {
@@ -67,6 +70,8 @@ public class FieldAndMethodAccessMode extends BaseAccessMode {
                         break;
                     }
                 }
+            } else if (m != null) { // skip even field
+                continue;
             }
             if (skip) {
                 continue;
@@ -111,8 +116,18 @@ public class FieldAndMethodAccessMode extends BaseAccessMode {
 
     private Method getMethod(final String methodName, final Class<?> type, final Class<?>... args) {
         try {
+            if (alwaysPreferMethodVisibility) {
+                return type.getDeclaredMethod(methodName, args);
+            }
             return type.getMethod(methodName, args);
         } catch (final NoSuchMethodException e) {
+            if (alwaysPreferMethodVisibility) {
+                try {
+                    return type.getMethod(methodName, args);
+                } catch (final NoSuchMethodException e2) {
+                    // no-op
+                }
+            }
             return null;
         }
     }
@@ -141,7 +156,7 @@ public class FieldAndMethodAccessMode extends BaseAccessMode {
             final String key = entry.getKey();
             final Method m = getMethod("set" + Character.toUpperCase(key.charAt(0)) + (key.length() > 1 ? key.substring(1) : ""), clazz, toType(entry.getValue().getType()));
             boolean skip = false;
-            if (m != null) {
+            if (m != null && Modifier.isPublic(m.getModifiers())) {
                 for (final Writer w : metodWriters.values()) {
                     if (MethodAccessMode.MethodDecoratedType.class.cast(w).getMethod().equals(m)) {
                         if (w.getAnnotation(JohnzonProperty.class) != null) {
@@ -150,6 +165,8 @@ public class FieldAndMethodAccessMode extends BaseAccessMode {
                         break;
                     }
                 }
+            } else if (m != null) {
+                continue;
             }
             if (skip) {
                 continue;
