diff --git a/apache-rat-core/src/main/java/org/apache/rat/Defaults.java b/apache-rat-core/src/main/java/org/apache/rat/Defaults.java
index bc7ef27d..6d3cfdba 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/Defaults.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/Defaults.java
@@ -135,7 +135,7 @@ public final class Defaults {
         }
 
         LicenseSetFactory result = new LicenseSetFactory(licenses);
-        approvedLicenseCategories.forEach(result::addLicenseCategory);
+        approvedLicenseCategories.forEach(result::approveLicenseCategory);
         return result;
     }
 
diff --git a/apache-rat-core/src/main/java/org/apache/rat/ReportConfiguration.java b/apache-rat-core/src/main/java/org/apache/rat/ReportConfiguration.java
index 8e7bbf84..9af3e8dc 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/ReportConfiguration.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/ReportConfiguration.java
@@ -452,7 +452,6 @@ public class ReportConfiguration {
         if (getStyleSheet() == null) {
             setStyleSheet(StyleSheets.PLAIN.getStyleSheet());
         }
-
         defaults.getStandardExclusion().forEach(this::addExcludedCollection);
     }
 
@@ -612,7 +611,7 @@ public class ReportConfiguration {
      * @param familyCategory the category to add.
      */
     public void addApprovedLicenseCategory(final String familyCategory) {
-        licenseSetFactory.addLicenseCategory(familyCategory);
+        licenseSetFactory.approveLicenseCategory(familyCategory);
     }
 
     /**
@@ -686,7 +685,7 @@ public class ReportConfiguration {
      * @param licenseId the license id to add.
      */
     public void addApprovedLicenseId(final String licenseId) {
-        licenseSetFactory.addLicenseId(licenseId);
+        licenseSetFactory.approveLicenseId(licenseId);
     }
 
     /**
@@ -805,6 +804,14 @@ public class ReportConfiguration {
         return claimValidator;
     }
 
+    /**
+     * Gets the enclosed LicenseSetFactory.
+     * @return the license set factory.
+     */
+    public LicenseSetFactory getLicenseSetFactory() {
+        return licenseSetFactory;
+    }
+
     /**
      * Validates that the configuration is valid.
      * @param logger String consumer to log warning messages to.
diff --git a/apache-rat-core/src/main/java/org/apache/rat/analysis/DefaultAnalyserFactory.java b/apache-rat-core/src/main/java/org/apache/rat/analysis/AnalyserFactory.java
similarity index 72%
rename from apache-rat-core/src/main/java/org/apache/rat/analysis/DefaultAnalyserFactory.java
rename to apache-rat-core/src/main/java/org/apache/rat/analysis/AnalyserFactory.java
index da2cc016..681adb47 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/analysis/DefaultAnalyserFactory.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/analysis/AnalyserFactory.java
@@ -27,7 +27,7 @@ import org.apache.rat.Defaults;
 import org.apache.rat.ReportConfiguration;
 import org.apache.rat.api.Document;
 import org.apache.rat.api.RatException;
-import org.apache.rat.document.IDocumentAnalyser;
+import org.apache.rat.document.DocumentAnalyser;
 import org.apache.rat.document.RatDocumentAnalysisException;
 import org.apache.rat.license.ILicense;
 import org.apache.rat.license.LicenseSetFactory;
@@ -38,32 +38,64 @@ import org.apache.rat.walker.ArchiveWalker;
 /**
  * Creates default analysers.
  */
-public final class DefaultAnalyserFactory {
+public final class AnalyserFactory {
 
-    private DefaultAnalyserFactory() {
+    private AnalyserFactory() {
         // do not instantiate
     }
+
+    /**
+     * Creates an analyser that adds the approved license predicate to the document metadata.
+     * <p>
+     *     Note you probably do not want this as it is automatically added to {@link #createConfiguredAnalyser}.
+     * </p>
+     * @param approvalPredicate the predicate to approve licenses.
+     * @return A document analyser that sets the approvalPredicate in document metadata.
+     */
+    public static DocumentAnalyser createPolicy(final Predicate<ILicense> approvalPredicate) {
+        return document -> {
+            if (document != null) {
+                document.getMetaData().setApprovalPredicate(approvalPredicate);
+            }
+        };
+    }
+
+    /**
+     * Creates an analyser that calls each of the provided analysers in order.
+     * @param analysers the array of analysers to call.
+     * @return an analyser that will call all the provided analysers.
+     */
+    public static DocumentAnalyser createMultiplexer(final DocumentAnalyser... analysers) {
+        return document -> {
+            for (DocumentAnalyser analyser : analysers) {
+                analyser.analyse(document);
+            }
+        };
+    }
+
     /**
-     * Creates a DocumentAnalyser from a collection of ILicenses.
+     * Creates a DocumentAnalyser from the report configuration.
      * @param configuration the ReportConfiguration
-     * @return A document analyser that uses the provides licenses.
+     * @return A document analyser that uses the provided licenses.
      */
-    public static IDocumentAnalyser createDefaultAnalyser(final ReportConfiguration configuration) {
-        Set<ILicense> licenses = configuration.getLicenses(LicenseSetFactory.LicenseFilter.ALL);
+    public static DocumentAnalyser createConfiguredAnalyser(final ReportConfiguration configuration) {
+        LicenseSetFactory licenseSetFactory = configuration.getLicenseSetFactory();
+        Set<ILicense> licenses = licenseSetFactory.getLicenses(LicenseSetFactory.LicenseFilter.ALL);
         if (licenses.isEmpty()) {
             throw new ConfigurationException("At least one license must be defined");
         }
         if (DefaultLog.getInstance().isEnabled(Log.Level.DEBUG)) {
-            DefaultLog.getInstance().debug("Currently active Licenses are:");
+            DefaultLog.getInstance().debug("Currently active licenses are:");
             licenses.forEach(DefaultLog.getInstance()::debug);
         }
-        return new DefaultAnalyser(configuration, licenses);
+        return createMultiplexer(createPolicy(licenseSetFactory.getApprovedLicensePredicate()),
+         new DefaultAnalyser(configuration, licenses));
     }
 
     /**
      * A DocumentAnalyser a collection of licenses.
      */
-    private static final class DefaultAnalyser implements IDocumentAnalyser {
+    private static final class DefaultAnalyser implements DocumentAnalyser {
 
         /** The licenses to analyze */
         private final Collection<ILicense> licenses;
diff --git a/apache-rat-core/src/main/java/org/apache/rat/analysis/DocumentHeaderAnalyser.java b/apache-rat-core/src/main/java/org/apache/rat/analysis/DocumentHeaderAnalyser.java
index f4b0812a..cec174f6 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/analysis/DocumentHeaderAnalyser.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/analysis/DocumentHeaderAnalyser.java
@@ -23,7 +23,7 @@ import java.io.Reader;
 import java.util.Collection;
 
 import org.apache.rat.api.Document;
-import org.apache.rat.document.IDocumentAnalyser;
+import org.apache.rat.document.DocumentAnalyser;
 import org.apache.rat.license.ILicense;
 import org.apache.rat.utils.DefaultLog;
 
@@ -32,7 +32,7 @@ import static java.lang.String.format;
 /**
  * A Document analyzer that analyses document headers for a license.
  */
-class DocumentHeaderAnalyser implements IDocumentAnalyser {
+class DocumentHeaderAnalyser implements DocumentAnalyser {
 
     /** The license to analyse */
     private final Collection<ILicense> licenses;
diff --git a/apache-rat-core/src/main/java/org/apache/rat/api/MetaData.java b/apache-rat-core/src/main/java/org/apache/rat/api/MetaData.java
index 098906e9..24d516f8 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/api/MetaData.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/api/MetaData.java
@@ -19,15 +19,13 @@
 package org.apache.rat.api;
 
 import java.nio.charset.Charset;
-import java.util.HashSet;
-import java.util.Set;
 import java.util.SortedSet;
 import java.util.TreeSet;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 
 import org.apache.rat.license.ILicense;
-import org.apache.rat.license.ILicenseFamily;
+import org.apache.rat.utils.DefaultLog;
 import org.apache.tika.mime.MediaType;
 
 /**
@@ -38,7 +36,7 @@ public class MetaData {
     /** The list of matched licenses */
     private final SortedSet<ILicense> matchedLicenses;
     /** The list of License Family Categories that are approved */
-    private final Set<String> approvedLicenses;
+    private Predicate<ILicense> approvalPredicate;
     /** The charset for this document */
     private Charset charset;
     /** The media type for this document */
@@ -53,7 +51,10 @@ public class MetaData {
      */
     public MetaData() {
         this.matchedLicenses = new TreeSet<>();
-        this.approvedLicenses = new HashSet<>();
+        this.approvalPredicate = x -> {
+                DefaultLog.getInstance().error("Approved Predicate was not set.");
+                throw new IllegalStateException("Approved Predicate was not set.");
+        };
     }
 
     /**
@@ -106,11 +107,10 @@ public class MetaData {
 
     /**
      * Sets the set of approved licenses.
-     * @param approvedLicenseFamilies the set of approved license families.
+     * @param approvalPredicate the predicate to validate licenses.
      */
-    public void setApprovedLicenses(final Set<ILicenseFamily> approvedLicenseFamilies) {
-        licenses().filter(lic -> approvedLicenseFamilies.contains(lic.getLicenseFamily()))
-                .forEach(lic -> approvedLicenses.add(lic.getId()));
+    public void setApprovalPredicate(final Predicate<ILicense> approvalPredicate) {
+        this.approvalPredicate = approvalPredicate;
     }
 
     /**
@@ -135,7 +135,7 @@ public class MetaData {
      * @return {@code true} if the license is in the list of approved licenses, {@code false} otherwise.
      */
     public boolean isApproved(final ILicense license) {
-        return approvedLicenses.contains(license.getId());
+        return approvalPredicate.test(license);
     }
 
     /**
@@ -197,6 +197,7 @@ public class MetaData {
 
     @Override
     public String toString() {
-        return String.format("MetaData[%s license, %s approved]", matchedLicenses.size(), approvedLicenses.size());
+        return String.format("MetaData[%s license, %s approved]", matchedLicenses.size(),
+                matchedLicenses.stream().filter(approvalPredicate).count());
     }
 }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java
index 8fe2b15c..e21432e0 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/ExclusionProcessor.java
@@ -136,7 +136,7 @@ public class ExclusionProcessor {
 
     /**
      * Add the patterns from collections of patterns as excluded patterns.
-     * @param patterns the strings to that define patterns to be ecxcuded from processing.
+     * @param patterns the strings to that define patterns to be excluded from processing.
      * @return this
      */
     public ExclusionProcessor addExcludedPatterns(final Iterable<String> patterns) {
diff --git a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/plexus/MatchPattern.java b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/plexus/MatchPattern.java
index 99b07dda..c43836ec 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/plexus/MatchPattern.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/config/exclusion/plexus/MatchPattern.java
@@ -83,7 +83,7 @@ public final class MatchPattern {
         } else {
             result = SelectorUtils.matchAntPathPattern(getTokenizedPathChars(), strDirs, isCaseSensitive);
         }
-        if (DefaultLog.getInstance().isEnabled(Log.Level.DEBUG)) {
+        if (result && DefaultLog.getInstance().isEnabled(Log.Level.DEBUG)) {
             DefaultLog.getInstance().debug(format("%s match %s -> %s", this, str, result));
         }
         return result;
diff --git a/apache-rat-core/src/main/java/org/apache/rat/document/IDocumentAnalyser.java b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentAnalyser.java
similarity index 96%
rename from apache-rat-core/src/main/java/org/apache/rat/document/IDocumentAnalyser.java
rename to apache-rat-core/src/main/java/org/apache/rat/document/DocumentAnalyser.java
index 4f2cb302..69d4ed3c 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/document/IDocumentAnalyser.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentAnalyser.java
@@ -23,7 +23,8 @@ import org.apache.rat.api.Document;
 /**
  * Analyses Documents.
  */
-public interface IDocumentAnalyser {
+@FunctionalInterface
+public interface DocumentAnalyser {
     /**
      * Analyse the specified document.
      * @param document the document to analyze
diff --git a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentAnalyserMultiplexer.java b/apache-rat-core/src/main/java/org/apache/rat/document/DocumentAnalyserMultiplexer.java
deleted file mode 100644
index af75e5bd..00000000
--- a/apache-rat-core/src/main/java/org/apache/rat/document/DocumentAnalyserMultiplexer.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one   *
- * or more contributor license agreements.  See the NOTICE file *
- * distributed with this work for additional information        *
- * regarding copyright ownership.  The ASF licenses this file   *
- * to you under the Apache License, Version 2.0 (the            *
- * "License"); you may not use this file except in compliance   *
- * with the License.  You may obtain a copy of the License at   *
- *                                                              *
- *   http://www.apache.org/licenses/LICENSE-2.0                 *
- *                                                              *
- * Unless required by applicable law or agreed to in writing,   *
- * software distributed under the License is distributed on an  *
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
- * KIND, either express or implied.  See the License for the    *
- * specific language governing permissions and limitations      *
- * under the License.                                           *
- */
-package org.apache.rat.document;
-
-import org.apache.rat.api.Document;
-
-public class DocumentAnalyserMultiplexer implements IDocumentAnalyser {
-
-    /**
-     * Array of Document analyzers that are to be executed.
-     */
-    private final IDocumentAnalyser[] analysers;
-
-    /**
-     * Constructor.
-     * @param analysers The Document analysers to execute.
-     */
-    public DocumentAnalyserMultiplexer(final IDocumentAnalyser[] analysers) {
-        super();
-        this.analysers = analysers;
-    }
-
-    /**
-     * Execute the Document analysers on the provided document.
-     * @param document The document to analyse.
-     * @throws RatDocumentAnalysisException on error.
-     */
-    public void analyse(final Document document) throws RatDocumentAnalysisException {
-        for (IDocumentAnalyser analyser : analysers) {
-            analyser.analyse(document);
-        }
-    }
-
-}
diff --git a/apache-rat-core/src/main/java/org/apache/rat/license/ILicenseFamily.java b/apache-rat-core/src/main/java/org/apache/rat/license/ILicenseFamily.java
index 0681c1a3..56ba494c 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/license/ILicenseFamily.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/license/ILicenseFamily.java
@@ -136,6 +136,22 @@ public interface ILicenseFamily extends Comparable<ILicenseFamily> {
                 public String getFamilyCategory() {
                     return cat;
                 }
+
+                @Override
+                public boolean equals(final Object other) {
+                    if (other == this) {
+                        return true;
+                    }
+                    if (other instanceof ILicenseFamily) {
+                        return this.getFamilyCategory().equals(((ILicenseFamily) other).getFamilyCategory());
+                    }
+                    return false;
+                }
+
+                @Override
+                public int hashCode() {
+                    return getFamilyCategory().hashCode();
+                }
             };
         }
     }
diff --git a/apache-rat-core/src/main/java/org/apache/rat/license/LicenseSetFactory.java b/apache-rat-core/src/main/java/org/apache/rat/license/LicenseSetFactory.java
index e417af54..6fe00db5 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/license/LicenseSetFactory.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/license/LicenseSetFactory.java
@@ -238,7 +238,7 @@ public class LicenseSetFactory {
      * Adds a license family category (id) to the list of approved licenses
      * @param familyCategory the category to add.
      */
-    public void addLicenseCategory(final String familyCategory) {
+    public void approveLicenseCategory(final String familyCategory) {
         approvedLicenseCategories.add(ILicenseFamily.makeCategory(familyCategory));
     }
 
@@ -254,7 +254,7 @@ public class LicenseSetFactory {
      * Adds a license family category (id) to the list of approved licenses
      * @param licenseId the license ID to add.
      */
-    public void addLicenseId(final String licenseId) {
+    public void approveLicenseId(final String licenseId) {
         approvedLicenseIds.add(licenseId);
     }
 
@@ -275,21 +275,27 @@ public class LicenseSetFactory {
         return approvedLicenseCategories.contains(family.getFamilyCategory()) && !removedLicenseCategories.contains(family.getFamilyCategory());
     }
 
+    /**
+     * Gets a predicate to filter for approved licenses.
+     * @return a predicate that returns {@code true} if the license is approved.
+     */
+    public Predicate<ILicense> getApprovedLicensePredicate() {
+        return lic -> !removedLicenseIds.contains(lic.getId()) && (approvedLicenseIds.contains(lic.getId()) ||
+                isApprovedCategory(lic.getLicenseFamily()));
+    }
+
     /**
      * Gets the License objects based on the filter.
      * @param filter the types of LicenseFamily objects to return.
      * @return a SortedSet of ILicense objects.
      */
     public SortedSet<ILicense> getLicenses(final LicenseFilter filter) {
-        Predicate<ILicense> approved =  l -> (isApprovedCategory(l.getLicenseFamily()) ||
-                approvedLicenseIds.contains(l.getId())) && !removedLicenseIds.contains(l.getId());
-
         switch (filter) {
         case ALL:
             return Collections.unmodifiableSortedSet(licenses);
         case APPROVED:
             SortedSet<ILicense> result = new TreeSet<>();
-            licenses.stream().filter(approved).forEach(result::add);
+            licenses.stream().filter(getApprovedLicensePredicate()).forEach(result::add);
             return result;
         case NONE:
         default:
@@ -322,12 +328,10 @@ public class LicenseSetFactory {
     /**
      * Gets the License ids based on the filter.
      *
-     * @param filter the types of License IDs to return.
+     * @param filter the types of License Ids to return.
      * @return The list of all licenses in the category regardless of whether or not it is used by an ILicense implementation.
      */
     public SortedSet<String> getLicenseCategories(final LicenseFilter filter) {
-        Predicate<ILicense> approved = l -> (isApprovedCategory(l.getLicenseFamily()) ||
-                approvedLicenseIds.contains(l.getId())) && !removedLicenseIds.contains(l.getId());
         SortedSet<String> result = new TreeSet<>();
         switch (filter) {
             case ALL:
@@ -338,7 +342,6 @@ public class LicenseSetFactory {
                 return result;
             case APPROVED:
                 approvedLicenseCategories.stream().filter(s -> !removedLicenseCategories.contains(s)).forEach(result::add);
-                licenses.stream().filter(approved).forEach(l -> result.add(l.getLicenseFamily().getFamilyCategory()));
                 families.stream().filter(this::isApprovedCategory).forEach(f -> result.add(f.getFamilyCategory()));
                 return result;
             case NONE:
@@ -350,7 +353,7 @@ public class LicenseSetFactory {
     /**
      * Gets the License ids based on the filter.
      *
-     * @param filter the types of License IDs to return.
+     * @param filter the types of License Ids to return.
      * @return The list of all licenses in the category regardless of whether or not it is used by an ILicense implementation.
      */
     public SortedSet<String> getLicenseIds(final LicenseFilter filter) {
@@ -441,7 +444,7 @@ public class LicenseSetFactory {
      * Search a SortedSet of licenses for the matching license.
      * License must match both family code, and license id.
      *
-     * @param target the license to search for. Must not be null.
+     * @param target the license to search for. Must not be {@code null}.
      * @param licenses the SortedSet of licenses to search.
      * @return the matching license or {@code null} if not found.
      */
diff --git a/apache-rat-core/src/main/java/org/apache/rat/policy/DefaultPolicy.java b/apache-rat-core/src/main/java/org/apache/rat/policy/DefaultPolicy.java
deleted file mode 100644
index c1155f71..00000000
--- a/apache-rat-core/src/main/java/org/apache/rat/policy/DefaultPolicy.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one   *
- * or more contributor license agreements.  See the NOTICE file *
- * distributed with this work for additional information        *
- * regarding copyright ownership.  The ASF licenses this file   *
- * to you under the Apache License, Version 2.0 (the            *
- * "License"); you may not use this file except in compliance   *
- * with the License.  You may obtain a copy of the License at   *
- *                                                              *
- *   http://www.apache.org/licenses/LICENSE-2.0                 *
- *                                                              *
- * Unless required by applicable law or agreed to in writing,   *
- * software distributed under the License is distributed on an  *
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
- * KIND, either express or implied.  See the License for the    *
- * specific language governing permissions and limitations      *
- * under the License.                                           *
- */
-package org.apache.rat.policy;
-
-import java.util.Collection;
-import java.util.Collections;
-import java.util.SortedSet;
-import java.util.TreeSet;
-
-import org.apache.rat.api.Document;
-import org.apache.rat.document.IDocumentAnalyser;
-import org.apache.rat.license.ILicenseFamily;
-
-/**
- * A default Document Analyser that determines if the matched license is in the
- * set of approved licenses.
- */
-public class DefaultPolicy implements IDocumentAnalyser {
-    /** The set of all approved license families */
-    private final SortedSet<ILicenseFamily> approvedLicenseFamilies;
-
-    /**
-     * Constructor with the list of approved license families.
-     * @param approvedLicenseFamilies the approved license families.
-     */
-    public DefaultPolicy(final Collection<ILicenseFamily> approvedLicenseFamilies) {
-        this.approvedLicenseFamilies = new TreeSet<>();
-        this.approvedLicenseFamilies.addAll(approvedLicenseFamilies);
-    }
-
-    /**
-     * Adds an ILicenseFamily to the list of approved licenses.
-     * @param approvedLicense license to be approved.
-     */
-    public void add(final ILicenseFamily approvedLicense) {
-        this.approvedLicenseFamilies.add(approvedLicense);
-    }
-
-    @Override
-    public void analyse(final Document document) {
-        if (document != null) {
-            document.getMetaData().setApprovedLicenses(getApprovedLicenseFamilies());
-        }
-    }
-
-    /**
-     * Gets an unmodifiable reference to the SortedSet of approved licenses that
-     * this policy is holding.
-     * @return sorted set of license family definitions.
-     */
-    public SortedSet<ILicenseFamily> getApprovedLicenseFamilies() {
-        return Collections.unmodifiableSortedSet(approvedLicenseFamilies);
-    }
-}
diff --git a/apache-rat-core/src/main/java/org/apache/rat/policy/package-info.java b/apache-rat-core/src/main/java/org/apache/rat/policy/package-info.java
deleted file mode 100644
index c2eec94d..00000000
--- a/apache-rat-core/src/main/java/org/apache/rat/policy/package-info.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one   *
- * or more contributor license agreements.  See the NOTICE file *
- * distributed with this work for additional information        *
- * regarding copyright ownership.  The ASF licenses this file   *
- * to you under the Apache License, Version 2.0 (the            *
- * "License"); you may not use this file except in compliance   *
- * with the License.  You may obtain a copy of the License at   *
- *                                                              *
- *   http://www.apache.org/licenses/LICENSE-2.0                 *
- *                                                              *
- * Unless required by applicable law or agreed to in writing,   *
- * software distributed under the License is distributed on an  *
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
- * KIND, either express or implied.  See the License for the    *
- * specific language governing permissions and limitations      *
- * under the License.                                           *
- */
-
-/**
- * Policies for various methods of reporting.
- */
-package org.apache.rat.policy;
diff --git a/apache-rat-core/src/main/java/org/apache/rat/report/claim/ClaimReporterMultiplexer.java b/apache-rat-core/src/main/java/org/apache/rat/report/claim/ClaimReporterMultiplexer.java
index 2b73cf4b..5f60284a 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/report/claim/ClaimReporterMultiplexer.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/report/claim/ClaimReporterMultiplexer.java
@@ -23,7 +23,7 @@ import java.util.List;
 
 import org.apache.rat.api.Document;
 import org.apache.rat.api.RatException;
-import org.apache.rat.document.IDocumentAnalyser;
+import org.apache.rat.document.DocumentAnalyser;
 import org.apache.rat.document.RatDocumentAnalysisException;
 import org.apache.rat.report.RatReport;
 import org.apache.rat.report.xml.XmlElements;
@@ -34,7 +34,7 @@ import org.apache.rat.report.xml.writer.IXmlWriter;
  */
 public class ClaimReporterMultiplexer implements RatReport {
     /** The document analyser to use */
-    private final IDocumentAnalyser analyser;
+    private final DocumentAnalyser analyser;
     /** A list of reports that are being updated */
     private final List<? extends RatReport> reporters;
     /** If {@code true} this is a dry run do not generate report */
@@ -48,7 +48,7 @@ public class ClaimReporterMultiplexer implements RatReport {
      * @param analyser the analyser to use.
      * @param reporters the reports to execute.
      */
-    public ClaimReporterMultiplexer(final IXmlWriter writer, final boolean dryRun, final IDocumentAnalyser analyser,
+    public ClaimReporterMultiplexer(final IXmlWriter writer, final boolean dryRun, final DocumentAnalyser analyser,
                                     final List<? extends RatReport> reporters) {
         this.analyser  = analyser;
         this.reporters = reporters;
diff --git a/apache-rat-core/src/main/java/org/apache/rat/report/xml/XmlReportFactory.java b/apache-rat-core/src/main/java/org/apache/rat/report/xml/XmlReportFactory.java
index 0d1280de..2bdce3b0 100644
--- a/apache-rat-core/src/main/java/org/apache/rat/report/xml/XmlReportFactory.java
+++ b/apache-rat-core/src/main/java/org/apache/rat/report/xml/XmlReportFactory.java
@@ -22,11 +22,8 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.rat.ReportConfiguration;
-import org.apache.rat.analysis.DefaultAnalyserFactory;
-import org.apache.rat.document.DocumentAnalyserMultiplexer;
-import org.apache.rat.document.IDocumentAnalyser;
+import org.apache.rat.analysis.AnalyserFactory;
 import org.apache.rat.license.LicenseSetFactory.LicenseFilter;
-import org.apache.rat.policy.DefaultPolicy;
 import org.apache.rat.report.ConfigurationReport;
 import org.apache.rat.report.RatReport;
 import org.apache.rat.report.claim.ClaimAggregator;
@@ -73,11 +70,6 @@ public final class XmlReportFactory {
         reporters.add(new SimpleXmlClaimReporter(writer));
         reporters.add(new ClaimValidatorReport(writer, statistic, configuration));
 
-        final IDocumentAnalyser analyser = DefaultAnalyserFactory.createDefaultAnalyser(configuration);
-        final DefaultPolicy policy = new DefaultPolicy(configuration.getLicenseFamilies(LicenseFilter.APPROVED));
-
-        final IDocumentAnalyser[] analysers = {analyser, policy};
-        DocumentAnalyserMultiplexer analysisMultiplexer = new DocumentAnalyserMultiplexer(analysers);
-        return new ClaimReporterMultiplexer(writer, configuration.isDryRun(), analysisMultiplexer, reporters);
+        return new ClaimReporterMultiplexer(writer, configuration.isDryRun(), AnalyserFactory.createConfiguredAnalyser(configuration), reporters);
     }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/analysis/DefaultAnalyserFactoryTest.java b/apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java
similarity index 69%
rename from apache-rat-core/src/test/java/org/apache/rat/analysis/DefaultAnalyserFactoryTest.java
rename to apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java
index bb2e515c..4e2461ce 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/analysis/DefaultAnalyserFactoryTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/analysis/AnalyserFactoryTest.java
@@ -18,10 +18,8 @@
  */
 package org.apache.rat.analysis;
 
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
 
 import java.io.File;
 import java.io.StringWriter;
@@ -33,13 +31,15 @@ import org.apache.rat.Defaults;
 import org.apache.rat.ReportConfiguration;
 import org.apache.rat.api.Document;
 import org.apache.rat.document.DocumentNameMatcher;
-import org.apache.rat.document.IDocumentAnalyser;
+import org.apache.rat.document.DocumentAnalyser;
 import org.apache.rat.document.DocumentName;
 import org.apache.rat.document.FileDocument;
 import org.apache.rat.document.RatDocumentAnalysisException;
 import org.apache.rat.report.claim.SimpleXmlClaimReporter;
 import org.apache.rat.report.xml.writer.XmlWriter;
 import org.apache.rat.test.utils.Resources;
+import org.apache.rat.testhelpers.TestingDocument;
+import org.apache.rat.testhelpers.TestingDocumentAnalyser;
 import org.apache.rat.testhelpers.TextUtils;
 import org.assertj.core.util.Files;
 import org.junit.jupiter.api.BeforeEach;
@@ -48,15 +48,15 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
-public class DefaultAnalyserFactoryTest {
+public class AnalyserFactoryTest {
 
     private final DocumentName basedir;
 
     private StringWriter out;
     private SimpleXmlClaimReporter reporter;
-    private IDocumentAnalyser analyser;
+    private DocumentAnalyser analyser;
 
-    DefaultAnalyserFactoryTest() {
+    AnalyserFactoryTest() {
         basedir = DocumentName.builder(new File(Files.currentFolder(), Resources.SRC_TEST_RESOURCES)).build();
     }
 
@@ -66,7 +66,7 @@ public class DefaultAnalyserFactoryTest {
         reporter = new SimpleXmlClaimReporter(new XmlWriter(out));
         ReportConfiguration config = new ReportConfiguration();
         config.addLicense(UnknownLicense.INSTANCE);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
     }
 
     @Test
@@ -74,10 +74,10 @@ public class DefaultAnalyserFactoryTest {
         final Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/Text.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertEquals(Document.Type.STANDARD, document.getMetaData().getDocumentType());
-        assertEquals("text/plain", document.getMetaData().getMediaType().toString());
-        assertEquals(1, document.getMetaData().licenses().count());
-        document.getMetaData().licenses().forEach(lic -> assertEquals(UnknownLicense.INSTANCE, lic));
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.STANDARD);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("text/plain");
+        assertThat(document.getMetaData().licenses().count()).isEqualTo(1);
+        document.getMetaData().licenses().forEach(lic -> assertThat(lic).isEqualTo(UnknownLicense.INSTANCE));
     }
 
     @Test
@@ -85,8 +85,8 @@ public class DefaultAnalyserFactoryTest {
         final Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/LICENSE"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertEquals(Document.Type.NOTICE, document.getMetaData().getDocumentType());
-        assertEquals("text/plain", document.getMetaData().getMediaType().toString());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.NOTICE);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("text/plain");
     }
 
     @Test
@@ -94,8 +94,8 @@ public class DefaultAnalyserFactoryTest {
         final Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/Image.png"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertEquals(Document.Type.BINARY, document.getMetaData().getDocumentType());
-        assertEquals("image/png", document.getMetaData().getMediaType().toString());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.BINARY);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("image/png");
     }
 
     @Test
@@ -105,10 +105,10 @@ public class DefaultAnalyserFactoryTest {
         Defaults defaults = Defaults.builder().build();
         ReportConfiguration config = new ReportConfiguration();
         config.setFrom(defaults);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
         analyser.analyse(document);
-        assertEquals(Document.Type.ARCHIVE, document.getMetaData().getDocumentType());
-        assertEquals("application/java-archive", document.getMetaData().getMediaType().toString());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.ARCHIVE);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("application/java-archive");
     }
 
     private static Stream<Arguments> archiveProcessingTestData() {
@@ -128,11 +128,11 @@ public class DefaultAnalyserFactoryTest {
         ReportConfiguration config = new ReportConfiguration();
         config.setFrom(defaults);
         config.setArchiveProcessing(archiveProcessing);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
         analyser.analyse(document);
-        assertEquals(Document.Type.ARCHIVE, document.getMetaData().getDocumentType());
-        assertEquals("application/java-archive", document.getMetaData().getMediaType().toString());
-        assertEquals(expectedLicenseCount, document.getMetaData().licenses().count());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.ARCHIVE);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("application/java-archive");
+        assertThat(document.getMetaData().licenses().count()).isEqualTo(expectedLicenseCount);
     }
 
     @Test
@@ -142,18 +142,17 @@ public class DefaultAnalyserFactoryTest {
         Defaults defaults = Defaults.builder().build();
         ReportConfiguration config = new ReportConfiguration();
         config.setFrom(defaults);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
-        assertThrows(RatDocumentAnalysisException.class, () -> analyser.analyse(document));
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
+        assertThatThrownBy(() -> analyser.analyse(document)).isInstanceOf(RatDocumentAnalysisException.class);
     }
 
-
     @Test
     public void archiveTypeAnalyser() throws Exception {
         final Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/dummy.jar"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertEquals(Document.Type.ARCHIVE, document.getMetaData().getDocumentType());
-        assertEquals("application/java-archive", document.getMetaData().getMediaType().toString());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.ARCHIVE);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("application/java-archive");
     }
 
     @Test
@@ -161,8 +160,8 @@ public class DefaultAnalyserFactoryTest {
         final Document document = new FileDocument(basedir,
                 Resources.getResourceFile("/jira/RAT211/side_left.bmp"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertEquals(Document.Type.BINARY, document.getMetaData().getDocumentType());
-        assertEquals("image/bmp", document.getMetaData().getMediaType().toString());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.BINARY);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("image/bmp");
     }
 
     @Test
@@ -170,8 +169,8 @@ public class DefaultAnalyserFactoryTest {
         final Document document = new FileDocument(basedir,
                 Resources.getResourceFile("/jira/RAT211/leader-election-message-arrives.dia"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertEquals(Document.Type.ARCHIVE, document.getMetaData().getDocumentType());
-        assertEquals("application/gzip", document.getMetaData().getMediaType().toString());
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(Document.Type.ARCHIVE);
+        assertThat(document.getMetaData().getMediaType().toString()).isEqualTo("application/gzip");
     }
 
     @Test
@@ -200,42 +199,40 @@ public class DefaultAnalyserFactoryTest {
 
     @Test
     public void standardNotificationTest() throws Exception {
-
         Defaults defaults = Defaults.builder().build();
         ReportConfiguration config = new ReportConfiguration();
         config.setFrom(defaults);
         config.setStandardProcessing(ReportConfiguration.Processing.NOTIFICATION);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
 
         Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/Text.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertFalse(document.getMetaData().detectedLicense());
+        assertThat(document.getMetaData().detectedLicense()).isFalse();
 
         document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/sub/Empty.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertFalse(document.getMetaData().detectedLicense());
+        assertThat(document.getMetaData().detectedLicense()).isFalse();
     }
 
     @Test
     public void standardAbsenceTest() throws Exception {
-
         Defaults defaults = Defaults.builder().build();
         ReportConfiguration config = new ReportConfiguration();
         config.setFrom(defaults);
         config.setStandardProcessing(ReportConfiguration.Processing.ABSENCE);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
 
         Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/Text.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertTrue(document.getMetaData().detectedLicense());
+        assertThat(document.getMetaData().detectedLicense()).isTrue();
 
         document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/sub/Empty.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertTrue(document.getMetaData().detectedLicense());
+        assertThat(document.getMetaData().detectedLicense()).isTrue();
     }
 
     @Test
@@ -244,16 +241,33 @@ public class DefaultAnalyserFactoryTest {
         ReportConfiguration config = new ReportConfiguration();
         config.setFrom(defaults);
         config.setStandardProcessing(ReportConfiguration.Processing.PRESENCE);
-        analyser = DefaultAnalyserFactory.createDefaultAnalyser(config);
+        analyser = AnalyserFactory.createConfiguredAnalyser(config);
 
         Document document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/Text.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertTrue(document.getMetaData().detectedLicense());
+        assertThat(document.getMetaData().detectedLicense()).isTrue();
 
         document = new FileDocument(basedir,
                 Resources.getExampleResource("exampleData/sub/Empty.txt"), DocumentNameMatcher.MATCHES_ALL);
         analyser.analyse(document);
-        assertFalse(document.getMetaData().detectedLicense());
+        assertThat(document.getMetaData().detectedLicense()).isFalse();
+    }
+
+    @Test
+    public void testMultiplexer() throws Exception {
+        TestingDocumentAnalyser[] analysers = {
+                new TestingDocumentAnalyser(),
+                new TestingDocumentAnalyser(),
+                new TestingDocumentAnalyser()
+        };
+        DocumentAnalyser multiplexer = AnalyserFactory.createMultiplexer(analysers);
+        TestingDocument document = new TestingDocument();
+
+        multiplexer.analyse(document);
+        for (int i = 0; i < analysers.length; i++) {
+            assertThat(analysers[i].matches.size()).as("Matcher " + i).isEqualTo(1);
+            assertThat(analysers[i].matches.get(0)).as("Matcher " + i).isEqualTo(document);
+        }
     }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/analysis/DocumentAnalyserTest.java b/apache-rat-core/src/test/java/org/apache/rat/analysis/DocumentAnalyserTest.java
new file mode 100644
index 00000000..0c872b6b
--- /dev/null
+++ b/apache-rat-core/src/test/java/org/apache/rat/analysis/DocumentAnalyserTest.java
@@ -0,0 +1,333 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one   *
+ * or more contributor license agreements.  See the NOTICE file *
+ * distributed with this work for additional information        *
+ * regarding copyright ownership.  The ASF licenses this file   *
+ * to you under the Apache License, Version 2.0 (the            *
+ * "License"); you may not use this file except in compliance   *
+ * with the License.  You may obtain a copy of the License at   *
+ *                                                              *
+ *   http://www.apache.org/licenses/LICENSE-2.0                 *
+ *                                                              *
+ * Unless required by applicable law or agreed to in writing,   *
+ * software distributed under the License is distributed on an  *
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+ * KIND, either express or implied.  See the License for the    *
+ * specific language governing permissions and limitations      *
+ * under the License.                                           *
+ */
+package org.apache.rat.analysis;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.ByteArrayInputStream;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import org.apache.rat.Defaults;
+import org.apache.rat.ReportConfiguration;
+import org.apache.rat.api.Document;
+import org.apache.rat.document.DocumentAnalyser;
+import org.apache.rat.document.RatDocumentAnalysisException;
+import org.apache.rat.license.ILicense;
+import org.apache.rat.license.ILicenseFamily;
+import org.apache.rat.license.LicenseSetFactory;
+import org.apache.rat.license.LicenseSetFactory.LicenseFilter;
+import org.apache.rat.testhelpers.TestingLicense;
+import org.apache.rat.testhelpers.TestingDocument;
+import org.apache.rat.testhelpers.TestingMatcher;
+import org.apache.rat.utils.DefaultLog;
+import org.apache.rat.utils.Log;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests the Default policy implementation.
+ */
+public class DocumentAnalyserTest {
+
+    private Document document;
+
+    private void assertApproval(boolean state) {
+        if (state) {
+            assertThat(document.getMetaData().approvedLicenses().findAny()).isPresent();
+        } else {
+            assertThat(document.getMetaData().approvedLicenses().findAny()).isNotPresent();
+        }
+    }
+
+    private void setMetadata(Document document, ILicenseFamily family) {
+        document.getMetaData().reportOnLicense(new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family));
+    }
+
+    private static ILicenseFamily makeFamily(String category, String name) {
+        return ILicenseFamily.builder().setLicenseFamilyCategory(category).setLicenseFamilyName(name).build();
+    }
+
+    private Collection<String> asCategories(Collection<ILicenseFamily> families) {
+        return families.stream().map(ILicenseFamily::getFamilyCategory).collect(Collectors.toList());
+    }
+
+    @ParameterizedTest(name = "{index} {0}")
+    @MethodSource("defaultAnalyserTestData")
+    void licenseSetFactoryTest(String name, ReportConfiguration configuration,
+                             Map<LicenseFilter, Collection<ILicenseFamily>> licenseFamilies,
+                             Map<LicenseFilter, Collection<ILicense>> licenses
+    ) {
+        DefaultLog.getInstance().log(Log.Level.DEBUG, "Running " + name);
+        LicenseSetFactory factory = configuration.getLicenseSetFactory();
+
+        Collection<String> categories = asCategories(licenseFamilies.get(LicenseFilter.APPROVED));
+        assertThat(factory.getLicenseCategories(LicenseFilter.APPROVED)).containsExactlyInAnyOrderElementsOf(categories);
+        categories = asCategories(licenseFamilies.get(LicenseFilter.ALL));
+        assertThat(factory.getLicenseCategories(LicenseFilter.ALL)).containsExactlyInAnyOrderElementsOf(categories);
+        assertThat(factory.getLicenseCategories(LicenseFilter.NONE)).isEmpty();
+
+        assertThat(factory.getLicenseFamilies(LicenseFilter.APPROVED)).containsExactlyInAnyOrderElementsOf(licenseFamilies.get(LicenseFilter.APPROVED));
+        assertThat(factory.getLicenseFamilies(LicenseFilter.ALL)).containsExactlyInAnyOrderElementsOf(licenseFamilies.get(LicenseFilter.ALL));
+        assertThat(factory.getLicenseFamilies(LicenseFilter.NONE)).isEmpty();
+
+        assertThat(factory.getLicenses(LicenseFilter.APPROVED)).containsExactlyInAnyOrderElementsOf(licenses.get(LicenseFilter.APPROVED));
+        assertThat(factory.getLicenses(LicenseFilter.ALL)).containsExactlyInAnyOrderElementsOf(licenses.get(LicenseFilter.ALL));
+        assertThat(factory.getLicenses(LicenseFilter.NONE)).isEmpty();
+    }
+
+    @ParameterizedTest(name = "{index} {0}")
+    @MethodSource("defaultAnalyserTestData")
+    void analyserTest(String name, ReportConfiguration configuration,
+                             Map<LicenseFilter, Collection<ILicenseFamily>> licenseFamilies,
+                             Map<LicenseFilter, Collection<ILicense>> licenses
+    ) throws RatDocumentAnalysisException {
+        DefaultLog.getInstance().log(Log.Level.DEBUG, "Running " + name);
+        DocumentAnalyser analyser = AnalyserFactory.createConfiguredAnalyser(configuration);
+
+        // verify approved license families report approved.
+        for (ILicenseFamily family : licenseFamilies.get(LicenseFilter.APPROVED)) {
+            document = new TestingDocument(() -> new ByteArrayInputStream("Hello World".getBytes(StandardCharsets.UTF_8)), "subject");
+            setMetadata(document, family);
+            analyser.analyse(document);
+            assertApproval(true);
+        }
+
+        // verify licenses report approved as per the licenses argument
+        for (ILicense license : licenses.get(LicenseFilter.ALL)) {
+            document = new TestingDocument(() -> new ByteArrayInputStream("Hello World".getBytes(StandardCharsets.UTF_8)), "subject");
+            document.getMetaData().reportOnLicense(license);
+            analyser.analyse(document);
+            assertApproval(licenses.get(LicenseFilter.APPROVED).contains(license));
+        }
+
+        // verify that the unknown license is not approved.
+        document = new TestingDocument(() -> new ByteArrayInputStream("Hello World".getBytes(StandardCharsets.UTF_8)), "subject");
+        setMetadata(document, makeFamily("?????", "Unknown document"));
+        analyser.analyse(document);
+        assertApproval(false);
+
+        // verify that the standard document without a license detected is not approved.
+        document = new TestingDocument(() -> new ByteArrayInputStream("Hello World".getBytes(StandardCharsets.UTF_8)), "subject");
+        document.getMetaData().setDocumentType(Document.Type.STANDARD);
+        analyser.analyse(document);
+        assertApproval(false);
+    }
+
+    private static List<ILicenseFamily> defaultApprovedLicenseFamilies() {
+        return Arrays.asList(
+                ILicenseFamily.builder().setLicenseFamilyCategory("AL").setLicenseFamilyName("Apache License Version 2.0").build(),
+                ILicenseFamily.builder().setLicenseFamilyCategory("CDDL1").setLicenseFamilyName("COMMON DEVELOPMENT AND DISTRIBUTION LICENSE Version 1.0").build(),
+                ILicenseFamily.builder().setLicenseFamilyCategory("MIT").setLicenseFamilyName("The MIT License").build(),
+                ILicenseFamily.builder().setLicenseFamilyCategory("OASIS").setLicenseFamilyName("OASIS Open License").build(),
+                ILicenseFamily.builder().setLicenseFamilyCategory("W3C").setLicenseFamilyName("W3C Software Copyright").build(),
+                ILicenseFamily.builder().setLicenseFamilyCategory("W3CD").setLicenseFamilyName("W3C Document Copyright").build(),
+                ILicenseFamily.builder().setLicenseFamilyCategory("BSD-3").setLicenseFamilyName("BSD 3 clause").build()
+        );
+    }
+
+    private static List<ILicenseFamily> defaultAllLicenseFamilies() {
+        List<ILicenseFamily> result = new ArrayList<>(defaultApprovedLicenseFamilies());
+        result.add(ILicenseFamily.builder().setLicenseFamilyCategory("GPL").setLicenseFamilyName("GNU General Public License family").build());
+        return result;
+    }
+
+    private static List<ILicense> defaultApprovedLicenses() {
+        return Arrays.asList(
+                new TestingLicense("AL", "AL"),
+                new TestingLicense("AL", "ASL"),
+                new TestingLicense("BSD-3", "BSD-3"),
+                new TestingLicense("BSD-3", "DOJO"),
+                new TestingLicense("BSD-3", "TMF"),
+                new TestingLicense("CDDL1", "CDDL1"),
+                new TestingLicense("CDDL1", "ILLUMOS"),
+                new TestingLicense("MIT", "MIT"),
+                new TestingLicense("OASIS", "OASIS"),
+                new TestingLicense("W3C", "W3C"),
+                new TestingLicense("W3CD", "W3CD")
+        );
+    }
+
+    private static List<ILicense> defaultAllLicenses() {
+        List<ILicense> result = new ArrayList<>(defaultApprovedLicenses());
+        result.addAll(Arrays.asList(new TestingLicense("GPL", "GPL1"),
+                new TestingLicense("GPL", "GPL2"),
+                new TestingLicense("GPL", "GPL3")));
+        return result;
+    }
+
+    private static Stream<Arguments> defaultAnalyserTestData() {
+        List<Arguments> lst = new ArrayList<>();
+        Defaults defaults = Defaults.builder().build();
+
+        ReportConfiguration config = new ReportConfiguration();
+        config.setFrom(defaults);
+
+        // default setup
+        Map<LicenseFilter, Collection<ILicenseFamily>> licenseFamilies = new HashMap<>();
+        licenseFamilies.put(LicenseFilter.APPROVED, defaultApprovedLicenseFamilies());
+        licenseFamilies.put(LicenseFilter.ALL, defaultAllLicenseFamilies());
+
+        Map<LicenseFilter, Collection<ILicense>> licenses = new HashMap<>();
+        licenses.put(LicenseFilter.APPROVED, defaultApprovedLicenses());
+        licenses.put(LicenseFilter.ALL, defaultAllLicenses());
+
+        lst.add(Arguments.of("default", config, licenseFamilies, licenses));
+
+        // GPL approved license id
+        config = new ReportConfiguration();
+        config.setFrom(defaults);
+        config.addApprovedLicenseId("GPL1");
+
+        licenseFamilies = new HashMap<>();
+        licenseFamilies.put(LicenseFilter.APPROVED, defaultApprovedLicenseFamilies());
+        licenseFamilies.put(LicenseFilter.ALL, defaultAllLicenseFamilies());
+
+        licenses = new HashMap<>();
+        List<ILicense> approvedLicenses = new ArrayList<>(defaultApprovedLicenses());
+        approvedLicenses.add(new TestingLicense("GPL", "GPL1"));
+        licenses.put(LicenseFilter.APPROVED, approvedLicenses);
+        licenses.put(LicenseFilter.ALL, defaultAllLicenses());
+
+        lst.add(Arguments.of("GPL1 id added ", config, licenseFamilies, licenses));
+
+        // GPL family added
+        config = new ReportConfiguration();
+        config.setFrom(defaults);
+        config.addApprovedLicenseCategory(ILicenseFamily.makeCategory("GPL"));
+
+        licenseFamilies = new HashMap<>();
+        licenseFamilies.put(LicenseFilter.APPROVED, defaultAllLicenseFamilies());
+        licenseFamilies.put(LicenseFilter.ALL, defaultAllLicenseFamilies());
+
+        licenses = new HashMap<>();
+        approvedLicenses = new ArrayList<>(defaultApprovedLicenses());
+        approvedLicenses.addAll(Arrays.asList(new TestingLicense("GPL", "GPL1"),
+                new TestingLicense("GPL", "GPL2"),
+                new TestingLicense("GPL", "GPL3")));
+        licenses.put(LicenseFilter.APPROVED, approvedLicenses);
+        licenses.put(LicenseFilter.ALL, defaultAllLicenses());
+
+        lst.add(Arguments.of("GPL family added", config, licenseFamilies, licenses));
+
+        // Add new license
+        config = new ReportConfiguration();
+        config.setFrom(defaults);
+        ILicense newLicense = new TestingLicense("FAM", "Testing");
+        config.addLicense(newLicense);
+
+        licenseFamilies = new HashMap<>();
+        licenseFamilies.put(LicenseFilter.APPROVED, defaultApprovedLicenseFamilies());
+        ArrayList<ILicenseFamily> allFamilies = new ArrayList<>(defaultAllLicenseFamilies());
+        allFamilies.add(newLicense.getLicenseFamily());
+        licenseFamilies.put(LicenseFilter.ALL, allFamilies);
+
+        licenses = new HashMap<>();
+        licenses.put(LicenseFilter.APPROVED, defaultApprovedLicenses());
+        ArrayList<ILicense> allLicenses = new ArrayList<>(defaultAllLicenses());
+        allLicenses.add(newLicense);
+        licenses.put(LicenseFilter.ALL, allLicenses);
+
+        lst.add(Arguments.of("Testing license added", config, licenseFamilies, licenses));
+
+        // Add new license approved by id
+        config = new ReportConfiguration();
+        config.setFrom(defaults);
+        newLicense = new TestingLicense("FAM", "Testing");
+        config.addLicense(newLicense);
+        config.addApprovedLicenseId(newLicense.getId());
+
+        licenseFamilies = new HashMap<>();
+        licenseFamilies.put(LicenseFilter.APPROVED, defaultApprovedLicenseFamilies());
+        allFamilies = new ArrayList<>(defaultAllLicenseFamilies());
+        allFamilies.add(newLicense.getLicenseFamily());
+        licenseFamilies.put(LicenseFilter.ALL, allFamilies);
+
+        licenses = new HashMap<>();
+
+        approvedLicenses = new ArrayList<>(defaultApprovedLicenses());
+        approvedLicenses.add(newLicense);
+        licenses.put(LicenseFilter.APPROVED, approvedLicenses);
+        allLicenses = new ArrayList<>(defaultAllLicenses());
+        allLicenses.add(newLicense);
+        licenses.put(LicenseFilter.ALL, allLicenses);
+
+        lst.add(Arguments.of("Testing license id approved", config, licenseFamilies, licenses));
+
+        // Add new license approved by family
+        config = new ReportConfiguration();
+        config.setFrom(defaults);
+        newLicense = new TestingLicense("FAM", "Testing");
+        config.addLicense(newLicense);
+        config.addApprovedLicenseCategory(newLicense.getLicenseFamily());
+
+        licenseFamilies = new HashMap<>();
+        ArrayList<ILicenseFamily> approvedFamilies = new ArrayList<>(defaultApprovedLicenseFamilies());
+        approvedFamilies.add(newLicense.getLicenseFamily());
+        licenseFamilies.put(LicenseFilter.APPROVED, approvedFamilies);
+        allFamilies = new ArrayList<>(defaultAllLicenseFamilies());
+        allFamilies.add(newLicense.getLicenseFamily());
+        licenseFamilies.put(LicenseFilter.ALL, allFamilies);
+
+        licenses = new HashMap<>();
+        approvedLicenses = new ArrayList<>(defaultApprovedLicenses());
+        approvedLicenses.add(newLicense);
+        licenses.put(LicenseFilter.APPROVED, approvedLicenses);
+        allLicenses = new ArrayList<>(defaultAllLicenses());
+        allLicenses.add(newLicense);
+        licenses.put(LicenseFilter.ALL, allLicenses);
+
+        lst.add(Arguments.of("Testing license family approved", config, licenseFamilies, licenses));
+
+        return lst.stream();
+    }
+
+    @ParameterizedTest(name = "{index} {0}")
+    @MethodSource("nonStandardDocumentData")
+    void testNonStandardDocumentsDoNotFailLicenseTests(Document.Type expected, Document document) throws RatDocumentAnalysisException {
+        Defaults defaults = Defaults.builder().build();
+        ReportConfiguration config = new ReportConfiguration();
+        config.setFrom(defaults);
+
+        DocumentAnalyser analyser = AnalyserFactory.createConfiguredAnalyser(config);
+        analyser.analyse(document);
+        assertThat(document.getMetaData().getDocumentType()).isEqualTo(expected);
+        assertThat(document.getMetaData().licenses()).hasSize(0);
+    }
+    
+    private static Stream<Arguments> nonStandardDocumentData() {
+        List<Arguments> lst = new ArrayList<>();
+
+        lst.add(Arguments.of(Document.Type.NOTICE, new TestingDocument(() -> new ByteArrayInputStream("Hello World".getBytes(StandardCharsets.UTF_8)), "NOTICE")));
+        byte[] zipMagic = new byte[]{0x50, 0x4B, 0x03, 0x06};
+        lst.add(Arguments.of(Document.Type.ARCHIVE, new TestingDocument(() -> new ByteArrayInputStream(zipMagic), "example.zip")));
+        byte[] gifMagic = new byte[]{0x47, 0x49, 0x46, 0x38, 0x37, 0x61};
+        lst.add(Arguments.of(Document.Type.BINARY, new TestingDocument(() -> new ByteArrayInputStream(gifMagic), "example.gif")));
+        lst.add(Arguments.of(Document.Type.IGNORED, new TestingDocument(() -> new ByteArrayInputStream("THIS FILE IS AUTOMATICALLY GENERATED".getBytes(StandardCharsets.UTF_8)), "example.ignored")));
+        return lst.stream();
+    }
+}
diff --git a/apache-rat-core/src/test/java/org/apache/rat/analysis/HeaderCheckWorkerTest.java b/apache-rat-core/src/test/java/org/apache/rat/analysis/HeaderCheckWorkerTest.java
index 8d9eb3fe..6e424032 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/analysis/HeaderCheckWorkerTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/analysis/HeaderCheckWorkerTest.java
@@ -23,6 +23,7 @@ import java.io.StringReader;
 
 import java.util.Collections;
 import java.util.stream.Collectors;
+import org.apache.rat.Defaults;
 import org.apache.rat.api.Document;
 import org.apache.rat.configuration.builders.AnyBuilder;
 import org.apache.rat.license.ILicenseFamily;
@@ -40,6 +41,7 @@ public class HeaderCheckWorkerTest {
     @Test
     public void emptyInputIsUnknownTest() throws Exception {
         final Document subject = new TestingDocument("subject");
+        subject.getMetaData().setApprovalPredicate(Defaults.builder().build().getLicenseSetFactory().getApprovedLicensePredicate());
         ILicense matcher = new TestingLicense("test", "test");
         HeaderCheckWorker worker = new HeaderCheckWorker(new TestingMatcher(), new StringReader(""), Lists.list(matcher), subject);
         worker.read();
diff --git a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreProcessorTest.java b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreProcessorTest.java
index 1eca257c..3085792c 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreProcessorTest.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/config/exclusion/fileProcessors/HgIgnoreProcessorTest.java
@@ -47,7 +47,6 @@ public class HgIgnoreProcessorTest extends AbstractIgnoreProcessorTest {
         HgIgnoreProcessor processor = new HgIgnoreProcessor();
         List<String> actual = processor.apply(baseName);
         assertEquals(expected, actual);
-
     }
 
     @Test
diff --git a/apache-rat-core/src/test/java/org/apache/rat/document/DocumentAnalyserMultiplexerTest.java b/apache-rat-core/src/test/java/org/apache/rat/document/DocumentAnalyserMultiplexerTest.java
deleted file mode 100644
index fb3e9940..00000000
--- a/apache-rat-core/src/test/java/org/apache/rat/document/DocumentAnalyserMultiplexerTest.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one   *
- * or more contributor license agreements.  See the NOTICE file *
- * distributed with this work for additional information        *
- * regarding copyright ownership.  The ASF licenses this file   *
- * to you under the Apache License, Version 2.0 (the            *
- * "License"); you may not use this file except in compliance   *
- * with the License.  You may obtain a copy of the License at   *
- *                                                              *
- *   http://www.apache.org/licenses/LICENSE-2.0                 *
- *                                                              *
- * Unless required by applicable law or agreed to in writing,   *
- * software distributed under the License is distributed on an  *
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
- * KIND, either express or implied.  See the License for the    *
- * specific language governing permissions and limitations      *
- * under the License.                                           *
- */ 
-package org.apache.rat.document;
-
-import org.apache.rat.testhelpers.TestingDocument;
-import org.apache.rat.testhelpers.TestingDocumentAnalyser;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-public class DocumentAnalyserMultiplexerTest {
-
-    private DocumentAnalyserMultiplexer multiplexer;
-    private IDocumentAnalyser[] analysers;
-    private TestingDocument document;
-    
-    @BeforeEach
-    public void setUp() {
-        IDocumentAnalyser[] analysers = {
-                new TestingDocumentAnalyser(),
-                new TestingDocumentAnalyser(),
-                new TestingDocumentAnalyser()
-        };
-        this.analysers = analysers;
-        document = new TestingDocument();
-        multiplexer = new DocumentAnalyserMultiplexer(analysers);
-    }
-
-    @Test
-    public void testAnalyse() throws Exception {
-        multiplexer.analyse(document);
-        TestingDocumentAnalyser analyser =  (TestingDocumentAnalyser) (analysers[0]);
-        assertEquals(1, analyser.matches.size(),"Call made to analyser");
-        assertEquals( document, analyser.matches.get(0), "Call made to analyser");
-        analyser =  (TestingDocumentAnalyser) (analysers[1]);
-        assertEquals(1, analyser.matches.size(), "Call made to analyser");
-        assertEquals(document, analyser.matches.get(0), "Call made to analyser");
-        analyser =  (TestingDocumentAnalyser) (analysers[2]);
-        assertEquals( 1, analyser.matches.size());
-        assertEquals( document, analyser.matches.get(0),"Call made to analyser");
-    }
-
-}
diff --git a/apache-rat-core/src/test/java/org/apache/rat/license/LicenseSetFactoryTest.java b/apache-rat-core/src/test/java/org/apache/rat/license/LicenseSetFactoryTest.java
new file mode 100644
index 00000000..92906c96
--- /dev/null
+++ b/apache-rat-core/src/test/java/org/apache/rat/license/LicenseSetFactoryTest.java
@@ -0,0 +1,168 @@
+/*
+     * Licensed to the Apache Software Foundation (ASF) under one   *
+     * or more contributor license agreements.  See the NOTICE file *
+     * distributed with this work for additional information        *
+     * regarding copyright ownership.  The ASF licenses this file   *
+     * to you under the Apache License, Version 2.0 (the            *
+     * "License"); you may not use this file except in compliance   *
+     * with the License.  You may obtain a copy of the License at   *
+     *                                                              *
+     *   http://www.apache.org/licenses/LICENSE-2.0                 *
+     *                                                              *
+     * Unless required by applicable law or agreed to in writing,   *
+     * software distributed under the License is distributed on an  *
+     * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
+     * KIND, either express or implied.  See the License for the    *
+     * specific language governing permissions and limitations      *
+     * under the License.                                           *
+     */
+package org.apache.rat.license;
+
+import java.util.SortedSet;
+import org.apache.rat.Defaults;
+import org.apache.rat.analysis.UnknownLicense;
+import org.apache.rat.testhelpers.TestingLicense;
+import org.apache.rat.testhelpers.TestingMatcher;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class LicenseSetFactoryTest {
+
+    /**
+     * This is the number of accepted licenses in the default license file:
+     * {@code /org/apache/rat/default.xml}
+     */
+    private static final int NUMBER_OF_DEFAULT_ACCEPTED_LICENSES = 7;
+
+    private static final ILicenseFamily[] APPROVED_FAMILIES = { //
+            makeFamily("AL", "Apache License Version 2.0"),
+            makeFamily("BSD-3", "BSD 3 clause"),
+            makeFamily("CDDL1", "COMMON DEVELOPMENT AND DISTRIBUTION LICENSE Version 1.0"),
+            makeFamily("MIT", "The MIT License"),
+            makeFamily("OASIS", "OASIS Open License"),
+            makeFamily("W3CD", "W3C Document Copyright"),
+            makeFamily("W3C", "W3C Software Copyright"),};
+
+    private Defaults defaults;
+    private LicenseSetFactory licenseSetFactory;
+
+    @BeforeEach
+    public void setUp() {
+        defaults = Defaults.builder().build();
+        licenseSetFactory = defaults.getLicenseSetFactory();
+        assertThat(licenseSetFactory.getLicenseFamilies(LicenseSetFactory.LicenseFilter.APPROVED).size()).isEqualTo(NUMBER_OF_DEFAULT_ACCEPTED_LICENSES);
+    }
+
+    private static ILicenseFamily makeFamily(String category, String name) {
+        return ILicenseFamily.builder().setLicenseFamilyCategory(category).setLicenseFamilyName(name).build();
+    }
+
+    private SortedSet<ILicenseFamily> getUnapprovedLicenseFamilies() {
+        SortedSet<ILicenseFamily> unapproved = defaults.getLicenseSetFactory().getLicenseFamilies(LicenseSetFactory.LicenseFilter.ALL);
+        for (ILicenseFamily family : APPROVED_FAMILIES) {
+            unapproved.remove(family);
+        }
+        return unapproved;
+    }
+
+    @Test
+    void testDefaultApprovedLicenses() {
+        assertThat(APPROVED_FAMILIES.length).as("Approved license count mismatch").isEqualTo(NUMBER_OF_DEFAULT_ACCEPTED_LICENSES);
+        for (ILicenseFamily family : APPROVED_FAMILIES) {
+            TestingLicense license = new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family);
+            assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                    .as("Did not approve family " + family)
+                    .isTrue();
+        }
+    }
+
+    @Test
+    void testDefaultUnApprovedLicenses() {
+        SortedSet<ILicenseFamily> unapproved = getUnapprovedLicenseFamilies();
+
+        for (ILicenseFamily family : unapproved) {
+            TestingLicense license = new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family);
+            assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                    .as("Did not find unapproved family " + family)
+                    .isFalse();
+        }
+    }
+
+    @Test
+    public void testUnknownFamily() {
+        ILicenseFamily family = makeFamily("?????", "Unknown document");
+        TestingLicense license = new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family);
+
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Did not find unapproved family " + family)
+                .isFalse();
+
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(UnknownLicense.INSTANCE))
+                .as("Did not find UnknownLicense.INSTANCE")
+                .isFalse();
+    }
+
+    @Test
+    void testLicenseCategoryManipulation() {
+        ILicenseFamily family = makeFamily("test", "Testing License Family");
+        TestingLicense license = new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family);
+
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Found unapproved family " + family)
+                .isFalse();
+
+        licenseSetFactory.approveLicenseCategory(family.getFamilyCategory());
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Did not find approved family " + family)
+                .isTrue();
+
+        licenseSetFactory.removeLicenseCategory(family.getFamilyCategory());
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Found unapproved family " + family)
+                .isFalse();
+    }
+
+    @Test
+    void testAddNewApprovedLicenseNoDefaults() {
+        licenseSetFactory = new LicenseSetFactory();
+        assertThat(licenseSetFactory.getLicenseFamilies(LicenseSetFactory.LicenseFilter.APPROVED).size())
+                .isEqualTo(0);
+
+        ILicenseFamily family = makeFamily("test", "Testing License Family");
+        TestingLicense license = new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family);
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Did find unapproved family " + family)
+                .isFalse();
+
+        licenseSetFactory.addLicense(license);
+        licenseSetFactory.approveLicenseCategory(family.getFamilyCategory());
+        assertThat(licenseSetFactory.getLicenseFamilies(LicenseSetFactory.LicenseFilter.APPROVED).size())
+                .isEqualTo(1);
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Did not find approved family " + family)
+                .isTrue();
+    }
+
+    @Test
+    void testLicenseIDManipulation() {
+        String licenseId = "customId";
+        ILicenseFamily family = getUnapprovedLicenseFamilies().first();
+        TestingLicense license = new TestingLicense(licenseId, new TestingMatcher(), family);
+
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Found unapproved id " + licenseId)
+                .isFalse();
+
+        licenseSetFactory.approveLicenseId(licenseId);
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Did not find approved id " + licenseId)
+                .isTrue();
+
+        licenseSetFactory.removeLicenseId(licenseId);
+        assertThat(licenseSetFactory.getApprovedLicensePredicate().test(license))
+                .as("Found unapproved id " + licenseId)
+                .isFalse();
+    }
+}
diff --git a/apache-rat-core/src/test/java/org/apache/rat/policy/DefaultPolicyTest.java b/apache-rat-core/src/test/java/org/apache/rat/policy/DefaultPolicyTest.java
deleted file mode 100644
index 32438edb..00000000
--- a/apache-rat-core/src/test/java/org/apache/rat/policy/DefaultPolicyTest.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one   *
- * or more contributor license agreements.  See the NOTICE file *
- * distributed with this work for additional information        *
- * regarding copyright ownership.  The ASF licenses this file   *
- * to you under the Apache License, Version 2.0 (the            *
- * "License"); you may not use this file except in compliance   *
- * with the License.  You may obtain a copy of the License at   *
- *                                                              *
- *   http://www.apache.org/licenses/LICENSE-2.0                 *
- *                                                              *
- * Unless required by applicable law or agreed to in writing,   *
- * software distributed under the License is distributed on an  *
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *
- * KIND, either express or implied.  See the License for the    *
- * specific language governing permissions and limitations      *
- * under the License.                                           *
- */
-package org.apache.rat.policy;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-
-import java.util.Collections;
-import java.util.SortedSet;
-import java.util.TreeSet;
-
-import org.apache.rat.Defaults;
-import org.apache.rat.api.Document;
-import org.apache.rat.license.ILicenseFamily;
-import org.apache.rat.license.LicenseSetFactory;
-import org.apache.rat.license.LicenseSetFactory.LicenseFilter;
-import org.apache.rat.testhelpers.TestingLicense;
-import org.apache.rat.testhelpers.TestingDocument;
-import org.apache.rat.testhelpers.TestingMatcher;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-/**
- * Tests the Default policy implementation.
- */
-public class DefaultPolicyTest {
-    /**
-     * This is the number of accepted licenses in the default license file :
-     * /org/apache/rat/default.xml
-     */
-    private static final int NUMBER_OF_DEFAULT_ACCEPTED_LICENSES = 7;
-
-    private static final ILicenseFamily[] APPROVED_FAMILIES = { //
-            makeFamily("AL", "Apache License Version 2.0"),
-            makeFamily("BSD-3", "BSD 3 clause"),
-            makeFamily("CDDL1", "COMMON DEVELOPMENT AND DISTRIBUTION LICENSE Version 1.0"),
-            makeFamily("MIT", "The MIT License"),
-            makeFamily("OASIS", "OASIS Open License"), makeFamily("W3CD", "W3C Document Copyright"),
-            makeFamily("W3C", "W3C Software Copyright"), };
-
-    private Document document;
-    private DefaultPolicy policy;
-    private Defaults defaults;
-
-    @BeforeEach
-    public void setUp() {
-        defaults = Defaults.builder().build();
-        policy = new DefaultPolicy(defaults.getLicenseSetFactory().getLicenseFamilies(LicenseFilter.APPROVED));
-        document = new TestingDocument("subject");
-    }
-
-    private void assertApproval(boolean pApproved) {
-        boolean state = document.getMetaData().approvedLicenses().findAny().isPresent();
-        assertEquals(pApproved, state);
-    }
-
-    private void setMetadata(ILicenseFamily family) {
-        document.getMetaData().reportOnLicense(new TestingLicense(family.getFamilyCategory().trim(), new TestingMatcher(), family));
-    }
-
-    private static ILicenseFamily makeFamily(String category, String name) {
-        return ILicenseFamily.builder().setLicenseFamilyCategory(category).setLicenseFamilyName(name).build();
-    }
-
-    @Test
-    public void testCount() {
-        assertEquals(NUMBER_OF_DEFAULT_ACCEPTED_LICENSES, policy.getApprovedLicenseFamilies().size());
-    }
-
-    @Test
-    public void testApprovedLicenses() {
-
-        assertEquals(NUMBER_OF_DEFAULT_ACCEPTED_LICENSES, APPROVED_FAMILIES.length, "Approved license count mismatch");
-        for (ILicenseFamily family : APPROVED_FAMILIES) {
-            setMetadata(family);
-            policy.analyse(document);
-            assertApproval(true);
-        }
-    }
-
-    @Test
-    public void testUnApprovedLicenses() {
-        SortedSet<ILicenseFamily> all = defaults.getLicenseSetFactory().getLicenseFamilies(LicenseFilter.ALL);
-        SortedSet<ILicenseFamily> unapproved = new TreeSet<>();
-        unapproved.addAll(all);
-        unapproved.removeAll(defaults.getLicenseSetFactory().getLicenseFamilies(LicenseFilter.APPROVED));
-
-        assertEquals(all.size() - NUMBER_OF_DEFAULT_ACCEPTED_LICENSES, unapproved.size(),
-                "Unapproved license count mismatch");
-        for (ILicenseFamily family : unapproved) {
-            setMetadata(family);
-            policy.analyse(document);
-            assertApproval(false);
-        }
-    }
-
-    @Test
-    public void testUnknownFamily() {
-        setMetadata(makeFamily("?????", "Unknown document"));
-        policy.analyse(document);
-        assertApproval(false);
-    }
-
-    @Test
-    public void testAddNewApprovedLicenseAndDefaults() {
-        ILicenseFamily testingFamily = makeFamily("test", "Testing License Family");
-        setMetadata(testingFamily);
-        policy.analyse(document);
-        assertApproval(false);
-
-        policy.add(testingFamily);
-        assertNotNull(LicenseSetFactory.familySearch(testingFamily, policy.getApprovedLicenseFamilies()),
-                "Did not properly add ILicenseFamily");
-        policy.analyse(document);
-        assertApproval(true);
-    }
-
-    @Test
-    public void testAddNewApprovedLicenseNoDefaults() {
-        policy = new DefaultPolicy(Collections.emptySet());
-        assertEquals(0, policy.getApprovedLicenseFamilies().size());
-        ILicenseFamily testingFamily = makeFamily("test", "Testing License Family");
-        setMetadata(testingFamily);
-        policy.analyse(document);
-        assertApproval(false);
-
-        policy.add(testingFamily);
-        assertEquals(1, policy.getApprovedLicenseFamilies().size());
-        assertNotNull(LicenseSetFactory.familySearch(testingFamily, policy.getApprovedLicenseFamilies()),
-                "Did not properly add ILicenseFamily");
-        policy.analyse(document);
-        assertApproval(true);
-    }
-
-    @Test
-    public void testNonStandardDocumentsDoNotFailLicenseTests() {
-        Document.Type[] nonStandardDocuments = { Document.Type.NOTICE, Document.Type.ARCHIVE, Document.Type.BINARY };
-
-        for (Document.Type d : nonStandardDocuments) {
-            document = new TestingDocument("subject");
-            document.getMetaData().setDocumentType(d);
-            policy.analyse(document);
-            assertEquals(0, document.getMetaData().licenses().count(), "failed on " + d);
-        }
-    }
-
-    @Test
-    public void testUnclassifiedDocumentsDoNotFailLicenseTests() {
-        document.getMetaData().setDocumentType(Document.Type.STANDARD);
-        policy.analyse(document);
-        assertApproval(false);
-    }
-}
diff --git a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocument.java b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocument.java
index 7ab034a3..c1e75668 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocument.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocument.java
@@ -18,11 +18,14 @@
  */
 package org.apache.rat.testhelpers;
 
+import java.io.IOException;
 import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.io.Reader;
 import java.util.Collections;
 import java.util.SortedSet;
 
+import org.apache.commons.io.function.IOSupplier;
 import org.apache.rat.api.Document;
 import org.apache.rat.document.DocumentNameMatcher;
 import org.apache.rat.document.DocumentName;
@@ -30,33 +33,43 @@ import org.apache.rat.document.DocumentName;
 public class TestingDocument extends Document {
 
     private final Reader reader;
+    private final IOSupplier<InputStream> input;
 
     public TestingDocument() {
-        this(null, "name");
+        this("name");
     }
 
     public TestingDocument(String name) {
-        this(null, name);
+        this(name, null);
     }
 
     public TestingDocument(DocumentName documentName) {
         super(documentName, DocumentNameMatcher.MATCHES_ALL);
         this.reader = null;
+        this.input = null;
     }
 
     public TestingDocument(String name, DocumentNameMatcher matcher) {
         super(DocumentName.builder().setName(name).setBaseName("").setDirSeparator("/").setCaseSensitive(true).build(), matcher);
         this.reader = null;
+        this.input = null;
     }
 
     public TestingDocument(Reader reader, String name) {
         super(DocumentName.builder().setName(name).setBaseName("").setDirSeparator("/").setCaseSensitive(true).build(), DocumentNameMatcher.MATCHES_ALL);
         this.reader = reader;
+        this.input = null;
+    }
+
+    public TestingDocument(IOSupplier<InputStream> inputStream, String name) {
+        super(DocumentName.builder().setName(name).setBaseName("").setDirSeparator("/").setCaseSensitive(true).build(), DocumentNameMatcher.MATCHES_ALL);
+        this.input = inputStream;
+        this.reader = null;
     }
 
     @Override
-    public Reader reader() {
-        return reader;
+    public Reader reader() throws IOException {
+            return reader == null ? new InputStreamReader(input.get()) : reader;
     }
 
     @Override
@@ -70,7 +83,10 @@ public class TestingDocument extends Document {
     }
 
     @Override
-    public InputStream inputStream() {
+    public InputStream inputStream() throws IOException {
+        if (input != null) {
+            return input.get();
+        }
         throw new UnsupportedOperationException();
     }
 }
diff --git a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocumentAnalyser.java b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocumentAnalyser.java
index f8c78d49..a4daaba0 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocumentAnalyser.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingDocumentAnalyser.java
@@ -22,9 +22,9 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.rat.api.Document;
-import org.apache.rat.document.IDocumentAnalyser;
+import org.apache.rat.document.DocumentAnalyser;
 
-public class TestingDocumentAnalyser implements IDocumentAnalyser {
+public class TestingDocumentAnalyser implements DocumentAnalyser {
 
     public final List<Document> matches = new ArrayList<>();
 
diff --git a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingLicense.java b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingLicense.java
index 10aee0d9..efc651be 100644
--- a/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingLicense.java
+++ b/apache-rat-core/src/test/java/org/apache/rat/testhelpers/TestingLicense.java
@@ -75,6 +75,7 @@ public class TestingLicense implements ILicense {
         this.matcher = matcher;
         this.note = null;
         this.id = id;
+        this.name = id;
     }
 
     /**
@@ -141,4 +142,9 @@ public class TestingLicense implements ILicense {
     public int hashCode() {
         return ILicense.hash(this);
     }
+
+    @Override
+    public String toString() {
+        return String.format("%s[id='%s', family='%s']", name, id, family);
+    }
 }
