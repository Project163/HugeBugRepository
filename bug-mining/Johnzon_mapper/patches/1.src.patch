diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index 77dd96cd..595b1aaa 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -19,6 +19,7 @@
 package org.apache.johnzon.mapper;
 
 import org.apache.johnzon.mapper.converter.EnumConverter;
+import org.apache.johnzon.mapper.reflection.JohnzonCollectionType;
 import org.apache.johnzon.mapper.reflection.Mappings;
 
 import javax.json.Json;
@@ -32,7 +33,6 @@ import javax.json.JsonValue;
 import javax.json.JsonValue.ValueType;
 import javax.json.stream.JsonGenerator;
 import javax.json.stream.JsonGeneratorFactory;
-
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
@@ -425,14 +425,14 @@ public class Mapper {
         }
     }
 
-    public <C extends Collection<T>, T> C readCollection(final InputStream stream, final ParameterizedType genericType, final Class<T> raw) {
+    public <T> Collection<T> readCollection(final InputStream stream, final ParameterizedType genericType) {
         final JsonReader reader = readerFactory.createReader(stream);
-        final Mappings.CollectionMapping mapping = mappings.findCollectionMapping(genericType, raw);
+        final Mappings.CollectionMapping mapping = mappings.findCollectionMapping(genericType);
         if (mapping == null) {
             throw new UnsupportedOperationException("type " + genericType + " not supported");
         }
         try {
-            return (C) mapCollection(mapping, reader.readArray());
+            return mapCollection(mapping, reader.readArray());
         } catch (final InstantiationException e) {
             throw new MapperException(e);
         } catch (final IllegalAccessException e) {
@@ -444,14 +444,22 @@ public class Mapper {
         }
     }
 
-    public <C extends Collection<T>, T> C readCollection(final Reader stream, final ParameterizedType genericType, final Class<T> raw) {
+    public <T> T readJohnzonCollection(final InputStream stream, final JohnzonCollectionType<T> genericType) {
+        return (T) readCollection(stream, genericType);
+    }
+
+    public <T> T readJohnzonCollection(final Reader stream, final JohnzonCollectionType<T> genericType) {
+        return (T) readCollection(stream, genericType);
+    }
+
+    public <T> Collection<T> readCollection(final Reader stream, final ParameterizedType genericType) {
         final JsonReader reader = readerFactory.createReader(stream);
-        final Mappings.CollectionMapping mapping = mappings.findCollectionMapping(genericType, raw);
+        final Mappings.CollectionMapping mapping = mappings.findCollectionMapping(genericType);
         if (mapping == null) {
             throw new UnsupportedOperationException("type " + genericType + " not supported");
         }
         try {
-            return (C) mapCollection(mapping, reader.readArray());
+            return mapCollection(mapping, reader.readArray());
         } catch (final InstantiationException e) {
             throw new MapperException(e);
         } catch (final IllegalAccessException e) {
@@ -639,8 +647,7 @@ public class Mapper {
         }
 
         if (ParameterizedType.class.isInstance(type)) {
-            final Mappings.CollectionMapping mapping = mappings.findCollectionMapping(
-                    ParameterizedType.class.cast(type), (Class<Object>) ParameterizedType.class.cast(type).getRawType());
+            final Mappings.CollectionMapping mapping = mappings.findCollectionMapping(ParameterizedType.class.cast(type));
             if (mapping != null) {
                 return mapCollection(mapping, jsonArray);
             }
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonCollectionType.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonCollectionType.java
new file mode 100644
index 00000000..615386c1
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonCollectionType.java
@@ -0,0 +1,25 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper.reflection;
+
+public abstract class JohnzonCollectionType<TYPE> extends JohnzonParameterizedType {
+    public JohnzonCollectionType() {
+        super(null);
+    }
+}
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonListType.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonListType.java
new file mode 100644
index 00000000..21e43fe1
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonListType.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper.reflection;
+
+import java.util.List;
+
+public abstract class JohnzonListType<A> extends JohnzonCollectionType<List<A>> {
+}
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonParameterizedType.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonParameterizedType.java
new file mode 100644
index 00000000..479268e4
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/JohnzonParameterizedType.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper.reflection;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.Arrays;
+
+public class JohnzonParameterizedType implements ParameterizedType {
+    private final Type rawType;
+    private final Type[] types;
+
+    public JohnzonParameterizedType(final Type raw, final Type... types) {
+        if (raw == null) {
+            final ParameterizedType userFinalType = findUserParameterizedType();
+            this.rawType = userFinalType.getRawType();
+            this.types = userFinalType.getActualTypeArguments();
+        } else {
+            this.rawType = raw;
+            this.types = types;
+        }
+    }
+
+    private ParameterizedType findUserParameterizedType() {
+        final Type genericSuperclass = getClass().getGenericSuperclass();
+        if (!ParameterizedType.class.isInstance(genericSuperclass)) {
+            throw new IllegalArgumentException("raw can be null only for children classes");
+        }
+        final ParameterizedType pt = ParameterizedType.class.cast(genericSuperclass); // our type, then unwrap it
+
+        final Type userType = pt.getActualTypeArguments()[0];
+        if (!ParameterizedType.class.isInstance(userType)) {
+            throw new IllegalArgumentException("You need to pass a parameterized type to Johnzon*Types");
+        }
+
+        return ParameterizedType.class.cast(userType);
+    }
+
+    @Override
+    public Type[] getActualTypeArguments() {
+        return types.clone();
+    }
+
+    @Override
+    public Type getOwnerType() {
+        return null;
+    }
+
+    @Override
+    public Type getRawType() {
+        return rawType;
+    }
+
+    @Override
+    public int hashCode() {
+        return Arrays.hashCode(types) ^ (rawType == null ? 0 : rawType.hashCode());
+    }
+
+    @Override
+    public boolean equals(final Object obj) {
+        if (this == obj) {
+            return true;
+        } else if (obj instanceof ParameterizedType) {
+            final ParameterizedType that = (ParameterizedType) obj;
+            final Type thatRawType = that.getRawType();
+            return that.getOwnerType() == null
+                    && (rawType == null ? thatRawType == null : rawType.equals(thatRawType))
+                    && Arrays.equals(types, that.getActualTypeArguments());
+        } else {
+            return false;
+        }
+    }
+
+    @Override
+    public String toString() {
+        final StringBuilder buffer = new StringBuilder();
+        buffer.append(((Class<?>) rawType).getSimpleName());
+        final Type[] actualTypes = getActualTypeArguments();
+        if (actualTypes.length > 0) {
+            buffer.append("<");
+            int length = actualTypes.length;
+            for (int i = 0; i < length; i++) {
+                buffer.append(actualTypes[i].toString());
+                if (i != actualTypes.length - 1) {
+                    buffer.append(",");
+                }
+            }
+
+            buffer.append(">");
+        }
+        return buffer.toString();
+    }
+}
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java
index 116c97fb..55aacdcd 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/reflection/Mappings.java
@@ -18,6 +18,11 @@
  */
 package org.apache.johnzon.mapper.reflection;
 
+import org.apache.johnzon.mapper.Converter;
+import org.apache.johnzon.mapper.JohnzonConverter;
+import org.apache.johnzon.mapper.JohnzonIgnore;
+import org.apache.johnzon.mapper.MapperException;
+
 import java.beans.IntrospectionException;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
@@ -38,11 +43,6 @@ import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
-import org.apache.johnzon.mapper.Converter;
-import org.apache.johnzon.mapper.JohnzonConverter;
-import org.apache.johnzon.mapper.JohnzonIgnore;
-import org.apache.johnzon.mapper.MapperException;
-
 public class Mappings {
     public static class ClassMapping {
         public final Class<?> clazz;
@@ -116,10 +116,10 @@ public class Mappings {
         this.fieldOrdering = attributeOrder;
     }
 
-    public <T> CollectionMapping findCollectionMapping(final ParameterizedType genericType, final Class<T> raw) {
+    public <T> CollectionMapping findCollectionMapping(final ParameterizedType genericType) {
         CollectionMapping collectionMapping = collections.get(genericType);
         if (collectionMapping == null) {
-            collectionMapping = createCollectionMapping(genericType, raw);
+            collectionMapping = createCollectionMapping(genericType);
             if (collectionMapping == null) {
                 return null;
             }
@@ -131,19 +131,21 @@ public class Mappings {
         return collectionMapping;
     }
 
-    private <T> CollectionMapping createCollectionMapping(final ParameterizedType aType, final Class<T> raw) {
+    private <T> CollectionMapping createCollectionMapping(final ParameterizedType aType) {
         final Type[] fieldArgTypes = aType.getActualTypeArguments();
-        if (fieldArgTypes.length == 1) {
+        final Type raw = aType.getRawType();
+        if (fieldArgTypes.length == 1 && Class.class.isInstance(raw)) {
+            final Class<?> r = Class.class.cast(raw);
             final Class<?> collectionType;
-            if (List.class.isAssignableFrom(raw)) {
+            if (List.class.isAssignableFrom(r)) {
                 collectionType = List.class;
-            }else if (SortedSet.class.isAssignableFrom(raw)) {
+            }else if (SortedSet.class.isAssignableFrom(r)) {
                 collectionType = SortedSet.class;
-            } else if (Set.class.isAssignableFrom(raw)) {
+            } else if (Set.class.isAssignableFrom(r)) {
                 collectionType = Set.class;
-            } else if (Queue.class.isAssignableFrom(raw)) {
+            } else if (Queue.class.isAssignableFrom(r)) {
                 collectionType = Queue.class;
-            } else if (Collection.class.isAssignableFrom(raw)) {
+            } else if (Collection.class.isAssignableFrom(r)) {
                 collectionType = Collection.class;
             } else {
                 return null;
diff --git a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
index f23f050b..2aefdcea 100644
--- a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
+++ b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
@@ -18,21 +18,24 @@
  */
 package org.apache.johnzon.mapper;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import org.apache.johnzon.mapper.reflection.JohnzonCollectionType;
+import org.apache.johnzon.mapper.reflection.JohnzonParameterizedType;
+import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.StringWriter;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
-import org.junit.Test;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 public class MapperTest {
     private static final String BIG_OBJECT_STR = "{" + "\"name\":\"the string\"," + "\"integer\":56," + "\"longnumber\":118,"
@@ -63,6 +66,20 @@ public class MapperTest {
         assertEquals(0, object.length);
     }
 
+    @Test
+    public void readCollection() { // mainly API test
+        final Collection<TheObject> object = new MapperBuilder().build()
+                .readCollection(new ByteArrayInputStream("[{}]".getBytes()),
+                        new JohnzonParameterizedType(List.class, TheObject.class));
+        assertNotNull(object);
+        assertEquals(1, object.size());
+        final Collection<TheObject> object2 = new MapperBuilder().build()
+                .readJohnzonCollection(new ByteArrayInputStream("[{}]".getBytes()),
+                        new JohnzonCollectionType<List<TheObject>>() {});
+        assertNotNull(object2);
+        assertEquals(1, object2.size());
+    }
+
     @Test
     public void writeMap() {
         final ByteArrayOutputStream baos = new ByteArrayOutputStream();
@@ -99,7 +116,7 @@ public class MapperTest {
     }
 
     static class Bool {
-        boolean bool;
+        private boolean bool;
 
         public boolean isBool() {
             return bool;
@@ -112,7 +129,7 @@ public class MapperTest {
     }
 
     static class Bool2 {
-        Map<String, Boolean> map;
+        private Map<String, Boolean> map;
 
         public Map<String, Boolean> getMap() {
             return map;
