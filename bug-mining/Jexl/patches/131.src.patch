diff --git a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
index 39c2ceea..17e19375 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
+++ b/src/main/java/org/apache/commons/jexl3/parser/JexlParser.java
@@ -26,14 +26,13 @@ import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.StringReader;
 import java.lang.reflect.Constructor;
+import java.util.ArrayDeque;
 import java.util.Arrays;
+import java.util.Deque;
 import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Queue;
 import java.util.Set;
-import java.util.Stack;
 import java.util.TreeMap;
 
 
@@ -62,7 +61,7 @@ public abstract class JexlParser extends StringParser {
     /**
      * When parsing inner functions/lambda, need to stack the scope (sic).
      */
-    protected Stack<Scope> frames = new Stack<Scope>();
+    protected Deque<Scope> frames = new ArrayDeque<Scope>();
     /**
      * The list of pragma declarations.
      */
@@ -74,9 +73,22 @@ public abstract class JexlParser extends StringParser {
     /**
      * Stack of parsing loop counts.
      */
-    protected Queue<Integer> loopCounts = null;
+    protected Deque<Integer> loopCounts = new ArrayDeque<Integer>();
 
 
+    /**
+     * Cleanup.
+     * @param features the feature set to restore if any
+     */
+    protected void cleanup(JexlFeatures features) {
+        info = null;
+        source = null;
+        frame = null;
+        frames.clear();
+        pragmas = null;
+        loopCounts.clear();
+        loopCount = 0;
+    }
     /**
      * Utility function to create '.' separated string from a list of string.
      * @param lstr the list of strings
@@ -167,10 +179,7 @@ public abstract class JexlParser extends StringParser {
             frames.push(frame);
         }
         frame = new Scope(frame, (String[]) null);
-        if (loopCounts == null) {
-            loopCounts = new LinkedList<Integer>();
-        }
-        loopCounts.add(loopCount);
+        loopCounts.push(loopCount);
         loopCount = 0;
     }
 
@@ -183,8 +192,8 @@ public abstract class JexlParser extends StringParser {
         } else {
             frame = null;
         }
-        if (loopCounts != null && !loopCounts.isEmpty()) {
-            loopCount = loopCounts.remove();
+        if (!loopCounts.isEmpty()) {
+            loopCount = loopCounts.pop();
         }
     }
 
diff --git a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
index dcb0f87d..3565ba0e 100644
--- a/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
+++ b/src/main/java/org/apache/commons/jexl3/parser/Parser.jjt
@@ -63,18 +63,14 @@ public final class Parser extends JexlParser
             script.setPragmas(pragmas != null
                              ? Collections.<String,Object>unmodifiableMap(pragmas)
                              : Collections.<String,Object>emptyMap());
-            pragmas = null;
             return script;
         } catch (TokenMgrError xtme) {
             throw new JexlException.Tokenization(info, xtme).clean();
         } catch (ParseException xparse) {
             throw new JexlException.Parsing(info, xparse).clean();
         } finally {
-            info = null;
-            source = null;
-            frame = null;
             token_source.defaultLexState = DEFAULT;
-            setFeatures(previous);
+            cleanup(previous);
         }
     }
 }
@@ -306,9 +302,9 @@ void Annotation() #Annotation :
 }
 
 void AnnotatedStatement() #AnnotatedStatement() : {}
-{
+ {
     (LOOKAHEAD(<ANNOTATION>) Annotation())+ (LOOKAHEAD(<VAR>) Var() | LOOKAHEAD(1) Block() | Expression())
-}
+ }
 
 void Statement() #void : {}
 {
diff --git a/src/test/java/org/apache/commons/jexl3/DoWhileTest.java b/src/test/java/org/apache/commons/jexl3/DoWhileTest.java
index 72603630..c29b853b 100644
--- a/src/test/java/org/apache/commons/jexl3/DoWhileTest.java
+++ b/src/test/java/org/apache/commons/jexl3/DoWhileTest.java
@@ -16,7 +16,6 @@
  */
 package org.apache.commons.jexl3;
 
-import org.apache.commons.jexl3.internal.Debugger;
 import org.junit.Assert;
 import org.junit.Test;
 
@@ -100,4 +99,10 @@ public class DoWhileTest extends JexlTestCase {
             Assert.assertTrue(str.contains("continue"));
         }
     }
+            
+    @Test
+    public void testForEachLambda() throws Exception {
+        JexlScript e = JEXL.createScript("(x)->{ for (i : 1..2) {  continue; var y = function() { 42; } break; } }");
+        Assert.assertNotNull(e);
+    }
 }
