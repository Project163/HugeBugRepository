diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index 77b22b64..a9ca6743 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -18,7 +18,6 @@
  */
 package org.apache.johnzon.mapper;
 
-import static java.util.Arrays.asList;
 import static org.apache.johnzon.mapper.internal.Streams.noClose;
 
 import java.io.Closeable;
@@ -38,6 +37,7 @@ import java.math.BigInteger;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 
 import javax.json.JsonArray;
@@ -53,6 +53,7 @@ import javax.json.stream.JsonGeneratorFactory;
 
 import org.apache.johnzon.mapper.internal.JsonPointerTracker;
 import org.apache.johnzon.mapper.reflection.JohnzonCollectionType;
+import org.apache.johnzon.mapper.util.ArrayUtil;
 
 public class Mapper implements Closeable {
 
@@ -82,15 +83,32 @@ public class Mapper implements Closeable {
 
 
     public <T> void writeArray(final Object object, final OutputStream stream) {
-        writeObject(asList((T[]) object), stream);
+        if (object instanceof short[]) {
+            writeObject(ArrayUtil.asList((short[]) object), stream);
+        } else if (object instanceof int[]) {
+            writeObject(ArrayUtil.asList((int[]) object), stream);
+        } else if (object instanceof long[]) {
+            writeObject(ArrayUtil.asList((long[]) object), stream);
+        } else if (object instanceof byte[]) {
+            writeObject(ArrayUtil.asList((byte[]) object), stream);
+        } else if (object instanceof char[]) {
+            writeObject(ArrayUtil.asList((char[]) object), stream);
+        } else if (object instanceof float[]) {
+            writeObject(ArrayUtil.asList((float[]) object), stream);
+        } else if (object instanceof double[]) {
+            writeObject(ArrayUtil.asList((double[]) object), stream);
+        } else {
+            writeObject(Arrays.asList((T[]) object), stream);
+        }
     }
 
+
     public <T> void writeArray(final T[] object, final OutputStream stream) {
-        writeObject(asList(object), stream);
+        writeObject(Arrays.asList(object), stream);
     }
 
     public <T> void writeArray(final T[] object, final Writer stream) {
-        writeObject(asList(object), stream);
+        writeObject(Arrays.asList(object), stream);
     }
 
     public <T> void writeArray(final Collection<T> object, final OutputStream stream) {
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/util/ArrayUtil.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/util/ArrayUtil.java
new file mode 100644
index 00000000..a7a6c572
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/util/ArrayUtil.java
@@ -0,0 +1,129 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.johnzon.mapper.util;
+
+import java.util.AbstractList;
+import java.util.List;
+
+/**
+ * Various Array utils which do not exist in Java.
+ */
+public final class ArrayUtil {
+    private ArrayUtil() {
+        // utility class ct
+    }
+
+    public static List<Integer> asList(final int[] vals) {
+        return new AbstractList<Integer>() {
+            @Override
+            public Integer get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+    public static List<Short> asList(final short[] vals) {
+        return new AbstractList<Short>() {
+            @Override
+            public Short get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+    public static List<Long> asList(final long[] vals) {
+        return new AbstractList<Long>() {
+            @Override
+            public Long get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+    public static List<Character> asList(final char[] vals) {
+        return new AbstractList<Character>() {
+            @Override
+            public Character get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+    public static List<Byte> asList(final byte[] vals) {
+        return new AbstractList<Byte>() {
+            @Override
+            public Byte get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+    public static List<Float> asList(final float[] vals) {
+        return new AbstractList<Float>() {
+            @Override
+            public Float get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+    public static List<Double> asList(final double[] vals) {
+        return new AbstractList<Double>() {
+            @Override
+            public Double get(int index) {
+                return vals[index];
+            }
+
+            @Override
+            public int size() {
+                return vals.length;
+            }
+        };
+    }
+
+
+}
diff --git a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
index 44e79a13..0aa4ccb1 100644
--- a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
+++ b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/MapperTest.java
@@ -486,6 +486,55 @@ public class MapperTest {
        assertEquals(expectedJson, writer.toString());
    }
 
+   @Test
+   public void testShortArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new short[] { 1, 2 }, baos);
+       assertEquals("[1,2]", baos.toString());
+   }
+
+   @Test
+   public void testLongArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new long[] { 1L, 2L }, baos);
+       assertEquals("[1,2]", baos.toString());
+   }
+
+   @Test
+   public void testByteArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new byte[] { 1, 2 }, baos);
+       assertEquals("[1,2]", baos.toString());
+   }
+
+   @Test
+   public void testCharArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new char[] { '1', '2' }, baos);
+       assertEquals("[\"1\",\"2\"]", baos.toString());
+   }
+
+   @Test
+   public void testIntArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new int[] { 1, 2 }, baos);
+       assertEquals("[1,2]", baos.toString());
+   }
+
+   @Test
+   public void testFloatArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new float[] { 1f, 2f }, baos);
+       assertEquals("[1.0,2.0]", baos.toString());
+   }
+
+   @Test
+   public void testDoubleArray() {
+       ByteArrayOutputStream baos = new ByteArrayOutputStream();
+       new MapperBuilder().build().writeArray(new double[] { 1d, 2d }, baos);
+       assertEquals("[1.0,2.0]", baos.toString());
+   }
+
     /**
      * Verify that assigning a short or byte number
      * which is too big to fit into the java field
