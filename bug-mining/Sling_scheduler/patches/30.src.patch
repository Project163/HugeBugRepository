diff --git a/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzThreadPool.java b/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzThreadPool.java
index cbf4c31..cbe5d75 100644
--- a/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzThreadPool.java
+++ b/src/main/java/org/apache/sling/commons/scheduler/impl/QuartzThreadPool.java
@@ -21,13 +21,18 @@ import org.apache.sling.commons.threads.ThreadPool;
 public class QuartzThreadPool implements org.quartz.spi.ThreadPool {
 
     /** Our executor thread pool */
-    private ThreadPool executor;
+    private volatile ThreadPool executor;
+
+    private final Object lock = new Object();
+
+    private volatile int counter;
 
     /**
      * Create a new wrapper implementation for Quartz.
      */
     public QuartzThreadPool(final ThreadPool executor) {
         this.executor = executor;
+        this.counter = executor.getConfiguration().getMaxPoolSize();
     }
 
     /**
@@ -67,8 +72,23 @@ public class QuartzThreadPool implements org.quartz.spi.ThreadPool {
      */
     @Override
     public boolean runInThread(final Runnable job) {
-        this.executor.execute(job);
-
+        synchronized ( this.lock ) {
+            if ( this.counter == 0 ) {
+                return false;
+            }
+            this.counter--;
+        }
+        final Runnable r = () -> {
+            try {
+                job.run();
+            } finally {
+                synchronized ( this.lock ) {
+                    this.counter++;
+                    this.lock.notify();
+                }    
+            }
+        };
+        this.executor.execute(r);
         return true;
     }
 
@@ -77,7 +97,16 @@ public class QuartzThreadPool implements org.quartz.spi.ThreadPool {
      */
     @Override
     public int blockForAvailableThreads() {
-        return this.executor.getConfiguration().getMaxPoolSize() - this.executor.getConfiguration().getQueueSize();
+        synchronized ( this.lock ) {
+            while ( this.counter == 0 ) {
+                try {
+                    this.lock.wait();
+                } catch (final InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            }
+            return this.counter;
+        }
     }
 
     /**
@@ -85,6 +114,11 @@ public class QuartzThreadPool implements org.quartz.spi.ThreadPool {
      */
     @Override
     public void shutdown(final boolean waitForJobsToComplete) {
+        // potentially wake up blockForAvailableThreads
+        synchronized ( this.lock ) {
+            this.counter = Integer.MAX_VALUE;
+            this.lock.notify();
+        }
         // the pool is managed by the thread pool manager,
         // so we can just return
         this.executor = null;
diff --git a/src/test/java/org/apache/sling/commons/scheduler/impl/ActivatedQuartzSchedulerFactory.java b/src/test/java/org/apache/sling/commons/scheduler/impl/ActivatedQuartzSchedulerFactory.java
index 5c06a81..9afe588 100644
--- a/src/test/java/org/apache/sling/commons/scheduler/impl/ActivatedQuartzSchedulerFactory.java
+++ b/src/test/java/org/apache/sling/commons/scheduler/impl/ActivatedQuartzSchedulerFactory.java
@@ -20,6 +20,7 @@ import java.lang.reflect.Field;
 import java.util.Dictionary;
 import java.util.Hashtable;
 
+import org.apache.sling.commons.threads.ThreadPoolManager;
 import org.apache.sling.commons.threads.impl.DefaultThreadPoolManager;
 import org.osgi.framework.BundleContext;
 import org.osgi.framework.Constants;
@@ -59,4 +60,32 @@ class ActivatedQuartzSchedulerFactory {
         }
         return quartzScheduler;
     }
+
+    public static QuartzScheduler create(BundleContext context, String poolName, ThreadPoolManager tpm) throws Exception {
+        QuartzScheduler quartzScheduler = null;
+        if (context != null) {
+            quartzScheduler = new QuartzScheduler();
+            Dictionary<String, Object> props = new Hashtable<String, Object>();
+            props.put(Constants.SERVICE_DESCRIPTION, "org.apache.sling.commons.threads.impl.DefaultThreadPoolManager");
+            props.put(Constants.SERVICE_PID, "org.apache.sling.commons.threads.impl.DefaultThreadPoolManager");
+
+            Field f = QuartzScheduler.class.getDeclaredField("threadPoolManager");
+            f.setAccessible(true);
+            f.set(quartzScheduler, tpm);
+
+            final QuartzSchedulerConfiguration configuration = mock(QuartzSchedulerConfiguration.class);
+            if (poolName == null) {
+                when(configuration.poolName()).thenReturn("testName");
+            } else {
+                final String[] allowedPoolNames = new String[] {"testName", "allowed"};
+                when(configuration.poolName()).thenReturn(poolName);
+                when(configuration.allowedPoolNames()).thenReturn(allowedPoolNames);
+            }
+
+            quartzScheduler.activate(context, configuration);
+            context.registerService("scheduler", quartzScheduler, props);
+        }
+        return quartzScheduler;
+    }
+
 }
diff --git a/src/test/java/org/apache/sling/commons/scheduler/impl/QuartzSchedulerTest.java b/src/test/java/org/apache/sling/commons/scheduler/impl/QuartzSchedulerTest.java
index 4905672..3d41f42 100644
--- a/src/test/java/org/apache/sling/commons/scheduler/impl/QuartzSchedulerTest.java
+++ b/src/test/java/org/apache/sling/commons/scheduler/impl/QuartzSchedulerTest.java
@@ -31,11 +31,21 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Semaphore;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.sling.commons.scheduler.Job;
+import org.apache.sling.commons.scheduler.ScheduleOptions;
+import org.apache.sling.commons.threads.ModifiableThreadPoolConfig;
+import org.apache.sling.commons.threads.ThreadPool;
+import org.apache.sling.commons.threads.ThreadPoolConfig;
+import org.apache.sling.commons.threads.ThreadPoolConfig.ThreadPoolPolicy;
+import org.apache.sling.commons.threads.ThreadPoolManager;
+import org.apache.sling.commons.threads.impl.DefaultThreadPool;
 import org.apache.sling.testing.mock.osgi.MockOsgi;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -74,6 +84,71 @@ public class QuartzSchedulerTest {
         this.proxies = (Map<String, SchedulerProxy>) sField.get(quartzScheduler);
     }
 
+    @Test
+    public void testThreadPoolConfigs_minSize1_maxSize1_queue1() throws Exception {
+        doTestThreadPool(1, 1, ThreadPoolPolicy.DISCARDOLDEST, 1);
+    }
+
+    @Test
+    public void testThreadPoolConfigst_minSize0_maxSize1_queue1() throws Exception {
+        doTestThreadPool(0, 1, ThreadPoolPolicy.DISCARDOLDEST, 1);
+    }
+
+    @Test
+    public void testThreadPoolConfigs_minSize0_maxSize2_queue1() throws Exception {
+        doTestThreadPool(0, 2, ThreadPoolPolicy.DISCARDOLDEST, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void doTestThreadPool(int minPoolSize, int maxPoolSize,
+            ThreadPoolPolicy policy, int queueSize) throws Exception,
+            NoSuchFieldException, IllegalAccessException, InterruptedException {
+        ModifiableThreadPoolConfig config = new ModifiableThreadPoolConfig();
+        config.setMinPoolSize(minPoolSize);
+        config.setMaxPoolSize(maxPoolSize);
+        config.setBlockPolicy(policy);
+        config.setQueueSize(queueSize);
+        DefaultThreadPool dtp = new DefaultThreadPool("myPoolName", config);
+
+        ThreadPoolManager fixedThreadPoolManager = new ThreadPoolManager() {
+
+            @Override
+            public void release(ThreadPool pool) {
+                // not implemented
+            }
+
+            @Override
+            public ThreadPool get(String name) {
+                return dtp;
+            }
+
+            @Override
+            public ThreadPool create(ThreadPoolConfig config, String label) {
+                return dtp;
+            }
+
+            @Override
+            public ThreadPool create(ThreadPoolConfig config) {
+                return dtp;
+            }
+        };
+
+        quartzScheduler = ActivatedQuartzSchedulerFactory.create(context, "testName", fixedThreadPoolManager);
+        Field sField = QuartzScheduler.class.getDeclaredField("schedulers");
+        sField.setAccessible(true);
+        this.proxies = (Map<String, SchedulerProxy>) sField.get(quartzScheduler);
+
+        final Semaphore s = new Semaphore(0);
+        ScheduleOptions opts = quartzScheduler.NOW();
+        opts.threadPoolName("myPoolName");
+        this.quartzScheduler.schedule(bundle.getBundleId(), null, new Runnable() {
+            public void run() {
+                s.release();
+            }
+        }, opts);
+        assertTrue("schedule.now not invoked within 5 sec", s.tryAcquire(5, TimeUnit.SECONDS));
+    }
+
     @Test
     public void testRunNow() {
         InternalScheduleOptions scheduleOptions = (InternalScheduleOptions) quartzScheduler.NOW();
