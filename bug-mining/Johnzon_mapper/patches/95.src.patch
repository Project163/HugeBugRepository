diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
index 18b73984..e8ae5cc8 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mapper.java
@@ -228,7 +228,7 @@ public class Mapper implements Closeable {
     }
 
     private void writeObject(final Object object, final JsonGenerator generator, final Collection<String> ignored, JsonPointerTracker jsonPointer) {
-        MappingGeneratorImpl mappingGenerator = new MappingGeneratorImpl(config, generator, mappings, jsonPointer != null);
+        final MappingGeneratorImpl mappingGenerator = new MappingGeneratorImpl(config, generator, mappings, jsonPointer != null);
         mappingGenerator.doWriteObject(object, generator, true, ignored, jsonPointer);
     }
 
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
index a182a5a4..e32b6505 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
@@ -36,6 +36,7 @@ import javax.json.JsonStructure;
 import javax.json.JsonValue;
 
 import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -713,6 +714,16 @@ public class MappingParserImpl implements MappingParser {
             }
         }
 
+        if (GenericArrayType.class.isInstance(type)) {
+            Type genericComponentType = GenericArrayType.class.cast(type).getGenericComponentType();
+            while (ParameterizedType.class.isInstance(genericComponentType)) {
+                genericComponentType = ParameterizedType.class.cast(genericComponentType).getRawType();
+            }
+            if (Class.class.isInstance(genericComponentType)) {
+                return buildArrayWithComponentType(jsonArray, Class.class.cast(genericComponentType), itemConverter, jsonPointer, rootType);
+            } // else: fail for now
+        }
+
         if (Object.class == type) {
             return buildArray(ANY_LIST, jsonArray, null, null, jsonPointer, rootType);
         }
@@ -861,7 +872,7 @@ public class MappingParserImpl implements MappingParser {
         }
         if (Integer.class == componentType) {
             Integer[] array = new Integer[jsonArray.size()];
-            Integer i = 0;
+            int i = 0;
             for (final JsonValue value : jsonArray) {
                 array[i] = (Integer) toObject(null, value, componentType, itemConverter,
                         isDeduplicateObjects ? new JsonPointerTracker(jsonPointer, i) : null, rootType);
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
index 1e7ea181..1ecbe44b 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/Mappings.java
@@ -29,6 +29,7 @@ import org.apache.johnzon.mapper.reflection.JohnzonParameterizedType;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
@@ -488,7 +489,9 @@ public class Mappings {
             final Type param = value.getType();
             final Class<?> returnType = Class.class.isInstance(param) ? Class.class.cast(param) : null;
             final Setter setter = new Setter(
-                    value, isPrimitive(param), returnType != null && returnType.isArray(), resolve(param, rootClass),
+                    value, isPrimitive(param),
+                    (returnType != null && returnType.isArray()) || GenericArrayType.class.isInstance(value.getType()),
+                    resolve(param, rootClass),
                     findConverter(copyDate, value), value.findObjectConverterReader(),
                     writeIgnore != null ? writeIgnore.minVersion() : -1);
             setters.put(key, setter);
@@ -506,7 +509,7 @@ public class Mappings {
             final Class<?> returnType = Class.class.isInstance(value.getType()) ? Class.class.cast(value.getType()) : null;
             final ParameterizedType pt = ParameterizedType.class.isInstance(value.getType()) ? ParameterizedType.class.cast(value.getType()) : null;
             final Getter getter = new Getter(value, returnType == Object.class, isPrimitive(returnType),
-                    returnType != null && returnType.isArray(),
+                    (returnType != null && returnType.isArray()) || GenericArrayType.class.isInstance(value.getType()),
                     (pt != null && Collection.class.isAssignableFrom(Class.class.cast(pt.getRawType())))
                             || (returnType != null && Collection.class.isAssignableFrom(returnType)),
                     (pt != null && Map.class.isAssignableFrom(Class.class.cast(pt.getRawType())))
@@ -710,15 +713,28 @@ public class Mappings {
         public MapUnwrapperWriter(final Map<String, Setter> writers, final String[] paths) {
             this.writers = writers;
             this.paths = paths;
-            this.componentTypes = new HashMap<String, Class<?>>();
+            this.componentTypes = new HashMap<>();
 
             for (final Map.Entry<String, Setter> setter : writers.entrySet()) {
                 if (setter.getValue().array) {
-                    componentTypes.put(setter.getKey(), Class.class.cast(setter.getValue().paramType).getComponentType());
+                    componentTypes.put(setter.getKey(),
+                            Class.class.isInstance(setter.getValue().paramType) ?
+                                    Class.class.cast(setter.getValue().paramType).getComponentType() :
+                                    cast(GenericArrayType.class.cast(setter.getValue().paramType).getGenericComponentType()));
                 }
             }
         }
 
+        private Class<?> cast(final Type genericComponentType) {
+            if (Class.class.isInstance(genericComponentType)) {
+                return Class.class.cast(genericComponentType);
+            }
+            if (ParameterizedType.class.isInstance(genericComponentType)) {
+                return cast(ParameterizedType.class.cast(genericComponentType).getRawType());
+            }
+            throw new UnsupportedOperationException("Unsupported type: " + genericComponentType);
+        }
+
         @Override
         public void write(final Object instance, final Object value) {
             Map<String, Object> nested = null;
