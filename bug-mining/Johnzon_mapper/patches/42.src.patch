diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
index 7185bb11..a96a64ea 100644
--- a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/MappingParserImpl.java
@@ -69,6 +69,10 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 import static java.util.Arrays.asList;
+import static javax.json.JsonValue.ValueType.FALSE;
+import static javax.json.JsonValue.ValueType.NULL;
+import static javax.json.JsonValue.ValueType.NUMBER;
+import static javax.json.JsonValue.ValueType.TRUE;
 
 /**
  * This class is not concurrently usable as it contains state.
@@ -341,16 +345,7 @@ public class MappingParserImpl implements MappingParser {
             //X TODO maybe we can put this into MapperConfig?
             //X      config.getAdapter(AdapterKey)
             //X      config.getAdapterKey(Adapter)
-            AdapterKey adapterKey = reverseAdaptersRegistry.get(converter);
-            if (adapterKey == null) {
-                for (final Map.Entry<AdapterKey, Adapter<?, ?>> entry : config.getAdapters().entrySet()) {
-                    if (entry.getValue() == converter) {
-                        adapterKey = entry.getKey();
-                        reverseAdaptersRegistry.put(converter, adapterKey);
-                        break;
-                    }
-                }
-            }
+            final AdapterKey adapterKey = getAdapterKey(converter);
 
             final Object param;
             try {
@@ -361,9 +356,68 @@ public class MappingParserImpl implements MappingParser {
             }
             return converter.to(param);
         }
+
+        final AdapterKey key = getAdapterKey(converter);
+        final JsonValue.ValueType valueType = jsonValue.getValueType();
+        if (NULL.equals(valueType)) {
+            return null;
+        }
+        if (TRUE.equals(valueType) || FALSE.equals(valueType)) {
+            if (key != null) {
+                if (boolean.class == key.getTo() || Boolean.class == key.getTo()) {
+                    return converter.to(Boolean.parseBoolean(jsonValue.toString()));
+                }
+            }
+        }
+        if (NUMBER.equals(valueType)) {
+            if (key != null) {
+                if (Long.class == key.getTo() || long.class == key.getTo()) {
+                    return converter.to(JsonNumber.class.cast(jsonValue).longValue());
+                } else if (Integer.class == key.getTo() || int.class == key.getTo()) {
+                    return converter.to(JsonNumber.class.cast(jsonValue).intValue());
+                } else if (Double.class == key.getTo() || double.class == key.getTo()) {
+                    return converter.to(JsonNumber.class.cast(jsonValue).doubleValue());
+                } else if (Float.class == key.getTo() || float.class == key.getTo()) {
+                    return converter.to(JsonNumber.class.cast(jsonValue).doubleValue());
+                } else if (BigInteger.class == key.getTo()) {
+                    return converter.to(JsonNumber.class.cast(jsonValue).bigIntegerValue());
+                } else if (BigDecimal.class == key.getTo()) {
+                    return converter.to(JsonNumber.class.cast(jsonValue).bigDecimalValue());
+                }
+            }
+        }
         return converter.to(jsonValue.toString());
+
     }
 
+    private AdapterKey getAdapterKey(final Adapter converter) {
+        AdapterKey adapterKey = reverseAdaptersRegistry.get(converter);
+        if (adapterKey == null) {
+            for (final Map.Entry<AdapterKey, Adapter<?, ?>> entry : config.getAdapters().entrySet()) {
+                if (entry.getValue() == converter) {
+                    adapterKey = entry.getKey();
+                    reverseAdaptersRegistry.put(converter, adapterKey);
+                    break;
+                }
+            }
+        }
+        if (adapterKey == null) {
+            final Type[] types = converter.getClass().getGenericInterfaces();
+            for (final Type t : types) {
+                if (!ParameterizedType.class.isInstance(t)) {
+                    continue;
+                }
+                final ParameterizedType pt = ParameterizedType.class.cast(t);
+                if (Adapter.class == pt.getRawType()) {
+                    final Type[] actualTypeArguments = pt.getActualTypeArguments();
+                    adapterKey = new AdapterKey(actualTypeArguments[0], actualTypeArguments[1]);
+                    reverseAdaptersRegistry.putIfAbsent(converter, adapterKey);
+                    break;
+                }
+            }
+        }
+        return adapterKey;
+    }
 
 
     private Object toObject(final Object baseInstance, final JsonValue jsonValue,
diff --git a/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/converter/TimestampAdapter.java b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/converter/TimestampAdapter.java
new file mode 100644
index 00000000..3d195138
--- /dev/null
+++ b/johnzon-mapper/src/main/java/org/apache/johnzon/mapper/converter/TimestampAdapter.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper.converter;
+
+import org.apache.johnzon.mapper.Adapter;
+
+import java.util.Date;
+
+public class TimestampAdapter implements Adapter<Date, Long> {
+    @Override
+    public Date to(final Long aLong) {
+        return aLong == null ? null : new Date(aLong);
+    }
+
+    @Override
+    public Long from(final Date date) {
+        return date == null ? null : date.getTime();
+    }
+}
diff --git a/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/converter/TimestampAdapterTest.java b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/converter/TimestampAdapterTest.java
new file mode 100644
index 00000000..6eaf3861
--- /dev/null
+++ b/johnzon-mapper/src/test/java/org/apache/johnzon/mapper/converter/TimestampAdapterTest.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.johnzon.mapper.converter;
+
+import org.apache.johnzon.mapper.JohnzonConverter;
+import org.apache.johnzon.mapper.MapperBuilder;
+import org.junit.Test;
+
+import java.util.Date;
+
+import static org.junit.Assert.assertEquals;
+
+public class TimestampAdapterTest {
+    @Test
+    public void convert() {
+        final Model model = new Model();
+        model.setDate(new Date(0));
+        final String actual = new MapperBuilder().build().writeObjectAsString(model);
+        assertEquals("{\"date\":0}", actual);
+        assertEquals(0L, Model.class.cast(new MapperBuilder().build().readObject(actual, Model.class)).getDate().getTime());
+    }
+
+    public static class Model {
+        @JohnzonConverter(TimestampAdapter.class)
+        private Date date;
+
+        public Date getDate() {
+            return date;
+        }
+
+        public void setDate(Date date) {
+            this.date = date;
+        }
+    }
+}
